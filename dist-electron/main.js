import { app, BrowserWindow } from "electron";
import { createRequire } from "node:module";
import { fileURLToPath } from "node:url";
import path$m from "node:path";
import require$$0$7 from "fs";
import require$$1$2 from "path";
import require$$0$5 from "tty";
import require$$1$3 from "util";
import require$$0$6 from "net";
import require$$0$8 from "events";
import require$$1$4 from "stream";
import require$$3$3 from "zlib";
import require$$0$9 from "buffer";
import require$$1$5 from "string_decoder";
import require$$8 from "querystring";
import require$$5$2 from "url";
import require$$0$a from "http";
import require$$2$3 from "crypto";
import require$$2$4 from "https";
import require$$5$3 from "assert";
import require$$0$b from "os";
import require$$1$6 from "tls";
import require$$3$4 from "dns";
import require$$0$c from "constants";
import require$$5$4 from "child_process";
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule) return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d2 = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d2.get ? d2 : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
function commonjsRequire(path3) {
  throw new Error('Could not dynamically require "' + path3 + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var express$2 = { exports: {} };
var bodyParser = { exports: {} };
/*!
 * depd
 * Copyright(c) 2014-2018 Douglas Christopher Wilson
 * MIT Licensed
 */
var relative = require$$1$2.relative;
var depd_1 = depd;
var basePath = process.cwd();
function containsNamespace(str2, namespace) {
  var vals = str2.split(/[ ,]+/);
  var ns = String(namespace).toLowerCase();
  for (var i = 0; i < vals.length; i++) {
    var val = vals[i];
    if (val && (val === "*" || val.toLowerCase() === ns)) {
      return true;
    }
  }
  return false;
}
function convertDataDescriptorToAccessor(obj, prop, message) {
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  var value2 = descriptor.value;
  descriptor.get = function getter() {
    return value2;
  };
  if (descriptor.writable) {
    descriptor.set = function setter(val) {
      return value2 = val;
    };
  }
  delete descriptor.value;
  delete descriptor.writable;
  Object.defineProperty(obj, prop, descriptor);
  return descriptor;
}
function createArgumentsString(arity) {
  var str2 = "";
  for (var i = 0; i < arity; i++) {
    str2 += ", arg" + i;
  }
  return str2.substr(2);
}
function createStackString(stack) {
  var str2 = this.name + ": " + this.namespace;
  if (this.message) {
    str2 += " deprecated " + this.message;
  }
  for (var i = 0; i < stack.length; i++) {
    str2 += "\n    at " + stack[i].toString();
  }
  return str2;
}
function depd(namespace) {
  if (!namespace) {
    throw new TypeError("argument namespace is required");
  }
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  var file2 = site[0];
  function deprecate2(message) {
    log.call(deprecate2, message);
  }
  deprecate2._file = file2;
  deprecate2._ignored = isignored(namespace);
  deprecate2._namespace = namespace;
  deprecate2._traced = istraced(namespace);
  deprecate2._warned = /* @__PURE__ */ Object.create(null);
  deprecate2.function = wrapfunction;
  deprecate2.property = wrapproperty;
  return deprecate2;
}
function eehaslisteners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function isignored(namespace) {
  if (process.noDeprecation) {
    return true;
  }
  var str2 = process.env.NO_DEPRECATION || "";
  return containsNamespace(str2, namespace);
}
function istraced(namespace) {
  if (process.traceDeprecation) {
    return true;
  }
  var str2 = process.env.TRACE_DEPRECATION || "";
  return containsNamespace(str2, namespace);
}
function log(message, site) {
  var haslisteners = eehaslisteners(process, "deprecation");
  if (!haslisteners && this._ignored) {
    return;
  }
  var caller;
  var callFile;
  var callSite;
  var depSite;
  var i = 0;
  var seen = false;
  var stack = getStack();
  var file2 = this._file;
  if (site) {
    depSite = site;
    callSite = callSiteLocation(stack[1]);
    callSite.name = depSite.name;
    file2 = callSite[0];
  } else {
    i = 2;
    depSite = callSiteLocation(stack[i]);
    callSite = depSite;
  }
  for (; i < stack.length; i++) {
    caller = callSiteLocation(stack[i]);
    callFile = caller[0];
    if (callFile === file2) {
      seen = true;
    } else if (callFile === this._file) {
      file2 = this._file;
    } else if (seen) {
      break;
    }
  }
  var key = caller ? depSite.join(":") + "__" + caller.join(":") : void 0;
  if (key !== void 0 && key in this._warned) {
    return;
  }
  this._warned[key] = true;
  var msg = message;
  if (!msg) {
    msg = callSite === depSite || !callSite.name ? defaultMessage(depSite) : defaultMessage(callSite);
  }
  if (haslisteners) {
    var err = DeprecationError(this._namespace, msg, stack.slice(i));
    process.emit("deprecation", err);
    return;
  }
  var format2 = process.stderr.isTTY ? formatColor : formatPlain;
  var output = format2.call(this, msg, caller, stack.slice(i));
  process.stderr.write(output + "\n", "utf8");
}
function callSiteLocation(callSite) {
  var file2 = callSite.getFileName() || "<anonymous>";
  var line = callSite.getLineNumber();
  var colm = callSite.getColumnNumber();
  if (callSite.isEval()) {
    file2 = callSite.getEvalOrigin() + ", " + file2;
  }
  var site = [file2, line, colm];
  site.callSite = callSite;
  site.name = callSite.getFunctionName();
  return site;
}
function defaultMessage(site) {
  var callSite = site.callSite;
  var funcName = site.name;
  if (!funcName) {
    funcName = "<anonymous@" + formatLocation(site) + ">";
  }
  var context2 = callSite.getThis();
  var typeName = context2 && callSite.getTypeName();
  if (typeName === "Object") {
    typeName = void 0;
  }
  if (typeName === "Function") {
    typeName = context2.name || typeName;
  }
  return typeName && callSite.getMethodName() ? typeName + "." + funcName : funcName;
}
function formatPlain(msg, caller, stack) {
  var timestamp = (/* @__PURE__ */ new Date()).toUTCString();
  var formatted = timestamp + " " + this._namespace + " deprecated " + msg;
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += "\n    at " + stack[i].toString();
    }
    return formatted;
  }
  if (caller) {
    formatted += " at " + formatLocation(caller);
  }
  return formatted;
}
function formatColor(msg, caller, stack) {
  var formatted = "\x1B[36;1m" + this._namespace + "\x1B[22;39m \x1B[33;1mdeprecated\x1B[22;39m \x1B[0m" + msg + "\x1B[39m";
  if (this._traced) {
    for (var i = 0; i < stack.length; i++) {
      formatted += "\n    \x1B[36mat " + stack[i].toString() + "\x1B[39m";
    }
    return formatted;
  }
  if (caller) {
    formatted += " \x1B[36m" + formatLocation(caller) + "\x1B[39m";
  }
  return formatted;
}
function formatLocation(callSite) {
  return relative(basePath, callSite[0]) + ":" + callSite[1] + ":" + callSite[2];
}
function getStack() {
  var limit = Error.stackTraceLimit;
  var obj = {};
  var prep = Error.prepareStackTrace;
  Error.prepareStackTrace = prepareObjectStackTrace;
  Error.stackTraceLimit = Math.max(10, limit);
  Error.captureStackTrace(obj);
  var stack = obj.stack.slice(1);
  Error.prepareStackTrace = prep;
  Error.stackTraceLimit = limit;
  return stack;
}
function prepareObjectStackTrace(obj, stack) {
  return stack;
}
function wrapfunction(fn, message) {
  if (typeof fn !== "function") {
    throw new TypeError("argument fn must be a function");
  }
  var args = createArgumentsString(fn.length);
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = fn.name;
  var deprecatedfn = new Function(
    "fn",
    "log",
    "deprecate",
    "message",
    "site",
    '"use strict"\nreturn function (' + args + ") {log.call(deprecate, message, site)\nreturn fn.apply(this, arguments)\n}"
  )(fn, log, this, message, site);
  return deprecatedfn;
}
function wrapproperty(obj, prop, message) {
  if (!obj || typeof obj !== "object" && typeof obj !== "function") {
    throw new TypeError("argument obj must be object");
  }
  var descriptor = Object.getOwnPropertyDescriptor(obj, prop);
  if (!descriptor) {
    throw new TypeError("must call property on owner object");
  }
  if (!descriptor.configurable) {
    throw new TypeError("property must be configurable");
  }
  var deprecate2 = this;
  var stack = getStack();
  var site = callSiteLocation(stack[1]);
  site.name = prop;
  if ("value" in descriptor) {
    descriptor = convertDataDescriptorToAccessor(obj, prop);
  }
  var get2 = descriptor.get;
  var set = descriptor.set;
  if (typeof get2 === "function") {
    descriptor.get = function getter() {
      log.call(deprecate2, message, site);
      return get2.apply(this, arguments);
    };
  }
  if (typeof set === "function") {
    descriptor.set = function setter() {
      log.call(deprecate2, message, site);
      return set.apply(this, arguments);
    };
  }
  Object.defineProperty(obj, prop, descriptor);
}
function DeprecationError(namespace, message, stack) {
  var error2 = new Error();
  var stackString;
  Object.defineProperty(error2, "constructor", {
    value: DeprecationError
  });
  Object.defineProperty(error2, "message", {
    configurable: true,
    enumerable: false,
    value: message,
    writable: true
  });
  Object.defineProperty(error2, "name", {
    enumerable: false,
    configurable: true,
    value: "DeprecationError",
    writable: true
  });
  Object.defineProperty(error2, "namespace", {
    configurable: true,
    enumerable: false,
    value: namespace,
    writable: true
  });
  Object.defineProperty(error2, "stack", {
    configurable: true,
    enumerable: false,
    get: function() {
      if (stackString !== void 0) {
        return stackString;
      }
      return stackString = createStackString.call(this, stack);
    },
    set: function setter(val) {
      stackString = val;
    }
  });
  return error2;
}
var bytes = { exports: {} };
/*!
 * bytes
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015 Jed Watson
 * MIT Licensed
 */
var hasRequiredBytes;
function requireBytes() {
  if (hasRequiredBytes) return bytes.exports;
  hasRequiredBytes = 1;
  bytes.exports = bytes$1;
  bytes.exports.format = format2;
  bytes.exports.parse = parse2;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map2 = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes$1(value2, options) {
    if (typeof value2 === "string") {
      return parse2(value2);
    }
    if (typeof value2 === "number") {
      return format2(value2, options);
    }
    return null;
  }
  function format2(value2, options) {
    if (!Number.isFinite(value2)) {
      return null;
    }
    var mag = Math.abs(value2);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map2[unit.toLowerCase()]) {
      if (mag >= map2.pb) {
        unit = "PB";
      } else if (mag >= map2.tb) {
        unit = "TB";
      } else if (mag >= map2.gb) {
        unit = "GB";
      } else if (mag >= map2.mb) {
        unit = "MB";
      } else if (mag >= map2.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value2 / map2[unit.toLowerCase()];
    var str2 = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str2 = str2.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str2 = str2.split(".").map(function(s2, i) {
        return i === 0 ? s2.replace(formatThousandsRegExp, thousandsSeparator) : s2;
      }).join(".");
    }
    return str2 + unitSeparator + unit;
  }
  function parse2(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    if (isNaN(floatValue)) {
      return null;
    }
    return Math.floor(map2[unit] * floatValue);
  }
  return bytes.exports;
}
var contentType = {};
/*!
 * content-type
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var PARAM_REGEXP$1 = /; *([!#$%&'*+.^_`|~0-9A-Za-z-]+) *= *("(?:[\u000b\u0020\u0021\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u000b\u0020-\u00ff])*"|[!#$%&'*+.^_`|~0-9A-Za-z-]+) */g;
var TEXT_REGEXP$1 = /^[\u000b\u0020-\u007e\u0080-\u00ff]+$/;
var TOKEN_REGEXP$1 = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
var QESC_REGEXP$1 = /\\([\u000b\u0020-\u00ff])/g;
var QUOTE_REGEXP$1 = /([\\"])/g;
var TYPE_REGEXP = /^[!#$%&'*+.^_`|~0-9A-Za-z-]+\/[!#$%&'*+.^_`|~0-9A-Za-z-]+$/;
contentType.format = format$2;
contentType.parse = parse$9;
function format$2(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || !TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string2 = type3;
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      if (!TOKEN_REGEXP$1.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string2 += "; " + param3 + "=" + qstring$2(parameters[param3]);
    }
  }
  return string2;
}
function parse$9(string2) {
  if (!string2) {
    throw new TypeError("argument string is required");
  }
  var header3 = typeof string2 === "object" ? getcontenttype$1(string2) : string2;
  if (typeof header3 !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = header3.indexOf(";");
  var type3 = index2 !== -1 ? header3.slice(0, index2).trim() : header3.trim();
  if (!TYPE_REGEXP.test(type3)) {
    throw new TypeError("invalid media type");
  }
  var obj = new ContentType(type3.toLowerCase());
  if (index2 !== -1) {
    var key;
    var match2;
    var value2;
    PARAM_REGEXP$1.lastIndex = index2;
    while (match2 = PARAM_REGEXP$1.exec(header3)) {
      if (match2.index !== index2) {
        throw new TypeError("invalid parameter format");
      }
      index2 += match2[0].length;
      key = match2[1].toLowerCase();
      value2 = match2[2];
      if (value2.charCodeAt(0) === 34) {
        value2 = value2.slice(1, -1);
        if (value2.indexOf("\\") !== -1) {
          value2 = value2.replace(QESC_REGEXP$1, "$1");
        }
      }
      obj.parameters[key] = value2;
    }
    if (index2 !== header3.length) {
      throw new TypeError("invalid parameter format");
    }
  }
  return obj;
}
function getcontenttype$1(obj) {
  var header3;
  if (typeof obj.getHeader === "function") {
    header3 = obj.getHeader("content-type");
  } else if (typeof obj.headers === "object") {
    header3 = obj.headers && obj.headers["content-type"];
  }
  if (typeof header3 !== "string") {
    throw new TypeError("content-type header is missing from object");
  }
  return header3;
}
function qstring$2(val) {
  var str2 = String(val);
  if (TOKEN_REGEXP$1.test(str2)) {
    return str2;
  }
  if (str2.length > 0 && !TEXT_REGEXP$1.test(str2)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str2.replace(QUOTE_REGEXP$1, "\\$1") + '"';
}
function ContentType(type3) {
  this.parameters = /* @__PURE__ */ Object.create(null);
  this.type = type3;
}
var httpErrors = { exports: {} };
var setprototypeof = Object.setPrototypeOf || ({ __proto__: [] } instanceof Array ? setProtoOf : mixinProperties);
function setProtoOf(obj, proto2) {
  obj.__proto__ = proto2;
  return obj;
}
function mixinProperties(obj, proto2) {
  for (var prop in proto2) {
    if (!Object.prototype.hasOwnProperty.call(obj, prop)) {
      obj[prop] = proto2[prop];
    }
  }
  return obj;
}
const require$$0$4 = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "103": "Early Hints",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a Teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Too Early",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
};
/*!
 * statuses
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var codes = require$$0$4;
var statuses$3 = status;
status.message = codes;
status.code = createMessageToStatusCodeMap(codes);
status.codes = createStatusCodeList(codes);
status.redirect = {
  300: true,
  301: true,
  302: true,
  303: true,
  305: true,
  307: true,
  308: true
};
status.empty = {
  204: true,
  205: true,
  304: true
};
status.retry = {
  502: true,
  503: true,
  504: true
};
function createMessageToStatusCodeMap(codes2) {
  var map2 = {};
  Object.keys(codes2).forEach(function forEachCode(code2) {
    var message = codes2[code2];
    var status3 = Number(code2);
    map2[message.toLowerCase()] = status3;
  });
  return map2;
}
function createStatusCodeList(codes2) {
  return Object.keys(codes2).map(function mapCode(code2) {
    return Number(code2);
  });
}
function getStatusCode(message) {
  var msg = message.toLowerCase();
  if (!Object.prototype.hasOwnProperty.call(status.code, msg)) {
    throw new Error('invalid status message: "' + message + '"');
  }
  return status.code[msg];
}
function getStatusMessage(code2) {
  if (!Object.prototype.hasOwnProperty.call(status.message, code2)) {
    throw new Error("invalid status code: " + code2);
  }
  return status.message[code2];
}
function status(code2) {
  if (typeof code2 === "number") {
    return getStatusMessage(code2);
  }
  if (typeof code2 !== "string") {
    throw new TypeError("code must be a number or string");
  }
  var n = parseInt(code2, 10);
  if (!isNaN(n)) {
    return getStatusMessage(n);
  }
  return getStatusCode(code2);
}
var inherits$1 = { exports: {} };
var inherits_browser = { exports: {} };
var hasRequiredInherits_browser;
function requireInherits_browser() {
  if (hasRequiredInherits_browser) return inherits_browser.exports;
  hasRequiredInherits_browser = 1;
  if (typeof Object.create === "function") {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    inherits_browser.exports = function inherits2(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
  return inherits_browser.exports;
}
try {
  var util$d = require("util");
  if (typeof util$d.inherits !== "function") throw "";
  inherits$1.exports = util$d.inherits;
} catch (e) {
  inherits$1.exports = requireInherits_browser();
}
var inheritsExports = inherits$1.exports;
/*!
 * toidentifier
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var toidentifier = toIdentifier;
function toIdentifier(str2) {
  return str2.split(" ").map(function(token) {
    return token.slice(0, 1).toUpperCase() + token.slice(1);
  }).join("").replace(/[^ _0-9a-z]/gi, "");
}
/*!
 * http-errors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module2) {
  var deprecate2 = depd_1("http-errors");
  var setPrototypeOf2 = setprototypeof;
  var statuses2 = statuses$3;
  var inherits2 = inheritsExports;
  var toIdentifier2 = toidentifier;
  module2.exports = createError2;
  module2.exports.HttpError = createHttpErrorConstructor();
  module2.exports.isHttpError = createIsHttpErrorFunction(module2.exports.HttpError);
  populateConstructorExports(module2.exports, statuses2.codes, module2.exports.HttpError);
  function codeClass(status3) {
    return Number(String(status3).charAt(0) + "00");
  }
  function createError2() {
    var err;
    var msg;
    var status3 = 500;
    var props = {};
    for (var i = 0; i < arguments.length; i++) {
      var arg = arguments[i];
      var type3 = typeof arg;
      if (type3 === "object" && arg instanceof Error) {
        err = arg;
        status3 = err.status || err.statusCode || status3;
      } else if (type3 === "number" && i === 0) {
        status3 = arg;
      } else if (type3 === "string") {
        msg = arg;
      } else if (type3 === "object") {
        props = arg;
      } else {
        throw new TypeError("argument #" + (i + 1) + " unsupported type " + type3);
      }
    }
    if (typeof status3 === "number" && (status3 < 400 || status3 >= 600)) {
      deprecate2("non-error status code; use only 4xx or 5xx status codes");
    }
    if (typeof status3 !== "number" || !statuses2.message[status3] && (status3 < 400 || status3 >= 600)) {
      status3 = 500;
    }
    var HttpError = createError2[status3] || createError2[codeClass(status3)];
    if (!err) {
      err = HttpError ? new HttpError(msg) : new Error(msg || statuses2.message[status3]);
      Error.captureStackTrace(err, createError2);
    }
    if (!HttpError || !(err instanceof HttpError) || err.status !== status3) {
      err.expose = status3 < 500;
      err.status = err.statusCode = status3;
    }
    for (var key in props) {
      if (key !== "status" && key !== "statusCode") {
        err[key] = props[key];
      }
    }
    return err;
  }
  function createHttpErrorConstructor() {
    function HttpError() {
      throw new TypeError("cannot construct abstract class");
    }
    inherits2(HttpError, Error);
    return HttpError;
  }
  function createClientErrorConstructor(HttpError, name2, code2) {
    var className = toClassName(name2);
    function ClientError(message) {
      var msg = message != null ? message : statuses2.message[code2];
      var err = new Error(msg);
      Error.captureStackTrace(err, ClientError);
      setPrototypeOf2(err, ClientError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ClientError, HttpError);
    nameFunc(ClientError, className);
    ClientError.prototype.status = code2;
    ClientError.prototype.statusCode = code2;
    ClientError.prototype.expose = true;
    return ClientError;
  }
  function createIsHttpErrorFunction(HttpError) {
    return function isHttpError(val) {
      if (!val || typeof val !== "object") {
        return false;
      }
      if (val instanceof HttpError) {
        return true;
      }
      return val instanceof Error && typeof val.expose === "boolean" && typeof val.statusCode === "number" && val.status === val.statusCode;
    };
  }
  function createServerErrorConstructor(HttpError, name2, code2) {
    var className = toClassName(name2);
    function ServerError(message) {
      var msg = message != null ? message : statuses2.message[code2];
      var err = new Error(msg);
      Error.captureStackTrace(err, ServerError);
      setPrototypeOf2(err, ServerError.prototype);
      Object.defineProperty(err, "message", {
        enumerable: true,
        configurable: true,
        value: msg,
        writable: true
      });
      Object.defineProperty(err, "name", {
        enumerable: false,
        configurable: true,
        value: className,
        writable: true
      });
      return err;
    }
    inherits2(ServerError, HttpError);
    nameFunc(ServerError, className);
    ServerError.prototype.status = code2;
    ServerError.prototype.statusCode = code2;
    ServerError.prototype.expose = false;
    return ServerError;
  }
  function nameFunc(func, name2) {
    var desc2 = Object.getOwnPropertyDescriptor(func, "name");
    if (desc2 && desc2.configurable) {
      desc2.value = name2;
      Object.defineProperty(func, "name", desc2);
    }
  }
  function populateConstructorExports(exports, codes2, HttpError) {
    codes2.forEach(function forEachCode(code2) {
      var CodeError;
      var name2 = toIdentifier2(statuses2.message[code2]);
      switch (codeClass(code2)) {
        case 400:
          CodeError = createClientErrorConstructor(HttpError, name2, code2);
          break;
        case 500:
          CodeError = createServerErrorConstructor(HttpError, name2, code2);
          break;
      }
      if (CodeError) {
        exports[code2] = CodeError;
        exports[name2] = CodeError;
      }
    });
  }
  function toClassName(name2) {
    return name2.substr(-5) !== "Error" ? name2 + "Error" : name2;
  }
})(httpErrors);
var httpErrorsExports = httpErrors.exports;
var src$5 = { exports: {} };
var browser$4 = { exports: {} };
var debug$m = { exports: {} };
var ms$6;
var hasRequiredMs$4;
function requireMs$4() {
  if (hasRequiredMs$4) return ms$6;
  hasRequiredMs$4 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$6 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name2) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name2;
    }
    return Math.ceil(ms2 / n) + " " + name2 + "s";
  }
  return ms$6;
}
var hasRequiredDebug$3;
function requireDebug$3() {
  if (hasRequiredDebug$3) return debug$m.exports;
  hasRequiredDebug$3 = 1;
  (function(module2, exports) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce2;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$4();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports.colors[Math.abs(hash2) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled) return;
        var self3 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self3.diff = ms2;
        self3.prev = prevTime;
        self3.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self3, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self3, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self3, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name2) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$m, debug$m.exports);
  return debug$m.exports;
}
var hasRequiredBrowser$4;
function requireBrowser$4() {
  if (hasRequiredBrowser$4) return browser$4.exports;
  hasRequiredBrowser$4 = 1;
  (function(module2, exports) {
    exports = module2.exports = requireDebug$3();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$4, browser$4.exports);
  return browser$4.exports;
}
var node$5 = { exports: {} };
var hasRequiredNode$4;
function requireNode$4() {
  if (hasRequiredNode$4) return node$5.exports;
  hasRequiredNode$4 = 1;
  (function(module2, exports) {
    var tty = require$$0$5;
    var util2 = require$$1$3;
    exports = module2.exports = requireDebug$3();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$0$7;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$0$6;
          stream22 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$5, node$5.exports);
  return node$5.exports;
}
var hasRequiredSrc;
function requireSrc() {
  if (hasRequiredSrc) return src$5.exports;
  hasRequiredSrc = 1;
  if (typeof process !== "undefined" && process.type === "renderer") {
    src$5.exports = requireBrowser$4();
  } else {
    src$5.exports = requireNode$4();
  }
  return src$5.exports;
}
/*!
 * destroy
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var EventEmitter = require$$0$8.EventEmitter;
var ReadStream = require$$0$7.ReadStream;
var Stream$5 = require$$1$4;
var Zlib = require$$3$3;
var destroy_1 = destroy$2;
function destroy$2(stream3, suppress) {
  if (isFsReadStream(stream3)) {
    destroyReadStream(stream3);
  } else if (isZlibStream(stream3)) {
    destroyZlibStream(stream3);
  } else if (hasDestroy(stream3)) {
    stream3.destroy();
  }
  if (isEventEmitter(stream3) && suppress) {
    stream3.removeAllListeners("error");
    stream3.addListener("error", noop$6);
  }
  return stream3;
}
function destroyReadStream(stream3) {
  stream3.destroy();
  if (typeof stream3.close === "function") {
    stream3.on("open", onOpenClose);
  }
}
function closeZlibStream(stream3) {
  if (stream3._hadError === true) {
    var prop = stream3._binding === null ? "_binding" : "_handle";
    stream3[prop] = {
      close: function() {
        this[prop] = null;
      }
    };
  }
  stream3.close();
}
function destroyZlibStream(stream3) {
  if (typeof stream3.destroy === "function") {
    if (stream3._binding) {
      stream3.destroy();
      if (stream3._processing) {
        stream3._needDrain = true;
        stream3.once("drain", onDrainClearBinding);
      } else {
        stream3._binding.clear();
      }
    } else if (stream3._destroy && stream3._destroy !== Stream$5.Transform.prototype._destroy) {
      stream3.destroy();
    } else if (stream3._destroy && typeof stream3.close === "function") {
      stream3.destroyed = true;
      stream3.close();
    } else {
      stream3.destroy();
    }
  } else if (typeof stream3.close === "function") {
    closeZlibStream(stream3);
  }
}
function hasDestroy(stream3) {
  return stream3 instanceof Stream$5 && typeof stream3.destroy === "function";
}
function isEventEmitter(val) {
  return val instanceof EventEmitter;
}
function isFsReadStream(stream3) {
  return stream3 instanceof ReadStream;
}
function isZlibStream(stream3) {
  return stream3 instanceof Zlib.Gzip || stream3 instanceof Zlib.Gunzip || stream3 instanceof Zlib.Deflate || stream3 instanceof Zlib.DeflateRaw || stream3 instanceof Zlib.Inflate || stream3 instanceof Zlib.InflateRaw || stream3 instanceof Zlib.Unzip;
}
function noop$6() {
}
function onDrainClearBinding() {
  this._binding.clear();
}
function onOpenClose() {
  if (typeof this.fd === "number") {
    this.close();
  }
}
var lib$6 = { exports: {} };
var safer_1;
var hasRequiredSafer;
function requireSafer() {
  if (hasRequiredSafer) return safer_1;
  hasRequiredSafer = 1;
  var buffer = require$$0$9;
  var Buffer2 = buffer.Buffer;
  var safer = {};
  var key;
  for (key in buffer) {
    if (!buffer.hasOwnProperty(key)) continue;
    if (key === "SlowBuffer" || key === "Buffer") continue;
    safer[key] = buffer[key];
  }
  var Safer = safer.Buffer = {};
  for (key in Buffer2) {
    if (!Buffer2.hasOwnProperty(key)) continue;
    if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
    Safer[key] = Buffer2[key];
  }
  safer.Buffer.prototype = Buffer2.prototype;
  if (!Safer.from || Safer.from === Uint8Array.from) {
    Safer.from = function(value2, encodingOrOffset, length) {
      if (typeof value2 === "number") {
        throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value2);
      }
      if (value2 && typeof value2.length === "undefined") {
        throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
      }
      return Buffer2(value2, encodingOrOffset, length);
    };
  }
  if (!Safer.alloc) {
    Safer.alloc = function(size, fill, encoding3) {
      if (typeof size !== "number") {
        throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
      }
      if (size < 0 || size >= 2 * (1 << 30)) {
        throw new RangeError('The value "' + size + '" is invalid for option "size"');
      }
      var buf = Buffer2(size);
      if (!fill || fill.length === 0) {
        buf.fill(0);
      } else if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
      return buf;
    };
  }
  if (!safer.kStringMaxLength) {
    try {
      safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
    } catch (e) {
    }
  }
  if (!safer.constants) {
    safer.constants = {
      MAX_LENGTH: safer.kMaxLength
    };
    if (safer.kStringMaxLength) {
      safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
    }
  }
  safer_1 = safer;
  return safer_1;
}
var bomHandling$1 = {};
var hasRequiredBomHandling$1;
function requireBomHandling$1() {
  if (hasRequiredBomHandling$1) return bomHandling$1;
  hasRequiredBomHandling$1 = 1;
  var BOMChar = "\uFEFF";
  bomHandling$1.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling$1.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res2 = this.decoder.write(buf);
    if (this.pass || !res2)
      return res2;
    if (res2[0] === BOMChar) {
      res2 = res2.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res2;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling$1;
}
var encodings$1 = {};
var internal$1;
var hasRequiredInternal$1;
function requireInternal$1() {
  if (hasRequiredInternal$1) return internal$1;
  hasRequiredInternal$1 = 1;
  var Buffer2 = requireSafer().Buffer;
  internal$1 = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "ðŸ’©") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$5.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res2 = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res2 += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res2 += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res2 += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res2 += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res2 += this.defaultCharUnicode;
            else
              res2 += String.fromCharCode(acc);
          }
        } else {
          res2 += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res2;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res2 = 0;
    if (this.contBytes > 0)
      res2 += this.defaultCharUnicode;
    return res2;
  };
  return internal$1;
}
var utf16$1 = {};
var hasRequiredUtf16$1;
function requireUtf16$1() {
  if (hasRequiredUtf16$1) return utf16$1;
  hasRequiredUtf16$1 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16$1.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j2 = 2;
    }
    for (; i < buf.length - 1; i += 2, j2 += 2) {
      buf2[j2] = buf[i + 1];
      buf2[j2 + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16$1.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      var res2 = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res2 + trail : res2;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
  return utf16$1;
}
var utf7$1 = {};
var hasRequiredUtf7$1;
function requireUtf7$1() {
  if (hasRequiredUtf7$1) return utf7$1;
  hasRequiredUtf7$1 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7$1.utf7 = Utf7Codec;
  utf7$1.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7Decoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  utf7$1.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  return utf7$1;
}
var sbcsCodec$1 = {};
var hasRequiredSbcsCodec$1;
function requireSbcsCodec$1() {
  if (hasRequiredSbcsCodec$1) return sbcsCodec$1;
  hasRequiredSbcsCodec$1 = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec$1._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec$1;
}
var sbcsData$1;
var hasRequiredSbcsData$1;
function requireSbcsData$1() {
  if (hasRequiredSbcsData$1) return sbcsData$1;
  hasRequiredSbcsData$1 = 1;
  sbcsData$1 = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡"
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–â‚¬â– Â "
    },
    "mik": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData$1;
}
var sbcsDataGenerated$1;
var hasRequiredSbcsDataGenerated$1;
function requireSbcsDataGenerated$1() {
  if (hasRequiredSbcsDataGenerated$1) return sbcsDataGenerated$1;
  hasRequiredSbcsDataGenerated$1 = 1;
  sbcsDataGenerated$1 = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾ÅºÂ Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅžÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÐŒÐ‹ÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸÂ ÐŽÑžÐˆÂ¤ÒÂ¦Â§ÐÂ©Ð„Â«Â¬Â­Â®Ð‡Â°Â±Ð†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ð…Ñ•Ñ—ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": "â‚¬Ù¾â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€ÚºÂ ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙŽÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€Žâ€Û’"
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™"
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅžÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅžÄžÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™"
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™"
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃžÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€Â¢Â£Â¤â€žÂ¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™"
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸žá¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä…Åâ‚¬â€žÅ Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿"
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏŽÎ†ÎˆÎ‰ÎŠÎŒÎŽÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€žÂ°âˆ™Â·Â¹Â³Â²â– Â "
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅžâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄŽÃ‹ÄÅ‡ÃÃŽÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– Â "
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": "Ñ’Ð‚Ñ“ÐƒÑ‘ÐÑ”Ð„Ñ•Ð…Ñ–Ð†Ñ—Ð‡Ñ˜ÐˆÑ™Ð‰ÑšÐŠÑ›Ð‹ÑœÐŒÑžÐŽÑŸÐÑŽÐ®ÑŠÐªÐ°ÐÐ±Ð‘Ñ†Ð¦Ð´Ð”ÐµÐ•Ñ„Ð¤Ð³Ð“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ð¥Ð¸Ð˜â•£â•‘â•—â•Ð¹Ð™â”â””â”´â”¬â”œâ”€â”¼ÐºÐšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ð»Ð›Ð¼ÐœÐ½ÐÐ¾ÐžÐ¿â”˜â”Œâ–ˆâ–„ÐŸÑâ–€Ð¯Ñ€Ð ÑÐ¡Ñ‚Ð¢ÑƒÐ£Ð¶Ð–Ð²Ð’ÑŒÐ¬â„–Â­Ñ‹Ð«Ð·Ð—ÑˆÐ¨ÑÐ­Ñ‰Ð©Ñ‡Ð§Â§â– Â "
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅžÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄžÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃžÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃŽâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆžÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºŽïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»Žï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–Â¤â– Â "
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎŽÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎžÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°ÏŽâ– Â "
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»Žï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºŽï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘ÒÒ‘Ð„Ñ”Ð†Ñ–Ð‡Ñ—Â·âˆšâ„–Â¤â– Â "
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºžàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½"
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦Â "
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡"
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°Â¢Â£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–Âµâˆ‚ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½"
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macroman": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macromania": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅžâˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢Žï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸º\uFEFFâ€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•žâ•Ÿâ• â•¡Ðâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñžâ•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒÐŽÂ©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": "Ò›Ò“â€šÒ’â€žâ€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕžÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕŽÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÒšÒºÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸÂ Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ÐÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ð†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0Ãšá»¤á»ªá»¬á»®\x07\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»ŽÃ•Ã“á»Œá»˜á»œá»žá» á»šá»¢Ã™á»¦Å¨Â Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "pt154": {
      "type": "_sbcs",
      "chars": "Ò–Ò’Ó®Ò“â€žâ€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹Â ÐŽÑžÐˆÓ¨Ò˜Ò°Â§ÐÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ð†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0áº²áº´áºª\x07\b	\n\v\f\rá»¶á»¸\x1Bá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»žá»Šá»Žá»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ã€Ã‚ÃˆÃŠÃ‹ÃŽÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃžÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½"
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "ascii": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "tis620": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    }
  };
  return sbcsDataGenerated$1;
}
var dbcsCodec$1 = {};
var hasRequiredDbcsCodec$1;
function requireDbcsCodec$1() {
  if (hasRequiredDbcsCodec$1) return dbcsCodec$1;
  hasRequiredDbcsCodec$1 = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec$1._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from; j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j2 = 48; j2 <= 57; j2++)
          secondByteNode[j2] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node2[bytes2[i2]];
      if (val == UNASSIGNED) {
        node2[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code2 = part.charCodeAt(l++);
          if (55296 <= code2 && code2 < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code2 - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code2 && code2 <= 4095) {
            var len = 4095 - code2 + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code2;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j2 = 1; j2 < seq.length - 1; j2++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j2 = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec$1;
}
const require$$0$3 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "ï½¡",
    62
  ],
  [
    "8140",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—"
  ],
  [
    "8180",
    "Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "81b8",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "81c8",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "81da",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "81f0",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "81fc",
    "â—¯"
  ],
  [
    "824f",
    "ï¼",
    9
  ],
  [
    "8260",
    "ï¼¡",
    25
  ],
  [
    "8281",
    "ï½",
    25
  ],
  [
    "829f",
    "ã",
    82
  ],
  [
    "8340",
    "ã‚¡",
    62
  ],
  [
    "8380",
    "ãƒ ",
    22
  ],
  [
    "839f",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "83bf",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "8440",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "8470",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    7
  ],
  [
    "8480",
    "Ð¾",
    17
  ],
  [
    "849f",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "8740",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "875f",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "877e",
    "ã»"
  ],
  [
    "8780",
    "ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "889f",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "8940",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††"
  ],
  [
    "8980",
    "åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "8a40",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«"
  ],
  [
    "8a80",
    "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "8b40",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘"
  ],
  [
    "8b80",
    "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "8c40",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨"
  ],
  [
    "8c80",
    "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "8d40",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™"
  ],
  [
    "8d80",
    "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "8e40",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢"
  ],
  [
    "8e80",
    "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "8f40",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³"
  ],
  [
    "8f80",
    "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "9040",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨"
  ],
  [
    "9080",
    "é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "9140",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»"
  ],
  [
    "9180",
    "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Žè‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "9240",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„"
  ],
  [
    "9280",
    "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "9340",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬"
  ],
  [
    "9380",
    "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "9440",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…"
  ],
  [
    "9480",
    "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "9540",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·"
  ],
  [
    "9580",
    "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "9640",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†"
  ],
  [
    "9680",
    "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "9740",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²"
  ],
  [
    "9780",
    "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "9840",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "989f",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "9940",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­"
  ],
  [
    "9980",
    "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "9a40",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸"
  ],
  [
    "9a80",
    "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "9b40",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€"
  ],
  [
    "9b80",
    "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "9c40",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ "
  ],
  [
    "9c80",
    "æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "9d40",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«"
  ],
  [
    "9d80",
    "æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "9e40",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Ž"
  ],
  [
    "9e80",
    "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "9f40",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯"
  ],
  [
    "9f80",
    "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "e040",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ"
  ],
  [
    "e080",
    "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e140",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿"
  ],
  [
    "e180",
    "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e240",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°"
  ],
  [
    "e280",
    "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e340",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·"
  ],
  [
    "e380",
    "ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e440",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤"
  ],
  [
    "e480",
    "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e540",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬"
  ],
  [
    "e580",
    "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "e640",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§"
  ],
  [
    "e680",
    "è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "e740",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œ"
  ],
  [
    "e780",
    "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "e840",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™"
  ],
  [
    "e880",
    "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™žé™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "e940",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ"
  ],
  [
    "e980",
    "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "ea40",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯"
  ],
  [
    "ea80",
    "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "ed40",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨"
  ],
  [
    "ed80",
    "ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "ee40",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™"
  ],
  [
    "ee80",
    "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "eeef",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "f040",
    "î€€",
    62
  ],
  [
    "f080",
    "î€¿",
    124
  ],
  [
    "f140",
    "î‚¼",
    62
  ],
  [
    "f180",
    "îƒ»",
    124
  ],
  [
    "f240",
    "î…¸",
    62
  ],
  [
    "f280",
    "î†·",
    124
  ],
  [
    "f340",
    "îˆ´",
    62
  ],
  [
    "f380",
    "î‰³",
    124
  ],
  [
    "f440",
    "î‹°",
    62
  ],
  [
    "f480",
    "îŒ¯",
    124
  ],
  [
    "f540",
    "îŽ¬",
    62
  ],
  [
    "f580",
    "î«",
    124
  ],
  [
    "f640",
    "î‘¨",
    62
  ],
  [
    "f680",
    "î’§",
    124
  ],
  [
    "f740",
    "î”¤",
    62
  ],
  [
    "f780",
    "î•£",
    124
  ],
  [
    "f840",
    "î— ",
    62
  ],
  [
    "f880",
    "î˜Ÿ",
    124
  ],
  [
    "f940",
    "îšœ"
  ],
  [
    "fa40",
    "â…°",
    9,
    "â… ",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Š"
  ],
  [
    "fa80",
    "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯"
  ],
  [
    "fb40",
    "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™"
  ],
  [
    "fb80",
    "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™"
  ],
  [
    "fc40",
    "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ]
];
const require$$1$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "ï½¡",
    62
  ],
  [
    "a1a1",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡"
  ],
  [
    "a2a1",
    "â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "a2ba",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "a2ca",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "a2dc",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "a2f2",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "a2fe",
    "â—¯"
  ],
  [
    "a3b0",
    "ï¼",
    9
  ],
  [
    "a3c1",
    "ï¼¡",
    25
  ],
  [
    "a3e1",
    "ï½",
    25
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã‚¡",
    85
  ],
  [
    "a6a1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "a8a1",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "ada1",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "adc0",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "addf",
    "ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "b0a1",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "b1a1",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ"
  ],
  [
    "b2a1",
    "æŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "b3a1",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±"
  ],
  [
    "b4a1",
    "ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "b5a1",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬"
  ],
  [
    "b6a1",
    "ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "b7a1",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²"
  ],
  [
    "b8a1",
    "æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "b9a1",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼"
  ],
  [
    "baa1",
    "æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "bba1",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚"
  ],
  [
    "bca1",
    "æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "bda1",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ"
  ],
  [
    "bea1",
    "å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "bfa1",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾"
  ],
  [
    "c0a1",
    "æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "c1a1",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Ž"
  ],
  [
    "c2a1",
    "è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "c3a1",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ"
  ],
  [
    "c4a1",
    "å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "c5a1",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°"
  ],
  [
    "c6a1",
    "è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "c7a1",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦"
  ],
  [
    "c8a1",
    "å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "c9a1",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ"
  ],
  [
    "caa1",
    "ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "cba1",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€"
  ],
  [
    "cca1",
    "æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "cda1",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒ"
  ],
  [
    "cea1",
    "ç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "cfa1",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "d0a1",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "d1a1",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨"
  ],
  [
    "d2a1",
    "è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "d3a1",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰"
  ],
  [
    "d4a1",
    "åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "d5a1",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“"
  ],
  [
    "d6a1",
    "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "d7a1",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š"
  ],
  [
    "d8a1",
    "æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "d9a1",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼"
  ],
  [
    "daa1",
    "æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "dba1",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Žæ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£"
  ],
  [
    "dca1",
    "æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "dda1",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾"
  ],
  [
    "dea1",
    "æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "dfa1",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼"
  ],
  [
    "e0a1",
    "ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e1a1",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°"
  ],
  [
    "e2a1",
    "ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e3a1",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­"
  ],
  [
    "e4a1",
    "ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e5a1",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼º"
  ],
  [
    "e6a1",
    "ç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e7a1",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™"
  ],
  [
    "e8a1",
    "èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e9a1",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™"
  ],
  [
    "eaa1",
    "è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "eba1",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«"
  ],
  [
    "eca1",
    "è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "eda1",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸"
  ],
  [
    "eea1",
    "ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "efa1",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™ž"
  ],
  [
    "f0a1",
    "é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "f1a1",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·"
  ],
  [
    "f2a1",
    "é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "f3a1",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ "
  ],
  [
    "f4a1",
    "å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "f9a1",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"
  ],
  [
    "faa1",
    "å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "fba1",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡š"
  ],
  [
    "fca1",
    "é‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "fcf1",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "8fa2af",
    "Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½žÎ„Î…"
  ],
  [
    "8fa2c2",
    "Â¡Â¦Â¿"
  ],
  [
    "8fa2eb",
    "ÂºÂªÂ©Â®â„¢Â¤â„–"
  ],
  [
    "8fa6e1",
    "Î†ÎˆÎ‰ÎŠÎª"
  ],
  [
    "8fa6e7",
    "ÎŒ"
  ],
  [
    "8fa6e9",
    "ÎŽÎ«"
  ],
  [
    "8fa6ec",
    "Î"
  ],
  [
    "8fa6f1",
    "Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°ÏŽ"
  ],
  [
    "8fa7c2",
    "Ð‚",
    10,
    "ÐŽÐ"
  ],
  [
    "8fa7f2",
    "Ñ’",
    10,
    "ÑžÑŸ"
  ],
  [
    "8fa9a1",
    "Ã†Ä"
  ],
  [
    "8fa9a4",
    "Ä¦"
  ],
  [
    "8fa9a6",
    "Ä²"
  ],
  [
    "8fa9a8",
    "ÅÄ¿"
  ],
  [
    "8fa9ab",
    "ÅŠÃ˜Å’"
  ],
  [
    "8fa9af",
    "Å¦Ãž"
  ],
  [
    "8fa9c1",
    "Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"
  ],
  [
    "8faaa1",
    "ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄŽÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"
  ],
  [
    "8faaba",
    "ÄœÄžÄ¢Ä Ä¤ÃÃŒÃÃŽÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅžÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»"
  ],
  [
    "8faba1",
    "Ã¡Ã Ã¤Ã¢ÄƒÇŽÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"
  ],
  [
    "8fabbd",
    "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"
  ],
  [
    "8fabc5",
    "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"
  ],
  [
    "8fb0a1",
    "ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„"
  ],
  [
    "8fb1a1",
    "ä¾…ä¾‰ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾žä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€Žå€å€“å€—å€˜å€›å€œå€å€žå€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåŽå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚Žå‚å‚"
  ],
  [
    "8fb2a1",
    "å‚’å‚“å‚”å‚–å‚›å‚œå‚ž",
    4,
    "å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒŽåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„Žåƒ²å„å„—å„™å„›å„œå„å„žå„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†Žå†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚"
  ],
  [
    "8fb3a1",
    "å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡žå‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹"
  ],
  [
    "8fb4a1",
    "åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒžåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åŽƒåŽ‡åŽˆåŽŽåŽ“åŽ”åŽ™åŽåŽ¡åŽ¤åŽªåŽ«åŽ¯åŽ²åŽ´åŽµåŽ·åŽ¸åŽºåŽ½å€å…åå’å“å•åšååžå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘žå‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿"
  ],
  [
    "8fb5a1",
    "å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“Žå“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”Žå”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•žå• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–Žå–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—Žå—‘å—’"
  ],
  [
    "8fb6a1",
    "å—“å——å—˜å—›å—žå—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜",
    5,
    "å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™žå™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšžåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤",
    4,
    "å›±å›«å›­"
  ],
  [
    "8fb7a1",
    "å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­",
    4,
    "å³å´åµå·å¹åºå»å¼å¾åžåžƒåžŒåž”åž—åž™åžšåžœåžåžžåžŸåž¡åž•åž§åž¨åž©åž¬åž¸åž½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸžåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡"
  ],
  [
    "8fb8a1",
    "å Œå å ›å žå Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£Žå£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥žå¥Ÿå¥¡å¥£å¥«å¥­"
  ],
  [
    "8fb9a1",
    "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦Žå¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§žå§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨Žå¨’å¨“å¨žå¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©žå©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªžåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"
  ],
  [
    "8fbaa1",
    "å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­žå­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®Žå®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–",
    4,
    "å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°žå°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©"
  ],
  [
    "8fbba1",
    "å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·Žå·˜å·™å· å·¤"
  ],
  [
    "8fbca1",
    "å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹žå¹¨å¹ª",
    4,
    "å¹°åº€åº‹åºŽåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»Žå»‘å»’å»”å»•å»œå»žå»¥å»«å¼‚å¼†å¼‡å¼ˆå¼Žå¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§"
  ],
  [
    "8fbda1",
    "å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿",
    4,
    "å¿žå¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚Žæ‚‘æ‚“æ‚•æ‚˜æ‚æ‚žæ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·"
  ],
  [
    "8fbea1",
    "æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒŽæƒæƒ”æƒ•æƒ™æƒ›æƒæƒžæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„",
    4,
    "æ„–æ„—æ„™æ„œæ„žæ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…žæ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡Žæ‡æ‡•æ‡œæ‡æ‡žæ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥"
  ],
  [
    "8fbfa1",
    "æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠŽæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹Žæ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹æŽæ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ"
  ],
  [
    "8fc0a1",
    "æ¸æ¼æ½æ¿æŽ‚æŽ„æŽ‡æŽŠæŽæŽ”æŽ•æŽ™æŽšæŽžæŽ¤æŽ¦æŽ­æŽ®æŽ¯æŽ½ææ…æˆæŽæ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜æžæ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿"
  ],
  [
    "8fc1a1",
    "æ“„æ“‰æ“Šæ“‹æ“Œæ“Žæ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”žæ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—Žæ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜"
  ],
  [
    "8fc2a1",
    "æ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™Žæ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›Žæ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœŽæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ"
  ],
  [
    "8fc3a1",
    "æ¦æ¬æ®æ´æ¶æ»æžæž„æžŽæžæž‘æž“æž–æž˜æž™æž›æž°æž±æž²æžµæž»æž¼æž½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®",
    4,
    "æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£"
  ],
  [
    "8fc4a1",
    "æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥Žæ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"
  ],
  [
    "8fc5a1",
    "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©Žæ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªžæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬žæ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"
  ],
  [
    "8fc6a1",
    "æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°Žæ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–"
  ],
  [
    "8fc7a1",
    "æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´Žæ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµžæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·Žæ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸žæ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹ž"
  ],
  [
    "8fc8a1",
    "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»Žæ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½žæ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š"
  ],
  [
    "8fc9a1",
    "æ¿šæ¿žæ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•ççžçŽç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”",
    4,
    "ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ",
    4,
    "ç„‹ç„Œç„ç„žç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…žç… "
  ],
  [
    "8fcaa1",
    "ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰Žç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰žç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠŽçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»"
  ],
  [
    "8fcba1",
    "ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒžçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜ççžçŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼çŽ€çŽçŽƒçŽ…çŽ†çŽŽçŽçŽ“çŽ•çŽ—çŽ˜çŽœçŽžçŽŸçŽ çŽ¢çŽ¥çŽ¦çŽªçŽ«çŽ­çŽµçŽ·çŽ¹çŽ¼çŽ½çŽ¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"
  ],
  [
    "8fcca1",
    "ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨",
    9,
    "ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“žç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†"
  ],
  [
    "8fcda1",
    "ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•Žç•ç•’ç•—ç•žç•Ÿç•¡ç•¯ç•±ç•¹",
    5,
    "ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—Žç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜žç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹"
  ],
  [
    "8fcea1",
    "ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢",
    6,
    "çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›Žç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœŽçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠççŽçç’ç–ç—çœçžçŸç ç¢"
  ],
  [
    "8fcfa1",
    "ç¤ç§çªç¬ç°ç²ç³ç´çºç½çž€çž„çžŒçžçž”çž•çž–çžšçžŸçž¢çž§çžªçž®çž¯çž±çžµçž¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸžçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç Žç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡Žç¡’ç¡œç¡žç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢žç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"
  ],
  [
    "8fd0a1",
    "ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£Žç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤žç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§ž"
  ],
  [
    "8fd1a1",
    "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨žç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªžçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«Žç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"
  ],
  [
    "8fd2a1",
    "ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­Žç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®Žç®ç®‘ç®–ç®›ç®žç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°Žç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™",
    5
  ],
  [
    "8fd3a1",
    "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²žç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´žç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶"
  ],
  [
    "8fd4a1",
    "ç¶žç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚",
    4,
    "ç·Œç·ç·Žç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹Žç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºžç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"
  ],
  [
    "8fd5a1",
    "ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿Žç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€Žè€è€‘è€“è€”è€–è€è€žè€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚Žè‚œè‚žè‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®"
  ],
  [
    "8fd6a1",
    "èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„žè„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†Žè†–è†˜è†›è†žè†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡Žè‡è‡•è‡—è‡›è‡è‡žè‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†"
  ],
  [
    "8fd7a1",
    "è‰‹è‰Žè‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠŽèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒžèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèŽè‘è•è–è—è°è¸"
  ],
  [
    "8fd8a1",
    "è½è¿èŽ€èŽ‚èŽ„èŽ†èŽèŽ’èŽ”èŽ•èŽ˜èŽ™èŽ›èŽœèŽèŽ¦èŽ§èŽ©èŽ¬èŽ¾èŽ¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™èŽ­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’žè’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““"
  ],
  [
    "8fd9a1",
    "è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”Žè”è”œè”žè”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•",
    4,
    "è•–è•™è•œ",
    6,
    "è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—Žè–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼"
  ],
  [
    "8fdaa1",
    "è—¿è˜€è˜„è˜…è˜è˜Žè˜è˜‘è˜’è˜˜è˜™è˜›è˜žè˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ",
    4,
    "è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœŽèœèœèœ“èœ”èœ™èœžèœŸèœ¡èœ£"
  ],
  [
    "8fdba1",
    "èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èžƒ",
    6,
    "èž‹èžŒèžèž“èž•èž—èž˜èž™èžžèž èž£èž§èž¬èž­èž®èž±èžµèž¾èž¿èŸèŸˆèŸ‰èŸŠèŸŽèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè žè Ÿè ¨è ­è ®è °è ²è µ"
  ],
  [
    "8fdca1",
    "è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡Žè¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š",
    4,
    "è£‘è£’è£“è£›è£žè£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤Žè¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"
  ],
  [
    "8fdda1",
    "è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”",
    4,
    "è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨žè¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©Žè©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³"
  ],
  [
    "8fdea1",
    "èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬žè¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚",
    4,
    "è­ˆè­’è­“è­”è­™è­è­žè­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®žè®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†"
  ],
  [
    "8fdfa1",
    "è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶žè¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·Žè·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢"
  ],
  [
    "8fe0a1",
    "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹Žè¹è¹”è¹›è¹œè¹è¹žè¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºžèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼žè¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½"
  ],
  [
    "8fe1a1",
    "è½ƒè½‡è½è½‘",
    4,
    "è½˜è½è½žè½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚Žé‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ"
  ],
  [
    "8fe2a1",
    "éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„žé„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†Žé†‘é†“é†”é†•é†˜é†žé†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿"
  ],
  [
    "8fe3a1",
    "é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡žé‡¤é‡¥é‡©é‡ªé‡¬",
    5,
    "é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰Žé‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ",
    4,
    "é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠŽéŠ’éŠ—"
  ],
  [
    "8fe4a1",
    "éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿",
    4,
    "é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹Žé‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒžéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéžé¤é¥é§é©éªé­é¯é°é±é³é´é¶"
  ],
  [
    "8fe5a1",
    "éºé½é¿éŽ€éŽéŽ‚éŽˆéŽŠéŽ‹éŽéŽéŽ’éŽ•éŽ˜éŽ›éŽžéŽ¡éŽ£éŽ¤éŽ¦éŽ¨éŽ«éŽ´éŽµéŽ¶éŽºéŽ©éé„é…é†é‡é‰",
    4,
    "é“é™éœéžéŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰ééŽéé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹"
  ],
  [
    "8fe6a1",
    "é•¾é–„é–ˆé–Œé–é–Žé–é–žé–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—žé—Ÿé— é—¤é—¦é˜é˜žé˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›žé›Ÿé›©é›¯é›±é›ºéœ‚"
  ],
  [
    "8fe7a1",
    "éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠéŽéé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿éž€éž‰éž•éž–éž—éž™éžšéžžéžŸéž¢éž¬éž®éž±éž²éžµéž¶éž¸éž¹éžºéž¼éž¾éž¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸŽéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸžéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é Žé ”é –é œé žé  é £é ¦"
  ],
  [
    "8fe8a1",
    "é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±",
    4,
    "é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥Žé¥”é¥˜é¥™é¥›é¥œé¥žé¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ"
  ],
  [
    "8fe9a1",
    "é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§žé§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨žé¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©Žé©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«Žé«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",
    4
  ],
  [
    "8feaa1",
    "é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬Žé¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­žé­¡é­£é­¥é­¦é­¨é­ª",
    4,
    "é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®žé®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯Žé¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"
  ],
  [
    "8feba1",
    "é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°žé°¢é°£é°¦",
    4,
    "é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±Žé±é±é±“é±”é±–é±˜é±›é±é±žé±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´žé´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"
  ],
  [
    "8feca1",
    "éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶Žé¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·žé·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸Žé¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºŽéºéº–éº˜éº›éºžéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"
  ],
  [
    "8feda1",
    "é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ",
    4,
    "é½“é½•é½–é½—é½˜é½šé½é½žé½¨é½©é½­",
    4,
    "é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾žé¾¡é¾¢é¾£é¾¥"
  ]
];
const require$$2$2 = [
  [
    "0",
    "\0",
    127,
    "â‚¬"
  ],
  [
    "8140",
    "ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",
    5,
    "ä¹²ä¹´",
    9,
    "ä¹¿",
    6,
    "äº‡äºŠ"
  ],
  [
    "8180",
    "äºäº–äº—äº™äºœäºäºžäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚",
    6,
    "ä¼‹ä¼Œä¼’",
    4,
    "ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",
    4,
    "ä½„ä½…ä½‡",
    5,
    "ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾žä¾Ÿä¾¡ä¾¢"
  ],
  [
    "8240",
    "ä¾¤ä¾«ä¾­ä¾°",
    4,
    "ä¾¶",
    8,
    "ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’",
    4,
    "ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",
    11
  ],
  [
    "8280",
    "å€‹å€Žå€å€‘å€“å€•å€–å€—å€›å€å€žå€ å€¢å€£å€¤å€§å€«å€¯",
    10,
    "å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå",
    4,
    "å–å—å˜å™å›å",
    7,
    "å¦",
    5,
    "å­",
    8,
    "å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚Ž",
    20,
    "å‚¤å‚¦å‚ªå‚«å‚­",
    4,
    "å‚³",
    6,
    "å‚¼"
  ],
  [
    "8340",
    "å‚½",
    17,
    "åƒ",
    5,
    "åƒ—åƒ˜åƒ™åƒ›",
    10,
    "åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶",
    4,
    "åƒ¼",
    9,
    "å„ˆ"
  ],
  [
    "8380",
    "å„‰å„Šå„Œ",
    5,
    "å„“",
    13,
    "å„¢",
    28,
    "å…‚å…‡å…Šå…Œå…Žå…å…å…’å…“å…—å…˜å…™å…›å…",
    4,
    "å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†Žå†å†å†‘å†“å†”å†˜å†šå†å†žå†Ÿå†¡å†£å†¦",
    4,
    "å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡Žå‡å‡’",
    5
  ],
  [
    "8440",
    "å‡˜å‡™å‡šå‡œå‡žå‡Ÿå‡¢å‡£å‡¥",
    5,
    "å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆžåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„",
    5,
    "å‰‹å‰Žå‰å‰’å‰“å‰•å‰—å‰˜"
  ],
  [
    "8480",
    "å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³",
    9,
    "å‰¾åŠ€åŠƒ",
    4,
    "åŠ‰",
    6,
    "åŠ‘åŠ’åŠ”",
    6,
    "åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´",
    9,
    "å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹Žå‹å‹‘å‹“å‹”å‹•å‹—å‹™",
    5,
    "å‹ å‹¡å‹¢å‹£å‹¥",
    10,
    "å‹±",
    7,
    "å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒŽ"
  ],
  [
    "8540",
    "åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒžåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯",
    9,
    "åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åŽ€åŽåŽƒåŽ‡åŽˆåŽŠåŽŽåŽ"
  ],
  [
    "8580",
    "åŽ",
    4,
    "åŽ–åŽ—åŽ™åŽ›åŽœåŽžåŽ åŽ¡åŽ¤åŽ§åŽªåŽ«åŽ¬åŽ­åŽ¯",
    6,
    "åŽ·åŽ¸åŽ¹åŽºåŽ¼åŽ½åŽ¾å€åƒ",
    4,
    "åŽååå’å“å•åšåœååžå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘Žå‘å‘‘å‘šå‘",
    4,
    "å‘£å‘¥å‘§å‘©",
    7,
    "å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’žå’Ÿå’ å’¡"
  ],
  [
    "8640",
    "å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ",
    4,
    "å“«å“¬å“¯å“°å“±å“´",
    5,
    "å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š",
    4,
    "å”’å”“å”•",
    5,
    "å”œå”å”žå”Ÿå”¡å”¥å”¦"
  ],
  [
    "8680",
    "å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹",
    4,
    "å•‘å•’å•“å•”å•—",
    4,
    "å•å•žå•Ÿå• å•¢å•£å•¨å•©å•«å•¯",
    5,
    "å•¹å•ºå•½å•¿å–…å–†å–Œå–å–Žå–å–’å–“å–•å––å–—å–šå–›å–žå– ",
    6,
    "å–¨",
    8,
    "å–²å–´å–¶å–¸å–ºå–¼å–¿",
    4,
    "å—†å—‡å—ˆå—Šå—‹å—Žå—å—å—•å——",
    4,
    "å—žå— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸",
    4,
    "å—¿å˜‚å˜ƒå˜„å˜…"
  ],
  [
    "8740",
    "å˜†å˜‡å˜Šå˜‹å˜å˜",
    7,
    "å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€",
    11,
    "å™",
    4,
    "å™•å™–å™šå™›å™",
    4
  ],
  [
    "8780",
    "å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½",
    7,
    "åš‡",
    6,
    "åšåš‘åš’åš”",
    14,
    "åš¤",
    10,
    "åš°",
    6,
    "åš¸åš¹åšºåš»åš½",
    12,
    "å›‹",
    8,
    "å›•å›–å›˜å›™å›œå›£å›¥",
    5,
    "å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹",
    6
  ],
  [
    "8840",
    "åœ’",
    9,
    "åœåœžåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´",
    4,
    "åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’",
    4,
    "å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿åž€"
  ],
  [
    "8880",
    "åžåž‡åžˆåž‰åžŠåž",
    4,
    "åž”",
    6,
    "åžœåžåžžåžŸåž¥åž¨åžªåž¬åž¯åž°åž±åž³åžµåž¶åž·åž¹",
    8,
    "åŸ„",
    6,
    "åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸžåŸ¡åŸ¢åŸ£åŸ¥",
    7,
    "åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå Žå å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥",
    4,
    "å «",
    4,
    "å ±å ²å ³å ´å ¶",
    7
  ],
  [
    "8940",
    "å ¾",
    5,
    "å¡…",
    6,
    "å¡Žå¡å¡å¡’å¡“å¡•å¡–å¡—å¡™",
    4,
    "å¡Ÿ",
    5,
    "å¡¦",
    4,
    "å¡­",
    16,
    "å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ"
  ],
  [
    "8980",
    "å¢",
    4,
    "å¢”",
    4,
    "å¢›å¢œå¢å¢ ",
    7,
    "å¢ª",
    17,
    "å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†",
    10,
    "å£’å£“å£”å£–",
    13,
    "å£¥",
    5,
    "å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",
    7,
    "å¤ƒå¤…å¤†å¤ˆ",
    4,
    "å¤Žå¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤žå¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"
  ],
  [
    "8a40",
    "å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›",
    4,
    "å¥¡å¥£å¥¤å¥¦",
    12,
    "å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦Žå¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦"
  ],
  [
    "8a80",
    "å¦§å¦¬å¦­å¦°å¦±å¦³",
    5,
    "å¦ºå¦¼å¦½å¦¿",
    6,
    "å§‡å§ˆå§‰å§Œå§å§Žå§å§•å§–å§™å§›å§ž",
    4,
    "å§¤å§¦å§§å§©å§ªå§«å§­",
    11,
    "å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨Žå¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨žå¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",
    6,
    "å¨³å¨µå¨·",
    4,
    "å¨½å¨¾å¨¿å©",
    4,
    "å©‡å©ˆå©‹",
    9,
    "å©–å©—å©˜å©™å©›",
    5
  ],
  [
    "8b40",
    "å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",
    8,
    "å©¸å©¹å©»å©¼å©½å©¾åª€",
    17,
    "åª“",
    6,
    "åªœ",
    13,
    "åª«åª¬"
  ],
  [
    "8b80",
    "åª­",
    4,
    "åª´åª¶åª·åª¹",
    4,
    "åª¿å«€å«ƒ",
    5,
    "å«Šå«‹å«",
    4,
    "å«“å«•å«—å«™å«šå«›å«å«žå«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬",
    4,
    "å«²",
    22,
    "å¬Š",
    11,
    "å¬˜",
    25,
    "å¬³å¬µå¬¶å¬¸",
    7,
    "å­",
    6
  ],
  [
    "8c40",
    "å­ˆ",
    7,
    "å­’å­–å­žå­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®Žå®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯Žå¯"
  ],
  [
    "8c80",
    "å¯‘å¯”",
    8,
    "å¯ å¯¢å¯£å¯¦å¯§å¯©",
    4,
    "å¯¯å¯±",
    6,
    "å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°Žå°å°’å°“å°—å°™å°›å°žå°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§",
    6,
    "å±°å±²",
    6,
    "å±»å±¼å±½å±¾å²€å²ƒ",
    4,
    "å²‰å²Šå²‹å²Žå²å²’å²“å²•å²",
    4,
    "å²¤",
    4
  ],
  [
    "8d40",
    "å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…",
    5,
    "å³Œ",
    5,
    "å³“",
    5,
    "å³š",
    6,
    "å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",
    9,
    "å³¼",
    4
  ],
  [
    "8d80",
    "å´å´„å´…å´ˆ",
    5,
    "å´",
    4,
    "å´•å´—å´˜å´™å´šå´œå´å´Ÿ",
    4,
    "å´¥å´¨å´ªå´«å´¬å´¯",
    4,
    "å´µ",
    7,
    "å´¿",
    7,
    "åµˆåµ‰åµ",
    10,
    "åµ™åµšåµœåµž",
    10,
    "åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",
    12,
    "å¶ƒ",
    21,
    "å¶šå¶›å¶œå¶žå¶Ÿå¶ "
  ],
  [
    "8e40",
    "å¶¡",
    21,
    "å¶¸",
    12,
    "å·†",
    6,
    "å·Ž",
    12,
    "å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"
  ],
  [
    "8e80",
    "å·°å·µå·¶å·¸",
    4,
    "å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸Žå¸’å¸“å¸—å¸ž",
    7,
    "å¸¨",
    4,
    "å¸¯å¸°å¸²",
    4,
    "å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†",
    5,
    "å¹",
    6,
    "å¹–",
    4,
    "å¹œå¹å¹Ÿå¹ å¹£",
    14,
    "å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºŽåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨",
    4,
    "åº®",
    4,
    "åº´åººåº»åº¼åº½åº¿",
    6
  ],
  [
    "8f40",
    "å»†å»‡å»ˆå»‹",
    5,
    "å»”å»•å»—å»˜å»™å»šå»œ",
    11,
    "å»©å»«",
    8,
    "å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼Žå¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼žå¼¡å¼¢å¼£å¼¤"
  ],
  [
    "8f80",
    "å¼¨å¼«å¼¬å¼®å¼°å¼²",
    6,
    "å¼»å¼½å¼¾å¼¿å½",
    14,
    "å½‘å½”å½™å½šå½›å½œå½žå½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾Žå¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾žå¾Ÿå¾ å¾¢",
    5,
    "å¾©å¾«å¾¬å¾¯",
    5,
    "å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",
    4,
    "å¿‡å¿ˆå¿Šå¿‹å¿Žå¿“å¿”å¿•å¿šå¿›å¿œå¿žå¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡"
  ],
  [
    "9040",
    "æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€žæ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°",
    4,
    "æ€¶",
    4,
    "æ€½æ€¾æ€æ„",
    6,
    "æŒæŽææ‘æ“æ”æ–æ—æ˜æ›æœæžæŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€"
  ],
  [
    "9080",
    "æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚Žæ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚žæ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½",
    7,
    "æƒ‡æƒˆæƒ‰æƒŒ",
    4,
    "æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒžæƒ¡",
    4,
    "æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»",
    4,
    "æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„",
    4,
    "æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„žæ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬",
    18,
    "æ…€",
    6
  ],
  [
    "9140",
    "æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–",
    6,
    "æ…žæ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©",
    6,
    "æ…±æ…²æ…³æ…´æ…¶æ…¸",
    18,
    "æ†Œæ†æ†",
    4,
    "æ†•"
  ],
  [
    "9180",
    "æ†–",
    6,
    "æ†ž",
    8,
    "æ†ªæ†«æ†­",
    9,
    "æ†¸",
    5,
    "æ†¿æ‡€æ‡æ‡ƒ",
    4,
    "æ‡‰æ‡Œ",
    4,
    "æ‡“æ‡•",
    16,
    "æ‡§",
    13,
    "æ‡¶",
    8,
    "æˆ€",
    5,
    "æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆžæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸",
    4,
    "æ‰‚æ‰„æ‰…æ‰†æ‰Š"
  ],
  [
    "9240",
    "æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ",
    6,
    "æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹",
    5,
    "æŠ”æŠ™æŠœæŠæŠžæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹"
  ],
  [
    "9280",
    "æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹žæ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³",
    5,
    "æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–",
    7,
    "æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æŽæŽƒæŽ„æŽ…æŽ†æŽ‹æŽæŽ‘æŽ“æŽ”æŽ•æŽ—æŽ™",
    6,
    "æŽ¡æŽ¤æŽ¦æŽ«æŽ¯æŽ±æŽ²æŽµæŽ¶æŽ¹æŽ»æŽ½æŽ¿æ€"
  ],
  [
    "9340",
    "ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—",
    6,
    "æŸæ¢æ¤",
    4,
    "æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†",
    4,
    "ææŽæ‘æ’æ•",
    5,
    "ææŸæ¢æ£æ¤"
  ],
  [
    "9380",
    "æ¥æ§æ¨æ©æ«æ®",
    5,
    "æµ",
    4,
    "æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹",
    6,
    "æ‘“æ‘•æ‘–æ‘—æ‘™",
    4,
    "æ‘Ÿ",
    7,
    "æ‘¨æ‘ªæ‘«æ‘¬æ‘®",
    9,
    "æ‘»",
    6,
    "æ’ƒæ’†æ’ˆ",
    8,
    "æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ",
    4,
    "æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†",
    6,
    "æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š"
  ],
  [
    "9440",
    "æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§",
    24,
    "æ”",
    7,
    "æ”Š",
    7,
    "æ”“",
    4,
    "æ”™",
    8
  ],
  [
    "9480",
    "æ”¢æ”£æ”¤æ”¦",
    4,
    "æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€",
    4,
    "æ•†æ•‡æ•Šæ•‹æ•æ•Žæ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸",
    14,
    "æ–ˆæ–‰æ–Šæ–æ–Žæ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–žæ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±",
    7,
    "æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜",
    7,
    "æ—¡æ—£æ—¤æ—ªæ—«"
  ],
  [
    "9540",
    "æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»",
    4,
    "æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·",
    4,
    "æ˜½æ˜¿æ™€æ™‚æ™„",
    6,
    "æ™æ™Žæ™æ™‘æ™˜"
  ],
  [
    "9580",
    "æ™™æ™›æ™œæ™æ™žæ™ æ™¢æ™£æ™¥æ™§æ™©",
    4,
    "æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšŽæšæšæš’æš“æš”æš•æš˜",
    4,
    "æšž",
    8,
    "æš©",
    4,
    "æš¯",
    4,
    "æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿",
    25,
    "æ›šæ›ž",
    7,
    "æ›§æ›¨æ›ª",
    5,
    "æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ"
  ],
  [
    "9640",
    "æœ„æœ…æœ†æœ‡æœŒæœŽæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœžæœ ",
    5,
    "æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—",
    4,
    "ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"
  ],
  [
    "9680",
    "æ¸æ¹æºæ»æ½æž€æž‚æžƒæž…æž†æžˆæžŠæžŒæžæžŽæžæž‘æž’æž“æž”æž–æž™æž›æžŸæž æž¡æž¤æž¦æž©æž¬æž®æž±æž²æž´æž¹",
    7,
    "æŸ‚æŸ…",
    9,
    "æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ",
    7,
    "æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜",
    4,
    "æ žæ Ÿæ  æ ¢",
    6,
    "æ «",
    6,
    "æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–",
    5
  ],
  [
    "9740",
    "æ¡œæ¡æ¡žæ¡Ÿæ¡ªæ¡¬",
    7,
    "æ¡µæ¡¸",
    8,
    "æ¢‚æ¢„æ¢‡",
    7,
    "æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜",
    9,
    "æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"
  ],
  [
    "9780",
    "æ¢¹",
    6,
    "æ£æ£ƒ",
    5,
    "æ£Šæ£Œæ£Žæ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›",
    4,
    "æ£¡æ£¢æ£¤",
    9,
    "æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†",
    4,
    "æ¤Œæ¤æ¤‘æ¤“",
    11,
    "æ¤¡æ¤¢æ¤£æ¤¥",
    7,
    "æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ",
    16,
    "æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ"
  ],
  [
    "9840",
    "æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",
    4,
    "æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦Ž",
    5,
    "æ¦–æ¦—æ¦™æ¦šæ¦",
    9,
    "æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"
  ],
  [
    "9880",
    "æ¦¾æ¦¿æ§€æ§‚",
    7,
    "æ§‹æ§æ§æ§‘æ§’æ§“æ§•",
    5,
    "æ§œæ§æ§žæ§¡",
    11,
    "æ§®æ§¯æ§°æ§±æ§³",
    9,
    "æ§¾æ¨€",
    9,
    "æ¨‹",
    11,
    "æ¨™",
    5,
    "æ¨ æ¨¢",
    5,
    "æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",
    6,
    "æ¨¿",
    4,
    "æ©…æ©†æ©ˆ",
    7,
    "æ©‘",
    6,
    "æ©š"
  ],
  [
    "9940",
    "æ©œ",
    4,
    "æ©¢æ©£æ©¤æ©¦",
    10,
    "æ©²",
    6,
    "æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…",
    8,
    "æªæª’",
    4,
    "æª˜",
    7,
    "æª¡",
    5
  ],
  [
    "9980",
    "æª§æª¨æªªæª­",
    114,
    "æ¬¥æ¬¦æ¬¨",
    6
  ],
  [
    "9a40",
    "æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­",
    11,
    "æ­š",
    7,
    "æ­¨æ­©æ­«",
    13,
    "æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ"
  ],
  [
    "9a80",
    "æ®Œæ®Žæ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ",
    4,
    "æ®¢",
    7,
    "æ®«",
    7,
    "æ®¶æ®¸",
    6,
    "æ¯€æ¯ƒæ¯„æ¯†",
    4,
    "æ¯Œæ¯Žæ¯æ¯‘æ¯˜æ¯šæ¯œ",
    4,
    "æ¯¢",
    7,
    "æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",
    6,
    "æ°ˆ",
    4,
    "æ°Žæ°’æ°—æ°œæ°æ°žæ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹",
    4,
    "æ±‘æ±’æ±“æ±–æ±˜"
  ],
  [
    "9b40",
    "æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«",
    4,
    "æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²Žæ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²žæ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³Žæ³æ³‘æ³’æ³˜"
  ],
  [
    "9b80",
    "æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ",
    5,
    "æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",
    4,
    "æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–",
    4,
    "æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",
    5,
    "æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š"
  ],
  [
    "9c40",
    "æ·æ·Žæ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",
    7,
    "æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸žæ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"
  ],
  [
    "9c80",
    "æ¸¶æ¸·æ¸¹æ¸»",
    7,
    "æ¹…",
    7,
    "æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹žæ¹ ",
    10,
    "æ¹¬æ¹­æ¹¯",
    14,
    "æº€æºæº‚æº„æº‡æºˆæºŠ",
    4,
    "æº‘",
    6,
    "æº™æºšæº›æºæºžæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»Žæ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª",
    5
  ],
  [
    "9d40",
    "æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",
    7,
    "æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š",
    4,
    "æ¼æ¼‘æ¼’æ¼–",
    9,
    "æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",
    6,
    "æ¼¿æ½€æ½æ½‚"
  ],
  [
    "9d80",
    "æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½Ž",
    9,
    "æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§",
    5,
    "æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",
    6,
    "æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾",
    12,
    "æ¾æ¾žæ¾Ÿæ¾ æ¾¢",
    4,
    "æ¾¨",
    10,
    "æ¾´æ¾µæ¾·æ¾¸æ¾º",
    5,
    "æ¿æ¿ƒ",
    5,
    "æ¿Š",
    6,
    "æ¿“",
    10,
    "æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥"
  ],
  [
    "9e40",
    "æ¿¦",
    7,
    "æ¿°",
    32,
    "ç€’",
    7,
    "ç€œ",
    6,
    "ç€¤",
    6
  ],
  [
    "9e80",
    "ç€«",
    9,
    "ç€¶ç€·ç€¸ç€º",
    17,
    "ççŽç",
    13,
    "çŸ",
    11,
    "ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚ž",
    12,
    "ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹",
    12,
    "çƒš"
  ],
  [
    "9f40",
    "çƒœçƒçƒžçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°",
    6,
    "çƒ¸çƒºçƒ»çƒ¼çƒ¾",
    10,
    "ç„‹",
    4,
    "ç„‘ç„’ç„”ç„—ç„›",
    10,
    "ç„§",
    7,
    "ç„²ç„³ç„´"
  ],
  [
    "9f80",
    "ç„µç„·",
    13,
    "ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…",
    12,
    "ç…ç…Ÿ",
    4,
    "ç…¥ç…©",
    4,
    "ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾",
    5,
    "ç†…",
    4,
    "ç†‹ç†Œç†ç†Žç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š",
    4,
    "ç†¡",
    6,
    "ç†©ç†ªç†«ç†­",
    5,
    "ç†´ç†¶ç†·ç†¸ç†º",
    8,
    "ç‡„",
    9,
    "ç‡",
    4
  ],
  [
    "a040",
    "ç‡–",
    9,
    "ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨",
    5,
    "ç‡¯",
    9,
    "ç‡º",
    11,
    "çˆ‡",
    19
  ],
  [
    "a080",
    "çˆ›çˆœçˆž",
    9,
    "çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€",
    6,
    "ç‰‰ç‰Šç‰‹ç‰Žç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰žç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…",
    4,
    "çŠŒçŠŽçŠçŠ‘çŠ“",
    11,
    "çŠ ",
    11,
    "çŠ®çŠ±çŠ²çŠ³çŠµçŠº",
    6,
    "ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›"
  ],
  [
    "a1a1",
    "ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½žâ€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
    7,
    "ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆžâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“"
  ],
  [
    "a2a1",
    "â…°",
    9
  ],
  [
    "a2b1",
    "â’ˆ",
    19,
    "â‘´",
    19,
    "â‘ ",
    9
  ],
  [
    "a2e5",
    "ãˆ ",
    9
  ],
  [
    "a2f1",
    "â… ",
    11
  ],
  [
    "a3a1",
    "ï¼ï¼‚ï¼ƒï¿¥ï¼…",
    88,
    "ï¿£"
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã‚¡",
    85
  ],
  [
    "a6a1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a6e0",
    "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"
  ],
  [
    "a6ee",
    "ï¸»ï¸¼ï¸·ï¸¸ï¸±"
  ],
  [
    "a6f4",
    "ï¸³ï¸´"
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "a840",
    "ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•",
    35,
    "â–",
    6
  ],
  [
    "a880",
    "â–ˆ",
    7,
    "â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€ž"
  ],
  [
    "a8a1",
    "ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"
  ],
  [
    "a8bd",
    "Å„Åˆ"
  ],
  [
    "a8c0",
    "É¡"
  ],
  [
    "a8c5",
    "ã„…",
    36
  ],
  [
    "a940",
    "ã€¡",
    8,
    "ãŠ£ãŽŽãŽãŽœãŽãŽžãŽ¡ã„ãŽã‘ã’ã•ï¸°ï¿¢ï¿¤"
  ],
  [
    "a959",
    "â„¡ãˆ±"
  ],
  [
    "a95c",
    "â€"
  ],
  [
    "a960",
    "ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚žï¹‰",
    9,
    "ï¹”ï¹•ï¹–ï¹—ï¹™",
    8
  ],
  [
    "a980",
    "ï¹¢",
    4,
    "ï¹¨ï¹©ï¹ªï¹«"
  ],
  [
    "a996",
    "ã€‡"
  ],
  [
    "a9a4",
    "â”€",
    75
  ],
  [
    "aa40",
    "ç‹œç‹ç‹Ÿç‹¢",
    5,
    "ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„",
    5,
    "çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€",
    8
  ],
  [
    "aa80",
    "ç‰çŠç‹çŒçŽçç‘ç“ç”ç•ç–ç˜",
    7,
    "ç¡",
    10,
    "ç®ç°ç±"
  ],
  [
    "ab40",
    "ç²",
    11,
    "ç¿",
    4,
    "çŽ…çŽ†çŽˆçŽŠçŽŒçŽçŽçŽçŽ’çŽ“çŽ”çŽ•çŽ—çŽ˜çŽ™çŽšçŽœçŽçŽžçŽ çŽ¡çŽ£",
    5,
    "çŽªçŽ¬çŽ­çŽ±çŽ´çŽµçŽ¶çŽ¸çŽ¹çŽ¼çŽ½çŽ¾çŽ¿ççƒ",
    4
  ],
  [
    "ab80",
    "ç‹çŒçŽç’",
    6,
    "çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³",
    4
  ],
  [
    "ac40",
    "ç¸",
    10,
    "ç„ç‡çˆç‹çŒççŽç‘",
    8,
    "çœ",
    5,
    "ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",
    4,
    "ç½ç¾ç¿ç‘€ç‘‚",
    11
  ],
  [
    "ac80",
    "ç‘Ž",
    6,
    "ç‘–ç‘˜ç‘ç‘ ",
    12,
    "ç‘®ç‘¯ç‘±",
    4,
    "ç‘¸ç‘¹ç‘º"
  ],
  [
    "ad40",
    "ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘",
    10,
    "ç’ç’Ÿ",
    7,
    "ç’ª",
    15,
    "ç’»",
    12
  ],
  [
    "ad80",
    "ç“ˆ",
    9,
    "ç““",
    8,
    "ç“ç“Ÿç“¡ç“¥ç“§",
    6,
    "ç“°ç“±ç“²"
  ],
  [
    "ae40",
    "ç“³ç“µç“¸",
    6,
    "ç”€ç”ç”‚ç”ƒç”…",
    7,
    "ç”Žç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”žç” ",
    4,
    "ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜"
  ],
  [
    "ae80",
    "ç•",
    7,
    "ç•§ç•¨ç•©ç•«",
    6,
    "ç•³ç•µç•¶ç•·ç•º",
    4,
    "ç–€ç–ç–‚ç–„ç–…ç–‡"
  ],
  [
    "af40",
    "ç–ˆç–‰ç–Šç–Œç–ç–Žç–ç–“ç–•ç–˜ç–›ç–œç–žç–¢ç–¦",
    4,
    "ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—Žç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡"
  ],
  [
    "af80",
    "ç˜ˆç˜‰ç˜‹ç˜ç˜Žç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜žç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„"
  ],
  [
    "b040",
    "ç™…",
    6,
    "ç™Ž",
    5,
    "ç™•ç™—",
    4,
    "ç™ç™Ÿç™ ç™¡ç™¢ç™¤",
    6,
    "ç™¬ç™­ç™®ç™°",
    7,
    "ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›"
  ],
  [
    "b080",
    "çšœ",
    7,
    "çš¥",
    8,
    "çš¯çš°çš³çšµ",
    9,
    "ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“Žå”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éžæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›Žå‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠžç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹žèƒžåŒ…è¤’å‰¥"
  ],
  [
    "b140",
    "ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›žç› ",
    4,
    "ç›¦",
    7,
    "ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœŽ",
    10,
    "çœ›çœœçœçœžçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«"
  ],
  [
    "b180",
    "çœ¬çœ®çœ°",
    4,
    "çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ",
    7,
    "ç’",
    7,
    "çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›éž­è¾¹ç¼–è´¬æ‰ä¾¿å˜åžè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³"
  ],
  [
    "b240",
    "ççžçŸç ç¤ç§ç©çªç­",
    11,
    "çºç»ç¼çžçž‚çžƒçž†",
    5,
    "çžçžçž“",
    11,
    "çž¡çž£çž¤çž¦çž¨çž«çž­çž®çž¯çž±çž²çž´çž¶",
    4
  ],
  [
    "b280",
    "çž¼çž¾çŸ€",
    12,
    "çŸŽ",
    8,
    "çŸ˜çŸ™çŸšçŸ",
    4,
    "çŸ¤ç—…å¹¶çŽ»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰åŽ•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æŽºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–"
  ],
  [
    "b340",
    "çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ",
    5,
    "ç Šç ‹ç Žç ç ç “ç •ç ™ç ›ç žç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š"
  ],
  [
    "b380",
    "ç¡›ç¡œç¡ž",
    11,
    "ç¡¯",
    7,
    "ç¡¸ç¡¹ç¡ºç¡»ç¡½",
    6,
    "åœºå°å¸¸é•¿å¿è‚ åŽ‚æ•žç•…å”±å€¡è¶…æŠ„é’žæœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æŽ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸŽæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€žéª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸çž…ä¸‘è‡­åˆå‡ºæ©±åŽ¨èº‡é”„é›æ»é™¤æ¥š"
  ],
  [
    "b440",
    "ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢žç¢ ç¢¢ç¢¤ç¢¦ç¢¨",
    7,
    "ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£Žç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š",
    9
  ],
  [
    "b480",
    "ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",
    4,
    "ç£³ç£µç£¶ç£¸ç£¹ç£»",
    5,
    "ç¤‚ç¤ƒç¤„ç¤†",
    6,
    "ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤åž‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾žæ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»Žä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æŽªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®"
  ],
  [
    "b540",
    "ç¤",
    5,
    "ç¤”",
    9,
    "ç¤Ÿ",
    4,
    "ç¤¥",
    14,
    "ç¤µ",
    4,
    "ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š",
    8,
    "ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£"
  ],
  [
    "b580",
    "ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",
    6,
    "ç¥¹ç¥»",
    4,
    "ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦Žç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æŽ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯žå¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çžªå‡³é‚“å ¤ä½Žæ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æŽ‚æ»‡ç¢˜ç‚¹å…¸é›åž«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæŽ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å "
  ],
  [
    "b640",
    "ç¦“",
    6,
    "ç¦›",
    11,
    "ç¦¨",
    10,
    "ç¦´",
    4,
    "ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§Žç§ç§ç§“ç§”ç§–ç§—ç§™",
    5,
    "ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"
  ],
  [
    "b680",
    "ç§¬ç§®ç§±",
    6,
    "ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨",
    4,
    "ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼Žé”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´žå…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼Žå †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæŽ‡å“†å¤šå¤ºåž›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶åŽ„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ"
  ],
  [
    "b740",
    "ç¨ç¨Ÿç¨¡ç¨¢ç¨¤",
    14,
    "ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€",
    5,
    "ç©‡",
    9,
    "ç©’",
    4,
    "ç©˜",
    16
  ],
  [
    "b780",
    "ç©©",
    6,
    "ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªŽçªçªçª“çª”çª™çªšçª›çªžçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éžå•¡é£žè‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æž«èœ‚å³°é”‹é£Žç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ"
  ],
  [
    "b840",
    "çª£çª¤çª§çª©çªªçª«çª®",
    4,
    "çª´",
    10,
    "ç«€",
    10,
    "ç«Œ",
    9,
    "ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§",
    5,
    "ç«®ç«°ç«±ç«²ç«³"
  ],
  [
    "b880",
    "ç«´",
    4,
    "ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬Žç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜Žè¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æžé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹"
  ],
  [
    "b940",
    "ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",
    5,
    "ç­†ç­ˆç­Šç­ç­Žç­“ç­•ç­—ç­™ç­œç­žç­Ÿç­¡ç­£",
    10,
    "ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†",
    6,
    "ç®Žç®"
  ],
  [
    "b980",
    "ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®žç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",
    7,
    "ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±žæ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—åž¢æž„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æžœè£¹è¿‡å“ˆ"
  ],
  [
    "ba40",
    "ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯Žç¯ç¯ç¯’ç¯”",
    4,
    "ç¯›ç¯œç¯žç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",
    4,
    "ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",
    7,
    "ç°ˆç°‰ç°Šç°ç°Žç°",
    5,
    "ç°—ç°˜ç°™"
  ],
  [
    "ba80",
    "ç°š",
    4,
    "ç° ",
    5,
    "ç°¨ç°©ç°«",
    12,
    "ç°¹",
    5,
    "ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšŽè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åŽšå€™åŽå‘¼ä¹Žå¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–"
  ],
  [
    "bb40",
    "ç±ƒ",
    9,
    "ç±Ž",
    36,
    "ç±µ",
    5,
    "ç±¾",
    9
  ],
  [
    "bb80",
    "ç²ˆç²Š",
    6,
    "ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",
    4,
    "ç²ºç²»å¼§è™Žå”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åŽçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢çŽ¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°Žç°æŒ¥è¾‰å¾½æ¢è›”å›žæ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«èŽ·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•"
  ],
  [
    "bc40",
    "ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³Ž",
    6,
    "ç³˜ç³šç³›ç³ç³žç³¡",
    6,
    "ç³©",
    5,
    "ç³°",
    7,
    "ç³¹ç³ºç³¼",
    13,
    "ç´‹",
    5
  ],
  [
    "bc80",
    "ç´‘",
    14,
    "ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",
    6,
    "è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰æžæ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼Žç¥­å‰‚æ‚¸æµŽå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æž·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æž¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…Žå…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶"
  ],
  [
    "bd40",
    "ç´·",
    54,
    "çµ¯",
    7
  ],
  [
    "bd80",
    "çµ¸",
    32,
    "å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»žå‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æŽ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸"
  ],
  [
    "be40",
    "ç¶™",
    12,
    "ç¶§",
    6,
    "ç¶¯",
    42
  ],
  [
    "be80",
    "ç·š",
    32,
    "å°½åŠ²è†å…¢èŒŽç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«žå‡€ç‚¯çª˜æªç©¶çº çŽ–éŸ­ä¹…ç¸ä¹é…’åŽ©æ•‘æ—§è‡¼èˆ…å’Žå°±ç–šéž æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸žé”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æŽ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»"
  ],
  [
    "bf40",
    "ç·»",
    62
  ],
  [
    "bf80",
    "ç¸ºç¸¼",
    4,
    "ç¹‚",
    4,
    "ç¹ˆ",
    21,
    "ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åŽç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒåž¦æ³å‘å­ç©ºæå­”æŽ§æŠ å£æ‰£å¯‡æž¯å“­çªŸè‹¦é…·åº“è£¤å¤¸åž®æŒŽè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥Žé­å‚€"
  ],
  [
    "c040",
    "ç¹ž",
    35,
    "çºƒ",
    23,
    "çºœçºçºž"
  ],
  [
    "c080",
    "çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼žç¼·ç¼¹ç¼»",
    6,
    "ç½ƒç½†",
    9,
    "ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åžƒæ‹‰å–‡èœ¡è…Šè¾£å•¦èŽ±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»ŠéƒŽæœ—æµªæžåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡åž’æ“‚è‚‹ç±»æ³ªæ£±æ¥žå†·åŽ˜æ¢¨çŠé»Žç¯±ç‹¸ç¦»æ¼“ç†æŽé‡Œé²¤ç¤¼èŽ‰è”åæ —ä¸½åŽ‰åŠ±ç ¾åŽ†åˆ©å‚ˆä¾‹ä¿"
  ],
  [
    "c140",
    "ç½–ç½™ç½›ç½œç½ç½žç½ ç½£",
    4,
    "ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚",
    7,
    "ç¾‹ç¾ç¾",
    4,
    "ç¾•",
    4,
    "ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",
    6,
    "ç¾±"
  ],
  [
    "c180",
    "ç¾³",
    4,
    "ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿",
    4,
    "ç¿–ç¿—ç¿™",
    5,
    "ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”èŽ²è¿žé•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡Žå¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒŽç³æž—ç£·éœ–ä¸´é‚»é³žæ·‹å‡›èµåæ‹ŽçŽ²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿"
  ],
  [
    "c240",
    "ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",
    6,
    "ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€Žè€è€‘è€“è€šè€›è€è€žè€Ÿè€¡è€£è€¤è€«",
    5,
    "è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èŽèèè‘è“è•è–è—"
  ],
  [
    "c280",
    "è™è›",
    13,
    "è«",
    5,
    "è²",
    11,
    "éš†åž„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æŽ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½žç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹çŽ‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æŽ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèžºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»çŽ›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰çž’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«"
  ],
  [
    "c340",
    "è¾è‚è‚‚è‚…è‚ˆè‚Šè‚",
    5,
    "è‚”è‚•è‚—è‚™è‚žè‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡",
    4,
    "èƒ",
    6,
    "èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹"
  ],
  [
    "c380",
    "è„Œè„•è„—è„™è„›è„œè„è„Ÿ",
    12,
    "è„­è„®è„°è„³è„´è„µè„·è„¹",
    4,
    "è„¿è°©èŠ’èŒ«ç›²æ°“å¿™èŽ½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆçŽ«æžšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾Žæ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æçž„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜ŽèžŸé¸£é“­åå‘½è°¬æ‘¸"
  ],
  [
    "c440",
    "è…€",
    5,
    "è…‡è…‰è…è…Žè…è…’è…–è…—è…˜è…›",
    4,
    "è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ",
    4,
    "è†‰è†‹è†Œè†è†Žè†è†’",
    5,
    "è†™è†šè†ž",
    4,
    "è†¤è†¥"
  ],
  [
    "c480",
    "è†§è†©è†«",
    7,
    "è†´",
    5,
    "è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡",
    6,
    "æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«èŽ«å¢¨é»˜æ²«æ¼ å¯žé™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹žå‡å®"
  ],
  [
    "c540",
    "è‡”",
    14,
    "è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®",
    4,
    "è‡µ",
    5,
    "è‡½è‡¿èˆƒèˆ‡",
    4,
    "èˆŽèˆèˆ‘èˆ“èˆ•",
    5,
    "èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿"
  ],
  [
    "c580",
    "è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰Žè‰",
    7,
    "è‰™è‰›è‰œè‰è‰žè‰ ",
    7,
    "è‰©æ‹§æ³žç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æŽ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºžæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾Žå½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—"
  ],
  [
    "c640",
    "è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠžèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸"
  ],
  [
    "c680",
    "è‹ºè‹¼",
    4,
    "èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ",
    9,
    "èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—žåƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡çž¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†èŽ†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´Žè„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹žä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æŽ"
  ],
  [
    "c740",
    "èŒ¾èŒ¿èè‚è„è…èˆèŠ",
    4,
    "è“è•",
    4,
    "èè¢è°",
    6,
    "è¹èºè¾",
    6,
    "èŽ‡èŽˆèŽŠèŽ‹èŽŒèŽèŽèŽèŽ‘èŽ”èŽ•èŽ–èŽ—èŽ™èŽšèŽèŽŸèŽ¡",
    6,
    "èŽ¬èŽ­èŽ®"
  ],
  [
    "c780",
    "èŽ¯èŽµèŽ»èŽ¾èŽ¿è‚èƒè„è†èˆè‰è‹èèŽèè‘è’è“è•è—è™èšè›èžè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’Žé“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æžªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥çž§ä¹”ä¾¨å·§éž˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“Žæ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ "
  ],
  [
    "c840",
    "è®è¯è³",
    4,
    "èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’",
    5,
    "è™èšè›èž",
    5,
    "è©",
    7,
    "è²",
    5,
    "è¹èºè»è¾",
    7,
    "è‘‡è‘ˆè‘‰"
  ],
  [
    "c880",
    "è‘Š",
    6,
    "è‘’",
    4,
    "è‘˜è‘è‘žè‘Ÿè‘ è‘¢è‘¤",
    4,
    "è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£åŽ»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆŽèŒ¸è“‰è£èžç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘žé”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡žèµ›ä¸‰å"
  ],
  [
    "c940",
    "è‘½",
    4,
    "è’ƒè’„è’…è’†è’Šè’è’",
    7,
    "è’˜è’šè’›è’è’žè’Ÿè’ è’¢",
    12,
    "è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“Žè“è“’è“”è“•è“—"
  ],
  [
    "c980",
    "è“˜",
    4,
    "è“žè“¡è“¢è“¤è“§",
    4,
    "è“­è“®è“¯è“±",
    10,
    "è“½è“¾è”€è”è”‚ä¼žæ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èŽŽç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…žç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æŽç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥žæ²ˆå®¡å©¶ç”šè‚¾æ…Žæ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³"
  ],
  [
    "ca40",
    "è”ƒ",
    8,
    "è”è”Žè”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”žè” è”¢",
    8,
    "è”­",
    9,
    "è”¾",
    4,
    "è•„è•…è•†è•‡è•‹",
    10
  ],
  [
    "ca80",
    "è•—è•˜è•šè•›è•œè•è•Ÿ",
    4,
    "è•¥è•¦è•§è•©",
    8,
    "è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®žè¯†å²çŸ¢ä½¿å±Žé©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æŽˆå”®å—ç˜¦å…½è”¬æž¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµŽå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±žæœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±"
  ],
  [
    "cb40",
    "è–‚è–ƒè–†è–ˆ",
    6,
    "è–",
    10,
    "è–",
    6,
    "è–¥è–¦è–§è–©è–«è–¬è–­è–±",
    5,
    "è–¸è–º",
    6,
    "è—‚",
    6,
    "è—Š",
    4,
    "è—‘è—’"
  ],
  [
    "cb80",
    "è—”è—–",
    5,
    "è—",
    6,
    "è—¥è—¦è—§è—¨è—ª",
    14,
    "æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨Žå®çž¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“žå—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢Žå²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”"
  ],
  [
    "cc40",
    "è—¹è—ºè—¼è—½è—¾è˜€",
    4,
    "è˜†",
    10,
    "è˜’è˜“è˜”è˜•è˜—",
    15,
    "è˜¨è˜ª",
    13,
    "è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€"
  ],
  [
    "cc80",
    "è™",
    11,
    "è™’è™“è™•",
    4,
    "è™›è™œè™è™Ÿè™ è™¡è™£",
    7,
    "ç­æŒžè¹‹è¸èƒŽè‹”æŠ¬å°æ³°é…žå¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æŽ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«æŽæ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–åŽ…å¬çƒƒ"
  ],
  [
    "cd40",
    "è™­è™¯è™°è™²",
    6,
    "èšƒ",
    6,
    "èšŽ",
    4,
    "èš”èš–",
    5,
    "èšž",
    4,
    "èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»",
    4,
    "è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ"
  ],
  [
    "cd80",
    "è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœŽèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®çž³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æŽ¨é¢“è…¿èœ•è¤ªé€€åžå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾çŽ©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªçŽ‹äº¡æž‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨"
  ],
  [
    "ce40",
    "èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€",
    6,
    "èŠè‹èèèè‘è’è”è•è–è˜èš",
    5,
    "è¡è¢è¦",
    7,
    "è¯è±è²è³èµ"
  ],
  [
    "ce80",
    "è·è¸è¹èºè¿èž€èžèž„èž†èž‡èž‰èžŠèžŒèžŽ",
    4,
    "èž”èž•èž–èž˜",
    6,
    "èž ",
    4,
    "å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èŽå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆžä¼ä¾®åžæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æžè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º"
  ],
  [
    "cf40",
    "èž¥èž¦èž§èž©èžªèž®èž°èž±èž²èž´èž¶èž·èž¸èž¹èž»èž¼èž¾èž¿èŸ",
    4,
    "èŸ‡èŸˆèŸ‰èŸŒ",
    4,
    "èŸ”",
    6,
    "èŸœèŸèŸžèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯",
    9
  ],
  [
    "cf80",
    "èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „",
    5,
    "è ‹",
    7,
    "è ”è —è ˜è ™è šè œ",
    4,
    "è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çžŽè™¾åŒ£éœžè¾–æš‡å³¡ä¾ ç‹­ä¸‹åŽ¦å¤å“æŽ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶Žå¼¦å«Œæ˜¾é™©çŽ°çŒ®åŽ¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸åŽ¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“"
  ],
  [
    "d040",
    "è ¤",
    13,
    "è ³",
    5,
    "è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†",
    5,
    "è¡Ž",
    5,
    "è¡•è¡–è¡˜è¡š",
    6,
    "è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"
  ],
  [
    "d080",
    "è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢Žè¢è¢è¢‘è¢“è¢”è¢•è¢—",
    4,
    "è¢",
    4,
    "è¢£è¢¥",
    5,
    "å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èŽéž‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘åž‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾žæœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹çŽ„"
  ],
  [
    "d140",
    "è¢¬è¢®è¢¯è¢°è¢²",
    4,
    "è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š",
    4,
    "è£ è£¡è£¦è£§è£©",
    6,
    "è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ",
    5
  ],
  [
    "d180",
    "è¤‰è¤‹",
    4,
    "è¤‘è¤”",
    4,
    "è¤œ",
    4,
    "è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…åŽ‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜Žç‚Žæ²¿å¥„æŽ©çœ¼è¡æ¼”è‰³å °ç‡•åŽŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶"
  ],
  [
    "d240",
    "è¤¸",
    8,
    "è¥‚è¥ƒè¥…",
    24,
    "è¥ ",
    5,
    "è¥§",
    19,
    "è¥¼"
  ],
  [
    "d280",
    "è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡",
    26,
    "æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™Žè€¶çˆ·é‡Žå†¶ä¹Ÿé¡µæŽ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»ŽèŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš"
  ],
  [
    "d340",
    "è¦¢",
    30,
    "è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",
    6
  ],
  [
    "d380",
    "è§»",
    4,
    "è¨",
    5,
    "è¨ˆ",
    21,
    "å°è‹±æ¨±å©´é¹°åº”ç¼¨èŽ¹è¤è¥è§è‡è¿Žèµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºŽç›‚æ¦†è™žæ„šèˆ†ä½™ä¿žé€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸Žå±¿ç¦¹å®‡è¯­ç¾½çŽ‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰"
  ],
  [
    "d440",
    "è¨ž",
    31,
    "è¨¿",
    8,
    "è©‰",
    21
  ],
  [
    "d480",
    "è©Ÿ",
    25,
    "è©º",
    6,
    "æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒåž£è¢åŽŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµžèµƒè„è‘¬é­ç³Ÿå‡¿è—»æž£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€Žå¢žæ†Žæ›¾èµ æ‰Žå–³æ¸£æœ­è½§"
  ],
  [
    "d540",
    "èª",
    7,
    "èª‹",
    7,
    "èª”",
    46
  ],
  [
    "d580",
    "è«ƒ",
    32,
    "é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨çž»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŽŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´žé’ˆä¾¦æž•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿"
  ],
  [
    "d640",
    "è«¤",
    34,
    "è¬ˆ",
    27
  ],
  [
    "d680",
    "è¬¤è¬¥è¬§",
    30,
    "å¸§ç—‡éƒ‘è¯èŠæžæ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæŽ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»žæ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·žæ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„çž©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘"
  ],
  [
    "d740",
    "è­†",
    31,
    "è­§",
    4,
    "è­­",
    25
  ],
  [
    "d780",
    "è®‡",
    24,
    "è®¬è®±è®»è¯‡è¯è¯ªè°‰è°žä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’žå£®çŠ¶æ¤Žé”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸžåšä½œååº§"
  ],
  [
    "d840",
    "è°¸",
    8,
    "è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±",
    7,
    "è±–è±—è±˜è±™è±›",
    5,
    "è±£",
    6,
    "è±¬",
    6,
    "è±´è±µè±¶è±·è±»",
    6,
    "è²ƒè²„è²†è²‡"
  ],
  [
    "d880",
    "è²ˆè²‹è²",
    6,
    "è²•è²–è²—è²™",
    20,
    "äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸žé¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„åŽåŽåŽ£åŽ¥åŽ®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆŽåˆ­åˆ³åˆ¿å‰€å‰Œå‰žå‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»žä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½žä½§æ”¸ä½šä½"
  ],
  [
    "d940",
    "è²®",
    62
  ],
  [
    "d980",
    "è³­",
    32,
    "ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåŽå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿Žé¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼"
  ],
  [
    "da40",
    "è´Ž",
    14,
    "è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",
    8,
    "è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ",
    4,
    "è¶’è¶“è¶•",
    9,
    "è¶ è¶¡"
  ],
  [
    "da80",
    "è¶¢è¶¤",
    12,
    "è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯Žè¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º"
  ],
  [
    "db40",
    "è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",
    6,
    "è¸†è¸‡è¸ˆè¸‹è¸è¸Žè¸è¸‘è¸’è¸“è¸•",
    7,
    "è¸ è¸¡è¸¤",
    4,
    "è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"
  ],
  [
    "db80",
    "è¸¿è¹ƒè¹…è¹†è¹Œ",
    4,
    "è¹“",
    5,
    "è¹š",
    11,
    "è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„žé„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯åŽ¶å¼ç•šå·¯åŒåž©åž¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©åž…å«åž†å¼å»å¨å­å¶å³åž­åž¤åžŒåž²åŸåž§åž´åž“åž åŸ•åŸ˜åŸšåŸ™åŸ’åž¸åŸ´åŸ¯åŸ¸åŸ¤åŸ"
  ],
  [
    "dc40",
    "è¹³è¹µè¹·",
    4,
    "è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ",
    6,
    "èº‘èº’èº“èº•",
    6,
    "èºèºŸ",
    11,
    "èº­èº®èº°èº±èº³",
    6,
    "èº»",
    7
  ],
  [
    "dc80",
    "è»ƒ",
    10,
    "è»",
    21,
    "å ‹å åŸ½åŸ­å €å žå ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠŽèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹ŽèŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆèŽ’èŒ¼èŒ´èŒ±èŽ›èžèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥"
  ],
  [
    "dd40",
    "è»¥",
    62
  ],
  [
    "dd80",
    "è¼¤",
    32,
    "è¨èŒ›è©è¬èªè­è®èŽ°è¸èŽ³èŽ´èŽ èŽªèŽ“èŽœèŽ…è¼èŽ¶èŽ©è½èŽ¸è»èŽ˜èŽžèŽ¨èŽºèŽ¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’Žè±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º"
  ],
  [
    "de40",
    "è½…",
    32,
    "è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†"
  ],
  [
    "de80",
    "è¿‰",
    4,
    "è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€Žé€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•žè•ºçž¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæŽ­æ¶æ±æºæŽŽæŽ´æ­æŽ¬æŽŠæ©æŽ®æŽ¼æ²æ¸æ æ¿æ„æžæŽæ‘’æ†æŽ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘žæ’„æ‘­æ’–"
  ],
  [
    "df40",
    "é€™é€œé€£é€¤é€¥é€§",
    5,
    "é€°",
    4,
    "é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ",
    4,
    "éŽé”é•é–é™éšéœ",
    5,
    "é¤é¦é§é©éªé«é¬é¯",
    4,
    "é¶",
    6,
    "é¾é‚"
  ],
  [
    "df80",
    "é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ",
    4,
    "é‚’é‚”é‚–é‚˜é‚šé‚œé‚žé‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“žå”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼"
  ],
  [
    "e040",
    "éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒžéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…",
    19,
    "é„šé„›é„œ"
  ],
  [
    "e080",
    "é„é„Ÿé„ é„¡é„¤",
    10,
    "é„°é„²",
    6,
    "é„º",
    8,
    "é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜žå˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼"
  ],
  [
    "e140",
    "é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€",
    4,
    "é††é†ˆé†Šé†Žé†é†“",
    6,
    "é†œ",
    5,
    "é†¤",
    5,
    "é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»"
  ],
  [
    "e180",
    "é†¼",
    10,
    "é‡ˆé‡‹é‡é‡’",
    9,
    "é‡",
    8,
    "å¸·å¹„å¹”å¹›å¹žå¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´žå´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹Žç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º"
  ],
  [
    "e240",
    "é‡¦",
    62
  ],
  [
    "e280",
    "éˆ¥",
    32,
    "ç‹»çŒ—çŒ“çŒ¡çŒŠçŒžçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§",
    5,
    "é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚"
  ],
  [
    "e340",
    "é‰†",
    45,
    "é‰µ",
    16
  ],
  [
    "e380",
    "éŠ†",
    7,
    "éŠ",
    24,
    "æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„Žæ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾"
  ],
  [
    "e440",
    "éŠ¨",
    5,
    "éŠ¯",
    24,
    "é‹‰",
    31
  ],
  [
    "e480",
    "é‹©",
    32,
    "æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´Žæ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶žæ¶ æµžæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·žæ¸Žæ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹Žæ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘"
  ],
  [
    "e540",
    "éŒŠ",
    51,
    "éŒ¿",
    10
  ],
  [
    "e580",
    "éŠ",
    31,
    "é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿žæ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççžå®€å®„å®•å®“å®¥å®¸ç”¯éªžæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£"
  ],
  [
    "e640",
    "é¬",
    34,
    "éŽ",
    27
  ],
  [
    "e680",
    "éŽ¬",
    29,
    "é‹éŒéå¦—å§Šå¦«å¦žå¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©"
  ],
  [
    "e740",
    "éŽ",
    7,
    "é—",
    54
  ],
  [
    "e780",
    "éŽ",
    32,
    "çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡",
    6,
    "ç¼ªç¼«ç¼¬ç¼­ç¼¯",
    4,
    "ç¼µå¹ºç•¿å·›ç”¾é‚•çŽŽçŽ‘çŽ®çŽ¢çŽŸçç‚ç‘çŽ·çŽ³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§çžçŽºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬"
  ],
  [
    "e840",
    "é¯",
    14,
    "é¿",
    43,
    "é‘¬é‘­é‘®é‘¯"
  ],
  [
    "e880",
    "é‘°",
    20,
    "é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’Žç’€ç’ç’‡ç’‹ç’žç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“æžæˆæ©æž¥æž‡æªæ³æž˜æž§æµæž¨æžžæž­æž‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æž°æ ŒæŸ™æžµæŸšæž³æŸæ €æŸƒæž¸æŸ¢æ ŽæŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡Žæ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹"
  ],
  [
    "e940",
    "é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·",
    7,
    "é–€",
    42
  ],
  [
    "e980",
    "é–«",
    32,
    "æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§Žæ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªŽæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹"
  ],
  [
    "ea40",
    "é—Œ",
    27,
    "é—¬é—¿é˜‡é˜“é˜˜é˜›é˜žé˜ é˜£",
    6,
    "é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™Žé™é™‘é™’é™“é™–é™—"
  ],
  [
    "ea80",
    "é™˜é™™é™šé™œé™é™žé™ é™£é™¥é™¦é™«é™­",
    4,
    "é™³é™¸",
    12,
    "éš‡éš‰éšŠè¾è¾Žè¾è¾˜è¾šè»Žæˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§Žè§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æŽ°"
  ],
  [
    "eb40",
    "éšŒéšŽéš‘éš’éš“éš•éš–éššéš›éš",
    9,
    "éš¨",
    7,
    "éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–",
    9,
    "é›¡",
    6,
    "é›«"
  ],
  [
    "eb80",
    "é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—",
    4,
    "éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„Žèƒ²èƒ¼æœ•è„’è±šè„¶è„žè„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»"
  ],
  [
    "ec40",
    "éœ¡",
    8,
    "éœ«éœ¬éœ®éœ¯éœ±éœ³",
    4,
    "éœºéœ»éœ¼éœ½éœ¿",
    18,
    "é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª",
    7
  ],
  [
    "ec80",
    "é²éµé·",
    4,
    "é½",
    7,
    "éž†",
    4,
    "éžŒéžŽéžéžéž“éž•éž–éž—éž™",
    4,
    "è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—Žæ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿"
  ],
  [
    "ed40",
    "éžžéžŸéž¡éž¢éž¤",
    6,
    "éž¬éž®éž°éž±éž³éžµ",
    46
  ],
  [
    "ed80",
    "éŸ¤éŸ¥éŸ¨éŸ®",
    4,
    "éŸ´éŸ·",
    23,
    "æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡Žç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤žç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨"
  ],
  [
    "ee40",
    "é ",
    62
  ],
  [
    "ee80",
    "é¡Ž",
    32,
    "ç¢ç¥ç¿çžç½çž€çžŒçž‘çžŸçž çž°çžµçž½ç”ºç•€ç•Žç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶",
    4,
    "é’¼é’½é’¿é“„é“ˆ",
    6,
    "é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“žé“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª"
  ],
  [
    "ef40",
    "é¡¯",
    5,
    "é¢‹é¢Žé¢’é¢•é¢™é¢£é¢¨",
    37,
    "é£é£é£”é£–é£—é£›é£œé£é£ ",
    4
  ],
  [
    "ef80",
    "é£¥é£¦é£©",
    30,
    "é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”Žé”é”’",
    4,
    "é”˜é”›é”é”žé”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•Žé•é•’é•“é•”é•–é•—é•˜é•™é•›é•žé•Ÿé•é•¡é•¢é•¤",
    8,
    "é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨žç¨”"
  ],
  [
    "f040",
    "é¤ˆ",
    4,
    "é¤Žé¤é¤‘",
    28,
    "é¤¯",
    26
  ],
  [
    "f080",
    "é¥Š",
    9,
    "é¥–",
    12,
    "é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšŽçš“çš™çš¤ç“žç“ ç”¬é¸ é¸¢é¸¨",
    4,
    "é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹Žé¹‘é¹•é¹—é¹šé¹›é¹œé¹žé¹£é¹¦",
    6,
    "é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™"
  ],
  [
    "f140",
    "é¦Œé¦Žé¦š",
    10,
    "é¦¦é¦§é¦©",
    47
  ],
  [
    "f180",
    "é§™",
    32,
    "ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™žç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£Žè££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ"
  ],
  [
    "f240",
    "é§º",
    62
  ],
  [
    "f280",
    "é¨¹",
    32,
    "é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢žé¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›Žèš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›žè›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœžèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿èž‚èœ¢è½è¾è»è è°èŒè®èž‹è“è£è¼è¤è™è¥èž“èž¯èž¨èŸ’"
  ],
  [
    "f340",
    "é©š",
    17,
    "é©²éªƒéª‰éªéªŽéª”éª•éª™éª¦éª©",
    6,
    "éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†",
    4,
    "é«é«Žé«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ"
  ],
  [
    "f380",
    "é«é«žé« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",
    8,
    "é«ºé«¼",
    6,
    "é¬„é¬…é¬†èŸ†èžˆèž…èž­èž—èžƒèž«èŸ¥èž¬èžµèž³èŸ‹èŸ“èž½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬žç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹"
  ],
  [
    "f440",
    "é¬‡é¬‰",
    5,
    "é¬é¬‘é¬’é¬”",
    10,
    "é¬ é¬¡é¬¢é¬¤",
    10,
    "é¬°é¬±é¬³",
    7,
    "é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­Žé­é­’é­“é­•",
    5
  ],
  [
    "f480",
    "é­›",
    32,
    "ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥žç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²žç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿Žç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…Žé…é…¤"
  ],
  [
    "f540",
    "é­¼",
    62
  ],
  [
    "f580",
    "é®»",
    32,
    "é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·žè·Žè·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºžè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§žè§šè§œ"
  ],
  [
    "f640",
    "é¯œ",
    62
  ],
  [
    "f680",
    "é°›",
    32,
    "è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœŽéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…",
    5,
    "é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›Žé›’çž¿é› éŠŽéŠ®é‹ˆéŒ¾éªéŠéŽé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²Žé²é²‘é²’é²”é²•é²šé²›é²ž",
    5,
    "é²¥",
    4,
    "é²«é²­é²®é²°",
    7,
    "é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹"
  ],
  [
    "f740",
    "é°¼",
    62
  ],
  [
    "f780",
    "é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾",
    4,
    "é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ",
    4,
    "é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼éž…éž‘éž’éž”éž¯éž«éž£éž²éž´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„"
  ],
  [
    "f840",
    "é³£",
    62
  ],
  [
    "f880",
    "é´¢",
    32
  ],
  [
    "f940",
    "éµƒ",
    62
  ],
  [
    "f980",
    "é¶‚",
    32
  ],
  [
    "fa40",
    "é¶£",
    62
  ],
  [
    "fa80",
    "é·¢",
    32
  ],
  [
    "fb40",
    "é¸ƒ",
    27,
    "é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",
    9,
    "éº€"
  ],
  [
    "fb80",
    "éºéºƒéº„éº…éº†éº‰éºŠéºŒ",
    5,
    "éº”",
    8,
    "éºžéº ",
    5,
    "éº§éº¨éº©éºª"
  ],
  [
    "fc40",
    "éº«",
    8,
    "éºµéº¶éº·éº¹éººéº¼éº¿",
    4,
    "é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»žé»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",
    8,
    "é»ºé»½é»¿",
    6
  ],
  [
    "fc80",
    "é¼†",
    4,
    "é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š",
    5,
    "é¼¡é¼£",
    8,
    "é¼­é¼®é¼°é¼±"
  ],
  [
    "fd40",
    "é¼²",
    4,
    "é¼¸é¼ºé¼¼é¼¿",
    4,
    "é½…",
    10,
    "é½’",
    38
  ],
  [
    "fd80",
    "é½¹",
    5,
    "é¾é¾‚é¾",
    11,
    "é¾œé¾é¾žé¾¡",
    4,
    "ï¤¬ï¥¹ï¦•ï§§ï§±"
  ],
  [
    "fe40",
    "ï¨Œï¨ï¨Žï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"
  ]
];
const require$$3$2 = [
  [
    "a140",
    "î“†",
    62
  ],
  [
    "a180",
    "î”…",
    32
  ],
  [
    "a240",
    "î”¦",
    62
  ],
  [
    "a280",
    "î•¥",
    32
  ],
  [
    "a2ab",
    "î¦",
    5
  ],
  [
    "a2e3",
    "â‚¬î­"
  ],
  [
    "a2ef",
    "î®î¯"
  ],
  [
    "a2fd",
    "î°î±"
  ],
  [
    "a340",
    "î–†",
    62
  ],
  [
    "a380",
    "î—…",
    31,
    "ã€€"
  ],
  [
    "a440",
    "î—¦",
    62
  ],
  [
    "a480",
    "î˜¥",
    32
  ],
  [
    "a4f4",
    "î²",
    10
  ],
  [
    "a540",
    "î™†",
    62
  ],
  [
    "a580",
    "îš…",
    32
  ],
  [
    "a5f7",
    "î½",
    7
  ],
  [
    "a640",
    "îš¦",
    62
  ],
  [
    "a680",
    "î›¥",
    32
  ],
  [
    "a6b9",
    "îž…",
    7
  ],
  [
    "a6d9",
    "îž",
    6
  ],
  [
    "a6ec",
    "îž”îž•"
  ],
  [
    "a6f3",
    "îž–"
  ],
  [
    "a6f6",
    "îž—",
    8
  ],
  [
    "a740",
    "îœ†",
    62
  ],
  [
    "a780",
    "î…",
    32
  ],
  [
    "a7c2",
    "îž ",
    14
  ],
  [
    "a7f2",
    "îž¯",
    12
  ],
  [
    "a896",
    "îž¼",
    10
  ],
  [
    "a8bc",
    "îŸ‡"
  ],
  [
    "a8bf",
    "Ç¹"
  ],
  [
    "a8c1",
    "îŸ‰îŸŠîŸ‹îŸŒ"
  ],
  [
    "a8ea",
    "îŸ",
    20
  ],
  [
    "a958",
    "îŸ¢"
  ],
  [
    "a95b",
    "îŸ£"
  ],
  [
    "a95d",
    "îŸ¤îŸ¥îŸ¦"
  ],
  [
    "a989",
    "ã€¾â¿°",
    11
  ],
  [
    "a997",
    "îŸ´",
    12
  ],
  [
    "a9f0",
    "î ",
    14
  ],
  [
    "aaa1",
    "î€€",
    93
  ],
  [
    "aba1",
    "îž",
    93
  ],
  [
    "aca1",
    "î‚¼",
    93
  ],
  [
    "ada1",
    "î„š",
    93
  ],
  [
    "aea1",
    "î…¸",
    93
  ],
  [
    "afa1",
    "î‡–",
    93
  ],
  [
    "d7fa",
    "î ",
    4
  ],
  [
    "f8a1",
    "îˆ´",
    93
  ],
  [
    "f9a1",
    "îŠ’",
    93
  ],
  [
    "faa1",
    "î‹°",
    93
  ],
  [
    "fba1",
    "îŽ",
    93
  ],
  [
    "fca1",
    "îŽ¬",
    93
  ],
  [
    "fda1",
    "îŠ",
    93
  ],
  [
    "fe50",
    "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î žã–žã˜šã˜ŽâºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­Žã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »äŽ±äŽ¬âº»ää“–ä™¡ä™Œî¡ƒ"
  ],
  [
    "fe80",
    "äœ£äœ©ä¼äžâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“",
    6,
    "ä¶®î¡¤î‘¨",
    93
  ]
];
const uChars$1 = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars$1 = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4$2 = {
  uChars: uChars$1,
  gbChars: gbChars$1
};
const require$$5$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "ê°‚ê°ƒê°…ê°†ê°‹",
    4,
    "ê°˜ê°žê°Ÿê°¡ê°¢ê°£ê°¥",
    6,
    "ê°®ê°²ê°³ê°´"
  ],
  [
    "8161",
    "ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±",
    9,
    "ê±Œê±Ž",
    5,
    "ê±•"
  ],
  [
    "8181",
    "ê±–ê±—ê±™ê±šê±›ê±",
    18,
    "ê±²ê±³ê±µê±¶ê±¹ê±»",
    4,
    "ê²‚ê²‡ê²ˆê²ê²Žê²ê²‘ê²’ê²“ê²•",
    6,
    "ê²žê²¢",
    5,
    "ê²«ê²­ê²®ê²±",
    6,
    "ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³",
    7,
    "ê³–ê³˜",
    7,
    "ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",
    4,
    "ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡",
    4,
    "ê´Žê´ê´’ê´“"
  ],
  [
    "8241",
    "ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´žê´Ÿê´¡",
    7,
    "ê´ªê´«ê´®",
    5
  ],
  [
    "8261",
    "ê´¶ê´·ê´¹ê´ºê´»ê´½",
    6,
    "êµ†êµˆêµŠ",
    5,
    "êµ‘êµ’êµ“êµ•êµ–êµ—"
  ],
  [
    "8281",
    "êµ™",
    7,
    "êµ¢êµ¤",
    7,
    "êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ",
    4,
    "ê¶Šê¶‹ê¶ê¶Žê¶ê¶‘",
    10,
    "ê¶ž",
    5,
    "ê¶¥",
    17,
    "ê¶¸",
    7,
    "ê·‚ê·ƒê·…ê·†ê·‡ê·‰",
    6,
    "ê·’ê·”",
    7,
    "ê·ê·žê·Ÿê·¡ê·¢ê·£ê·¥",
    18
  ],
  [
    "8341",
    "ê·ºê·»ê·½ê·¾ê¸‚",
    5,
    "ê¸Šê¸Œê¸Ž",
    5,
    "ê¸•",
    7
  ],
  [
    "8361",
    "ê¸",
    18,
    "ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"
  ],
  [
    "8381",
    "ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—",
    4,
    "ê¹žê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",
    6,
    "ê¹ºê¹¾",
    5,
    "êº†",
    5,
    "êº",
    46,
    "êº¿ê»ê»‚ê»ƒê»…",
    6,
    "ê»Žê»’",
    5,
    "ê»šê»›ê»",
    8
  ],
  [
    "8441",
    "ê»¦ê»§ê»©ê»ªê»¬ê»®",
    5,
    "ê»µê»¶ê»·ê»¹ê»ºê»»ê»½",
    8
  ],
  [
    "8461",
    "ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼Žê¼ê¼‘",
    18
  ],
  [
    "8481",
    "ê¼¤",
    7,
    "ê¼®ê¼¯ê¼±ê¼³ê¼µ",
    6,
    "ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š",
    5,
    "ê½‘",
    10,
    "ê½ž",
    5,
    "ê½¦",
    18,
    "ê½º",
    5,
    "ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰",
    6,
    "ê¾’ê¾“ê¾”ê¾–",
    5,
    "ê¾",
    26,
    "ê¾ºê¾»ê¾½ê¾¾"
  ],
  [
    "8541",
    "ê¾¿ê¿",
    5,
    "ê¿Šê¿Œê¿",
    4,
    "ê¿•",
    6,
    "ê¿",
    4
  ],
  [
    "8561",
    "ê¿¢",
    5,
    "ê¿ª",
    5,
    "ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹",
    6,
    "ë€‚ë€ƒ"
  ],
  [
    "8581",
    "ë€…",
    6,
    "ë€ë€Žë€ë€‘ë€’ë€“ë€•",
    6,
    "ë€ž",
    9,
    "ë€©",
    26,
    "ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœëž",
    29,
    "ë¾ë¿ë‚ë‚‚ë‚ƒë‚…",
    6,
    "ë‚Žë‚ë‚’",
    5,
    "ë‚›ë‚ë‚žë‚£ë‚¤"
  ],
  [
    "8641",
    "ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½",
    6,
    "ëƒ†ëƒŠ",
    5,
    "ëƒ’"
  ],
  [
    "8661",
    "ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™",
    6,
    "ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦",
    10
  ],
  [
    "8681",
    "ëƒ±",
    22,
    "ë„Šë„ë„Žë„ë„‘ë„”ë„•ë„–ë„—ë„šë„ž",
    4,
    "ë„¦ë„§ë„©ë„ªë„«ë„­",
    6,
    "ë„¶ë„º",
    5,
    "ë…‚ë…ƒë……ë…†ë…‡ë…‰",
    6,
    "ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…žë…Ÿë…¡",
    22,
    "ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ",
    4,
    "ë†Šë†Œë†Žë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†"
  ],
  [
    "8741",
    "ë†ž",
    9,
    "ë†©",
    15
  ],
  [
    "8761",
    "ë†¹",
    18,
    "ë‡ë‡Žë‡ë‡‘ë‡’ë‡“ë‡•"
  ],
  [
    "8781",
    "ë‡–",
    5,
    "ë‡žë‡ ",
    7,
    "ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±",
    7,
    "ë‡ºë‡¼ë‡¾",
    5,
    "ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ",
    6,
    "ëˆ–ëˆ˜ëˆš",
    5,
    "ëˆ¡",
    18,
    "ëˆµ",
    6,
    "ëˆ½",
    26,
    "ë‰™ë‰šë‰›ë‰ë‰žë‰Ÿë‰¡",
    6,
    "ë‰ª",
    4
  ],
  [
    "8841",
    "ë‰¯",
    4,
    "ë‰¶",
    5,
    "ë‰½",
    6,
    "ëŠ†ëŠ‡ëŠˆëŠŠ",
    4
  ],
  [
    "8861",
    "ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›",
    4,
    "ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"
  ],
  [
    "8881",
    "ëŠ¸",
    15,
    "ë‹Šë‹‹ë‹ë‹Žë‹ë‹‘ë‹“",
    4,
    "ë‹šë‹œë‹žë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰",
    6,
    "ëŒ’ëŒ–",
    5,
    "ëŒ",
    54,
    "ë—ë™ëšëë ë¡ë¢ë£"
  ],
  [
    "8941",
    "ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹",
    6,
    "ëŽ‚ëŽ†",
    5,
    "ëŽ"
  ],
  [
    "8961",
    "ëŽŽëŽëŽ‘ëŽ’ëŽ“ëŽ•",
    10,
    "ëŽ¢",
    5,
    "ëŽ©ëŽªëŽ«ëŽ­"
  ],
  [
    "8981",
    "ëŽ®",
    21,
    "ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëžëŸë¡ë¢ë£ë¥ë¦ë§ë©",
    18,
    "ë½",
    18,
    "ë‘",
    6,
    "ë™ëšë›ëëžëŸë¡",
    6,
    "ëªë¬",
    7,
    "ëµ",
    15
  ],
  [
    "8a41",
    "ë‘…",
    10,
    "ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™",
    6,
    "ë‘¢ë‘¤ë‘¦"
  ],
  [
    "8a61",
    "ë‘§",
    4,
    "ë‘­",
    18,
    "ë’ë’‚"
  ],
  [
    "8a81",
    "ë’ƒ",
    4,
    "ë’‰",
    19,
    "ë’ž",
    5,
    "ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­",
    7,
    "ë’¶ë’¸ë’º",
    5,
    "ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰",
    6,
    "ë“‘ë“’ë““ë“”ë“–",
    5,
    "ë“žë“Ÿë“¡ë“¢ë“¥ë“§",
    4,
    "ë“®ë“°ë“²",
    5,
    "ë“¹",
    26,
    "ë”–ë”—ë”™ë”šë”"
  ],
  [
    "8b41",
    "ë”ž",
    5,
    "ë”¦ë”«",
    4,
    "ë”²ë”³ë”µë”¶ë”·ë”¹",
    6,
    "ë•‚ë•†"
  ],
  [
    "8b61",
    "ë•‡ë•ˆë•‰ë•Šë•Žë•ë•‘ë•’ë•“ë••",
    6,
    "ë•žë•¢",
    8
  ],
  [
    "8b81",
    "ë•«",
    52,
    "ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶",
    4,
    "ë–¾ë–¿ë—ë—‚ë—ƒë—…",
    6,
    "ë—Žë—’",
    5,
    "ë—™",
    18,
    "ë—­",
    18
  ],
  [
    "8c41",
    "ë˜€",
    15,
    "ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™",
    4
  ],
  [
    "8c61",
    "ë˜ž",
    6,
    "ë˜¦",
    5,
    "ë˜­",
    6,
    "ë˜µ",
    5
  ],
  [
    "8c81",
    "ë˜»",
    12,
    "ë™‰",
    26,
    "ë™¥ë™¦ë™§ë™©",
    50,
    "ëšžëšŸëš¡ëš¢ëš£ëš¥",
    5,
    "ëš­ëš®ëš¯ëš°ëš²",
    16
  ],
  [
    "8d41",
    "ë›ƒ",
    16,
    "ë›•",
    8
  ],
  [
    "8d61",
    "ë›ž",
    17,
    "ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"
  ],
  [
    "8d81",
    "ë›»",
    4,
    "ëœ‚ëœƒëœ„ëœ†",
    33,
    "ëœªëœ«ëœ­ëœ®ëœ±",
    6,
    "ëœºëœ¼",
    7,
    "ë…ë†ë‡ë‰ëŠë‹ë",
    6,
    "ë–",
    9,
    "ë¡ë¢ë£ë¥ë¦ë§ë©",
    6,
    "ë²ë´ë¶",
    5,
    "ë¾ë¿ëžëž‚ëžƒëž…",
    6,
    "ëžŽëž“ëž”ëž•ëžšëž›ëžëžž"
  ],
  [
    "8e41",
    "ëžŸëž¡",
    6,
    "ëžªëž®",
    5,
    "ëž¶ëž·ëž¹",
    8
  ],
  [
    "8e61",
    "ëŸ‚",
    4,
    "ëŸˆëŸŠ",
    19
  ],
  [
    "8e81",
    "ëŸž",
    13,
    "ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ",
    6,
    "ëŸ¾ë ‚",
    4,
    "ë Šë ‹ë ë Žë ë ‘",
    6,
    "ë šë œë ž",
    5,
    "ë ¦ë §ë ©ë ªë «ë ­",
    6,
    "ë ¶ë º",
    5,
    "ë¡ë¡‚ë¡ƒë¡…",
    11,
    "ë¡’ë¡”",
    7,
    "ë¡žë¡Ÿë¡¡ë¡¢ë¡£ë¡¥",
    6,
    "ë¡®ë¡°ë¡²",
    5,
    "ë¡¹ë¡ºë¡»ë¡½",
    7
  ],
  [
    "8f41",
    "ë¢…",
    7,
    "ë¢Ž",
    17
  ],
  [
    "8f61",
    "ë¢ ",
    7,
    "ë¢©",
    6,
    "ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹",
    4
  ],
  [
    "8f81",
    "ë¢¾ë¢¿ë£‚ë£„ë£†",
    5,
    "ë£ë£Žë£ë£‘ë£’ë£“ë£•",
    7,
    "ë£žë£ ë£¢",
    5,
    "ë£ªë£«ë£­ë£®ë£¯ë£±",
    6,
    "ë£ºë£¼ë£¾",
    5,
    "ë¤…",
    18,
    "ë¤™",
    6,
    "ë¤¡",
    26,
    "ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…",
    6,
    "ë¥ë¥Žë¥ë¥’",
    5
  ],
  [
    "9041",
    "ë¥šë¥›ë¥ë¥žë¥Ÿë¥¡",
    6,
    "ë¥ªë¥¬ë¥®",
    5,
    "ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"
  ],
  [
    "9061",
    "ë¥¾",
    5,
    "ë¦†ë¦ˆë¦‹ë¦Œë¦",
    15
  ],
  [
    "9081",
    "ë¦Ÿ",
    12,
    "ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",
    6,
    "ë¦¾ë§€ë§‚",
    5,
    "ë§Šë§‹ë§ë§“",
    4,
    "ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",
    6,
    "ë§¶ë§»",
    4,
    "ë¨‚",
    5,
    "ë¨‰",
    11,
    "ë¨–",
    33,
    "ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†"
  ],
  [
    "9141",
    "ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©",
    6,
    "ë©¦ë©ª",
    5
  ],
  [
    "9161",
    "ë©²ë©³ë©µë©¶ë©·ë©¹",
    9,
    "ëª†ëªˆëª‰ëªŠëª‹ëª",
    5
  ],
  [
    "9181",
    "ëª“",
    20,
    "ëªªëª­ëª®ëª¯ëª±ëª³",
    4,
    "ëªºëª¼ëª¾",
    5,
    "ë«…ë«†ë«‡ë«‰",
    14,
    "ë«š",
    33,
    "ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…",
    7,
    "ë¬Žë¬ë¬’",
    5,
    "ë¬™ë¬šë¬›ë¬ë¬žë¬Ÿë¬¡",
    6
  ],
  [
    "9241",
    "ë¬¨ë¬ªë¬¬",
    7,
    "ë¬·ë¬¹ë¬ºë¬¿",
    4,
    "ë­†ë­ˆë­Šë­‹ë­Œë­Žë­‘ë­’"
  ],
  [
    "9261",
    "ë­“ë­•ë­–ë­—ë­™",
    7,
    "ë­¢ë­¤",
    7,
    "ë­­",
    4
  ],
  [
    "9281",
    "ë­²",
    21,
    "ë®‰ë®Šë®‹ë®ë®Žë®ë®‘",
    18,
    "ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",
    6,
    "ë®µë®¶ë®¸",
    7,
    "ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰",
    6,
    "ë¯‘ë¯’ë¯”",
    35,
    "ë¯ºë¯»ë¯½ë¯¾ë°"
  ],
  [
    "9341",
    "ë°ƒ",
    4,
    "ë°Šë°Žë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"
  ],
  [
    "9361",
    "ë°¶ë°·ë°¹",
    6,
    "ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±Žë±ë±‘",
    8
  ],
  [
    "9381",
    "ë±šë±›ë±œë±ž",
    37,
    "ë²†ë²‡ë²‰ë²Šë²ë²",
    4,
    "ë²–ë²˜ë²›",
    4,
    "ë²¢ë²£ë²¥ë²¦ë²©",
    6,
    "ë²²ë²¶",
    5,
    "ë²¾ë²¿ë³ë³‚ë³ƒë³…",
    7,
    "ë³Žë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³",
    22,
    "ë³·ë³¹ë³ºë³»ë³½"
  ],
  [
    "9441",
    "ë³¾",
    5,
    "ë´†ë´ˆë´Š",
    5,
    "ë´‘ë´’ë´“ë´•",
    8
  ],
  [
    "9461",
    "ë´ž",
    5,
    "ë´¥",
    6,
    "ë´­",
    12
  ],
  [
    "9481",
    "ë´º",
    5,
    "ëµ",
    6,
    "ëµŠëµ‹ëµëµŽëµëµ‘",
    6,
    "ëµš",
    9,
    "ëµ¥ëµ¦ëµ§ëµ©",
    22,
    "ë¶‚ë¶ƒë¶…ë¶†ë¶‹",
    4,
    "ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶",
    6,
    "ë¶¥",
    10,
    "ë¶±",
    6,
    "ë¶¹",
    24
  ],
  [
    "9541",
    "ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·",
    11,
    "ë·ª",
    5,
    "ë·±"
  ],
  [
    "9561",
    "ë·²ë·³ë·µë·¶ë··ë·¹",
    6,
    "ë¸ë¸‚ë¸„ë¸†",
    5,
    "ë¸Žë¸ë¸‘ë¸’ë¸“"
  ],
  [
    "9581",
    "ë¸•",
    6,
    "ë¸žë¸ ",
    35,
    "ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹",
    4,
    "ë¹–ë¹˜ë¹œë¹ë¹žë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",
    4,
    "ë¹²ë¹¶",
    4,
    "ë¹¾ë¹¿ëºëº‚ëºƒëº…",
    6,
    "ëºŽëº’",
    5,
    "ëºš",
    13,
    "ëº©",
    14
  ],
  [
    "9641",
    "ëº¸",
    23,
    "ë»’ë»“"
  ],
  [
    "9661",
    "ë»•ë»–ë»™",
    6,
    "ë»¡ë»¢ë»¦",
    5,
    "ë»­",
    8
  ],
  [
    "9681",
    "ë»¶",
    10,
    "ë¼‚",
    5,
    "ë¼Š",
    13,
    "ë¼šë¼ž",
    33,
    "ë½‚ë½ƒë½…ë½†ë½‡ë½‰",
    6,
    "ë½’ë½“ë½”ë½–",
    44
  ],
  [
    "9741",
    "ë¾ƒ",
    16,
    "ë¾•",
    8
  ],
  [
    "9761",
    "ë¾ž",
    17,
    "ë¾±",
    7
  ],
  [
    "9781",
    "ë¾¹",
    11,
    "ë¿†",
    5,
    "ë¿Žë¿ë¿‘ë¿’ë¿“ë¿•",
    6,
    "ë¿ë¿žë¿ ë¿¢",
    89,
    "ì€½ì€¾ì€¿"
  ],
  [
    "9841",
    "ì€",
    16,
    "ì’",
    5,
    "ì™ìšì›"
  ],
  [
    "9861",
    "ììžìŸì¡",
    6,
    "ìª",
    15
  ],
  [
    "9881",
    "ìº",
    21,
    "ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™",
    6,
    "ì‚¢ì‚¤ì‚¦",
    5,
    "ì‚®ì‚±ì‚²ì‚·",
    4,
    "ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒŽìƒìƒ‘",
    6,
    "ìƒšìƒž",
    5,
    "ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­",
    6,
    "ìƒ¶ìƒ¸ìƒº",
    5,
    "ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰",
    6,
    "ì„‘ì„’ì„“ì„”ì„–",
    5,
    "ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®"
  ],
  [
    "9941",
    "ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…",
    6,
    "ì…Šì…Ž",
    5,
    "ì…–ì…—"
  ],
  [
    "9961",
    "ì…™ì…šì…›ì…",
    6,
    "ì…¦ì…ª",
    5,
    "ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"
  ],
  [
    "9981",
    "ì…¼",
    8,
    "ì††",
    5,
    "ì†ì†‘ì†’ì†“ì†•ì†—",
    4,
    "ì†žì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±",
    11,
    "ì†¾",
    5,
    "ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡",
    6,
    "ì‡•ì‡–ì‡™",
    6,
    "ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©",
    6,
    "ì‡²ì‡´",
    7,
    "ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…",
    6,
    "ìˆŽìˆìˆ’",
    5,
    "ìˆšìˆ›ìˆìˆžìˆ¡ìˆ¢ìˆ£"
  ],
  [
    "9a41",
    "ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ",
    16
  ],
  [
    "9a61",
    "ì‰†ì‰‡ì‰‰",
    6,
    "ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™",
    6,
    "ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"
  ],
  [
    "9a81",
    "ì‰§",
    4,
    "ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ",
    6,
    "ì‰¾ìŠ€ìŠ‚",
    5,
    "ìŠŠ",
    5,
    "ìŠ‘",
    6,
    "ìŠ™ìŠšìŠœìŠž",
    5,
    "ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®",
    5,
    "ìŠ¶ìŠ¸ìŠº",
    33,
    "ì‹žì‹Ÿì‹¡ì‹¢ì‹¥",
    5,
    "ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ",
    6,
    "ìŒŠìŒ‹ìŒŽìŒ"
  ],
  [
    "9b41",
    "ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ",
    6,
    "ìŒ¦ìŒ§ìŒª",
    8
  ],
  [
    "9b61",
    "ìŒ³",
    17,
    "ì†",
    7
  ],
  [
    "9b81",
    "ìŽ",
    25,
    "ìªì«ì­ì®ì¯ì±ì³",
    4,
    "ìºì»ì¾",
    5,
    "ìŽ…ìŽ†ìŽ‡ìŽ‰ìŽŠìŽ‹ìŽ",
    50,
    "ì",
    22,
    "ìš"
  ],
  [
    "9c41",
    "ì›ììžì¡ì£",
    4,
    "ìªì«ì¬ì®",
    5,
    "ì¶ì·ì¹",
    5
  ],
  [
    "9c61",
    "ì¿",
    8,
    "ì‰",
    6,
    "ì‘",
    9
  ],
  [
    "9c81",
    "ì›",
    8,
    "ì¥",
    6,
    "ì­ì®ì¯ì±ì²ì³ìµ",
    6,
    "ì¾",
    9,
    "ì‘‰",
    26,
    "ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­",
    6,
    "ì‘¶ì‘·ì‘¸ì‘º",
    5,
    "ì’",
    18,
    "ì’•",
    6,
    "ì’",
    12
  ],
  [
    "9d41",
    "ì’ª",
    13,
    "ì’¹ì’ºì’»ì’½",
    8
  ],
  [
    "9d61",
    "ì“†",
    25
  ],
  [
    "9d81",
    "ì“ ",
    8,
    "ì“ª",
    5,
    "ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚",
    9,
    "ì”ì”Žì”ì”‘ì”’ì”“ì”•",
    6,
    "ì”",
    10,
    "ì”ªì”«ì”­ì”®ì”¯ì”±",
    6,
    "ì”ºì”¼ì”¾",
    5,
    "ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©",
    6,
    "ì•²ì•¶",
    5,
    "ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–Žì–ì–’ì–“ì–”"
  ],
  [
    "9e41",
    "ì––ì–™ì–šì–›ì–ì–žì–Ÿì–¡",
    7,
    "ì–ª",
    9,
    "ì–¶"
  ],
  [
    "9e61",
    "ì–·ì–ºì–¿",
    4,
    "ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™",
    6,
    "ì—¢ì—¤ì—¦ì—§"
  ],
  [
    "9e81",
    "ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜Žì˜ì˜‘",
    6,
    "ì˜šì˜",
    6,
    "ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰",
    6,
    "ì™’ì™–",
    5,
    "ì™žì™Ÿì™¡",
    10,
    "ì™­ì™®ì™°ì™²",
    5,
    "ì™ºì™»ì™½ì™¾ì™¿ìš",
    6,
    "ìšŠìšŒìšŽ",
    5,
    "ìš–ìš—ìš™ìššìš›ìš",
    6,
    "ìš¦"
  ],
  [
    "9f41",
    "ìš¨ìšª",
    5,
    "ìš²ìš³ìšµìš¶ìš·ìš»",
    4,
    "ì›‚ì›„ì›†",
    5,
    "ì›Ž"
  ],
  [
    "9f61",
    "ì›ì›‘ì›’ì›“ì›•",
    6,
    "ì›žì›Ÿì›¢",
    5,
    "ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"
  ],
  [
    "9f81",
    "ì›³",
    4,
    "ì›ºì›»ì›¼ì›¾",
    5,
    "ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ",
    6,
    "ìœ–ìœ˜ìœš",
    5,
    "ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©",
    6,
    "ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…",
    4,
    "ì‹ìŽìì™ìšì›ììžìŸì¡",
    6,
    "ì©ìªì¬",
    7,
    "ì¶ì·ì¹ìºì»ì¿ìž€ìžìž‚ìž†ìž‹ìžŒìžìžìž’ìž“ìž•ìž™ìž›",
    4,
    "ìž¢ìž§",
    4,
    "ìž®ìž¯ìž±ìž²ìž³ìžµìž¶ìž·"
  ],
  [
    "a041",
    "ìž¸ìž¹ìžºìž»ìž¾ìŸ‚",
    5,
    "ìŸŠìŸ‹ìŸìŸìŸ‘",
    6,
    "ìŸ™ìŸšìŸ›ìŸœ"
  ],
  [
    "a061",
    "ìŸž",
    5,
    "ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­",
    13
  ],
  [
    "a081",
    "ìŸ»",
    4,
    "ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹",
    4,
    "ì ’ì ”ì —",
    4,
    "ì žì Ÿì ¡ì ¢ì £ì ¥",
    6,
    "ì ®ì °ì ²",
    5,
    "ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",
    6,
    "ì¡Šì¡‹ì¡Ž",
    5,
    "ì¡•",
    26,
    "ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",
    4,
    "ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢Ž",
    5,
    "ì¢•",
    7,
    "ì¢žì¢ ì¢¢ì¢£ì¢¤"
  ],
  [
    "a141",
    "ì¢¥ì¢¦ì¢§ì¢©",
    18,
    "ì¢¾ì¢¿ì£€ì£"
  ],
  [
    "a161",
    "ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£",
    6,
    "ì£–ì£˜ì£š",
    5,
    "ì£¢ì££ì£¥"
  ],
  [
    "a181",
    "ì£¦",
    14,
    "ì£¶",
    5,
    "ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡",
    4,
    "ì¤Žã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
    9,
    "Â±Ã—Ã·â‰ â‰¤â‰¥âˆžâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢"
  ],
  [
    "a241",
    "ì¤ì¤’",
    5,
    "ì¤™",
    18
  ],
  [
    "a261",
    "ì¤­",
    6,
    "ì¤µ",
    18
  ],
  [
    "a281",
    "ì¥ˆ",
    7,
    "ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™",
    6,
    "ì¥¢ì¥¤",
    7,
    "ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½žË‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜Žâ˜œâ˜žÂ¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®"
  ],
  [
    "a341",
    "ì¥±ì¥²ì¥³ì¥µ",
    6,
    "ì¥½",
    10,
    "ì¦Šì¦‹ì¦ì¦Žì¦"
  ],
  [
    "a361",
    "ì¦‘",
    6,
    "ì¦šì¦œì¦ž",
    16
  ],
  [
    "a381",
    "ì¦¯",
    16,
    "ì§‚ì§ƒì§…ì§†ì§‰ì§‹",
    4,
    "ì§’ì§”ì§—ì§˜ì§›ï¼",
    58,
    "ï¿¦ï¼½",
    32,
    "ï¿£"
  ],
  [
    "a441",
    "ì§žì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²",
    5,
    "ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"
  ],
  [
    "a461",
    "ì¨…ì¨†ì¨‡ì¨Šì¨Ž",
    5,
    "ì¨•ì¨–ì¨—ì¨™",
    12
  ],
  [
    "a481",
    "ì¨¦ì¨§ì¨¨ì¨ª",
    28,
    "ã„±",
    93
  ],
  [
    "a541",
    "ì©‡",
    4,
    "ì©Žì©ì©‘ì©’ì©“ì©•",
    6,
    "ì©žì©¢",
    5,
    "ì©©ì©ª"
  ],
  [
    "a561",
    "ì©«",
    17,
    "ì©¾",
    5,
    "ìª…ìª†"
  ],
  [
    "a581",
    "ìª‡",
    16,
    "ìª™",
    14,
    "â…°",
    9
  ],
  [
    "a5b0",
    "â… ",
    9
  ],
  [
    "a5c1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a5e1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a641",
    "ìª¨",
    19,
    "ìª¾ìª¿ì«ì«‚ì«ƒì«…"
  ],
  [
    "a661",
    "ì«†",
    5,
    "ì«Žì«ì«’ì«”ì«•ì«–ì«—ì«š",
    5,
    "ì«¡",
    6
  ],
  [
    "a681",
    "ì«¨ì«©ì«ªì««ì«­",
    6,
    "ì«µ",
    18,
    "ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”Žâ”â”žâ”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ",
    7
  ],
  [
    "a741",
    "ì¬‹",
    4,
    "ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™",
    6,
    "ì¬¢",
    7
  ],
  [
    "a761",
    "ì¬ª",
    22,
    "ì­‚ì­ƒì­„"
  ],
  [
    "a781",
    "ì­…ì­†ì­‡ì­Šì­‹ì­ì­Žì­ì­‘",
    6,
    "ì­šì­›ì­œì­ž",
    5,
    "ì­¥",
    7,
    "ãŽ•ãŽ–ãŽ—â„“ãŽ˜ã„ãŽ£ãŽ¤ãŽ¥ãŽ¦ãŽ™",
    9,
    "ãŠãŽãŽŽãŽããŽˆãŽ‰ãˆãŽ§ãŽ¨ãŽ°",
    9,
    "ãŽ€",
    4,
    "ãŽº",
    5,
    "ãŽ",
    4,
    "â„¦ã€ããŽŠãŽ‹ãŽŒã–ã…ãŽ­ãŽ®ãŽ¯ã›ãŽ©ãŽªãŽ«ãŽ¬ããã“ãƒã‰ãœã†"
  ],
  [
    "a841",
    "ì­­",
    10,
    "ì­º",
    14
  ],
  [
    "a861",
    "ì®‰",
    18,
    "ì®",
    6
  ],
  [
    "a881",
    "ì®¤",
    19,
    "ì®¹",
    11,
    "Ã†ÃÂªÄ¦"
  ],
  [
    "a8a6",
    "Ä²"
  ],
  [
    "a8a8",
    "Ä¿ÅÃ˜Å’ÂºÃžÅ¦ÅŠ"
  ],
  [
    "a8b1",
    "ã‰ ",
    27,
    "â“",
    25,
    "â‘ ",
    14,
    "Â½â…“â…”Â¼Â¾â…›â…œâ…â…ž"
  ],
  [
    "a941",
    "ì¯…",
    14,
    "ì¯•",
    10
  ],
  [
    "a961",
    "ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª",
    18
  ],
  [
    "a981",
    "ì¯½",
    14,
    "ì°Žì°ì°‘ì°’ì°“ì°•",
    6,
    "ì°žì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€",
    27,
    "â’œ",
    25,
    "â‘´",
    14,
    "Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„"
  ],
  [
    "aa41",
    "ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±",
    6,
    "ì°ºì°¿",
    4,
    "ì±†ì±‡ì±‰ì±Šì±‹ì±ì±Ž"
  ],
  [
    "aa61",
    "ì±",
    4,
    "ì±–ì±š",
    5,
    "ì±¡ì±¢ì±£ì±¥ì±§ì±©",
    6,
    "ì±±ì±²"
  ],
  [
    "aa81",
    "ì±³ì±´ì±¶",
    29,
    "ã",
    82
  ],
  [
    "ab41",
    "ì²”ì²•ì²–ì²—ì²šì²›ì²ì²žì²Ÿì²¡",
    6,
    "ì²ªì²®",
    5,
    "ì²¶ì²·ì²¹"
  ],
  [
    "ab61",
    "ì²ºì²»ì²½",
    6,
    "ì³†ì³ˆì³Š",
    5,
    "ì³‘ì³’ì³“ì³•",
    5
  ],
  [
    "ab81",
    "ì³›",
    8,
    "ì³¥",
    6,
    "ì³­ì³®ì³¯ì³±",
    12,
    "ã‚¡",
    85
  ],
  [
    "ac41",
    "ì³¾ì³¿ì´€ì´‚",
    5,
    "ì´Šì´‹ì´ì´Žì´ì´‘",
    6,
    "ì´šì´œì´žì´Ÿì´ "
  ],
  [
    "ac61",
    "ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­",
    11,
    "ì´º",
    4
  ],
  [
    "ac81",
    "ì´¿",
    28,
    "ìµìµžìµŸÐ",
    5,
    "ÐÐ–",
    25
  ],
  [
    "acd1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "ad41",
    "ìµ¡ìµ¢ìµ£ìµ¥",
    6,
    "ìµ®ìµ°ìµ²",
    5,
    "ìµ¹",
    7
  ],
  [
    "ad61",
    "ì¶",
    6,
    "ì¶‰",
    10,
    "ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶žì¶Ÿ"
  ],
  [
    "ad81",
    "ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª",
    5,
    "ì¶±",
    18,
    "ì·…"
  ],
  [
    "ae41",
    "ì·†",
    5,
    "ì·ì·Žì·ì·‘",
    16
  ],
  [
    "ae61",
    "ì·¢",
    5,
    "ì·©ì·ªì·«ì·­ì·®ì·¯ì·±",
    6,
    "ì·ºì·¼ì·¾",
    4
  ],
  [
    "ae81",
    "ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸",
    6,
    "ì¸•ì¸–ì¸—ì¸˜ì¸š",
    5,
    "ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"
  ],
  [
    "af41",
    "ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶",
    19
  ],
  [
    "af61",
    "ì¹Š",
    13,
    "ì¹šì¹›ì¹ì¹žì¹¢",
    5,
    "ì¹ªì¹¬"
  ],
  [
    "af81",
    "ì¹®",
    5,
    "ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½",
    6,
    "ìº†ìºˆìºŠ",
    5,
    "ìº’ìº“ìº•ìº–ìº—ìº™"
  ],
  [
    "b041",
    "ìºš",
    5,
    "ìº¢ìº¦",
    5,
    "ìº®",
    12
  ],
  [
    "b061",
    "ìº»",
    5,
    "ì»‚",
    19
  ],
  [
    "b081",
    "ì»–",
    13,
    "ì»¦ì»§ì»©ì»ªì»­",
    6,
    "ì»¶ì»º",
    5,
    "ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°",
    7,
    "ê°™",
    4,
    "ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†"
  ],
  [
    "b141",
    "ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰",
    6,
    "ì¼’ì¼”ì¼–",
    5,
    "ì¼ì¼žì¼Ÿì¼¡ì¼¢ì¼£"
  ],
  [
    "b161",
    "ì¼¥",
    6,
    "ì¼®ì¼²",
    5,
    "ì¼¹",
    11
  ],
  [
    "b181",
    "ì½…",
    14,
    "ì½–ì½—ì½™ì½šì½›ì½",
    6,
    "ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹Žê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"
  ],
  [
    "b241",
    "ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹",
    6,
    "ì¾ì¾‚ì¾ƒì¾„ì¾†",
    5,
    "ì¾"
  ],
  [
    "b261",
    "ì¾Ž",
    18,
    "ì¾¢",
    5,
    "ì¾©"
  ],
  [
    "b281",
    "ì¾ª",
    5,
    "ì¾±",
    18,
    "ì¿…",
    6,
    "ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿Žê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëŽë“ë”ë•ë—ë™"
  ],
  [
    "b341",
    "ì¿Œ",
    19,
    "ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"
  ],
  [
    "b361",
    "ì¿ª",
    5,
    "ì¿²ì¿´ì¿¶",
    5,
    "ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…",
    5
  ],
  [
    "b381",
    "í€‹",
    5,
    "í€’",
    5,
    "í€™",
    19,
    "ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«",
    4,
    "ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡"
  ],
  [
    "b441",
    "í€®",
    5,
    "í€¶í€·í€¹í€ºí€»í€½",
    6,
    "í†íˆíŠ",
    5
  ],
  [
    "b461",
    "í‘í’í“í•í–í—í™",
    6,
    "í¡",
    10,
    "í®í¯"
  ],
  [
    "b481",
    "í±í²í³íµ",
    6,
    "í¾í¿í‚€í‚‚",
    18,
    "ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«",
    4,
    "ë‹³ë‹´ë‹µë‹·",
    4,
    "ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëžëŸë¤ë¥"
  ],
  [
    "b541",
    "í‚•",
    14,
    "í‚¦í‚§í‚©í‚ªí‚«í‚­",
    5
  ],
  [
    "b561",
    "í‚³í‚¶í‚¸í‚º",
    5,
    "íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ",
    5,
    "íƒ’íƒ–",
    4
  ],
  [
    "b581",
    "íƒ›íƒžíƒŸíƒ¡íƒ¢íƒ£íƒ¥",
    6,
    "íƒ®íƒ²",
    5,
    "íƒ¹",
    11,
    "ë§ë©ë«ë®ë°ë±ë´ë¸ëŽ€ëŽëŽƒëŽ„ëŽ…ëŽŒëŽëŽ”ëŽ ëŽ¡ëŽ¨ëŽ¬ë„ë…ëˆë‹ëŒëŽëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸"
  ],
  [
    "b641",
    "í„…",
    7,
    "í„Ž",
    17
  ],
  [
    "b661",
    "í„ ",
    15,
    "í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"
  ],
  [
    "b681",
    "í„¿í…‚í…†",
    5,
    "í…Ží…í…‘í…’í…“í…•",
    6,
    "í…ží… í…¢",
    5,
    "í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ëž€ëž„ëžŒëžëžëžëž‘ëž’ëž–ëž—"
  ],
  [
    "b741",
    "í…®",
    13,
    "í…½",
    6,
    "í†…í††í†‡í†‰í†Š"
  ],
  [
    "b761",
    "í†‹",
    20,
    "í†¢í†£í†¥í†¦í†§"
  ],
  [
    "b781",
    "í†©",
    6,
    "í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡",
    14,
    "ëž˜ëž™ëžœëž ëž¨ëž©ëž«ëž¬ëž­ëž´ëžµëž¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©"
  ],
  [
    "b841",
    "í‡",
    7,
    "í‡™",
    17
  ],
  [
    "b861",
    "í‡«",
    8,
    "í‡µí‡¶í‡·í‡¹",
    13
  ],
  [
    "b881",
    "íˆˆíˆŠ",
    5,
    "íˆ‘",
    24,
    "ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦Žë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§Ž",
    4,
    "ë§˜ë§™ë§›ë§ë§žë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©Žë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼"
  ],
  [
    "b941",
    "íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ",
    6,
    "íˆ¾í‰€í‰‚",
    5,
    "í‰‰í‰Ší‰‹í‰Œ"
  ],
  [
    "b961",
    "í‰",
    14,
    "í‰",
    6,
    "í‰¥í‰¦í‰§í‰¨"
  ],
  [
    "b981",
    "í‰©",
    22,
    "íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”",
    4,
    "ë°›",
    4,
    "ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²Žë²”ë²•ë²—"
  ],
  [
    "ba41",
    "íŠíŠŽíŠíŠ’íŠ“íŠ”íŠ–",
    5,
    "íŠíŠžíŠŸíŠ¡íŠ¢íŠ£íŠ¥",
    6,
    "íŠ­"
  ],
  [
    "ba61",
    "íŠ®íŠ¯íŠ°íŠ²",
    5,
    "íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ",
    4,
    "í‹Ší‹Œ",
    5
  ],
  [
    "ba81",
    "í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹",
    6,
    "í‹¦",
    9,
    "í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹Žë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤"
  ],
  [
    "bb41",
    "í‹»",
    4,
    "íŒ‚íŒ„íŒ†",
    5,
    "íŒíŒ‘íŒ’íŒ“íŒ•íŒ—",
    4,
    "íŒžíŒ¢íŒ£"
  ],
  [
    "bb61",
    "íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±",
    6,
    "íŒºíŒ¾",
    5,
    "í†í‡íˆí‰"
  ],
  [
    "bb81",
    "íŠ",
    31,
    "ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤"
  ],
  [
    "bc41",
    "íª",
    17,
    "í¾í¿íŽíŽ‚íŽƒíŽ…íŽ†íŽ‡"
  ],
  [
    "bc61",
    "íŽˆíŽ‰íŽŠíŽ‹íŽŽíŽ’",
    5,
    "íŽšíŽ›íŽíŽžíŽŸíŽ¡",
    6,
    "íŽªíŽ¬íŽ®"
  ],
  [
    "bc81",
    "íŽ¯",
    4,
    "íŽµíŽ¶íŽ·íŽ¹íŽºíŽ»íŽ½",
    6,
    "í†í‡íŠ",
    5,
    "í‘",
    5,
    "ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ",
    4,
    "ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†Žì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­"
  ],
  [
    "bd41",
    "í—í™",
    7,
    "í¢í¤",
    7,
    "í®í¯í±í²í³íµí¶í·"
  ],
  [
    "bd61",
    "í¸í¹íºí»í¾í€í‚",
    5,
    "í‰",
    13
  ],
  [
    "bd81",
    "í—",
    5,
    "íž",
    25,
    "ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ìŽ„ìŽˆìŽŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°"
  ],
  [
    "be41",
    "í¸",
    7,
    "í‘í‘‚í‘ƒí‘…",
    14
  ],
  [
    "be61",
    "í‘”",
    7,
    "í‘í‘ží‘Ÿí‘¡í‘¢í‘£í‘¥",
    7,
    "í‘®í‘°í‘±í‘²"
  ],
  [
    "be81",
    "í‘³",
    4,
    "í‘ºí‘»í‘½í‘¾í’í’ƒ",
    4,
    "í’Ší’Œí’Ž",
    5,
    "í’•",
    8,
    "ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•Žì•“ì•”ì••ì•—ì•˜ì•™ì•ì•žì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„",
    6,
    "ì—Œì—Ž"
  ],
  [
    "bf41",
    "í’ž",
    10,
    "í’ª",
    14
  ],
  [
    "bf61",
    "í’¹",
    18,
    "í“í“Ží“í“‘í“’í““í“•"
  ],
  [
    "bf81",
    "í“–",
    5,
    "í“í“ží“ ",
    7,
    "í“©í“ªí“«í“­í“®í“¯í“±",
    6,
    "í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼",
    5,
    "ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨"
  ],
  [
    "c041",
    "í“¾",
    5,
    "í”…í”†í”‡í”‰í”Ší”‹í”",
    6,
    "í”–í”˜",
    5
  ],
  [
    "c061",
    "í”ž",
    25
  ],
  [
    "c081",
    "í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…",
    6,
    "í•Ží•í•’",
    5,
    "í•ší•›í•í•ží•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘",
    7,
    "ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìžƒìž„ìž…ìž‡ìžˆìž‰ìžŠìžŽìžìž‘ìž”ìž–ìž—ìž˜ìžšìž ìž¡ìž£ìž¤ìž¥ìž¦ìž¬ìž­ìž°ìž´ìž¼ìž½ìž¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸŽìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š"
  ],
  [
    "c141",
    "í•¤í•¦í•§í•ªí•¬í•®",
    5,
    "í•¶í•·í•¹í•ºí•»í•½",
    6,
    "í–†í–Ší–‹"
  ],
  [
    "c161",
    "í–Œí–í–Ží–í–‘",
    19,
    "í–¦í–§"
  ],
  [
    "c181",
    "í–¨",
    31,
    "ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“"
  ],
  [
    "c241",
    "í—Ší—‹í—í—Ží—í—‘í—“",
    4,
    "í—ší—œí—ž",
    5,
    "í—¦í—§í—©í—ªí—«í—­í—®"
  ],
  [
    "c261",
    "í—¯",
    4,
    "í—¶í—¸í—º",
    5,
    "í˜‚í˜ƒí˜…í˜†í˜‡í˜‰",
    6,
    "í˜’"
  ],
  [
    "c281",
    "í˜–",
    5,
    "í˜í˜ží˜Ÿí˜¡í˜¢í˜£í˜¥",
    7,
    "í˜®",
    9,
    "í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"
  ],
  [
    "c341",
    "í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™Ží™í™í™’í™“í™–í™—í™™í™ší™›í™",
    4
  ],
  [
    "c361",
    "í™¢",
    4,
    "í™¨í™ª",
    5,
    "í™²í™³í™µ",
    11
  ],
  [
    "c381",
    "íšíš‚íš„íš†",
    5,
    "íšŽíšíš‘íš’íš“íš•",
    7,
    "íšžíš íš¢",
    5,
    "íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"
  ],
  [
    "c441",
    "íš«íš­íš®íš¯íš±",
    7,
    "íšºíš¼",
    7,
    "í›†í›‡í›‰í›Ší›‹"
  ],
  [
    "c461",
    "í›í›Ží›í›í›’í›“í›•í›–í›˜í›š",
    5,
    "í›¡í›¢í›£í›¥í›¦í›§í›©",
    4
  ],
  [
    "c481",
    "í›®í›¯í›±í›²í›³í›´í›¶",
    5,
    "í›¾í›¿íœíœ‚íœƒíœ…",
    11,
    "íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼"
  ],
  [
    "c541",
    "íœ•íœ–íœ—íœšíœ›íœíœžíœŸíœ¡",
    6,
    "íœªíœ¬íœ®",
    5,
    "íœ¶íœ·íœ¹"
  ],
  [
    "c561",
    "íœºíœ»íœ½",
    6,
    "í…í†íˆíŠ",
    5,
    "í’í“í•íš",
    4
  ],
  [
    "c581",
    "íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",
    6,
    "í¾í¿íž€íž‚",
    5,
    "ížŠíž‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ"
  ],
  [
    "c641",
    "ížížŽížíž‘",
    6,
    "ížšížœížž",
    5
  ],
  [
    "c6a1",
    "í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒŽíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½íŽ€íŽ„íŽŒíŽíŽíŽíŽ‘íŽ˜íŽ™íŽœíŽ íŽ¨íŽ©íŽ«íŽ­íŽ´íŽ¸íŽ¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í"
  ],
  [
    "c7a1",
    "íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ "
  ],
  [
    "c8a1",
    "í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ížížˆíž‰ížŒížíž˜íž™íž›íž"
  ],
  [
    "caa1",
    "ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æž¶æž·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™Žçœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èŽéž¨å‹˜åŽå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£çž°ç´ºé‚¯é‘‘é‘’é¾•"
  ],
  [
    "cba1",
    "åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€éŽ§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨åŽ»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸žï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹žå‚‘æ°æ¡€å„‰åŠåŠ’æª¢"
  ],
  [
    "cca1",
    "çž¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŽŒäº¬ä¿“å€žå‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“Žæ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›èŽ–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°"
  ],
  [
    "cda1",
    "æ£¨æºªç•Œç™¸ç£Žç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšŽé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æž¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢žé¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æŽ§æ”»ç™ç©ºèš£è²¢éžä¸²å¯¡æˆˆæžœç“œ"
  ],
  [
    "cea1",
    "ç§‘è“èª‡èª²è·¨éŽé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æŽ›ç½«ä¹–å‚€å¡Šå£žæ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•Žæ ¡æ©‹ç‹¡çšŽçŸ¯çµžç¿¹è† è•Žè›Ÿè¼ƒè½ŽéƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾"
  ],
  [
    "cfa1",
    "å€å£å¥å’Žå˜”åµåž¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æž¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—çŽ–çƒçž¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠéž éž«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæŽ˜çªŸå®®å¼“ç©¹çª®èŠŽèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·åŽ¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´"
  ],
  [
    "d0a1",
    "é¬¼ï¤‡å«åœ­å¥Žæ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆžï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªŽç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼Žå…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´Žå·±å¹¾å¿ŒæŠ€æ——æ—£"
  ],
  [
    "d1a1",
    "æœžæœŸæžæ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡çŽ˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨Žé¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤Ž",
    5,
    "é‚£ï¤”",
    4,
    "è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤žï¤Ÿé›£ï¤ ææºå—ï¤¡æžæ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥"
  ],
  [
    "d2a1",
    "ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨",
    4,
    "ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³",
    5,
    "é§‘ï¤¹",
    10,
    "æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š",
    7,
    "å«©è¨¥æ»ç´ï¥’",
    5,
    "èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶"
  ],
  [
    "d3a1",
    "ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°žç·žè›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’žæ£ ç•¶ç³–èž³é»¨ä»£åžˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡çŽ³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°Žå± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æŽ‰æ—æ¡ƒ"
  ],
  [
    "d4a1",
    "æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„žç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´žæ½¼ç–¼çž³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæž“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…"
  ],
  [
    "d5a1",
    "è˜¿èžºè£¸é‚ï¥œæ´›çƒ™çžçµ¡è½ï¥é…ªé§±ï¥žäº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸žå‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯èž‚éƒžä¾†å´å¾ èŠå†·æŽ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»ŽåŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£"
  ],
  [
    "d6a1",
    "ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œçŽ²ç¬­ç¾šç¿Žè†é€žéˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹žï¥ æ’ˆæ“„æ«“æ½žç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡Žç™‚çž­èŠè“¼"
  ],
  [
    "d7a1",
    "é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”žè¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡žå…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥žç¨œç¶¾è±é™µä¿šåˆ©åŽ˜åå”Žå±¥æ‚§æŽæ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸èŽ‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæž—æ·‹ç³è‡¨éœ–ç ¬"
  ],
  [
    "d8a1",
    "ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯žå¹•æ¼ è†œèŽ«é‚ˆä¸‡åå¨©å·’å½Žæ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çžžè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«èŽ½è¼žé‚™åŸ‹å¦¹åª’å¯æ˜§æžšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…"
  ],
  [
    "d9a1",
    "è”‘å†¥åå‘½æ˜Žæšæ¤§æºŸçš¿çž‘èŒ—è“‚èžŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆžèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆŽå»å•æ–‡"
  ],
  [
    "daa1",
    "æ±¶ç´Šç´‹èžèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾Žè–‡è¬Žè¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŽŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’žç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘"
  ],
  [
    "dba1",
    "ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æž‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæŽ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±Žæ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–"
  ],
  [
    "dca1",
    "ç¢§è˜—é—¢éœ¹ï¥¥åžå¼è®Šè¾¨è¾¯é‚Šåˆ¥çž¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜žæ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦"
  ],
  [
    "dda1",
    "å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™èŽ©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³žç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æž‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥"
  ],
  [
    "dea1",
    "è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éžé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰çŽ­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèŽŽè“‘è›‡è£Ÿè©è©žè¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª"
  ],
  [
    "dfa1",
    "å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…žè–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³žéœœå¡žç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘žç­®çµ®ç·–ç½²"
  ],
  [
    "e0a1",
    "èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³æžæ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸŽå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬"
  ],
  [
    "e1a1",
    "è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æŽƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–Žç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡çŽ‡å®‹æ‚šæ¾æ·žè¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢ŽéŽ–è¡°é‡—ä¿®å—å—½å›šåž‚å£½å«‚å®ˆå²«å³€å¸¥æ„"
  ],
  [
    "e2a1",
    "æˆæ‰‹æŽˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾žè„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾çž¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒžé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§"
  ],
  [
    "e3a1",
    "åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸žä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™žä¾åŒ™å˜¶å§‹åª¤å°¸å±Žå±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æž¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥žç´³è…Žè‡£èŽ˜è–ªè—Žèœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²"
  ],
  [
    "e4a1",
    "ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºžä¿„å…’å•žå¨¥å³¨æˆ‘ç‰™èŠ½èŽªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡Žé°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éžé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹Žé´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦åŽ“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„åŽ„æ‰¼æŽ–æ¶²ç¸Šè…‹é¡"
  ],
  [
    "e5a1",
    "æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡Žå¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªžé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æŽ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚"
  ],
  [
    "e6a1",
    "ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦Žå»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶Žæ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦žæ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±åŽ­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚Žç„°ç°è‰¶è‹’"
  ],
  [
    "e7a1",
    "ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšŽæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©Žçº“ï¦¯ï¦°è‹±è© è¿Žï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³"
  ],
  [
    "e8a1",
    "çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„çŽ‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£çŽ©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èŽžè±Œé˜®é ‘æ›°å¾€æ—ºæž‰æ±ªçŽ‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§"
  ],
  [
    "e9a1",
    "çªˆçª¯ç¹‡ç¹žè€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸ŠéŽ”éžï§„äºŽä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›çŽ—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™žè¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®žæ¾ç†‰è€˜èŠ¸è•“"
  ],
  [
    "eaa1",
    "é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŽŸå“¡åœ“åœ’åž£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰žä½å‰åƒžå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèŽè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹"
  ],
  [
    "eba1",
    "æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§Žï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤çŽ§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆŽç€œçµ¨èžï§œåž æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼"
  ],
  [
    "eca1",
    "è­°é†«äºŒä»¥ä¼Šï§ï§žå¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸éŽ°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„"
  ],
  [
    "eda1",
    "ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®çŽ†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›žå²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŽŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŽŠè‘¬è”£è–”è—è£è´“é†¬é•·"
  ],
  [
    "eea1",
    "éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½Žçˆ­ç®è«éŒšä½‡ä½Žå„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›Žé½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±"
  ],
  [
    "efa1",
    "ç…Žç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤žåˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®Žé»žæŽ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹žç€žç‚¡çŽŽç½ç”ºç›ç¢‡ç¦Žç¨‹ç©½ç²¾ç¶Žè‰‡è¨‚è«ªè²žé„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–"
  ],
  [
    "f0a1",
    "éœé ‚é¼Žåˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿Žå…†å‡‹åŠ©å˜²å¼”å½«æŽªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾žæ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«"
  ],
  [
    "f1a1",
    "è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·žå»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…Žé…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢žæ†Žæ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª"
  ],
  [
    "f2a1",
    "å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºæžæž³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœžçž‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²éŽ­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡Žç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯"
  ],
  [
    "f3a1",
    "é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•žæ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æŽ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–"
  ],
  [
    "f4a1",
    "è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºçŽ”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›çž»ç°½ç±¤è©¹è«‚å žå¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éžé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢"
  ],
  [
    "f5a1",
    "æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤Žç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æŽ¨æ¤Žæ¥¸æ¨žæ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éŽšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ"
  ],
  [
    "f6a1",
    "è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„åŽ æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æž•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—"
  ],
  [
    "f7a1",
    "é¸å‘‘å˜†å¦å½ˆæ†šæ­Žç˜ç‚­ç¶»èª•å¥ªè„«æŽ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬žèƒŽè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ŽååœŸè¨Žæ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘"
  ],
  [
    "f8a1",
    "é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾Žçƒ¹è†¨æ„Žä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©ééž­é¨™è²¶åªå¹³æž°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒžè„¯è‹žè‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ"
  ],
  [
    "f9a1",
    "å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•åŽ¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœžé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª"
  ],
  [
    "faa1",
    "ï¨ˆï¨‰é …äº¥å•å’³åž“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«çŽ„çŽ¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡èŽ¢é‹é °äº¨å…„åˆ‘åž‹"
  ],
  [
    "fba1",
    "å½¢æ³‚æ»Žç€…çç‚¯ç†’ç©ç‘©èŠèž¢è¡¡é€ˆé‚¢éŽ£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯éž‹ä¹Žäº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸žèƒ¡èŠ¦è‘«è’¿è™Žè™Ÿè´è­·è±ªéŽ¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±žæ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ"
  ],
  [
    "fca1",
    "ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›žå»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†"
  ],
  [
    "fda1",
    "çˆ»è‚´é…µé©ä¾¯å€™åŽšåŽå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£Žç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­Žé·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡žå–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™žæ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°"
  ]
];
const require$$6$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    "ã€€ï¼Œã€ã€‚ï¼Žâ€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€Žã€ï¹ƒï¹„ï¹™ï¹š"
  ],
  [
    "a1a1",
    "ï¹›ï¹œï¹ï¹žâ€˜â€™â€œâ€ã€ã€žâ€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—Žâ˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹Žï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼žï¼â‰¦â‰§â‰ âˆžâ‰’â‰¡ï¹¢",
    4,
    "ï½žâˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼"
  ],
  [
    "a240",
    "ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãŽœãŽãŽžãŽãŽ¡ãŽŽãŽã„Â°å…™å…›å…žå…å…¡å…£å—§ç“©ç³Žâ–",
    7,
    "â–â–Žâ–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­"
  ],
  [
    "a2a1",
    "â•®â•°â•¯â•â•žâ•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼",
    9,
    "â… ",
    9,
    "ã€¡",
    8,
    "åå„å…ï¼¡",
    25,
    "ï½",
    21
  ],
  [
    "a340",
    "ï½—ï½˜ï½™ï½šÎ‘",
    16,
    "Î£",
    6,
    "Î±",
    16,
    "Ïƒ",
    6,
    "ã„…",
    10
  ],
  [
    "a3a1",
    "ã„",
    25,
    "Ë™Ë‰ËŠË‡Ë‹"
  ],
  [
    "a3e1",
    "â‚¬"
  ],
  [
    "a440",
    "ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹žäºŽäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰"
  ],
  [
    "a4a1",
    "ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åžåŽ„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰Žæ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬çŽ‹ä¸™"
  ],
  [
    "a540",
    "ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹Žä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»žå……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®åŽ»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–"
  ],
  [
    "a5a1",
    "å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯çŽ„çŽ‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸žä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨"
  ],
  [
    "a640",
    "å…±å†å†°åˆ—åˆ‘åˆ’åˆŽåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåŽå†å’å› å›žå›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·žå¸†å¹¶å¹´"
  ],
  [
    "a6a1",
    "å¼å¼›å¿™å¿–æˆŽæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±Žç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½žä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£"
  ],
  [
    "a740",
    "ä½œä½ ä¼¯ä½Žä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åžå¾å¦å‘Žå§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å"
  ],
  [
    "a7a1",
    "å‡åŽåœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦žå¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸæŽæææ‘æœæ–æžæ‰æ†æ "
  ],
  [
    "a840",
    "æ“æ—æ­¥æ¯æ±‚æ±žæ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚çŽ–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’"
  ],
  [
    "a8a1",
    "èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºžäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ"
  ],
  [
    "a940",
    "å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’Žå›ºåžƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…"
  ],
  [
    "a9a1",
    "å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹Žæ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜Žæ˜€æ˜æ˜•æ˜Š"
  ],
  [
    "aa40",
    "æ˜‡æœæœ‹æ­æž‹æž•æ±æžœæ³æ·æž‡æžæž—æ¯æ°æ¿æž‰æ¾æžæµæžšæž“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ "
  ],
  [
    "aaa1",
    "ç‚•ç‚Žç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹Žç‹™ç‹—ç‹çŽ©çŽ¨çŽŸçŽ«çŽ¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™Žè™±åˆè¡¨è»‹è¿Žè¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„"
  ],
  [
    "ab40",
    "é™‚éš¹é›¨é’éžäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿Žä¿žä¾·å…—å†’å†‘å† å‰Žå‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åŽšå›å’¬å“€å’¨å“Žå“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“"
  ],
  [
    "aba1",
    "å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿åž‚åž‹åž åž£åž¢åŸŽåž®åž“å¥•å¥‘å¥å¥Žå¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±Žå±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€Žæ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·"
  ],
  [
    "ac40",
    "æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æž¶æž¯æŸµæŸ©æŸ¯æŸ„æŸ‘æž´æŸšæŸ¥æž¸æŸæŸžæŸ³æž°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´žæ´—"
  ],
  [
    "aca1",
    "æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´Žæ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡çŽ·çŠçŽ»çŽ²çç€çŽ³ç”šç”­ç•ç•Œç•Žç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾Žç¾¿è€„"
  ],
  [
    "ad40",
    "è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒŽèƒžèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹žè‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²žè² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥"
  ],
  [
    "ada1",
    "è¿­è¿«è¿¤è¿¨éƒŠéƒŽéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŽŸåŽåŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª"
  ],
  [
    "ae40",
    "å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™"
  ],
  [
    "aea1",
    "æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿æŽæŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“"
  ],
  [
    "af40",
    "æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·çŽ†ç­ç‰ç®ç çªçžç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›Žçœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·"
  ],
  [
    "afa1",
    "ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥žç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ"
  ],
  [
    "b040",
    "è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨Žè¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡"
  ],
  [
    "b0a1",
    "é™›é™é™¤é™˜é™žéš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åŽå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•žå•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€"
  ],
  [
    "b140",
    "å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´Žå´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾žå¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½"
  ],
  [
    "b1a1",
    "æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæŽ æŽ§æ²æŽ–æŽ¢æŽ¥æ·æ§æŽ˜æŽªæ±æŽ©æŽ‰æŽƒæŽ›æ«æŽ¨æŽ„æŽˆæŽ™æŽ¡æŽ¬æŽ’æŽæŽ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—Žæ™æ™šæ™¤æ™¨æ™¦æ™žæ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º"
  ],
  [
    "b240",
    "æ¯«æ¯¬æ°«æ¶Žæ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·žæ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™çŽ‡ç…çŠçƒç†ç¾çç“ ç“¶"
  ],
  [
    "b2a1",
    "ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšŽç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡Žç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬žç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾žç¾šç¿Œç¿Žç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èŽŽèŽžèŽ˜è¸èŽ¢èŽ–èŽ½èŽ«èŽ’èŽŠèŽ“èŽ‰èŽ è·è»è¼"
  ],
  [
    "b340",
    "èŽ†èŽ§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢žè¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€žé€ é€é€¢é€–é€›é€”"
  ],
  [
    "b3a1",
    "éƒ¨éƒ­éƒ½é…—é‡Žé‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹žå‹å‹›åšåŽ¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "
  ],
  [
    "b440",
    "å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„Žæƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æŽ£æŽŒææ€æ©æ‰æ†æ"
  ],
  [
    "b4a1",
    "æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•žæ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤Žæ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹"
  ],
  [
    "b540",
    "æº‰æ¸™æ¹Žæ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—žç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜"
  ],
  [
    "b5a1",
    "çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµžçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…Žè„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èŽè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›žè¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©žè¨¼è©"
  ],
  [
    "b640",
    "è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·Žè·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆžéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘"
  ],
  [
    "b6a1",
    "é–“é–’é–ŽéšŠéšŽéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—Žå—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡žå¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼"
  ],
  [
    "b740",
    "åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…Žæ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾æžæªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­"
  ],
  [
    "b7a1",
    "æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥žæ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…Žç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…žç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘žç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›žç›Ÿç›ç«ç¦çžç£"
  ],
  [
    "b840",
    "ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢Žç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨žçªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«"
  ],
  [
    "b8a1",
    "è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™žè™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š"
  ],
  [
    "b940",
    "è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡ééŽéé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´"
  ],
  [
    "b9a1",
    "é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼Žé¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒŽåƒ©å…¢å‡³åŠƒåŠ‚åŒ±åŽ­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜Žå—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯žå¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡"
  ],
  [
    "ba40",
    "æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢"
  ],
  [
    "baa1",
    "æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£çž„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦Žç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬"
  ],
  [
    "bb40",
    "ç½°ç¿ ç¿¡ç¿Ÿèžèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆžè‰‹è“‰è’¿è“†è“„è’™è’žè’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªžèª£èªèª¡èª“èª¤"
  ],
  [
    "bba1",
    "èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éžé¢éé›é„™é„˜é„žé…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼éž…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ"
  ],
  [
    "bc40",
    "åŠ‡åŠˆåŠ‰åŠåŠŠå‹°åŽ²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™Žå™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢žå¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚"
  ],
  [
    "bca1",
    "æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†Žæ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’žæ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨žæ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­Žæ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾Žæ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çŽç—ç‘©ç’‹ç’ƒ"
  ],
  [
    "bd40",
    "ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çžŽçž‡çžŒçž‘çž‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·žç·©ç¶žç·™ç·²ç·¹ç½µç½·ç¾¯"
  ],
  [
    "bda1",
    "ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†èž‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±Žè±¬è³ è³žè³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸žèººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼ž"
  ],
  [
    "be40",
    "è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éžéž‹éžé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰"
  ],
  [
    "bea1",
    "é´ƒéº©éº¾é»Žå¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°Žå½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡"
  ],
  [
    "bf40",
    "æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡Žç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’žç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥çž çžžçžŸçž¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©Žç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š"
  ],
  [
    "bfa1",
    "ç¸‘ç¸ˆç¸›ç¸£ç¸žç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•žèžƒèžŸèžžèž¢èžè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš"
  ],
  [
    "c040",
    "éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœŽéœ‘éœ–éœéœ“éœé›éœé¦éž˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤žé¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšŽåš€åšåš…åš‡"
  ],
  [
    "c0a1",
    "åšå£•å£“å£‘å£Žå¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“Žæ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªçž³çžªçž°çž¬"
  ],
  [
    "c140",
    "çž§çž­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³žç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª"
  ],
  [
    "c1a1",
    "è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘èž³èŸ’èŸ†èž«èž»èžºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬Žè¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†žé†œééŽ‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœžéž éŸ“é¡†é¢¶é¤µé¨"
  ],
  [
    "c240",
    "é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»žé»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜"
  ],
  [
    "c2a1",
    "ç™’çž½çž¿çž»çž¼ç¤Žç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°žç°£ç°¡ç³§ç¹”ç¹•ç¹žç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡éŽ”éŽŠéŽ–éŽ¢éŽ³éŽ®éŽ¬éŽ°éŽ˜éŽšéŽ—é—”é—–é—é—•é›¢é›œé›™é››é›žéœ¤éž£éž¦"
  ],
  [
    "c340",
    "éž­éŸ¹é¡é¡é¡Œé¡Žé¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨Žé«é¬ƒé¬†é­é­Žé­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£žå£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸"
  ],
  [
    "c3a1",
    "çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥žè­è­œè­˜è­‰è­šè­Žè­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½Žè¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡ž"
  ],
  [
    "c440",
    "é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼"
  ],
  [
    "c4a1",
    "çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´"
  ],
  [
    "c540",
    "è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½Žæ‡¿æ”¤æ¬Šæ­¡ç‘ç˜çŽ€ç“¤ç–Šç™®ç™¬"
  ],
  [
    "c5a1",
    "ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çžç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’"
  ],
  [
    "c640",
    "è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥žé«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸žç±²"
  ],
  [
    "c940",
    "ä¹‚ä¹œå‡µåŒšåŽ‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸Žä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬åŽ¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•"
  ],
  [
    "c9a1",
    "æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŽŠç¦¸è‚Šé˜žä¼Žä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŽŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰žæ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹"
  ],
  [
    "ca40",
    "æ±Œç±ç‰žçŠ´çŠµçŽŽç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆžåˆ¡åŠ­åŠ®åŒ‰å£å²åŽŽåŽå°å·åªå‘”å‘…å™åœå¥å˜"
  ],
  [
    "caa1",
    "å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦Žå¦¢å¦å¦å¦§å¦¡å®Žå®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸Žåº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠŽæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡"
  ],
  [
    "cb40",
    "æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²Žç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…çŽ•çŽ—çŽ“çŽ”çŽ’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠŽèŠ‘èŠ“"
  ],
  [
    "cba1",
    "èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚žé‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾žä¾’ä¾‚ä¾•ä½«ä½®å†žå†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼åŽ’åŽ”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶åž€åµå»å³å´å¢"
  ],
  [
    "cc40",
    "å¨å½å¤Œå¥…å¦µå¦ºå§å§Žå¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿žå¿¥æ€­æ€¦æ€™æ€²æ€‹"
  ],
  [
    "cca1",
    "æ€´æ€Šæ€—æ€³æ€šæ€žæ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæž…æ¬æžŽæž’æ¶æ»æž˜æž†æž„æ´æžæžŒæºæžŸæž‘æž™æžƒæ½æžæ¸æ¹æž”æ¬¥æ®€æ­¾æ¯žæ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²"
  ],
  [
    "cd40",
    "æ³’æ³æ²´æ²Šæ²æ²€æ³žæ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘çŽ¤çŽ¡çŽ­çŽ¦çŽ¢çŽ çŽ¬çŽç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº"
  ],
  [
    "cda1",
    "çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠžèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼åŽ—åŽ–åŽ™åŽ˜å’ºå’¡å’­å’¥å“"
  ],
  [
    "ce40",
    "å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“žå’°åžµåžžåžŸåž¤åžŒåž—åžåž›åž”åž˜åžåž™åž¥åžšåž•å£´å¤å¥“å§¡å§žå§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›"
  ],
  [
    "cea1",
    "å³žå³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³Žå³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²æžæ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒŽæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæžº"
  ],
  [
    "cf40",
    "æŸœæž»æŸ¸æŸ˜æŸ€æž·æŸ…æŸ«æŸ¤æŸŸæžµæŸæž³æŸ·æŸ¶æŸ®æŸ£æŸ‚æž¹æŸŽæŸ§æŸ°æž²æŸ¼æŸ†æŸ­æŸŒæž®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚"
  ],
  [
    "cfa1",
    "æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£çŽ…çŒç‚çˆç…çŽ¹çŽ¶çŽµçŽ´ç«çŽ¿ç‡çŽ¾çƒç†çŽ¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç Žç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§Žçª€"
  ],
  [
    "d040",
    "ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€Žè€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª"
  ],
  [
    "d0a1",
    "è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡Žè¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™Žå€žå€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€Žå…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡Žå‰¡å‰šå‰’å‰žå‰Ÿå‰•å‰¢å‹åŒŽåŽžå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±"
  ],
  [
    "d140",
    "å”Šå“»å“·å“¸å“ å”Žå”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åžºåŸ†åž½åž¼åž¸åž¶åž¿åŸ‡åŸåž¹åŸå¤Žå¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨žå¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§"
  ],
  [
    "d1a1",
    "ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚Žæˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡Žæ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤"
  ],
  [
    "d240",
    "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµžæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒžçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒŽçƒ¡ç‰‚ç‰¸"
  ],
  [
    "d2a1",
    "ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–çŽ¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“žç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§žç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬"
  ],
  [
    "d340",
    "ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬Žç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´žç´ç´‘ç´Žç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½žç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢"
  ],
  [
    "d3a1",
    "è‚èŽèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒžèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšžèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšŽèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…"
  ],
  [
    "d440",
    "é…Žé…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åžå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åŽœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…"
  ],
  [
    "d4a1",
    "å”Œå”²å•¥å•Žå”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å ŽåŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©žå¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªŽå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´žå´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´"
  ],
  [
    "d540",
    "å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŽŠæŽ‚æ½æŽ½æŽžæŽ­æŽæŽ—æŽ«æŽŽæ¯æŽ‡æŽæ®æŽ¯æµæŽœæ­æŽ®æ¼æŽ¤æŒ»æŽŸ"
  ],
  [
    "d5a1",
    "æ¸æŽ…æŽæŽ‘æŽæ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®Žæ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰"
  ],
  [
    "d640",
    "æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„Žç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒžçŽˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—Žç—’ç—"
  ],
  [
    "d6a1",
    "ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ"
  ],
  [
    "d740",
    "è€žè€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„žè„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èŽèŽ£èŽ¨èŽèºè³èŽ¤è´èŽèŽèŽ•èŽ™èµèŽ”èŽ©è½èŽƒèŽŒèŽèŽ›èŽªèŽ‹è¾èŽ¥èŽ¯èŽˆèŽ—èŽ°è¿èŽ¦èŽ‡èŽ®è¶èŽšè™™è™–èš¿èš·"
  ],
  [
    "d7a1",
    "è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢Žè¦‚è§–è§™è§•è¨°è¨§è¨¬è¨žè°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»žè»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª"
  ],
  [
    "d840",
    "é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚žå‚‹å‚£å‚ƒå‚Œå‚Žå‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘åŽ¤åŽ§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–ŽåœŒå ©å ·"
  ],
  [
    "d8a1",
    "å ™å žå §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªžå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯Žå°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµŽåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒŽæƒ„æ„”"
  ],
  [
    "d940",
    "æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰ŠæŽ”æŽ±æŽ°æŽæ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæŽ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–žæ–®æ—æ—’"
  ],
  [
    "d9a1",
    "æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£Žæ£ˆæ£æ£žæ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹ž"
  ],
  [
    "da40",
    "æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„žç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–"
  ],
  [
    "daa1",
    "çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçŽç‹çŒçŸžçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡žç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­Žç­€ç­˜ç­…ç²¢ç²žç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµŽç¼¾ç¼¿ç½¥"
  ],
  [
    "db40",
    "ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£èŽ¿èèè¥è˜è¿è¡è‹èŽè–èµè‰è‰èèžè‘è†è‚è³"
  ],
  [
    "dba1",
    "è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©Žè©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º"
  ],
  [
    "dc40",
    "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ"
  ],
  [
    "dca1",
    "éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡Žå¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†"
  ],
  [
    "dd40",
    "åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµžåµ¨åµ§åµ¢å·°å¹å¹Žå¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤"
  ],
  [
    "dda1",
    "æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡æŽæ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥Žæ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼"
  ],
  [
    "de40",
    "æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºžæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºŽæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“"
  ],
  [
    "dea1",
    "ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠŽçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘Žç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“"
  ],
  [
    "df40",
    "ç¨›ç¨çª£çª¢çªžç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶Žçµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…žè…¶è…§è…¯"
  ],
  [
    "dfa1",
    "è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘žè·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘Žè‘Œè‘’è‘¯è“…è’Žè»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœŽèœ‰èœè›¶èœèœ…è£–è£‹è£è£Žè£žè£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤"
  ],
  [
    "e040",
    "è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶Žè¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿"
  ],
  [
    "e0a1",
    "é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„Žé…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰žéŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰Žé‰“é‰Œé‰–éˆ²é–Ÿé–œé–žé–›éš’éš“éš‘éš—é›Žé›ºé›½é›¸é›µé³é·é¸é²é é é Žé¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ "
  ],
  [
    "e140",
    "å‡˜åŠ€åŠå‹©å‹«åŒ°åŽ¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢Žå¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«žå«å«™å«¨å«Ÿå­·å¯ "
  ],
  [
    "e1a1",
    "å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»Žå»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…žæ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘Žæ’‚æ‘žæ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰"
  ],
  [
    "e240",
    "æ¦ æ§Žæ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦Žæ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦žæ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®žæ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»Žæ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½Žæ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š"
  ],
  [
    "e2a1",
    "æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼Žæ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼žæ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çžç¼çž…çž‚ç®çž€ç¯ç¾çžƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢žç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“"
  ],
  [
    "e340",
    "ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®Žç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·Žç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿ž"
  ],
  [
    "e3a1",
    "è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“Žè“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœžèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"
  ],
  [
    "e440",
    "è£°è£¬è£«è¦è¦¡è¦Ÿè¦žè§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼Žè¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ"
  ],
  [
    "e4a1",
    "éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠŽéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšžéš¡é›¿é˜é½éºé¾éžƒéž€éž‚é»éž„éžé¿éŸŽéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜"
  ],
  [
    "e540",
    "å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶žå¹©å¹å¹ å¹œç·³å»›å»žå»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰"
  ],
  [
    "e5a1",
    "æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’"
  ],
  [
    "e640",
    "æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†žç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’çžçŸç çç›ç¡çšç™"
  ],
  [
    "e6a1",
    "ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜žç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšžçš›çžçžçž‰çžˆç£ç¢»ç£ç£Œç£‘ç£Žç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯Žç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ"
  ],
  [
    "e740",
    "è†žè†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰Žè‰‘è”¤è”»è”è”€è”©è”Žè”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”žè“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢"
  ],
  [
    "e7a1",
    "è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èžè­èªèèŽèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤Žè¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§"
  ],
  [
    "e840",
    "è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹Žé‹¦é‹é‹•é‹‰é‹ é‹žé‹§é‹‘é‹“"
  ],
  [
    "e8a1",
    "éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéžŠéžŽéžˆéŸéŸé žé é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§Žé§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡žåŒ´å¡å™°å™ å™®"
  ],
  [
    "e940",
    "å™³å™¦å™£å™­å™²å™žå™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬žå¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º"
  ],
  [
    "e9a1",
    "æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©žæ©–æ©•æ©æ©Žæ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿Žæ¿ˆæ½žæ¿„æ¾½æ¾žæ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"
  ],
  [
    "ea40",
    "æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠžç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çžšçžçž¡çžœçž›çž¢çž£çž•çž™"
  ],
  [
    "eaa1",
    "çž—ç£ç£©ç£¥ç£ªç£žç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯žç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸Žç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜"
  ],
  [
    "eb40",
    "è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•Žè•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤èž›èžèž—èž“èž’èžˆèžèž–èž˜è¹èž‡èž£èž…èžèž‘èžèž„èž”èžœèžšèž‰è¤žè¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« "
  ],
  [
    "eba1",
    "è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«žè«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒžéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒŽéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ"
  ],
  [
    "ec40",
    "éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœéž™éž—éž”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦žé§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•"
  ],
  [
    "eca1",
    "é­½é®ˆé´¥é´—é´ é´žé´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡žæ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªžæª‡æª“æªŽ"
  ],
  [
    "ed40",
    "æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿žæ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çžµçž«çž²çž·çž¶"
  ],
  [
    "eda1",
    "çž´çž±çž¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°Žç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–ž"
  ],
  [
    "ee40",
    "è•·è•¼è–‰è–¡è•ºè•¸è•—è–Žè––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨èž¾èžªèž­èŸ…èž°èž¬èž¹èžµèž¼èž®èŸ‰èŸƒèŸ‚èŸŒèž·èž¯èŸ„èŸŠèž´èž¶èž¿èž¸èž½èŸžèž²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬ž"
  ],
  [
    "eea1",
    "è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹Žè¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† éŽ¡éŽƒéŽ¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­éŽéŒéªé¹é—é•é’éé±é·é»é¡éžé£é§éŽ€éŽé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éžšéž¡éžœ"
  ],
  [
    "ef40",
    "éžžéžéŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®žé®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"
  ],
  [
    "efa1",
    "éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­žæ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€Žæ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶"
  ],
  [
    "f040",
    "ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çžºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’"
  ],
  [
    "f0a1",
    "è‡è‰Ÿè‰žè–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—Žè—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£èž¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹žè¹¥è¹§"
  ],
  [
    "f140",
    "è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéŽµéŽŒéŽ’éŽ·éŽ›éŽéŽ‰éŽ§éŽŽéŽªéŽžéŽ¦éŽ•éŽˆéŽ™éŽŸéŽéŽ±éŽ‘éŽ²éŽ¤éŽ¨éŽ´éŽ£éŽ¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥éž¬éž®éž¨éž«éž¤éžª"
  ],
  [
    "f1a1",
    "éž¢éž¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºŽéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·åŽ´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°"
  ],
  [
    "f240",
    "å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”Žæ–„æ—žæ—æ›žæ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«žæ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›"
  ],
  [
    "f2a1",
    "ç¤¡ç¤œç¤—ç¤žç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—žè—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•"
  ],
  [
    "f340",
    "è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éžé‡éé‚éšéé¹é¬éŒé™éŽ©é¦éŠé”é®é£é•é„éŽé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦"
  ],
  [
    "f3a1",
    "éž³éž·éž¶éŸéŸžéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨žé¨œé¨”é«‚é¬‹é¬Šé¬Žé¬Œé¬·é¯ªé¯«é¯ é¯žé¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²"
  ],
  [
    "f440",
    "åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸŽçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"
  ],
  [
    "f4a1",
    "ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éŽé–é’éºé‰é¸éŠé¿"
  ],
  [
    "f540",
    "é¼éŒé¶é‘é†é—žé— é—Ÿéœ®éœ¯éž¹éž»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥Žé¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°Žé°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›"
  ],
  [
    "f5a1",
    "é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶žé¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½žé½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜žè˜¥"
  ],
  [
    "f640",
    "è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºŽèºŒè½žè½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºéž¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º"
  ],
  [
    "f6a1",
    "é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·Žé¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½Žé½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆžçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š"
  ],
  [
    "f740",
    "ç³´ç³±çº‘ç½ç¾‡è‡žè‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©Žé©“é©”é©Œé©é©ˆé©Š"
  ],
  [
    "f7a1",
    "é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·žé·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢çŽ‚çŽçŽƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"
  ],
  [
    "f840",
    "è®Œè®Žè®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘žéŸ„éŸ…é €é©–é©™é¬žé¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±Žé·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½"
  ],
  [
    "f8a1",
    "é½±é½°é½®é½¯å›“å›å­Žå±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºžèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©žé«•é­™é±£é±§é±¦é±¢é±žé± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼žé½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš"
  ],
  [
    "f940",
    "çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœžç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š"
  ],
  [
    "f9a1",
    "é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®žè²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬žçˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•žâ•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“"
  ]
];
const require$$7$1 = [
  [
    "8740",
    "ä°ä°²ä˜ƒä–¦ä•¸ð§‰§äµ·ä–³ð§²±ä³¢ð§³…ã®•äœ¶ä„ä±‡ä±€ð¤Š¿ð£˜—ð§’ð¦º‹ð§ƒ’ä±—ðª‘ää—šä²…ð§±¬ä´‡äª¤äš¡ð¦¬£çˆ¥ð¥©”ð¡©£ð£¸†ð£½¡æ™å›»"
  ],
  [
    "8767",
    "ç¶•å¤ð¨®¹ã·´éœ´ð§¯¯å¯›ð¡µžåª¤ã˜¥ð©º°å«‘å®·å³¼æ®è–“ð©¥…ç‘¡ç’ã¡µð¡µ“ð£šžð¦€¡ã»¬"
  ],
  [
    "87a1",
    "ð¥£žã«µç«¼é¾—ð¤…¡ð¨¤ð£‡ªð ªŠð£‰žäŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æž‚ç¨¬å‰é†ã“¦ç„ð¥¶¹ç“†é¿‡åž³ä¤¯å‘Œä„±ð£šŽå ˜ç©²ð§­¥è®äš®ð¦ºˆä†ð¥¶™ç®®ð¢’¼é¿ˆð¢“ð¢“‰ð¢“Œé¿‰è”„ð£–»ä‚´é¿Šä“¡ðª·¿æ‹ç®é¿‹"
  ],
  [
    "8840",
    "ã‡€",
    4,
    "ð „Œã‡…ð ƒ‘ð ƒã‡†ã‡‡ð ƒ‹ð¡¿¨ã‡ˆð ƒŠã‡‰ã‡Šã‡‹ã‡Œð „Žã‡ã‡ŽÄ€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇŽÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš"
  ],
  [
    "88a1",
    "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"
  ],
  [
    "8940",
    "ðªŽ©ð¡……"
  ],
  [
    "8943",
    "æ”Š"
  ],
  [
    "8946",
    "ä¸½æ»éµŽé‡Ÿ"
  ],
  [
    "894c",
    "ð§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åŽå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®žå®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµŽç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®"
  ],
  [
    "89a1",
    "ç‘ç³¼ç·æ¥†ç«‰åˆ§"
  ],
  [
    "89ab",
    "é†Œç¢¸é…žè‚¼"
  ],
  [
    "89b0",
    "è´‹èƒ¶ð §§"
  ],
  [
    "89b5",
    "è‚Ÿé»‡ä³é·‰é¸Œä°¾ð©·¶ð§€Žé¸Šðª„³ã—"
  ],
  [
    "89c1",
    "æºšèˆ¾ç”™"
  ],
  [
    "89c5",
    "ä¤‘é©¬éªé¾™ç¦‡ð¨‘¬ð¡·Šð —ð¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡åŽ©ã•‘åŽ°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…"
  ],
  [
    "8a40",
    "ð§¶„å”¥"
  ],
  [
    "8a43",
    "ð ±‚ð ´•ð¥„«å–ð¢³†ã§¬ð è¹†ð¤¶¸ð©“¥ä“ð¨‚¾çºð¢°¸ã¨´äŸ•ð¨…ð¦§²ð¤·ªæ“ð µ¼ð ¾´ð ³•ð¡ƒ´æ’è¹¾ð º–ð °‹ð ½¤ð¢²©ð¨‰–ð¤““"
  ],
  [
    "8a64",
    "ð µ†ð©©ð¨ƒ©äŸ´ð¤º§ð¢³‚éª²ã©§ð©—´ã¿­ã”†ð¥‹‡ð©Ÿ”ð§£ˆð¢µ„éµ®é •"
  ],
  [
    "8a76",
    "ä™ð¦‚¥æ’´å“£ð¢µŒð¢¯Šð¡·ã§»ð¡¯"
  ],
  [
    "8aa1",
    "ð¦›šð¦œ–ð§¦ æ“ªð¥’ð ±ƒè¹¨ð¢†¡ð¨­Œð œ±"
  ],
  [
    "8aac",
    "ä ‹ð †©ã¿ºå¡³ð¢¶"
  ],
  [
    "8ab2",
    "ð¤—ˆð “¼ð¦‚—ð ½Œð ¶–å•¹ä‚»äŽº"
  ],
  [
    "8abb",
    "äª´ð¢©¦ð¡‚è†ªé£µð ¶œæ¹ã§¾ð¢µè·€åš¡æ‘¼ã¹ƒ"
  ],
  [
    "8ac9",
    "ðª˜ð ¸‰ð¢«ð¢³‰"
  ],
  [
    "8ace",
    "ð¡ƒˆð£§‚ã¦’ã¨†ð¨Š›ã•¸ð¥¹‰ð¢ƒ‡å™’ð ¼±ð¢²²ð©œ ã’¼æ°½ð¤¸»"
  ],
  [
    "8adf",
    "ð§•´ð¢º‹ð¢ˆˆðª™›ð¨³ð ¹ºð °´ð¦ œç¾“ð¡ƒð¢ ƒð¢¤¹ã—»ð¥‡£ð ºŒð ¾ð ºªã¾“ð ¼°ð µ‡ð¡…ð ¹Œ"
  ],
  [
    "8af6",
    "ð º«ð ®©ð µˆð¡ƒ€ð¡„½ã¿¹ð¢š–æ²ð ¾­"
  ],
  [
    "8b40",
    "ð£´ð§˜¹ð¢¯Žð µ¾ð µ¿ð¢±‘ð¢±•ã¨˜ð º˜ð¡ƒ‡ð ¼®ðª˜²ð¦­ð¨³’ð¨¶™ð¨³Šé–ªå“Œè‹„å–¹"
  ],
  [
    "8b55",
    "ð©»ƒé°¦éª¶ð§žð¢·®ç…€è…­èƒ¬å°œð¦•²è„´ãž—åŸð¨‚½é†¶ð »ºð ¸ð ¹·ð »»ã—ð¤·«ã˜‰ð ³–åš¯ð¢žµð¡ƒ‰ð ¸ð ¹¸ð¡¸ð¡…ˆð¨ˆ‡ð¡‘•ð ¹¹ð¤¹ð¢¶¤å©”ð¡€ð¡€žð¡ƒµð¡ƒ¶åžœð ¸‘"
  ],
  [
    "8ba1",
    "ð§š”ð¨‹ð ¾µð ¹»ð¥…¾ãœƒð ¾¶ð¡†€ð¥‹˜ðªŠ½ð¤§šð¡ ºð¤…·ð¨‰¼å¢™å‰¨ã˜šð¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ð¥­´ð£„½å—»ã—²åš‰ä¸¨å¤‚ð¡¯ð¯¡¸é‘ð ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ð¤£©ç½’ç¤»ç³¹ç½“ð¦‰ªã“"
  ],
  [
    "8bde",
    "ð¦‹è€‚è‚€ð¦˜’ð¦¥‘åè¡¤è§ð§¢²è® è´é’…é•¸é•¿é—¨ð¨¸éŸ¦é¡µé£Žé£žé¥£ð© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ð ‚‡é˜æˆ·é’¢"
  ],
  [
    "8c40",
    "å€»æ·¾ð©±³é¾¦ã·‰è¢ð¤…Žç·å³µä¬ ð¥‡ã•™ð¥´°æ„¢ð¨¨²è¾§é‡¶ç†‘æœ™çŽºð£Šðª„‡ã²‹ð¡¦€ä¬ç£¤ç‚å†®ð¨œä€‰æ©£ðªŠºäˆ£è˜ð ©¯ç¨ªð©¥‡ð¨«ªé•çåŒ¤ð¢¾é´ç›™ð¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ð¡¶¶åº’åº™å¿‚ð¢œ’æ–‹"
  ],
  [
    "8ca1",
    "ð£¹æ¤™æ©ƒð£±£æ³¿"
  ],
  [
    "8ca7",
    "çˆ€ð¤”…çŽŒã»›ð¤¨“å¬•ç’¹è®ƒð¥²¤ð¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ð¨¶¹ð¡¿ä±äŠ¢å¨š"
  ],
  [
    "8cc9",
    "é¡¨æ«ä‰¶åœ½"
  ],
  [
    "8cce",
    "è—–ð¤¥»èŠ¿ð§„ä²ð¦µ´åµ»ð¦¬•ð¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒð£‰–ð¢ž–äŽšä”¶"
  ],
  [
    "8ce6",
    "å³•ð£¬šè«¹å±¸ã´’ð£•‘åµ¸é¾²ç…—ä•˜ð¤ƒ¬ð¡¸£ä±·ã¥¸ã‘Šð †¤ð¦±è«Œä¾´ð ˆ¹å¦¿è…¬é¡–ð©£ºå¼»"
  ],
  [
    "8d40",
    "ð ®Ÿ"
  ],
  [
    "8d42",
    "ð¢‡ð¨¥­ä„‚äš»ð©¹ã¼‡é¾³ðª†µäƒ¸ãŸ–ä›·ð¦±†ä…¼ð¨š²ð§¿ä•­ã£”ð¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆð¤¬ã™¡ä“žä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±"
  ],
  [
    "8da1",
    "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æž¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ð¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ð£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ð Œ¥äã—±ð »˜"
  ],
  [
    "8e40",
    "ð£»—åž¾ð¦»“ç„¾ð¥Ÿ ã™Žæ¦¢ð¨¯©å­´ç©‰ð¥£¡ð©“™ç©¥ç©½ð¥¦¬çª»çª°ç«‚ç«ƒç‡‘ð¦’ä‡Šç«šç«ç«ªä‡¯å’²ð¥°ç¬‹ç­•ç¬©ð¥ŒŽð¥³¾ç®¢ç­¯èŽœð¥®´ð¦±¿ç¯è¡ç®’ç®¸ð¥´ ã¶­ð¥±¥è’’ç¯ºç°†ç°µð¥³ç±„ç²ƒð¤¢‚ç²¦æ™½ð¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³Ž"
  ],
  [
    "8ea1",
    "ç¹§ä”ð¦¹„çµð¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ð¤—ð¦€©ç·¤ã´“ç·µð¡Ÿ¹ç·¥ð¨­ç¸ð¦„¡ð¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ð¦‹é§¡ç¾—ð¦‘ç¾£ð¡™¡ð ¨ä•œð£¦ä”ƒð¨Œºç¿ºð¦’‰è€…è€ˆè€è€¨è€¯ðª‚‡ð¦³ƒè€»è€¼è¡ð¢œ”ä¦‰ð¦˜¦ð£·£ð¦›¨æœ¥è‚§ð¨©ˆè„‡è„šå¢°ð¢›¶æ±¿ð¦’˜ð¤¾¸æ“§ð¡’Šèˆ˜ð¡¡žæ©“ð¤©¥ð¤ª•ä‘ºèˆ©ð ¬ð¦©’ð£µ¾ä¿¹ð¡“½è“¢è¢ð¦¬Šð¤¦§ð£”°ð¡³ð£·¸èŠªæ¤›ð¯¦”ä‡›"
  ],
  [
    "8f40",
    "è•‹è‹èŒšð ¸–ð¡ž´ã›ð£…½ð£•šè‰»è‹¢èŒ˜ð£º‹ð¦¶£ð¦¬…ð¦®—ð£—Žã¶¿èŒå—¬èŽ…ä”‹ð¦¶¥èŽ¬èè“ã‘¾ð¦»”æ©—è•šã’–ð¦¹‚ð¢»¯è‘˜ð¥¯¤è‘±ã·“ä“¤æª§è‘Šð£²µç¥˜è’¨ð¦®–ð¦¹·ð¦¹ƒè“žèèŽ‘ä’ è’“è“¤ð¥²‘ä‰€ð¥³€ä•ƒè”´å«²ð¦º™ä”§è•³ä”–æž¿è˜–"
  ],
  [
    "8fa1",
    "ð¨˜¥ð¨˜»è—ð§‚ˆè˜‚ð¡–‚ð§ƒð¯¦²ä•ªè˜¨ã™ˆð¡¢¢å·ð§Žšè™¾è±ðªƒ¸èŸ®ð¢°§èž±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ð§— ð£¶¹ð§—¤è¡žè¢œä™›è¢´è¢µæè£…ç·ð§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªœçž“é‡¾èªð§©™ç«©ð§¬ºð£¾äœ“ð§¬¸ç…¼è¬Œè¬Ÿð¥°ð¥•¥è¬¿è­Œè­èª©ð¤©ºè®è®›èª¯ð¡›Ÿä˜•è¡è²›ð§µ”ð§¶ð¯§”ãœ¥ð§µ“è³–ð§¶˜ð§¶½è´’è´ƒð¡¤è³›çœè´‘ð¤³‰ã»èµ·"
  ],
  [
    "9040",
    "è¶©ð¨€‚ð¡€”ð¤¦Šã­¼ð¨†¼ð§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ð¨¥ð¨’è¾¥éŒƒðªŠŸð ©è¾³ä¤ªð¨§žð¨”½ð£¶»å»¸ð£‰¢è¿¹ðª€”ð¨š¼ð¨”ð¢Œ¥ã¦€ð¦»—é€·ð¨”¼ð§ª¾é¡ð¨•¬ð¨˜‹é‚¨ð¨œ“éƒ„ð¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ð¨¤³ð¡º‰éˆŽæ²Ÿé‰é‰¢ð¥–¹éŠ¹ð¨«†ð£²›ð¨¬Œð¥—›"
  ],
  [
    "90a1",
    "ð ´±éŒ¬é«ð¨«¡ð¨¯«ç‚å«ƒð¨«¢ð¨«¥ä¥¥é‰„ð¨¯¬ð¨°¹ð¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ð¢™ºð¨›˜ð¡‰¼ð£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ð¦»•æ‡šéš¶ç£µð¨« éš½åŒä¦¡ð¦²¸ð ‰´ð¦ð©‚¯ð©ƒ¥ð¤«‘ð¡¤•ð£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ð¤«©çµå­éœ›éœð©‡•é—å­Šð©‡«éŸé¥åƒð£‚·ð£‚¼éž‰éžŸéž±éž¾éŸ€éŸ’éŸ ð¥‘¬éŸ®çœð©³éŸ¿éŸµð©ð§¥ºä«‘é ´é ³é¡‹é¡¦ã¬Žð§…µãµ‘ð ˜°ð¤…œ"
  ],
  [
    "9140",
    "ð¥œ†é£Šé¢·é£ˆé£‡ä«¿ð¦´§ð¡›“å–°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡—ð©¤…é§µé¨Œé¨»é¨é©˜ð¥œ¥ã›„ð©‚±ð©¯•é« é«¢ð©¬…é«´ä°Žé¬”é¬­ð¨˜€å€´é¬´ð¦¦¨ã£ƒð£½é­é­€ð©´¾å©…ð¡¡£é®Žð¤‰‹é°‚é¯¿é°Œð©¹¨é·”ð©¾·ðª†’ðª†«ðªƒ¡ðª„£ðª‡Ÿéµ¾é¶ƒðª„´é¸Žæ¢ˆ"
  ],
  [
    "91a1",
    "é·„ð¢…›ðª†“ðªˆ ð¡¤»ðªˆ³é´¹ðª‚¹ðªŠ´éºéº•éºžéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ãž¾ð¨°«é¼‚é¼ˆä®–é¤ð¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ð©‚‹éŸ²è‘¿é½¢é½©ç«œé¾Žçˆ–ä®¾ð¤¥µð¤¦»ç…·ð¤§¸ð¤ˆð¤©‘çŽžð¨¯šð¡£ºç¦Ÿð¨¥¾ð¨¸¶é©é³ð¨©„é‹¬éŽé‹ð¨¥¬ð¤’¹çˆ—ã»«ç²ç©ƒçƒð¤‘³ð¤¸ç…¾ð¡Ÿ¯ç‚£ð¡¢¾ð£–™ã»‡ð¡¢…ð¥¯ð¡Ÿ¸ãœ¢ð¡›»ð¡ ¹ã›¡ð¡´ð¡£‘ð¥½‹ãœ£ð¡›€å›ð¤¨¥ð¡¾ð¡Š¨"
  ],
  [
    "9240",
    "ð¡†ð¡’¶è”ƒð£š¦è”ƒè‘•ð¤¦”ð§…¥ð£¸±ð¥•œð£»»ð§’ä“´ð£›®ð©¦ð¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ð¡¤¢æ ä—ð£œ¿ð¤ƒ¡ð¤‚‹ð¤„ð¦°¡å“‹åšžð¦š±åš’ð ¿Ÿð ®¨ð ¸é†ð¨¬“éŽœä»¸å„«ã ™ð¤¶äº¼ð ‘¥ð ¿ä½‹ä¾Šð¥™‘å©¨ð †«ð ‹ã¦™ð ŒŠð ”ãµä¼©ð ‹€ð¨º³ð ‰µè«šð ˆŒäº˜"
  ],
  [
    "92a1",
    "åƒå„ä¾¢ä¼ƒð¤¨Žð£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…žæ¹¶ð£–•ð£¸¹ð£º¿æµ²ð¡¢„ð£º‰å†¨å‡ƒð — ä“ð ’£ð ’’ð ’‘èµºð¨ªœð œŽå‰™åŠ¤ð ¡³å‹¡é®ä™ºç†Œð¤ŽŒð ° ð¤¦¬ð¡ƒ¤æ§‘ð ¸ç‘¹ã»žç’™ç”ç‘–çŽ˜ä®Žð¤ª¼ð¤‚åã–„çˆð¤ƒ‰å–´ð …å“ð ¯†åœé‰é›´é¦åŸåžå¿ã˜¾å£‹åª™ð¨©†ð¡›ºð¡¯ð¡œå¨¬å¦¸éŠå©¾å«å¨’ð¥¥†ð¡§³ð¡¡¡ð¤Š•ã›µæ´…ç‘ƒå¨¡ð¥ºƒ"
  ],
  [
    "9340",
    "åªð¨¯—ð “é ç’Œð¡Œƒç„…ä¥²éˆð¨§»éŽ½ãž å°žå²žå¹žå¹ˆð¡¦–ð¡¥¼ð£«®å»å­ð¡¤ƒð¡¤„ãœð¡¢ ã›ð¡›¾ã›“è„ªð¨©‡ð¡¶ºð£‘²ð¨¦¨å¼Œå¼Žð¡¤§ð¡ž«å©«ð¡œ»å­„è˜”ð§—½è¡ æ¾ð¢¡ ð¢˜«å¿›ãº¸ð¢–¯ð¢–¾ð©‚ˆð¦½³æ‡€ð €¾ð †ð¢˜›æ†™æ†˜æµð¢²›ð¢´‡ð¤›”ð©…"
  ],
  [
    "93a1",
    "æ‘±ð¤™¥ð¢­ªã¨©ð¢¬¢ð£‘ð©£ªð¢¹¸æŒ·ðª‘›æ’¶æŒ±æ‘ð¤§£ð¢µ§æŠ¤ð¢²¡æ»æ•«æ¥²ã¯´ð£‚Žð£Š­ð¤¦‰ð£Š«å”ð£‹ ð¡£™ð©¿æ›Žð£Š‰ð£†³ã« ä†ð¥–„ð¨¬¢ð¥–ð¡›¼ð¥•›ð¥¥ç£®ð£„ƒð¡ ªð£ˆ´ã‘¤ð£ˆð£†‚ð¤‹‰æšŽð¦´¤æ™«ä®“æ˜°ð§¡°ð¡·«æ™£ð£‹’ð£‹¡æ˜žð¥¡²ã£‘ð£ ºð£ž¼ã®™ð£ž¢ð£¾ç“ã®–æžð¤˜ªæ¢¶æ žã¯„æª¾ã¡£ð£Ÿ•ð¤’‡æ¨³æ©’æ«‰æ¬…ð¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ð£¿€ð£²šéŽ é‹²ð¨¯ªð¨«‹"
  ],
  [
    "9440",
    "éŠ‰ð¨€žð¨§œé‘§æ¶¥æ¼‹ð¤§¬æµ§ð£½¿ã¶æ¸„ð¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ð¤Œšð¤‰¶çƒ±ç‰çŠ‡çŠ”ð¤žð¤œ¥å…¹ð¤ª¤ð —«ç‘ºð£»¸ð£™Ÿð¤©Šð¤¤—ð¥¿¡ã¼†ãº±ð¤«Ÿð¨°£ð£¼µæ‚§ã»³ç“Œç¼éŽ‡ç·ä’Ÿð¦·ªä•‘ç–ƒã½£ð¤³™ð¤´†ã½˜ç••ç™³ðª—†ã¬™ç‘¨ð¨«Œð¤¦«ð¤¦Žã«»"
  ],
  [
    "94a1",
    "ã·ð¤©Žã»¿ð¤§…ð¤£³é‡ºåœ²é‚ð¨«£ð¡¡¤åƒŸð¥ˆ¡ð¥‡§ç¸ð£ˆ²çœŽçœç»ð¤š—ð£žã©žð¤£°ç¸ç’›ãº¿ð¤ªºð¤«‡äƒˆð¤ª–ð¦†®éŒ‡ð¥–ç žç¢ç¢ˆç£’çç¥™ð§ð¥›£ä„Žç¦›è’–ç¦¥æ¨­ð£»ºç¨ºç§´ä…®ð¡›¦ä„²éˆµç§±ð µŒð¤¦Œð Š™ð£¶ºð¡®ã–—å•«ã•°ãšªð ‡”ð °ç«¢å©™ð¢›µð¥ª¯ð¥ªœå¨ð ‰›ç£°å¨ªð¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡ž°ç²Žç±¼ç²®æª²ç·œç¸‡ç·“ç½Žð¦‰¡"
  ],
  [
    "9540",
    "ð¦…œð§­ˆç¶—ð¥º‚ä‰ªð¦­µð ¤–æŸ–ð Žð£—åŸ„ð¦’ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µƒç¬Œð¥¸Žé§¦è™…é©£æ¨œð£¿ã§¢ð¤§·ð¦–­é¨Ÿð¦– è’€ð§„§ð¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ð¦ž´é£ƒð¦©‚è‰¢è‰¥ð¦©‘è‘“ð¦¶§è˜ð§ˆ›åª†ä…¿ð¡¡€å¬«ð¡¢¡å«¤ð¡£˜èš ð¯¦¼ð£¶è ­ð§¢å¨‚"
  ],
  [
    "95a1",
    "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ð¥šƒè¥”ð§ž…ð§ž„ð¨¯µð¨¯™ð¨®œð¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œð©‘ˆå½éˆ«ð¤Š„æ—”ç„©çƒ„ð¡¡…éµ­è²Ÿè³©ð§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ð¤°‰è¼°è½Šä‹´æ±˜æ¾»ð¢Œ¡ä¢›æ½¹æº‹ð¡Ÿšé¯©ãšµð¤¤¯é‚»é‚—å•±ä¤†é†»é„ð¨©‹ä¢ð¨«¼é§ð¨°ð¨°»è“¥è¨«é–™é–§é–—é––ð¨´´ç‘…ã»‚ð¤£¿ð¤©‚ð¤ªã»§ð£ˆ¥éšð¨»§ð¨¹¦ð¨¹¥ã»Œð¤§­ð¤©¸ð£¿®ç’ç‘«ã»¼éð©‚°"
  ],
  [
    "9640",
    "æ¡‡ä¨ð©‚“ð¥ŸŸéé¨ð¨¦‰ð¨°¦ð¨¬¯ð¦Ž¾éŠºå¬‘è­©ä¤¼ç¹ð¤ˆ›éž›é±é¤¸ð ¼¦å·ð¨¯…ð¤ª²é Ÿð©“šé‹¶ð©——é‡¥ä“€ð¨­ð¤©§ð¨­¤é£œð¨©…ã¼€éˆªä¤¥è”é¤»é¥ð§¬†ã·½é¦›ä­¯é¦ªé©œð¨­¥ð¥£ˆæªé¨¡å«¾é¨¯ð©£±ä®ð©¥ˆé¦¼ä®½ä®—é½å¡²ð¡Œ‚å ¢ð¤¦¸"
  ],
  [
    "96a1",
    "ð¡“¨ç¡„ð¢œŸð£¶¸æ£…ãµ½é‘˜ã¤§æ…ð¢žð¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ð©¸­é®Ÿðª‡µðªƒ¾é´¡ä²®ð¤„„é¸˜ä²°é´Œðª†´ðªƒ­ðªƒ³ð©¤¯é¶¥è’½ð¦¸’ð¦¿Ÿð¦®‚è—¼ä”³ð¦¶¤ð¦º„ð¦·°è è—®ð¦¸€ð£Ÿ—ð¦¤ç§¢ð£–œð£™€ä¤­ð¤§žãµ¢é›éŠ¾éˆð Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ð¥•ç ½ç¡”ç¢¶ç¡‹ð¡—ð£‡‰ð¤¥ãššä½²æ¿šæ¿™ç€žç€žå”ð¤†µåž»å£³åžŠé´–åŸ—ç„´ã’¯ð¤†¬ç‡«ð¦±€ð¤¾—å¬¨ð¡žµð¨©‰"
  ],
  [
    "9740",
    "æ„Œå«Žå¨‹äŠ¼ð¤’ˆãœ¬ä­»ð¨§¼éŽ»éŽ¸ð¡£–ð ¼è‘²ð¦³€ð¡“ð¤‹ºð¢°¦ð¤å¦”ð£¶·ð¦ç¶¨ð¦…›ð¦‚¤ð¤¦¹ð¤¦‹ð¨§ºé‹¥ç¢ã»©ç’´ð¨­£ð¡¢Ÿã»¡ð¤ª³æ«˜ç³ç»ã»–ð¤¨¾ð¤ª”ð¡Ÿ™ð¤©¦ð Ž§ð¡¤ð¤§¥ç‘ˆð¤¤–ç‚¥ð¤¥¶éŠ„ç¦éŸð “¾éŒ±ð¨«Žð¨¨–éŽ†ð¨¯§ð¥—•ä¤µð¨ª‚ç…«"
  ],
  [
    "97a1",
    "ð¤¥ƒð ³¿åš¤ð ˜šð ¯«ð ²¸å”‚ç§„ð¡Ÿºç·¾ð¡›‚ð¤©ð¡¡’ä”®éãœŠð¨«€ð¤¦­å¦°ð¡¢¿ð¡¢ƒð§’„åª¡ã›¢ð£µ›ãš°é‰Ÿå©¹ð¨ªð¡¡¢é´ã³ð ª´äª–ã¦Šåƒ´ãµ©ãµŒð¡Žœç…µä‹»ð¨ˆ˜æ¸ð©ƒ¤ä“«æµ—ð§¹ç§æ²¯ã³–ð£¿­ð£¸­æ¸‚æ¼Œãµ¯ð µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ð¨°œð¦¯€å ’åŸˆã›–ð¡‘’çƒ¾ð¤¢ð¤©±ð¢¿£ð¡Š°ð¢Ž½æ¢¹æ¥§ð¡Ž˜ð£“¥ð§¯´ð£›Ÿð¨ªƒð£Ÿ–ð£ºð¤²Ÿæ¨šð£š­ð¦²·è¾ä“Ÿä“Ž"
  ],
  [
    "9840",
    "ð¦´¦ð¦µ‘ð¦²‚ð¦¿žæ¼—ð§„‰èŒ½ð¡œºè­ð¦²€ð§“ð¡Ÿ›å¦‰åª‚ð¡ž³å©¡å©±ð¡¤…ð¤‡¼ãœ­å§¯ð¡œ¼ã›‡ç†ŽéŽæššð¤Š¥å©®å¨«ð¤Š“æ¨«ð£»¹ð§œ¶ð¤‘›ð¤‹Šç„ð¤‰™ð¨§¡ä¾°ð¦´¨å³‚ð¤“Žð§¹ð¤Ž½æ¨Œð¤‰–ð¡Œ„ç‚¦ç„³ð¤©ã¶¥æ³Ÿð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½œð¤©ð¡ŸŸç¶¤è¦"
  ],
  [
    "98a1",
    "å’…ð£«ºð£Œ€ð ˆ”å¾ð £•ð ˜™ã¿¥ð¡¾žðªŠ¶ç€ƒð©…›åµ°çŽç³“ð¨©™ð© ä¿ˆç¿§ç‹çŒð§«´çŒ¸çŒ¹ð¥›¶ççˆãº©ð§¬˜é¬ç‡µð¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™çžçŸã»¢ã»°ã»´ã»ºç““ã¼Žã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºð¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›çž˜äªä¯å±žçž¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆð¥”µç¤³æ ƒç¤²ä„ƒ"
  ],
  [
    "9940",
    "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ð ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸäŽ—è€ è€¥ç¬¹è€®è€±è”ã·Œåž´ç‚ è‚·èƒ©ä­è„ŒçŒªè„Žè„’ç• è„”äã¬¹è…–è…™è…š"
  ],
  [
    "99a1",
    "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…èž‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ð§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œäž˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»Žè»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤žéˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿"
  ],
  [
    "9a40",
    "é‹£é‹«é‹³é‹´é‹½éƒéŽ„éŽ­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æž ä¨¤é€ä¨µéž²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤Žé¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯‚éµ‰é°º"
  ],
  [
    "9aa1",
    "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ð ‚”ð Š·ð Ž æ¤šé“ƒå¦¬ð “—å¡€é“ãž¹ð —•ð ˜•ð ™¶ð¡šºå—ç…³ð «‚ð «ð ®¿å‘ªð¯ »ð ¯‹å’žð ¯»ð °»ð ±“ð ±¥ð ±¼æƒ§ð ²å™ºð ²µð ³ð ³­ð µ¯ð ¶²ð ·ˆæ¥•é°¯èž¥ð ¸„ð ¸Žð »—ð ¾ð ¼­ð ¹³å° ð ¾¼å¸‹ð¡œð¡ð¡¶æœžð¡»ð¡‚ˆð¡‚–ã™‡ð¡‚¿ð¡ƒ“ð¡„¯ð¡„»å¤è’­ð¡‹£ð¡µð¡Œ¶è®ð¡•·ð¡˜™ð¡Ÿƒð¡Ÿ‡ä¹¸ç‚»ð¡ ­ð¡¥ª"
  ],
  [
    "9b40",
    "ð¡¨­ð¡©…ð¡°ªð¡±°ð¡²¬ð¡»ˆæ‹ƒð¡»•ð¡¼•ç†˜æ¡•ð¢…æ§©ã›ˆð¢‰¼ð¢—ð¢ºð¢œªð¢¡±ð¢¥è‹½ð¢¥§ð¢¦“ð¢«•è¦¥ð¢«¨è¾ ð¢¬Žéž¸ð¢¬¿é¡‡éª½ð¢±Œ"
  ],
  [
    "9b62",
    "ð¢²ˆð¢²·ð¥¯¨ð¢´ˆð¢´’ð¢¶·ð¢¶•ð¢¹‚ð¢½´ð¢¿Œð£€³ð£¦ð£ŒŸð£žå¾±æ™ˆæš¿ð§©¹ð£•§ð£—³çˆð¤¦ºçŸ—ð£˜šð£œ–çº‡ð †å¢µæœŽ"
  ],
  [
    "9ba1",
    "æ¤˜ð£ª§ð§™—ð¥¿¢ð£¸‘ð£º¹ð§—¾ð¢‚šä£äª¸ð¤„™ð¨ªšð¤‹®ð¤Œð¤€»ð¤Œ´ð¤Ž–ð¤©…ð —Šå‡’ð ˜‘å¦Ÿð¡º¨ã®¾ð£³¿ð¤„ð¤“–åžˆð¤™´ã¦›ð¤œ¯ð¨—¨ð©§‰ã¢ð¢‡ƒè­žð¨­Žé§–ð¤ ’ð¤£»ð¤¨•çˆ‰ð¤«€ð ±¸å¥¥ð¤º¥ð¤¾†ð ¹è»šð¥€¬åŠåœ¿ç…±ð¥Š™ð¥™ð£½Šð¤ª§å–¼ð¥‘†ð¥‘®ð¦­’é‡”ã‘³ð¥”¿ð§˜²ð¥•žäœ˜ð¥•¢ð¥•¦ð¥Ÿ‡ð¤¤¿ð¥¡å¦ã“»ð£Œæƒžð¥¤ƒä¼ð¨¥ˆð¥ª®ð¥®‰ð¥°†ð¡¶åž¡ç…‘æ¾¶ð¦„‚ð§°’é–ð¦†²ð¤¾šè­¢ð¦‚ð¦‘Š"
  ],
  [
    "9c40",
    "åµ›ð¦¯·è¼¶ð¦’„ð¡¤œè«ªð¤§¶ð¦’ˆð£¿¯ð¦”’ä¯€ð¦–¿ð¦šµð¢œ›é‘¥ð¥Ÿ¡æ†•å¨§ð¯£ä¾»åš¹ð¤”¡ð¦›¼ä¹ªð¤¤´é™–æ¶ð¦²½ã˜˜è¥·ð¦ž™ð¦¡®ð¦‘ð¦¡žç‡Ÿð¦£‡ç­‚ð©ƒ€ð ¨‘ð¦¤¦é„„ð¦¤¹ç©…é·°ð¦§ºé¨¦ð¦¨­ã™Ÿð¦‘©ð €¡ç¦ƒð¦¨´ð¦­›å´¬ð£”™èð¦®ä›ð¦²¤ç”»è¡¥ð¦¶®å¢¶"
  ],
  [
    "9ca1",
    "ãœœð¢–ð§‹ð§‡ã±”ð§Š€ð§Š…éŠð¢…ºð§Š‹éŒ°ð§‹¦ð¤§æ°¹é’Ÿð§‘ð »¸è §è£µð¢¤¦ð¨‘³ð¡ž±æº¸ð¤¨ªð¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ð©²­ð©¢¤è¥ƒð§ŸŒð§¡˜å›–äƒŸð¡˜Šã¦¡ð£œ¯ð¨ƒ¨ð¡…ç†­è¦ð§§ð©†¨å©§ä²·ð§‚¯ð¨¦«ð§§½ð§¨Šð§¬‹ð§µ¦ð¤…ºç­ƒç¥¾ð¨€‰æ¾µðª‹Ÿæ¨ƒð¨Œ˜åŽ¢ð¦¸‡éŽ¿æ ¶éð¨…¯ð¨€£ð¦¦µð¡­ð£ˆ¯ð¨ˆå¶…ð¨°°ð¨‚ƒåœ•é £ð¨¥‰å¶«ð¤¦ˆæ–¾æ§•å’ð¤ª¥ð£¾ã°‘æœ¶ð¨‚ð¨ƒ´ð¨„®ð¡¾¡ð¨…"
  ],
  [
    "9d40",
    "ð¨†‰ð¨†¯ð¨ˆšð¨Œ†ð¨Œ¯ð¨ŽŠã—Šð¨‘¨ð¨šªä£ºæ¦ð¨¥–ç ˆé‰•ð¨¦¸ä²ð¨§§äŸð¨§¨ð¨­†ð¨¯”å§¸ð¨°‰è¼‹ð¨¿…ð©ƒ¬ç­‘ð©„ð©„¼ã··ð©…žð¤«Šè¿çŠåš‹ð©“§ð©—©ð©–°ð©–¸ð©œ²ð©£‘ð©¥‰ð©¥ªð©§ƒð©¨¨ð©¬Žð©µšð©¶›çºŸð©»¸ð©¼£ä²¤é•‡ðªŠ“ç†¢ðª‹¿ä¶‘é€’ðª—‹ä¶œð ²œè¾¾å—"
  ],
  [
    "9da1",
    "è¾ºð¢’°è¾¹ð¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ð¨¬¬ð§¢ãœºèº€ð¡Ÿµð¨€¤ð¨­¬ð¨®™ð§¨¾ð¦š¯ã·«ð§™•ð£²·ð¥˜µð¥¥–äºšð¥ºð¦‰˜åš¿ð ¹­è¸Žå­­ð£ºˆð¤²žæžæ‹ð¡Ÿ¶ð¡¡»æ”°å˜­ð¥±Šåšð¥Œ‘ã·†ð©¶˜ä±½å˜¢å˜žç½‰ð¥»˜å¥µð£µ€è°ä¸œð ¿ªð µ‰ð£šºè„—éµžè´˜ç˜»é±…ç™Žçž¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ð ºã—Žå˜…å—±æ›±ð¨‹¢ã˜­ç”´å—°å–ºå’—å•²ð ±ð ²–å»ð¥…ˆð ¹¶ð¢±¢"
  ],
  [
    "9e40",
    "ð º¢éº«çµšå—žð¡µæŠé­å’”è³ç‡¶é…¶æ¼æŽ¹æ¾å•©ð¢­ƒé±²ð¢º³å†šã“Ÿð ¶§å†§å‘å”žå”“ç™¦è¸­ð¦¢Šç–±è‚¶è „èž†è£‡è†¶èœð¡ƒä“¬çŒ„ð¤œ†å®èŒ‹ð¦¢“å™»ð¢›´ð§´¯ð¤†£ð§µ³ð¦»ð§Š¶é…°ð¡‡™éˆˆð£³¼ðªš©ð º¬ð »¹ç‰¦ð¡²¢äŽð¤¿‚ð§¿¹ð ¿«äƒº"
  ],
  [
    "9ea1",
    "é±æ”Ÿð¢¶ ä£³ð¤Ÿ ð©µ¼ð ¿¬ð ¸Šæ¢ð§–£ð ¿­"
  ],
  [
    "9ead",
    "ð¦ˆð¡†‡ç†£çºŽéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ð¤˜˜å¢šð¤­®èˆ­å‘‹åžªð¥ª•ð ¥¹"
  ],
  [
    "9ec5",
    "ã©’ð¢‘¥ç´ð©º¬ä´‰é¯­ð£³¾ð©¼°ä±›ð¤¾©ð©–žð©¿žè‘œð£¶¶ð§Š²ð¦ž³ð£œ æŒ®ç´¥ð£»·ð£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ð ’Žç™€å«°ð º¶ç¡ºð§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ðª´éº…ä³¡ç—¹ãŸ»æ„™ð£ƒšð¤²"
  ],
  [
    "9ef5",
    "å™ð¡Š©åž§ð¤¥£ð©¸†åˆ´ð§‚®ã–­æ±Šéµ¼"
  ],
  [
    "9f40",
    "ç±–é¬¹åŸžð¡¬å±“æ““ð©“ð¦Œµð§…¤èš­ð ´¨ð¦´¢ð¤«¢ð µ±"
  ],
  [
    "9f4f",
    "å‡¾ð¡¼å¶Žéœƒð¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ð¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©éž´é¥€éžºåŒ¬æ„°"
  ],
  [
    "9fa1",
    "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ð¡­é§šå‰³"
  ],
  [
    "9fae",
    "é…™éšé…œ"
  ],
  [
    "9fb2",
    "é…‘ð¨º—æ¿ð¦´£æ«Šå˜‘é†Žç•ºæŠ…ð ¼çç±°ð¥°¡ð£³½"
  ],
  [
    "9fc1",
    "ð¤¤™ç›–é®ä¸ªð ³”èŽ¾è¡‚"
  ],
  [
    "9fc9",
    "å±Šæ§€åƒ­åºåˆŸå·µä»Žæ°±ð ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"
  ],
  [
    "9fdb",
    "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"
  ],
  [
    "9fe7",
    "æ¯ºè ˜ç½¸"
  ],
  [
    "9feb",
    "å˜ ðª™Šè¹·é½“"
  ],
  [
    "9ff0",
    "è·”è¹é¸œè¸æŠ‚ð¨½è¸¨è¹µç«“ð¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"
  ],
  [
    "a040",
    "ð¨©šé¼¦æ³ŽèŸ–ç—ƒðªŠ²ç¡“ð¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ð¤ª»è˜¯å¾ºè¢ ä’·"
  ],
  [
    "a055",
    "ð¡ »ð¦¸…"
  ],
  [
    "a058",
    "è©¾ð¢”›"
  ],
  [
    "a05b",
    "æƒ½ç™§é«—éµ„é®é®èŸµ"
  ],
  [
    "a063",
    "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šð¦…™æ…™ä°„éº–æ…½"
  ],
  [
    "a073",
    "åŸæ…¯æŠ¦æˆ¹æ‹Žã©œæ‡¢åŽªð£µæ¤æ ‚ã—’"
  ],
  [
    "a0a1",
    "åµ—ð¨¯‚è¿šð¨¸¹"
  ],
  [
    "a0a6",
    "åƒ™ð¡µ†ç¤†åŒ²é˜¸ð ¼»ä¥"
  ],
  [
    "a0ae",
    "çŸ¾"
  ],
  [
    "a0b0",
    "ç³‚ð¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ð§’†è›ç“°è„ƒçœ¤è¦‰ð¦ŸŒç•“ð¦»‘èž©èŸŽè‡ˆèžŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦"
  ],
  [
    "a0d4",
    "è¦©ç‘¨æ¶¹èŸð¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"
  ],
  [
    "a0e2",
    "ç½±ð¨¬­ç‰æƒ©ä­¾åˆ ã°˜ð£³‡ð¥»—ð§™–ð¥”±ð¡¥„ð¡‹¾ð©¤ƒð¦·œð§‚­å³ð¦†­ð¨¨ð£™·ð ƒ®ð¦¡†ð¤¼Žä•¢å¬Ÿð¦Œé½éº¦ð¦‰«"
  ],
  [
    "a3c0",
    "â€",
    31,
    "â¡"
  ],
  [
    "c6a1",
    "â‘ ",
    9,
    "â‘´",
    9,
    "â…°",
    9,
    "ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©åŽ¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã",
    23
  ],
  [
    "c740",
    "ã™",
    58,
    "ã‚¡ã‚¢ã‚£ã‚¤"
  ],
  [
    "c7a1",
    "ã‚¥",
    81,
    "Ð",
    5,
    "ÐÐ–",
    4
  ],
  [
    "c840",
    "Ð›",
    26,
    "Ñ‘Ð¶",
    25,
    "â‡§â†¸â†¹ã‡ð ƒŒä¹šð ‚Šåˆ‚ä’‘"
  ],
  [
    "c8a1",
    "é¾°å†ˆé¾±ð§˜‡"
  ],
  [
    "c8cd",
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»žâ»£"
  ],
  [
    "c8f5",
    "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"
  ],
  [
    "f9fe",
    "ï¿­"
  ],
  [
    "fa40",
    "ð •‡é‹›ð —Ÿð£¿…è•ŒäŠµç¯å†µã™‰ð¤¥‚ð¨§¤é„ð¡§›è‹®ð£³ˆç ¼æ„æ‹Ÿð¤¤³ð¨¦ªð Š ð¦®³ð¡Œ…ä¾«ð¢“­å€ˆð¦´©ð§ª„ð£˜€ð¤ª±ð¢”“å€©ð ¾å¾¤ð Ž€ð ‡æ»›ð Ÿå½å„ã‘ºå„Žé¡¬ãƒè–ð¤¦¤ð ’‡å… ð£Ž´å…ªð ¯¿ð¢ƒ¼ð ‹¥ð¢”°ð –Žð£ˆ³ð¡¦ƒå®‚è½ð –³ð£²™å†²å†¸"
  ],
  [
    "faa1",
    "é´´å‡‰å‡å‡‘ã³œå‡“ð¤ª¦å†³å‡¢å‚å‡­èæ¤¾ð£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ð¦¬“åŒ…ð¨«žå•‰æ»™ð£¾€ð ¥”ð£¿¬åŒ³å„ð ¯¢æ³‹ð¡œ¦æ ›ç•æŠãºªã£Œð¡›¨ç‡ä’¢å­å´ð¨š«å¾å¿ð¡––ð¡˜“çŸ¦åŽ“ð¨ª›åŽ åŽ«åŽ®çŽ§ð¥²ã½™çŽœåå…æ±‰ä¹‰åŸ¾å™ãª«ð ®å ð£¿«ð¢¶£å¶ð ±·å“ç¹å”«æ™—æµ›å‘­ð¦­“ð µ´å•å’å’¤äž¦ð¡œð »ã¶´ð µ"
  ],
  [
    "fb40",
    "ð¨¦¼ð¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ð¡£—ð¤€ºä•’ð¤µæš³ð¡‚´å˜·æ›ð£ŠŠæš¤æš­å™å™ç£±å›±éž‡å¾åœ€å›¯å›­ð¨­¦ã˜£ð¡‰å†ð¤†¥æ±®ç‚‹å‚ãš±ð¦±¾åŸ¦ð¡–å ƒð¡‘”ð¤£å ¦ð¤¯µå¡œå¢ªã•¡å£ å£œð¡ˆ¼å£»å¯¿åƒðª…ð¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™"
  ],
  [
    "fba1",
    "ð¡˜¾å¨¤å•“ð¡š’è”…å§‰ð µŽð¦²ð¦´ªð¡Ÿœå§™ð¡Ÿ»ð¡ž²ð¦¶¦æµ±ð¡ ¨ð¡›•å§¹ð¦¹…åª«å©£ã›¦ð¤¦©å©·ãœˆåª–ç‘¥å«“ð¦¾¡ð¢•”ã¶…ð¡¤‘ãœ²ð¡š¸åºƒå‹å­¶æ–ˆå­¼ð§¨Žä€„ä¡ð ˆ„å¯•æ… ð¡¨´ð¥§Œð –¥å¯³å®ä´å°…ð¡­„å°“çŽå°”ð¡²¥ð¦¬¨å±‰ä£å²…å³©å³¯å¶‹ð¡·¹ð¡¸·å´å´˜åµ†ð¡º¤å²ºå·—è‹¼ã ­ð¤¤ð¢‰ð¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºð¤’¼ð ³“åŽ¦äº·å»åŽ¨ð¡±å¸‰å»´ð¨’‚"
  ],
  [
    "fc40",
    "å»¹å»»ã¢ å»¼æ ¾é›å¼ð ‡ð¯¢”ã«žä¢®ð¡Œºå¼ºð¦¢ˆð¢å½˜ð¢‘±å½£éž½ð¦¹®å½²é€ð¨¨¶å¾§å¶¶ãµŸð¥‰ð¡½ªð§ƒ¸ð¢™¨é‡–ð Šžð¨¨©æ€±æš…ð¡¡·ã¥£ã·‡ã˜¹åžð¢ž´ç¥±ã¹€æ‚žæ‚¤æ‚³ð¤¦‚ð¤¦ð§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ð¯¢¦ð¦»’æ†å‡´ð ™–æ†‡å®ªð£¾·"
  ],
  [
    "fca1",
    "ð¢¡Ÿæ‡“ð¨®ð©¥æ‡ã¤²ð¢¦€ð¢£æ€£æ…œæ”žæŽ‹ð „˜æ‹…ð¡°æ‹•ð¢¸æ¬ð¤§Ÿã¨—æ¸æ¸ð¡ŽŽð¡Ÿ¼æ’æ¾Šð¢¸¶é ”ð¤‚Œð¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ð¤¨¨ð¤¨£æ–…æ•­æ•Ÿð£¾æ–µð¤¥€ä¬·æ—‘äƒ˜ð¡ ©æ— æ—£å¿Ÿð£€æ˜˜ð£‡·ð£‡¸æ™„ð£†¤ð£†¥æ™‹ð ¹µæ™§ð¥‡¦æ™³æ™´ð¡¸½ð£ˆ±ð¨—´ð£‡ˆð¥Œ“çŸ…ð¢£·é¦¤æœ‚ð¤Žœð¤¨¡ã¬«æ§ºð£Ÿ‚æžæ§æ¢ð¤‡ð©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ð£¦ð¦¶ æ¡"
  ],
  [
    "fd40",
    "ð£‘¯æ§¡æ¨‹ð¨«Ÿæ¥³æ£ƒð£—æ¤æ¤€ã´²ã¨ð£˜¼ã®€æž¬æ¥¡ð¨©Šä‹¼æ¤¶æ¦˜ã®¡ð ‰è£å‚æ§¹ð£™™ð¢„ªæ©…ð£œƒæªã¯³æž±æ«ˆð©†œã°æ¬ð ¤£æƒžæ¬µæ­´ð¢Ÿæºµð£«›ð Žµð¡¥˜ã€å¡ð£­šæ¯¡ð£»¼æ¯œæ°·ð¢’‹ð¤£±ð¦­‘æ±šèˆ¦æ±¹ð£¶¼ä“…ð£¶½ð¤†¤ð¤¤Œð¤¤€"
  ],
  [
    "fda1",
    "ð£³‰ã›¥ã³«ð ´²é®ƒð£‡¹ð¢’‘ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶–æµœæ¹¼æ¼„ð¤¥¿ð¤‚…ð¦¹²è”³ð¦½´å‡‡æ²œæ¸è®ð¨¬¡æ¸¯ð£¸¯ç‘“ð£¾‚ç§Œæ¹åª‘ð£‹æ¿¸ãœæ¾ð£¸°æ»ºð¡’—ð¤€½ä••é°æ½„æ½œãµŽæ½´ð©…°ã´»æ¾Ÿð¤…„æ¿“ð¤‚‘ð¤…•ð¤€¹ð£¿°ð£¾´ð¤„¿å‡Ÿð¤…–ð¤…—ð¤…€ð¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ð¤‰·ç„«ç……åªˆç…Šç…®å²œð¤¥ç…é¢ð¤‹ç„¬ð¤‘šð¤¨§ð¤¨¢ç†ºð¨¯¨ç‚½çˆŽ"
  ],
  [
    "fe40",
    "é‘‚çˆ•å¤‘é‘ƒçˆ¤éð¥˜…çˆ®ç‰€ð¤¥´æ¢½ç‰•ç‰—ã¹•ð£„æ æ¼½çŠ‚çŒªçŒ«ð¤ £ð¨ «ä£­ð¨ „çŒ¨çŒ®ççŽªð °ºð¦¨®ç‰ç‘‰ð¤‡¢ð¡›§ð¤¨¤æ˜£ã›…ð¤¦·ð¤¦ð¤§»ç·ç•æ¤ƒð¤¨¦ç¹ð —ƒã»—ç‘œð¢¢­ç‘ ð¨º²ç‘‡ç¤ç‘¶èŽ¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ð¤ªŒ"
  ],
  [
    "fea1",
    "ð¤…Ÿð¤©¹ð¨®å­†ð¨°ƒð¡¢žç“ˆð¡¦ˆç”Žç“©ç”žð¨»™ð¡©‹å¯—ð¨º¬éŽ…ç•ç•Šç•§ç•®ð¤¾‚ã¼„ð¤´“ç–Žç‘ç–žç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ð¦µçšè‡¯ãŸ¸ð¦¤‘ð¦¤Žçš¡çš¥çš·ç›Œð¦¾Ÿè‘¢ð¥‚ð¥…½ð¡¸œçœžçœ¦ç€æ’¯ð¥ˆ ç˜ð£Š¬çž¯ð¨¥¤ð¨¥¨ð¡›çŸ´ç ‰ð¡¶ð¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ð¥— ç£—ç¤´ç¢±ð§˜Œè¾¸è¢„ð¨¬«ð¦‚ƒð¢˜œç¦†è¤€æ¤‚ç¦€ð¥¡—ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§„¦ãº¨ç§†ð©„ç§”"
  ]
];
var dbcsData$1;
var hasRequiredDbcsData$1;
function requireDbcsData$1() {
  if (hasRequiredDbcsData$1) return dbcsData$1;
  hasRequiredDbcsData$1 = 1;
  dbcsData$1 = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + Â¥ + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$3;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1$1;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$2;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$2.concat(require$$3$2);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$2.concat(require$$3$2);
      },
      gb18030: function() {
        return require$$4$2;
      },
      encodeSkipVals: [128],
      encodeAdd: { "â‚¬": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5$1;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6$1;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6$1.concat(require$$7$1);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData$1;
}
var hasRequiredEncodings$1;
function requireEncodings$1() {
  if (hasRequiredEncodings$1) return encodings$1;
  hasRequiredEncodings$1 = 1;
  (function(exports) {
    var modules = [
      requireInternal$1(),
      requireUtf16$1(),
      requireUtf7$1(),
      requireSbcsCodec$1(),
      requireSbcsData$1(),
      requireSbcsDataGenerated$1(),
      requireDbcsCodec$1(),
      requireDbcsData$1()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module2 = modules[i];
      for (var enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports[enc] = module2[enc];
    }
  })(encodings$1);
  return encodings$1;
}
var streams$1;
var hasRequiredStreams$1;
function requireStreams$1() {
  if (hasRequiredStreams$1) return streams$1;
  hasRequiredStreams$1 = 1;
  var Buffer2 = require$$0$9.Buffer, Transform = require$$1$4.Transform;
  streams$1 = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding3, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding3, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding3, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding3, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length) this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length) this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length) this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length) this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res2 = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res2 += chunk;
    });
    this.on("end", function() {
      cb(null, res2);
    });
    return this;
  };
  return streams$1;
}
var extendNode$1;
var hasRequiredExtendNode$1;
function requireExtendNode$1() {
  if (hasRequiredExtendNode$1) return extendNode$1;
  hasRequiredExtendNode$1 = 1;
  var Buffer2 = require$$0$9.Buffer;
  extendNode$1 = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original) return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        "hex": true,
        "utf8": true,
        "utf-8": true,
        "ascii": true,
        "binary": true,
        "base64": true,
        "ucs2": true,
        "ucs-2": true,
        "utf16le": true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require$$0$9.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined") start = 0;
        if (typeof end == "undefined") end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string2, offset, length, encoding3) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferWrite.call(this, string2, offset, length, encoding3);
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding3);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding3) {
        return Buffer2.isNativeEncoding(encoding3) || iconv.encodingExists(encoding3);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str2, encoding3) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferByteLength.call(this, str2, encoding3);
        return iconv.encode(str2, encoding3).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined") start = 0;
        if (typeof end == "undefined") end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string2, offset, length, encoding3) {
        var _offset = offset, _length = length, _encoding = encoding3;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferWrite.call(this, string2, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding3);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable2 = require$$1$4.Readable;
        original.ReadableSetEncoding = Readable2.prototype.setEncoding;
        Readable2.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable2.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require$$0$9.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable2 = require$$1$4.Readable;
        Readable2.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable2.prototype.collect;
      }
      original = void 0;
    };
  };
  return extendNode$1;
}
var hasRequiredLib$2;
function requireLib$2() {
  if (hasRequiredLib$2) return lib$6.exports;
  hasRequiredLib$2 = 1;
  (function(module2) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling$1(), iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "ï¿½";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str2, encoding3, options) {
      str2 = "" + (str2 || "");
      var encoder = iconv.getEncoder(encoding3, options);
      var res2 = encoder.write(str2);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res2, trail]) : res2;
    };
    iconv.decode = function decode2(buf, encoding3, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding3, options);
      var res2 = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res2 + trail : res2;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding3) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings$1();
      var enc = iconv._canonicalizeEncoding(encoding3);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding3 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding3) {
      return ("" + encoding3).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding3, options) {
      var codec = iconv.getCodec(encoding3), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder2(encoding3, options) {
      var codec = iconv.getCodec(encoding3), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams$1()(iconv);
      }
      requireExtendNode$1()(iconv);
    }
  })(lib$6);
  return lib$6.exports;
}
/*!
 * unpipe
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var unpipe_1 = unpipe$1;
function hasPipeDataListeners(stream3) {
  var listeners = stream3.listeners("data");
  for (var i = 0; i < listeners.length; i++) {
    if (listeners[i].name === "ondata") {
      return true;
    }
  }
  return false;
}
function unpipe$1(stream3) {
  if (!stream3) {
    throw new TypeError("argument stream is required");
  }
  if (typeof stream3.unpipe === "function") {
    stream3.unpipe();
    return;
  }
  if (!hasPipeDataListeners(stream3)) {
    return;
  }
  var listener2;
  var listeners = stream3.listeners("close");
  for (var i = 0; i < listeners.length; i++) {
    listener2 = listeners[i];
    if (listener2.name !== "cleanup" && listener2.name !== "onclose") {
      continue;
    }
    listener2.call(stream3);
  }
}
/*!
 * raw-body
 * Copyright(c) 2013-2014 Jonathan Ong
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var rawBody;
var hasRequiredRawBody;
function requireRawBody() {
  if (hasRequiredRawBody) return rawBody;
  hasRequiredRawBody = 1;
  var asyncHooks2 = tryRequireAsyncHooks2();
  var bytes2 = requireBytes();
  var createError2 = httpErrorsExports;
  var iconv = requireLib$2();
  var unpipe2 = unpipe_1;
  rawBody = getRawBody;
  var ICONV_ENCODING_MESSAGE_REGEXP = /^Encoding not recognized: /;
  function getDecoder2(encoding3) {
    if (!encoding3) return null;
    try {
      return iconv.getDecoder(encoding3);
    } catch (e) {
      if (!ICONV_ENCODING_MESSAGE_REGEXP.test(e.message)) throw e;
      throw createError2(415, "specified encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
  }
  function getRawBody(stream3, options, callback) {
    var done = callback;
    var opts = options || {};
    if (stream3 === void 0) {
      throw new TypeError("argument stream is required");
    } else if (typeof stream3 !== "object" || stream3 === null || typeof stream3.on !== "function") {
      throw new TypeError("argument stream must be a stream");
    }
    if (options === true || typeof options === "string") {
      opts = {
        encoding: options
      };
    }
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    if (done !== void 0 && typeof done !== "function") {
      throw new TypeError("argument callback must be a function");
    }
    if (!done && !commonjsGlobal.Promise) {
      throw new TypeError("argument callback is required");
    }
    var encoding3 = opts.encoding !== true ? opts.encoding : "utf-8";
    var limit = bytes2.parse(opts.limit);
    var length = opts.length != null && !isNaN(opts.length) ? parseInt(opts.length, 10) : null;
    if (done) {
      return readStream2(stream3, encoding3, length, limit, wrap2(done));
    }
    return new Promise(function executor(resolve3, reject) {
      readStream2(stream3, encoding3, length, limit, function onRead(err, buf) {
        if (err) return reject(err);
        resolve3(buf);
      });
    });
  }
  function halt(stream3) {
    unpipe2(stream3);
    if (typeof stream3.pause === "function") {
      stream3.pause();
    }
  }
  function readStream2(stream3, encoding3, length, limit, callback) {
    var complete = false;
    var sync = true;
    if (limit !== null && length !== null && length > limit) {
      return done(createError2(413, "request entity too large", {
        expected: length,
        length,
        limit,
        type: "entity.too.large"
      }));
    }
    var state2 = stream3._readableState;
    if (stream3._decoder || state2 && (state2.encoding || state2.decoder)) {
      return done(createError2(500, "stream encoding should not be set", {
        type: "stream.encoding.set"
      }));
    }
    if (typeof stream3.readable !== "undefined" && !stream3.readable) {
      return done(createError2(500, "stream is not readable", {
        type: "stream.not.readable"
      }));
    }
    var received = 0;
    var decoder;
    try {
      decoder = getDecoder2(encoding3);
    } catch (err) {
      return done(err);
    }
    var buffer = decoder ? "" : [];
    stream3.on("aborted", onAborted);
    stream3.on("close", cleanup);
    stream3.on("data", onData);
    stream3.on("end", onEnd);
    stream3.on("error", onEnd);
    sync = false;
    function done() {
      var args = new Array(arguments.length);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i];
      }
      complete = true;
      if (sync) {
        process.nextTick(invokeCallback);
      } else {
        invokeCallback();
      }
      function invokeCallback() {
        cleanup();
        if (args[0]) {
          halt(stream3);
        }
        callback.apply(null, args);
      }
    }
    function onAborted() {
      if (complete) return;
      done(createError2(400, "request aborted", {
        code: "ECONNABORTED",
        expected: length,
        length,
        received,
        type: "request.aborted"
      }));
    }
    function onData(chunk) {
      if (complete) return;
      received += chunk.length;
      if (limit !== null && received > limit) {
        done(createError2(413, "request entity too large", {
          limit,
          received,
          type: "entity.too.large"
        }));
      } else if (decoder) {
        buffer += decoder.write(chunk);
      } else {
        buffer.push(chunk);
      }
    }
    function onEnd(err) {
      if (complete) return;
      if (err) return done(err);
      if (length !== null && received !== length) {
        done(createError2(400, "request size did not match content length", {
          expected: length,
          length,
          received,
          type: "request.size.invalid"
        }));
      } else {
        var string2 = decoder ? buffer + (decoder.end() || "") : Buffer.concat(buffer);
        done(null, string2);
      }
    }
    function cleanup() {
      buffer = null;
      stream3.removeListener("aborted", onAborted);
      stream3.removeListener("data", onData);
      stream3.removeListener("end", onEnd);
      stream3.removeListener("error", onEnd);
      stream3.removeListener("close", cleanup);
    }
  }
  function tryRequireAsyncHooks2() {
    try {
      return require("async_hooks");
    } catch (e) {
      return {};
    }
  }
  function wrap2(fn) {
    var res2;
    if (asyncHooks2.AsyncResource) {
      res2 = new asyncHooks2.AsyncResource(fn.name || "bound-anonymous-fn");
    }
    if (!res2 || !res2.runInAsyncScope) {
      return fn;
    }
    return res2.runInAsyncScope.bind(res2, fn, null);
  }
  return rawBody;
}
var lib$5 = { exports: {} };
var bomHandling = {};
var hasRequiredBomHandling;
function requireBomHandling() {
  if (hasRequiredBomHandling) return bomHandling;
  hasRequiredBomHandling = 1;
  var BOMChar = "\uFEFF";
  bomHandling.PrependBOM = PrependBOMWrapper;
  function PrependBOMWrapper(encoder, options) {
    this.encoder = encoder;
    this.addBOM = true;
  }
  PrependBOMWrapper.prototype.write = function(str2) {
    if (this.addBOM) {
      str2 = BOMChar + str2;
      this.addBOM = false;
    }
    return this.encoder.write(str2);
  };
  PrependBOMWrapper.prototype.end = function() {
    return this.encoder.end();
  };
  bomHandling.StripBOM = StripBOMWrapper;
  function StripBOMWrapper(decoder, options) {
    this.decoder = decoder;
    this.pass = false;
    this.options = options || {};
  }
  StripBOMWrapper.prototype.write = function(buf) {
    var res2 = this.decoder.write(buf);
    if (this.pass || !res2)
      return res2;
    if (res2[0] === BOMChar) {
      res2 = res2.slice(1);
      if (typeof this.options.stripBOM === "function")
        this.options.stripBOM();
    }
    this.pass = true;
    return res2;
  };
  StripBOMWrapper.prototype.end = function() {
    return this.decoder.end();
  };
  return bomHandling;
}
var encodings = {};
var internal;
var hasRequiredInternal;
function requireInternal() {
  if (hasRequiredInternal) return internal;
  hasRequiredInternal = 1;
  var Buffer2 = requireSafer().Buffer;
  internal = {
    // Encodings
    utf8: { type: "_internal", bomAware: true },
    cesu8: { type: "_internal", bomAware: true },
    unicode11utf8: "utf8",
    ucs2: { type: "_internal", bomAware: true },
    utf16le: "ucs2",
    binary: { type: "_internal" },
    base64: { type: "_internal" },
    hex: { type: "_internal" },
    // Codec.
    _internal: InternalCodec
  };
  function InternalCodec(codecOptions, iconv) {
    this.enc = codecOptions.encodingName;
    this.bomAware = codecOptions.bomAware;
    if (this.enc === "base64")
      this.encoder = InternalEncoderBase64;
    else if (this.enc === "cesu8") {
      this.enc = "utf8";
      this.encoder = InternalEncoderCesu8;
      if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "ðŸ’©") {
        this.decoder = InternalDecoderCesu8;
        this.defaultCharUnicode = iconv.defaultCharUnicode;
      }
    }
  }
  InternalCodec.prototype.encoder = InternalEncoder;
  InternalCodec.prototype.decoder = InternalDecoder;
  var StringDecoder = require$$1$5.StringDecoder;
  if (!StringDecoder.prototype.end)
    StringDecoder.prototype.end = function() {
    };
  function InternalDecoder(options, codec) {
    StringDecoder.call(this, codec.enc);
  }
  InternalDecoder.prototype = StringDecoder.prototype;
  function InternalEncoder(options, codec) {
    this.enc = codec.enc;
  }
  InternalEncoder.prototype.write = function(str2) {
    return Buffer2.from(str2, this.enc);
  };
  InternalEncoder.prototype.end = function() {
  };
  function InternalEncoderBase64(options, codec) {
    this.prevStr = "";
  }
  InternalEncoderBase64.prototype.write = function(str2) {
    str2 = this.prevStr + str2;
    var completeQuads = str2.length - str2.length % 4;
    this.prevStr = str2.slice(completeQuads);
    str2 = str2.slice(0, completeQuads);
    return Buffer2.from(str2, "base64");
  };
  InternalEncoderBase64.prototype.end = function() {
    return Buffer2.from(this.prevStr, "base64");
  };
  function InternalEncoderCesu8(options, codec) {
  }
  InternalEncoderCesu8.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length * 3), bufIdx = 0;
    for (var i = 0; i < str2.length; i++) {
      var charCode = str2.charCodeAt(i);
      if (charCode < 128)
        buf[bufIdx++] = charCode;
      else if (charCode < 2048) {
        buf[bufIdx++] = 192 + (charCode >>> 6);
        buf[bufIdx++] = 128 + (charCode & 63);
      } else {
        buf[bufIdx++] = 224 + (charCode >>> 12);
        buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
        buf[bufIdx++] = 128 + (charCode & 63);
      }
    }
    return buf.slice(0, bufIdx);
  };
  InternalEncoderCesu8.prototype.end = function() {
  };
  function InternalDecoderCesu8(options, codec) {
    this.acc = 0;
    this.contBytes = 0;
    this.accBytes = 0;
    this.defaultCharUnicode = codec.defaultCharUnicode;
  }
  InternalDecoderCesu8.prototype.write = function(buf) {
    var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res2 = "";
    for (var i = 0; i < buf.length; i++) {
      var curByte = buf[i];
      if ((curByte & 192) !== 128) {
        if (contBytes > 0) {
          res2 += this.defaultCharUnicode;
          contBytes = 0;
        }
        if (curByte < 128) {
          res2 += String.fromCharCode(curByte);
        } else if (curByte < 224) {
          acc = curByte & 31;
          contBytes = 1;
          accBytes = 1;
        } else if (curByte < 240) {
          acc = curByte & 15;
          contBytes = 2;
          accBytes = 1;
        } else {
          res2 += this.defaultCharUnicode;
        }
      } else {
        if (contBytes > 0) {
          acc = acc << 6 | curByte & 63;
          contBytes--;
          accBytes++;
          if (contBytes === 0) {
            if (accBytes === 2 && acc < 128 && acc > 0)
              res2 += this.defaultCharUnicode;
            else if (accBytes === 3 && acc < 2048)
              res2 += this.defaultCharUnicode;
            else
              res2 += String.fromCharCode(acc);
          }
        } else {
          res2 += this.defaultCharUnicode;
        }
      }
    }
    this.acc = acc;
    this.contBytes = contBytes;
    this.accBytes = accBytes;
    return res2;
  };
  InternalDecoderCesu8.prototype.end = function() {
    var res2 = 0;
    if (this.contBytes > 0)
      res2 += this.defaultCharUnicode;
    return res2;
  };
  return internal;
}
var utf16 = {};
var hasRequiredUtf16;
function requireUtf16() {
  if (hasRequiredUtf16) return utf16;
  hasRequiredUtf16 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf16.utf16be = Utf16BECodec;
  function Utf16BECodec() {
  }
  Utf16BECodec.prototype.encoder = Utf16BEEncoder;
  Utf16BECodec.prototype.decoder = Utf16BEDecoder;
  Utf16BECodec.prototype.bomAware = true;
  function Utf16BEEncoder() {
  }
  Utf16BEEncoder.prototype.write = function(str2) {
    var buf = Buffer2.from(str2, "ucs2");
    for (var i = 0; i < buf.length; i += 2) {
      var tmp = buf[i];
      buf[i] = buf[i + 1];
      buf[i + 1] = tmp;
    }
    return buf;
  };
  Utf16BEEncoder.prototype.end = function() {
  };
  function Utf16BEDecoder() {
    this.overflowByte = -1;
  }
  Utf16BEDecoder.prototype.write = function(buf) {
    if (buf.length == 0)
      return "";
    var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j2 = 0;
    if (this.overflowByte !== -1) {
      buf2[0] = buf[0];
      buf2[1] = this.overflowByte;
      i = 1;
      j2 = 2;
    }
    for (; i < buf.length - 1; i += 2, j2 += 2) {
      buf2[j2] = buf[i + 1];
      buf2[j2 + 1] = buf[i];
    }
    this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
    return buf2.slice(0, j2).toString("ucs2");
  };
  Utf16BEDecoder.prototype.end = function() {
  };
  utf16.utf16 = Utf16Codec;
  function Utf16Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf16Codec.prototype.encoder = Utf16Encoder;
  Utf16Codec.prototype.decoder = Utf16Decoder;
  function Utf16Encoder(options, codec) {
    options = options || {};
    if (options.addBOM === void 0)
      options.addBOM = true;
    this.encoder = codec.iconv.getEncoder("utf-16le", options);
  }
  Utf16Encoder.prototype.write = function(str2) {
    return this.encoder.write(str2);
  };
  Utf16Encoder.prototype.end = function() {
    return this.encoder.end();
  };
  function Utf16Decoder(options, codec) {
    this.decoder = null;
    this.initialBytes = [];
    this.initialBytesLen = 0;
    this.options = options || {};
    this.iconv = codec.iconv;
  }
  Utf16Decoder.prototype.write = function(buf) {
    if (!this.decoder) {
      this.initialBytes.push(buf);
      this.initialBytesLen += buf.length;
      if (this.initialBytesLen < 16)
        return "";
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      this.initialBytes.length = this.initialBytesLen = 0;
    }
    return this.decoder.write(buf);
  };
  Utf16Decoder.prototype.end = function() {
    if (!this.decoder) {
      var buf = Buffer2.concat(this.initialBytes), encoding3 = detectEncoding(buf, this.options.defaultEncoding);
      this.decoder = this.iconv.getDecoder(encoding3, this.options);
      var res2 = this.decoder.write(buf), trail = this.decoder.end();
      return trail ? res2 + trail : res2;
    }
    return this.decoder.end();
  };
  function detectEncoding(buf, defaultEncoding) {
    var enc = defaultEncoding || "utf-16le";
    if (buf.length >= 2) {
      if (buf[0] == 254 && buf[1] == 255)
        enc = "utf-16be";
      else if (buf[0] == 255 && buf[1] == 254)
        enc = "utf-16le";
      else {
        var asciiCharsLE = 0, asciiCharsBE = 0, _len = Math.min(buf.length - buf.length % 2, 64);
        for (var i = 0; i < _len; i += 2) {
          if (buf[i] === 0 && buf[i + 1] !== 0) asciiCharsBE++;
          if (buf[i] !== 0 && buf[i + 1] === 0) asciiCharsLE++;
        }
        if (asciiCharsBE > asciiCharsLE)
          enc = "utf-16be";
        else if (asciiCharsBE < asciiCharsLE)
          enc = "utf-16le";
      }
    }
    return enc;
  }
  return utf16;
}
var utf7 = {};
var hasRequiredUtf7;
function requireUtf7() {
  if (hasRequiredUtf7) return utf7;
  hasRequiredUtf7 = 1;
  var Buffer2 = requireSafer().Buffer;
  utf7.utf7 = Utf7Codec;
  utf7.unicode11utf7 = "utf7";
  function Utf7Codec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7Codec.prototype.encoder = Utf7Encoder;
  Utf7Codec.prototype.decoder = Utf7Decoder;
  Utf7Codec.prototype.bomAware = true;
  var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
  function Utf7Encoder(options, codec) {
    this.iconv = codec.iconv;
  }
  Utf7Encoder.prototype.write = function(str2) {
    return Buffer2.from(str2.replace(nonDirectChars, (function(chunk) {
      return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
    }).bind(this)));
  };
  Utf7Encoder.prototype.end = function() {
  };
  function Utf7Decoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64Regex = /[A-Za-z0-9\/+]/;
  var base64Chars = [];
  for (var i = 0; i < 256; i++)
    base64Chars[i] = base64Regex.test(String.fromCharCode(i));
  var plusChar = "+".charCodeAt(0), minusChar = "-".charCodeAt(0), andChar = "&".charCodeAt(0);
  Utf7Decoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == plusChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64Chars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "+";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString();
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString();
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7Decoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  utf7.utf7imap = Utf7IMAPCodec;
  function Utf7IMAPCodec(codecOptions, iconv) {
    this.iconv = iconv;
  }
  Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
  Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
  Utf7IMAPCodec.prototype.bomAware = true;
  function Utf7IMAPEncoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = Buffer2.alloc(6);
    this.base64AccumIdx = 0;
  }
  Utf7IMAPEncoder.prototype.write = function(str2) {
    var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str2.length * 5 + 10), bufIdx = 0;
    for (var i2 = 0; i2 < str2.length; i2++) {
      var uChar = str2.charCodeAt(i2);
      if (32 <= uChar && uChar <= 126) {
        if (inBase64) {
          if (base64AccumIdx > 0) {
            bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
            base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          inBase64 = false;
        }
        if (!inBase64) {
          buf[bufIdx++] = uChar;
          if (uChar === andChar)
            buf[bufIdx++] = minusChar;
        }
      } else {
        if (!inBase64) {
          buf[bufIdx++] = andChar;
          inBase64 = true;
        }
        if (inBase64) {
          base64Accum[base64AccumIdx++] = uChar >> 8;
          base64Accum[base64AccumIdx++] = uChar & 255;
          if (base64AccumIdx == base64Accum.length) {
            bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
            base64AccumIdx = 0;
          }
        }
      }
    }
    this.inBase64 = inBase64;
    this.base64AccumIdx = base64AccumIdx;
    return buf.slice(0, bufIdx);
  };
  Utf7IMAPEncoder.prototype.end = function() {
    var buf = Buffer2.alloc(10), bufIdx = 0;
    if (this.inBase64) {
      if (this.base64AccumIdx > 0) {
        bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
        this.base64AccumIdx = 0;
      }
      buf[bufIdx++] = minusChar;
      this.inBase64 = false;
    }
    return buf.slice(0, bufIdx);
  };
  function Utf7IMAPDecoder(options, codec) {
    this.iconv = codec.iconv;
    this.inBase64 = false;
    this.base64Accum = "";
  }
  var base64IMAPChars = base64Chars.slice();
  base64IMAPChars[",".charCodeAt(0)] = true;
  Utf7IMAPDecoder.prototype.write = function(buf) {
    var res2 = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
    for (var i2 = 0; i2 < buf.length; i2++) {
      if (!inBase64) {
        if (buf[i2] == andChar) {
          res2 += this.iconv.decode(buf.slice(lastI, i2), "ascii");
          lastI = i2 + 1;
          inBase64 = true;
        }
      } else {
        if (!base64IMAPChars[buf[i2]]) {
          if (i2 == lastI && buf[i2] == minusChar) {
            res2 += "&";
          } else {
            var b64str = base64Accum + buf.slice(lastI, i2).toString().replace(/,/g, "/");
            res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
          }
          if (buf[i2] != minusChar)
            i2--;
          lastI = i2 + 1;
          inBase64 = false;
          base64Accum = "";
        }
      }
    }
    if (!inBase64) {
      res2 += this.iconv.decode(buf.slice(lastI), "ascii");
    } else {
      var b64str = base64Accum + buf.slice(lastI).toString().replace(/,/g, "/");
      var canBeDecoded = b64str.length - b64str.length % 8;
      base64Accum = b64str.slice(canBeDecoded);
      b64str = b64str.slice(0, canBeDecoded);
      res2 += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
    }
    this.inBase64 = inBase64;
    this.base64Accum = base64Accum;
    return res2;
  };
  Utf7IMAPDecoder.prototype.end = function() {
    var res2 = "";
    if (this.inBase64 && this.base64Accum.length > 0)
      res2 = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
    this.inBase64 = false;
    this.base64Accum = "";
    return res2;
  };
  return utf7;
}
var sbcsCodec = {};
var hasRequiredSbcsCodec;
function requireSbcsCodec() {
  if (hasRequiredSbcsCodec) return sbcsCodec;
  hasRequiredSbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  sbcsCodec._sbcs = SBCSCodec;
  function SBCSCodec(codecOptions, iconv) {
    if (!codecOptions)
      throw new Error("SBCS codec is called without the data.");
    if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
      throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
    if (codecOptions.chars.length === 128) {
      var asciiString = "";
      for (var i = 0; i < 128; i++)
        asciiString += String.fromCharCode(i);
      codecOptions.chars = asciiString + codecOptions.chars;
    }
    this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
    var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
    for (var i = 0; i < codecOptions.chars.length; i++)
      encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
    this.encodeBuf = encodeBuf;
  }
  SBCSCodec.prototype.encoder = SBCSEncoder;
  SBCSCodec.prototype.decoder = SBCSDecoder;
  function SBCSEncoder(options, codec) {
    this.encodeBuf = codec.encodeBuf;
  }
  SBCSEncoder.prototype.write = function(str2) {
    var buf = Buffer2.alloc(str2.length);
    for (var i = 0; i < str2.length; i++)
      buf[i] = this.encodeBuf[str2.charCodeAt(i)];
    return buf;
  };
  SBCSEncoder.prototype.end = function() {
  };
  function SBCSDecoder(options, codec) {
    this.decodeBuf = codec.decodeBuf;
  }
  SBCSDecoder.prototype.write = function(buf) {
    var decodeBuf = this.decodeBuf;
    var newBuf = Buffer2.alloc(buf.length * 2);
    var idx1 = 0, idx2 = 0;
    for (var i = 0; i < buf.length; i++) {
      idx1 = buf[i] * 2;
      idx2 = i * 2;
      newBuf[idx2] = decodeBuf[idx1];
      newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
    }
    return newBuf.toString("ucs2");
  };
  SBCSDecoder.prototype.end = function() {
  };
  return sbcsCodec;
}
var sbcsData;
var hasRequiredSbcsData;
function requireSbcsData() {
  if (hasRequiredSbcsData) return sbcsData;
  hasRequiredSbcsData = 1;
  sbcsData = {
    // Not supported by iconv, not sure why.
    "10029": "maccenteuro",
    "maccenteuro": {
      "type": "_sbcs",
      "chars": "Ã„Ä€ÄÃ‰Ä„Ã–ÃœÃ¡Ä…ÄŒÃ¤ÄÄ†Ä‡Ã©Å¹ÅºÄŽÃ­ÄÄ’Ä“Ä–Ã³Ä—Ã´Ã¶ÃµÃºÄšÄ›Ã¼â€ Â°Ä˜Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Ä™Â¨â‰ Ä£Ä®Ä¯Äªâ‰¤â‰¥Ä«Ä¶âˆ‚âˆ‘Å‚Ä»Ä¼Ä½Ä¾Ä¹ÄºÅ…Å†ÅƒÂ¬âˆšÅ„Å‡âˆ†Â«Â»â€¦Â ÅˆÅÃ•Å‘ÅŒâ€“â€”â€œâ€â€˜â€™Ã·â—ŠÅÅ”Å•Å˜â€¹â€ºÅ™Å–Å—Å â€šâ€žÅ¡ÅšÅ›ÃÅ¤Å¥ÃÅ½Å¾ÅªÃ“Ã”Å«Å®ÃšÅ¯Å°Å±Å²Å³ÃÃ½Ä·Å»ÅÅ¼Ä¢Ë‡"
    },
    "808": "cp808",
    "ibm808": "cp808",
    "cp808": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–â‚¬â– Â "
    },
    "mik": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ””â”´â”¬â”œâ”€â”¼â•£â•‘â•šâ•”â•©â•¦â• â•â•¬â”â–‘â–’â–“â”‚â”¤â„–Â§â•—â•â”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    // Aliases of generated encodings.
    "ascii8bit": "ascii",
    "usascii": "ascii",
    "ansix34": "ascii",
    "ansix341968": "ascii",
    "ansix341986": "ascii",
    "csascii": "ascii",
    "cp367": "ascii",
    "ibm367": "ascii",
    "isoir6": "ascii",
    "iso646us": "ascii",
    "iso646irv": "ascii",
    "us": "ascii",
    "latin1": "iso88591",
    "latin2": "iso88592",
    "latin3": "iso88593",
    "latin4": "iso88594",
    "latin5": "iso88599",
    "latin6": "iso885910",
    "latin7": "iso885913",
    "latin8": "iso885914",
    "latin9": "iso885915",
    "latin10": "iso885916",
    "csisolatin1": "iso88591",
    "csisolatin2": "iso88592",
    "csisolatin3": "iso88593",
    "csisolatin4": "iso88594",
    "csisolatincyrillic": "iso88595",
    "csisolatinarabic": "iso88596",
    "csisolatingreek": "iso88597",
    "csisolatinhebrew": "iso88598",
    "csisolatin5": "iso88599",
    "csisolatin6": "iso885910",
    "l1": "iso88591",
    "l2": "iso88592",
    "l3": "iso88593",
    "l4": "iso88594",
    "l5": "iso88599",
    "l6": "iso885910",
    "l7": "iso885913",
    "l8": "iso885914",
    "l9": "iso885915",
    "l10": "iso885916",
    "isoir14": "iso646jp",
    "isoir57": "iso646cn",
    "isoir100": "iso88591",
    "isoir101": "iso88592",
    "isoir109": "iso88593",
    "isoir110": "iso88594",
    "isoir144": "iso88595",
    "isoir127": "iso88596",
    "isoir126": "iso88597",
    "isoir138": "iso88598",
    "isoir148": "iso88599",
    "isoir157": "iso885910",
    "isoir166": "tis620",
    "isoir179": "iso885913",
    "isoir199": "iso885914",
    "isoir203": "iso885915",
    "isoir226": "iso885916",
    "cp819": "iso88591",
    "ibm819": "iso88591",
    "cyrillic": "iso88595",
    "arabic": "iso88596",
    "arabic8": "iso88596",
    "ecma114": "iso88596",
    "asmo708": "iso88596",
    "greek": "iso88597",
    "greek8": "iso88597",
    "ecma118": "iso88597",
    "elot928": "iso88597",
    "hebrew": "iso88598",
    "hebrew8": "iso88598",
    "turkish": "iso88599",
    "turkish8": "iso88599",
    "thai": "iso885911",
    "thai8": "iso885911",
    "celtic": "iso885914",
    "celtic8": "iso885914",
    "isoceltic": "iso885914",
    "tis6200": "tis620",
    "tis62025291": "tis620",
    "tis62025330": "tis620",
    "10000": "macroman",
    "10006": "macgreek",
    "10007": "maccyrillic",
    "10079": "maciceland",
    "10081": "macturkish",
    "cspc8codepage437": "cp437",
    "cspc775baltic": "cp775",
    "cspc850multilingual": "cp850",
    "cspcp852": "cp852",
    "cspc862latinhebrew": "cp862",
    "cpgr": "cp869",
    "msee": "cp1250",
    "mscyrl": "cp1251",
    "msansi": "cp1252",
    "msgreek": "cp1253",
    "msturk": "cp1254",
    "mshebr": "cp1255",
    "msarab": "cp1256",
    "winbaltrim": "cp1257",
    "cp20866": "koi8r",
    "20866": "koi8r",
    "ibm878": "koi8r",
    "cskoi8r": "koi8r",
    "cp21866": "koi8u",
    "21866": "koi8u",
    "ibm1168": "koi8u",
    "strk10482002": "rk1048",
    "tcvn5712": "tcvn",
    "tcvn57121": "tcvn",
    "gb198880": "iso646cn",
    "cn": "iso646cn",
    "csiso14jisc6220ro": "iso646jp",
    "jisc62201969ro": "iso646jp",
    "jp": "iso646jp",
    "cshproman8": "hproman8",
    "r8": "hproman8",
    "roman8": "hproman8",
    "xroman8": "hproman8",
    "ibm1051": "hproman8",
    "mac": "macintosh",
    "csmacintosh": "macintosh"
  };
  return sbcsData;
}
var sbcsDataGenerated;
var hasRequiredSbcsDataGenerated;
function requireSbcsDataGenerated() {
  if (hasRequiredSbcsDataGenerated) return sbcsDataGenerated;
  hasRequiredSbcsDataGenerated = 1;
  sbcsDataGenerated = {
    "437": "cp437",
    "737": "cp737",
    "775": "cp775",
    "850": "cp850",
    "852": "cp852",
    "855": "cp855",
    "856": "cp856",
    "857": "cp857",
    "858": "cp858",
    "860": "cp860",
    "861": "cp861",
    "862": "cp862",
    "863": "cp863",
    "864": "cp864",
    "865": "cp865",
    "866": "cp866",
    "869": "cp869",
    "874": "windows874",
    "922": "cp922",
    "1046": "cp1046",
    "1124": "cp1124",
    "1125": "cp1125",
    "1129": "cp1129",
    "1133": "cp1133",
    "1161": "cp1161",
    "1162": "cp1162",
    "1163": "cp1163",
    "1250": "windows1250",
    "1251": "windows1251",
    "1252": "windows1252",
    "1253": "windows1253",
    "1254": "windows1254",
    "1255": "windows1255",
    "1256": "windows1256",
    "1257": "windows1257",
    "1258": "windows1258",
    "28591": "iso88591",
    "28592": "iso88592",
    "28593": "iso88593",
    "28594": "iso88594",
    "28595": "iso88595",
    "28596": "iso88596",
    "28597": "iso88597",
    "28598": "iso88598",
    "28599": "iso88599",
    "28600": "iso885910",
    "28601": "iso885911",
    "28603": "iso885913",
    "28604": "iso885914",
    "28605": "iso885915",
    "28606": "iso885916",
    "windows874": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½ï¿½ï¿½ï¿½â€¦ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "win874": "windows874",
    "cp874": "windows874",
    "windows1250": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°Å â€¹ÅšÅ¤Å½Å¹ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Å¡â€ºÅ›Å¥Å¾ÅºÂ Ë‡Ë˜ÅÂ¤Ä„Â¦Â§Â¨Â©ÅžÂ«Â¬Â­Â®Å»Â°Â±Ë›Å‚Â´ÂµÂ¶Â·Â¸Ä…ÅŸÂ»Ä½ËÄ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "win1250": "windows1250",
    "cp1250": "windows1250",
    "windows1251": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÐŒÐ‹ÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÑœÑ›ÑŸÂ ÐŽÑžÐˆÂ¤ÒÂ¦Â§ÐÂ©Ð„Â«Â¬Â­Â®Ð‡Â°Â±Ð†Ñ–Ò‘ÂµÂ¶Â·Ñ‘â„–Ñ”Â»Ñ˜Ð…Ñ•Ñ—ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "win1251": "windows1251",
    "cp1251": "windows1251",
    "windows1252": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½Å½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½Å¾Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "win1252": "windows1252",
    "cp1252": "windows1252",
    "windows1253": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Î…Î†Â£Â¤Â¥Â¦Â§Â¨Â©ï¿½Â«Â¬Â­Â®â€•Â°Â±Â²Â³Î„ÂµÂ¶Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "win1253": "windows1253",
    "cp1253": "windows1253",
    "windows1254": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "win1254": "windows1254",
    "cp1254": "windows1254",
    "windows1255": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹ï¿½ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½Â Â¡Â¢Â£â‚ªÂ¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾Â¿Ö°Ö±Ö²Ö³Ö´ÖµÖ¶Ö·Ö¸Ö¹ÖºÖ»Ö¼Ö½Ö¾Ö¿×€××‚×ƒ×°×±×²×³×´ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "win1255": "windows1255",
    "cp1255": "windows1255",
    "windows1256": {
      "type": "_sbcs",
      "chars": "â‚¬Ù¾â€šÆ’â€žâ€¦â€ â€¡Ë†â€°Ù¹â€¹Å’Ú†Ú˜ÚˆÚ¯â€˜â€™â€œâ€â€¢â€“â€”Ú©â„¢Ú‘â€ºÅ“â€Œâ€ÚºÂ ØŒÂ¢Â£Â¤Â¥Â¦Â§Â¨Â©Ú¾Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ø›Â»Â¼Â½Â¾ØŸÛØ¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ã—Ø·Ø¸Ø¹ØºÙ€ÙÙ‚ÙƒÃ Ù„Ã¢Ù…Ù†Ù‡ÙˆÃ§Ã¨Ã©ÃªÃ«Ù‰ÙŠÃ®Ã¯Ù‹ÙŒÙÙŽÃ´ÙÙÃ·Ù‘Ã¹Ù’Ã»Ã¼â€Žâ€Û’"
    },
    "win1256": "windows1256",
    "cp1256": "windows1256",
    "windows1257": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šï¿½â€žâ€¦â€ â€¡ï¿½â€°ï¿½â€¹ï¿½Â¨Ë‡Â¸ï¿½â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½Â¯Ë›ï¿½Â ï¿½Â¢Â£Â¤ï¿½Â¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³Â´ÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾Ë™"
    },
    "win1257": "windows1257",
    "cp1257": "windows1257",
    "windows1258": {
      "type": "_sbcs",
      "chars": "â‚¬ï¿½â€šÆ’â€žâ€¦â€ â€¡Ë†â€°ï¿½â€¹Å’ï¿½ï¿½ï¿½ï¿½â€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢ï¿½â€ºÅ“ï¿½ï¿½Å¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "win1258": "windows1258",
    "cp1258": "windows1258",
    "iso88591": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28591": "iso88591",
    "iso88592": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ë˜ÅÂ¤Ä½ÅšÂ§Â¨Å ÅžÅ¤Å¹Â­Å½Å»Â°Ä…Ë›Å‚Â´Ä¾Å›Ë‡Â¸Å¡ÅŸÅ¥ÅºËÅ¾Å¼Å”ÃÃ‚Ä‚Ã„Ä¹Ä†Ã‡ÄŒÃ‰Ä˜Ã‹ÄšÃÃŽÄŽÄÅƒÅ‡Ã“Ã”ÅÃ–Ã—Å˜Å®ÃšÅ°ÃœÃÅ¢ÃŸÅ•Ã¡Ã¢ÄƒÃ¤ÄºÄ‡Ã§ÄÃ©Ä™Ã«Ä›Ã­Ã®ÄÄ‘Å„ÅˆÃ³Ã´Å‘Ã¶Ã·Å™Å¯ÃºÅ±Ã¼Ã½Å£Ë™"
    },
    "cp28592": "iso88592",
    "iso88593": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä¦Ë˜Â£Â¤ï¿½Ä¤Â§Â¨Ä°ÅžÄžÄ´Â­ï¿½Å»Â°Ä§Â²Â³Â´ÂµÄ¥Â·Â¸Ä±ÅŸÄŸÄµÂ½ï¿½Å¼Ã€ÃÃ‚ï¿½Ã„ÄŠÄˆÃ‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃï¿½Ã‘Ã’Ã“Ã”Ä Ã–Ã—ÄœÃ™ÃšÃ›ÃœÅ¬ÅœÃŸÃ Ã¡Ã¢ï¿½Ã¤Ä‹Ä‰Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ï¿½Ã±Ã²Ã³Ã´Ä¡Ã¶Ã·ÄÃ¹ÃºÃ»Ã¼Å­ÅË™"
    },
    "cp28593": "iso88593",
    "iso88594": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä¸Å–Â¤Ä¨Ä»Â§Â¨Å Ä’Ä¢Å¦Â­Å½Â¯Â°Ä…Ë›Å—Â´Ä©Ä¼Ë‡Â¸Å¡Ä“Ä£Å§ÅŠÅ¾Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÄªÄÅ…ÅŒÄ¶Ã”Ã•Ã–Ã—Ã˜Å²ÃšÃ›ÃœÅ¨ÅªÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ä«Ä‘Å†ÅÄ·Ã´ÃµÃ¶Ã·Ã¸Å³ÃºÃ»Ã¼Å©Å«Ë™"
    },
    "cp28594": "iso88594",
    "iso88595": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ñ“Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "cp28595": "iso88595",
    "iso88596": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½ï¿½ï¿½Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ØŒÂ­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Ø›ï¿½ï¿½ï¿½ØŸï¿½Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·Ø¸Ø¹Øºï¿½ï¿½ï¿½ï¿½ï¿½Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28596": "iso88596",
    "iso88597": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€˜â€™Â£â‚¬â‚¯Â¦Â§Â¨Â©ÍºÂ«Â¬Â­ï¿½â€•Â°Â±Â²Â³Î„Î…Î†Â·ÎˆÎ‰ÎŠÂ»ÎŒÂ½ÎŽÎÎÎ‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡ï¿½Î£Î¤Î¥Î¦Î§Î¨Î©ÎªÎ«Î¬Î­Î®Î¯Î°Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏ‚ÏƒÏ„Ï…Ï†Ï‡ÏˆÏ‰ÏŠÏ‹ÏŒÏÏŽï¿½"
    },
    "cp28597": "iso88597",
    "iso88598": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Â¢Â£Â¤Â¥Â¦Â§Â¨Â©Ã—Â«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹Ã·Â»Â¼Â½Â¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â€—××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½ï¿½â€Žâ€ï¿½"
    },
    "cp28598": "iso88598",
    "iso88599": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄžÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÄ°ÅžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÄŸÃ±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ä±ÅŸÃ¿"
    },
    "cp28599": "iso88599",
    "iso885910": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä’Ä¢ÄªÄ¨Ä¶Â§Ä»ÄÅ Å¦Å½Â­ÅªÅŠÂ°Ä…Ä“Ä£Ä«Ä©Ä·Â·Ä¼Ä‘Å¡Å§Å¾â€•Å«Å‹Ä€ÃÃ‚ÃƒÃ„Ã…Ã†Ä®ÄŒÃ‰Ä˜Ã‹Ä–ÃÃŽÃÃÅ…ÅŒÃ“Ã”Ã•Ã–Å¨Ã˜Å²ÃšÃ›ÃœÃÃžÃŸÄÃ¡Ã¢Ã£Ã¤Ã¥Ã¦Ä¯ÄÃ©Ä™Ã«Ä—Ã­Ã®Ã¯Ã°Å†ÅÃ³Ã´ÃµÃ¶Å©Ã¸Å³ÃºÃ»Ã¼Ã½Ã¾Ä¸"
    },
    "cp28600": "iso885910",
    "iso885911": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "cp28601": "iso885911",
    "iso885913": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ â€Â¢Â£Â¤â€žÂ¦Â§Ã˜Â©Å–Â«Â¬Â­Â®Ã†Â°Â±Â²Â³â€œÂµÂ¶Â·Ã¸Â¹Å—Â»Â¼Â½Â¾Ã¦Ä„Ä®Ä€Ä†Ã„Ã…Ä˜Ä’ÄŒÃ‰Å¹Ä–Ä¢Ä¶ÄªÄ»Å ÅƒÅ…Ã“ÅŒÃ•Ã–Ã—Å²ÅÅšÅªÃœÅ»Å½ÃŸÄ…Ä¯ÄÄ‡Ã¤Ã¥Ä™Ä“ÄÃ©ÅºÄ—Ä£Ä·Ä«Ä¼Å¡Å„Å†Ã³ÅÃµÃ¶Ã·Å³Å‚Å›Å«Ã¼Å¼Å¾â€™"
    },
    "cp28603": "iso885913",
    "iso885914": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ á¸‚á¸ƒÂ£ÄŠÄ‹á¸ŠÂ§áº€Â©áº‚á¸‹á»²Â­Â®Å¸á¸žá¸ŸÄ Ä¡á¹€á¹Â¶á¹–áºá¹—áºƒá¹ á»³áº„áº…á¹¡Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ´Ã‘Ã’Ã“Ã”Ã•Ã–á¹ªÃ˜Ã™ÃšÃ›ÃœÃÅ¶ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯ÅµÃ±Ã²Ã³Ã´ÃµÃ¶á¹«Ã¸Ã¹ÃºÃ»Ã¼Ã½Å·Ã¿"
    },
    "cp28604": "iso885914",
    "iso885915": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Å Â§Å¡Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å½ÂµÂ¶Â·Å¾Â¹ÂºÂ»Å’Å“Å¸Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÃÃ‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÃžÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "cp28605": "iso885915",
    "iso885916": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ä„Ä…Åâ‚¬â€žÅ Â§Å¡Â©È˜Â«Å¹Â­ÅºÅ»Â°Â±ÄŒÅ‚Å½â€Â¶Â·Å¾ÄÈ™Â»Å’Å“Å¸Å¼Ã€ÃÃ‚Ä‚Ã„Ä†Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÄÅƒÃ’Ã“Ã”ÅÃ–ÅšÅ°Ã™ÃšÃ›ÃœÄ˜ÈšÃŸÃ Ã¡Ã¢ÄƒÃ¤Ä‡Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ä‘Å„Ã²Ã³Ã´Å‘Ã¶Å›Å±Ã¹ÃºÃ»Ã¼Ä™È›Ã¿"
    },
    "cp28606": "iso885916",
    "cp437": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm437": "cp437",
    "csibm437": "cp437",
    "cp737": {
      "type": "_sbcs",
      "chars": "Î‘Î’Î“Î”Î•Î–Î—Î˜Î™ÎšÎ›ÎœÎÎžÎŸÎ Î¡Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³Î´ÎµÎ¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Ï…Ï†Ï‡Ïˆâ–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ï‰Î¬Î­Î®ÏŠÎ¯ÏŒÏÏ‹ÏŽÎ†ÎˆÎ‰ÎŠÎŒÎŽÎÂ±â‰¥â‰¤ÎªÎ«Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm737": "cp737",
    "csibm737": "cp737",
    "cp775": {
      "type": "_sbcs",
      "chars": "Ä†Ã¼Ã©ÄÃ¤Ä£Ã¥Ä‡Å‚Ä“Å–Å—Ä«Å¹Ã„Ã…Ã‰Ã¦Ã†ÅÃ¶Ä¢Â¢ÅšÅ›Ã–ÃœÃ¸Â£Ã˜Ã—Â¤Ä€ÄªÃ³Å»Å¼Åºâ€Â¦Â©Â®Â¬Â½Â¼ÅÂ«Â»â–‘â–’â–“â”‚â”¤Ä„ÄŒÄ˜Ä–â•£â•‘â•—â•Ä®Å â”â””â”´â”¬â”œâ”€â”¼Å²Åªâ•šâ•”â•©â•¦â• â•â•¬Å½Ä…ÄÄ™Ä—Ä¯Å¡Å³Å«Å¾â”˜â”Œâ–ˆâ–„â–Œâ–â–€Ã“ÃŸÅŒÅƒÃµÃ•ÂµÅ„Ä¶Ä·Ä»Ä¼Å†Ä’Å…â€™Â­Â±â€œÂ¾Â¶Â§Ã·â€žÂ°âˆ™Â·Â¹Â³Â²â– Â "
    },
    "ibm775": "cp775",
    "csibm775": "cp775",
    "cp850": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹ÃˆÄ±ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm850": "cp850",
    "csibm850": "cp850",
    "cp852": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Å¯Ä‡Ã§Å‚Ã«ÅÅ‘Ã®Å¹Ã„Ä†Ã‰Ä¹ÄºÃ´Ã¶Ä½Ä¾ÅšÅ›Ã–ÃœÅ¤Å¥ÅÃ—ÄÃ¡Ã­Ã³ÃºÄ„Ä…Å½Å¾Ä˜Ä™Â¬ÅºÄŒÅŸÂ«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚ÄšÅžâ•£â•‘â•—â•Å»Å¼â”â””â”´â”¬â”œâ”€â”¼Ä‚Äƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ä‘ÄÄŽÃ‹ÄÅ‡ÃÃŽÄ›â”˜â”Œâ–ˆâ–„Å¢Å®â–€Ã“ÃŸÃ”ÅƒÅ„ÅˆÅ Å¡Å”ÃšÅ•Å°Ã½ÃÅ£Â´Â­ËË›Ë‡Ë˜Â§Ã·Â¸Â°Â¨Ë™Å±Å˜Å™â– Â "
    },
    "ibm852": "cp852",
    "csibm852": "cp852",
    "cp855": {
      "type": "_sbcs",
      "chars": "Ñ’Ð‚Ñ“ÐƒÑ‘ÐÑ”Ð„Ñ•Ð…Ñ–Ð†Ñ—Ð‡Ñ˜ÐˆÑ™Ð‰ÑšÐŠÑ›Ð‹ÑœÐŒÑžÐŽÑŸÐÑŽÐ®ÑŠÐªÐ°ÐÐ±Ð‘Ñ†Ð¦Ð´Ð”ÐµÐ•Ñ„Ð¤Ð³Ð“Â«Â»â–‘â–’â–“â”‚â”¤Ñ…Ð¥Ð¸Ð˜â•£â•‘â•—â•Ð¹Ð™â”â””â”´â”¬â”œâ”€â”¼ÐºÐšâ•šâ•”â•©â•¦â• â•â•¬Â¤Ð»Ð›Ð¼ÐœÐ½ÐÐ¾ÐžÐ¿â”˜â”Œâ–ˆâ–„ÐŸÑâ–€Ð¯Ñ€Ð ÑÐ¡Ñ‚Ð¢ÑƒÐ£Ð¶Ð–Ð²Ð’ÑŒÐ¬â„–Â­Ñ‹Ð«Ð·Ð—ÑˆÐ¨ÑÐ­Ñ‰Ð©Ñ‡Ð§Â§â– Â "
    },
    "ibm855": "cp855",
    "csibm855": "cp855",
    "cp856": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªï¿½Â£ï¿½Ã—ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â®Â¬Â½Â¼ï¿½Â«Â»â–‘â–’â–“â”‚â”¤ï¿½ï¿½ï¿½Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼ï¿½ï¿½â•šâ•”â•©â•¦â• â•â•¬Â¤ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½â”˜â”Œâ–ˆâ–„Â¦ï¿½â–€ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Âµï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Â¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm856": "cp856",
    "csibm856": "cp856",
    "cp857": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ä±Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ä°Ã–ÃœÃ¸Â£Ã˜ÅžÅŸÃ¡Ã­Ã³ÃºÃ±Ã‘ÄžÄŸÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤ÂºÂªÃŠÃ‹Ãˆï¿½ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•Âµï¿½Ã—ÃšÃ›Ã™Ã¬Ã¿Â¯Â´Â­Â±ï¿½Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm857": "cp857",
    "csibm857": "cp857",
    "cp858": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜Ã—Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Â®Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤ÃÃ‚Ã€Â©â•£â•‘â•—â•Â¢Â¥â”â””â”´â”¬â”œâ”€â”¼Ã£Ãƒâ•šâ•”â•©â•¦â• â•â•¬Â¤Ã°ÃÃŠÃ‹Ãˆâ‚¬ÃÃŽÃâ”˜â”Œâ–ˆâ–„Â¦ÃŒâ–€Ã“ÃŸÃ”Ã’ÃµÃ•ÂµÃ¾ÃžÃšÃ›Ã™Ã½ÃÂ¯Â´Â­Â±â€—Â¾Â¶Â§Ã·Â¸Â°Â¨Â·Â¹Â³Â²â– Â "
    },
    "ibm858": "cp858",
    "csibm858": "cp858",
    "cp860": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã£Ã ÃÃ§ÃªÃŠÃ¨ÃÃ”Ã¬ÃƒÃ‚Ã‰Ã€ÃˆÃ´ÃµÃ²ÃšÃ¹ÃŒÃ•ÃœÂ¢Â£Ã™â‚§Ã“Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿Ã’Â¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm860": "cp860",
    "csibm860": "cp860",
    "cp861": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨ÃÃ°ÃžÃ„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã¾Ã»ÃÃ½Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃÃÃ“ÃšÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm861": "cp861",
    "csibm861": "cp861",
    "cp862": {
      "type": "_sbcs",
      "chars": "××‘×’×“×”×•×–×—×˜×™×š×›×œ××ž×Ÿ× ×¡×¢×£×¤×¥×¦×§×¨×©×ªÂ¢Â£Â¥â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm862": "cp862",
    "csibm862": "cp862",
    "cp863": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã‚Ã Â¶Ã§ÃªÃ«Ã¨Ã¯Ã®â€—Ã€Â§Ã‰ÃˆÃŠÃ´Ã‹ÃÃ»Ã¹Â¤Ã”ÃœÂ¢Â£Ã™Ã›Æ’Â¦Â´Ã³ÃºÂ¨Â¸Â³Â¯ÃŽâŒÂ¬Â½Â¼Â¾Â«Â»â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm863": "cp863",
    "csibm863": "cp863",
    "cp864": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$Ùª&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Â°Â·âˆ™âˆšâ–’â”€â”‚â”¼â”¤â”¬â”œâ”´â”â”Œâ””â”˜Î²âˆžÏ†Â±Â½Â¼â‰ˆÂ«Â»ï»·ï»¸ï¿½ï¿½ï»»ï»¼ï¿½Â Â­ïº‚Â£Â¤ïº„ï¿½ï¿½ïºŽïºïº•ïº™ØŒïºïº¡ïº¥Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ï»‘Ø›ïº±ïºµïº¹ØŸÂ¢ïº€ïºïºƒïº…ï»Šïº‹ïºïº‘ïº“ïº—ïº›ïºŸïº£ïº§ïº©ïº«ïº­ïº¯ïº³ïº·ïº»ïº¿ï»ï»…ï»‹ï»Â¦Â¬Ã·Ã—ï»‰Ù€ï»“ï»—ï»›ï»Ÿï»£ï»§ï»«ï»­ï»¯ï»³ïº½ï»Œï»Žï»ï»¡ï¹½Ù‘ï»¥ï»©ï»¬ï»°ï»²ï»ï»•ï»µï»¶ï»ï»™ï»±â– ï¿½"
    },
    "ibm864": "cp864",
    "csibm864": "cp864",
    "cp865": {
      "type": "_sbcs",
      "chars": "Ã‡Ã¼Ã©Ã¢Ã¤Ã Ã¥Ã§ÃªÃ«Ã¨Ã¯Ã®Ã¬Ã„Ã…Ã‰Ã¦Ã†Ã´Ã¶Ã²Ã»Ã¹Ã¿Ã–ÃœÃ¸Â£Ã˜â‚§Æ’Ã¡Ã­Ã³ÃºÃ±Ã‘ÂªÂºÂ¿âŒÂ¬Â½Â¼Â¡Â«Â¤â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Î±ÃŸÎ“Ï€Î£ÏƒÂµÏ„Î¦Î˜Î©Î´âˆžÏ†Îµâˆ©â‰¡Â±â‰¥â‰¤âŒ âŒ¡Ã·â‰ˆÂ°âˆ™Â·âˆšâ¿Â²â– Â "
    },
    "ibm865": "cp865",
    "csibm865": "cp865",
    "cp866": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘Ð„Ñ”Ð‡Ñ—ÐŽÑžÂ°âˆ™Â·âˆšâ„–Â¤â– Â "
    },
    "ibm866": "cp866",
    "csibm866": "cp866",
    "cp869": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½Î†ï¿½Â·Â¬Â¦â€˜â€™Îˆâ€•Î‰ÎŠÎªÎŒï¿½ï¿½ÎŽÎ«Â©ÎÂ²Â³Î¬Â£Î­Î®Î¯ÏŠÎÏŒÏÎ‘Î’Î“Î”Î•Î–Î—Â½Î˜Î™Â«Â»â–‘â–’â–“â”‚â”¤ÎšÎ›ÎœÎâ•£â•‘â•—â•ÎžÎŸâ”â””â”´â”¬â”œâ”€â”¼Î Î¡â•šâ•”â•©â•¦â• â•â•¬Î£Î¤Î¥Î¦Î§Î¨Î©Î±Î²Î³â”˜â”Œâ–ˆâ–„Î´Îµâ–€Î¶Î·Î¸Î¹ÎºÎ»Î¼Î½Î¾Î¿Ï€ÏÏƒÏ‚Ï„Î„Â­Â±Ï…Ï†Ï‡Â§ÏˆÎ…Â°Â¨Ï‰Ï‹Î°ÏŽâ– Â "
    },
    "ibm869": "cp869",
    "csibm869": "cp869",
    "cp922": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®â€¾Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚ÃƒÃ„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹ÃŒÃÃŽÃÅ Ã‘Ã’Ã“Ã”Ã•Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÃÅ½ÃŸÃ Ã¡Ã¢Ã£Ã¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Å¡Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Å¾Ã¿"
    },
    "ibm922": "cp922",
    "csibm922": "cp922",
    "cp1046": {
      "type": "_sbcs",
      "chars": "ïºˆÃ—Ã·ï£¶ï£µï£´ï£·ï¹±Âˆâ– â”‚â”€â”â”Œâ””â”˜ï¹¹ï¹»ï¹½ï¹¿ï¹·ïºŠï»°ï»³ï»²ï»Žï»ï»ï»¶ï»¸ï»ºï»¼Â ï£ºï£¹ï£¸Â¤ï£»ïº‹ïº‘ïº—ïº›ïºŸïº£ØŒÂ­ïº§ïº³Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©ïº·Ø›ïº»ïº¿ï»ŠØŸï»‹Ø¡Ø¢Ø£Ø¤Ø¥Ø¦Ø§Ø¨Ø©ØªØ«Ø¬Ø­Ø®Ø¯Ø°Ø±Ø²Ø³Ø´ØµØ¶Ø·ï»‡Ø¹Øºï»Œïº‚ïº„ïºŽï»“Ù€ÙÙ‚ÙƒÙ„Ù…Ù†Ù‡ÙˆÙ‰ÙŠÙ‹ÙŒÙÙŽÙÙÙ‘Ù’ï»—ï»›ï»Ÿï£¼ï»µï»·ï»¹ï»»ï»£ï»§ï»¬ï»©ï¿½"
    },
    "ibm1046": "cp1046",
    "csibm1046": "cp1046",
    "cp1124": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ÐÐ‚ÒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÂ­ÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑâ„–Ñ‘Ñ’Ò‘Ñ”Ñ•Ñ–Ñ—Ñ˜Ñ™ÑšÑ›ÑœÂ§ÑžÑŸ"
    },
    "ibm1124": "cp1124",
    "csibm1124": "cp1124",
    "cp1125": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿â–‘â–’â–“â”‚â”¤â•¡â•¢â•–â••â•£â•‘â•—â•â•œâ•›â”â””â”´â”¬â”œâ”€â”¼â•žâ•Ÿâ•šâ•”â•©â•¦â• â•â•¬â•§â•¨â•¤â•¥â•™â•˜â•’â•“â•«â•ªâ”˜â”Œâ–ˆâ–„â–Œâ–â–€Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑÐÑ‘ÒÒ‘Ð„Ñ”Ð†Ñ–Ð‡Ñ—Â·âˆšâ„–Â¤â– Â "
    },
    "ibm1125": "cp1125",
    "csibm1125": "cp1125",
    "cp1129": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£Â¤Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1129": "cp1129",
    "csibm1129": "cp1129",
    "cp1133": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ àºàº‚àº„àº‡àºˆàºªàºŠàºàº”àº•àº–àº—àº™àºšàº›àºœàºàºžàºŸàº¡àº¢àº£àº¥àº§àº«àº­àº®ï¿½ï¿½ï¿½àº¯àº°àº²àº³àº´àºµàº¶àº·àº¸àº¹àº¼àº±àº»àº½ï¿½ï¿½ï¿½à»€à»à»‚à»ƒà»„à»ˆà»‰à»Šà»‹à»Œà»à»†ï¿½à»œà»â‚­ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à»à»‘à»’à»“à»”à»•à»–à»—à»˜à»™ï¿½ï¿½Â¢Â¬Â¦ï¿½"
    },
    "ibm1133": "cp1133",
    "csibm1133": "cp1133",
    "cp1161": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¹ˆà¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºà¹‰à¹Šà¹‹â‚¬à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›Â¢Â¬Â¦Â "
    },
    "ibm1161": "cp1161",
    "csibm1161": "cp1161",
    "cp1162": {
      "type": "_sbcs",
      "chars": "â‚¬ÂÂ‚ÂƒÂ„â€¦Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    },
    "ibm1162": "cp1162",
    "csibm1162": "cp1162",
    "cp1163": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Â¡Â¢Â£â‚¬Â¥Â¦Â§Å“Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Å¸ÂµÂ¶Â·Å’Â¹ÂºÂ»Â¼Â½Â¾Â¿Ã€ÃÃ‚Ä‚Ã„Ã…Ã†Ã‡ÃˆÃ‰ÃŠÃ‹Ì€ÃÃŽÃÄÃ‘Ì‰Ã“Ã”Æ Ã–Ã—Ã˜Ã™ÃšÃ›ÃœÆ¯ÌƒÃŸÃ Ã¡Ã¢ÄƒÃ¤Ã¥Ã¦Ã§Ã¨Ã©ÃªÃ«ÌÃ­Ã®Ã¯Ä‘Ã±Ì£Ã³Ã´Æ¡Ã¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Æ°â‚«Ã¿"
    },
    "ibm1163": "cp1163",
    "csibm1163": "cp1163",
    "maccroatian": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Å â„¢Â´Â¨â‰ Å½Ã˜âˆžÂ±â‰¤â‰¥âˆ†Âµâˆ‚âˆ‘âˆÅ¡âˆ«ÂªÂºâ„¦Å¾Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆÄ†Â«ÄŒâ€¦Â Ã€ÃƒÃ•Å’Å“Äâ€”â€œâ€â€˜â€™Ã·â—Šï¿½Â©â„Â¤â€¹â€ºÃ†Â»â€“Â·â€šâ€žâ€°Ã‚Ä‡ÃÄÃˆÃÃŽÃÃŒÃ“Ã”Ä‘Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ï€Ã‹ËšÂ¸ÃŠÃ¦Ë‡"
    },
    "maccyrillic": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°Â¢Â£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–Âµâˆ‚ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "macgreek": {
      "type": "_sbcs",
      "chars": "Ã„Â¹Â²Ã‰Â³Ã–ÃœÎ…Ã Ã¢Ã¤Î„Â¨Ã§Ã©Ã¨ÃªÃ«Â£â„¢Ã®Ã¯â€¢Â½â€°Ã´Ã¶Â¦Â­Ã¹Ã»Ã¼â€ Î“Î”Î˜Î›ÎžÎ ÃŸÂ®Â©Î£ÎªÂ§â‰ Â°Î‡Î‘Â±â‰¤â‰¥Â¥Î’Î•Î–Î—Î™ÎšÎœÎ¦Î«Î¨Î©Î¬ÎÂ¬ÎŸÎ¡â‰ˆÎ¤Â«Â»â€¦Â Î¥Î§Î†ÎˆÅ“â€“â€•â€œâ€â€˜â€™Ã·Î‰ÎŠÎŒÎŽÎ­Î®Î¯ÏŒÎÏÎ±Î²ÏˆÎ´ÎµÏ†Î³Î·Î¹Î¾ÎºÎ»Î¼Î½Î¿Ï€ÏŽÏÏƒÏ„Î¸Ï‰Ï‚Ï‡Ï…Î¶ÏŠÏ‹ÎÎ°ï¿½"
    },
    "maciceland": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼ÃÂ°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤ÃÃ°ÃžÃ¾Ã½Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macroman": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macromania": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ä‚ÅžâˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦ÄƒÅŸÂ¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºÅ¢Å£â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macthai": {
      "type": "_sbcs",
      "chars": "Â«Â»â€¦ï¢Œï¢ï¢’ï¢•ï¢˜ï¢‹ï¢Žï¢‘ï¢”ï¢—â€œâ€ï¢™ï¿½â€¢ï¢„ï¢‰ï¢…ï¢†ï¢‡ï¢ˆï¢Šï¢ï¢ï¢“ï¢–â€˜â€™ï¿½Â à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸º\uFEFFâ€‹â€“â€”à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹â„¢à¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™Â®Â©ï¿½ï¿½ï¿½ï¿½"
    },
    "macturkish": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸ÄžÄŸÄ°Ä±ÅžÅŸâ€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™ï¿½Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "macukraine": {
      "type": "_sbcs",
      "chars": "ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯â€ Â°ÒÂ£Â§â€¢Â¶Ð†Â®Â©â„¢Ð‚Ñ’â‰ ÐƒÑ“âˆžÂ±â‰¤â‰¥Ñ–ÂµÒ‘ÐˆÐ„Ñ”Ð‡Ñ—Ð‰Ñ™ÐŠÑšÑ˜Ð…Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ð‹Ñ›ÐŒÑœÑ•â€“â€”â€œâ€â€˜â€™Ã·â€žÐŽÑžÐÑŸâ„–ÐÑ‘ÑÐ°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÂ¤"
    },
    "koi8r": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘â•“â•”â••â•–â•—â•˜â•™â•šâ•›â•œâ•â•žâ•Ÿâ• â•¡Ðâ•¢â•£â•¤â•¥â•¦â•§â•¨â•©â•ªâ•«â•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8u": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘â•â•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒâ•¬Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8ru": {
      "type": "_sbcs",
      "chars": "â”€â”‚â”Œâ”â””â”˜â”œâ”¤â”¬â”´â”¼â–€â–„â–ˆâ–Œâ–â–‘â–’â–“âŒ â– âˆ™âˆšâ‰ˆâ‰¤â‰¥Â âŒ¡Â°Â²Â·Ã·â•â•‘â•’Ñ‘Ñ”â•”Ñ–Ñ—â•—â•˜â•™â•šâ•›Ò‘Ñžâ•žâ•Ÿâ• â•¡ÐÐ„â•£Ð†Ð‡â•¦â•§â•¨â•©â•ªÒÐŽÂ©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "koi8t": {
      "type": "_sbcs",
      "chars": "Ò›Ò“â€šÒ’â€žâ€¦â€ â€¡ï¿½â€°Ò³â€¹Ò²Ò·Ò¶ï¿½Òšâ€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢ï¿½â€ºï¿½ï¿½ï¿½ï¿½ï¿½Ó¯Ó®Ñ‘Â¤Ó£Â¦Â§ï¿½ï¿½ï¿½Â«Â¬Â­Â®ï¿½Â°Â±Â²Ðï¿½Ó¢Â¶Â·ï¿½â„–ï¿½Â»ï¿½ï¿½ï¿½Â©ÑŽÐ°Ð±Ñ†Ð´ÐµÑ„Ð³Ñ…Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿ÑÑ€ÑÑ‚ÑƒÐ¶Ð²ÑŒÑ‹Ð·ÑˆÑÑ‰Ñ‡ÑŠÐ®ÐÐ‘Ð¦Ð”Ð•Ð¤Ð“Ð¥Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ¯Ð Ð¡Ð¢Ð£Ð–Ð’Ð¬Ð«Ð—Ð¨Ð­Ð©Ð§Ðª"
    },
    "armscii8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ ï¿½Ö‡Ö‰)(Â»Â«â€”.Õ,-ÖŠâ€¦ÕœÕ›ÕžÔ±Õ¡Ô²Õ¢Ô³Õ£Ô´Õ¤ÔµÕ¥Ô¶Õ¦Ô·Õ§Ô¸Õ¨Ô¹Õ©ÔºÕªÔ»Õ«Ô¼Õ¬Ô½Õ­Ô¾Õ®Ô¿Õ¯Õ€Õ°ÕÕ±Õ‚Õ²ÕƒÕ³Õ„Õ´Õ…ÕµÕ†Õ¶Õ‡Õ·ÕˆÕ¸Õ‰Õ¹ÕŠÕºÕ‹Õ»ÕŒÕ¼ÕÕ½ÕŽÕ¾ÕÕ¿ÕÖ€Õ‘ÖÕ’Ö‚Õ“ÖƒÕ”Ö„Õ•Ö…Õ–Ö†Õšï¿½"
    },
    "rk1048": {
      "type": "_sbcs",
      "chars": "Ð‚Ðƒâ€šÑ“â€žâ€¦â€ â€¡â‚¬â€°Ð‰â€¹ÐŠÒšÒºÐÑ’â€˜â€™â€œâ€â€¢â€“â€”ï¿½â„¢Ñ™â€ºÑšÒ›Ò»ÑŸÂ Ò°Ò±Ó˜Â¤Ó¨Â¦Â§ÐÂ©Ò’Â«Â¬Â­Â®Ò®Â°Â±Ð†Ñ–Ó©ÂµÂ¶Â·Ñ‘â„–Ò“Â»Ó™Ò¢Ò£Ò¯ÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "tcvn": {
      "type": "_sbcs",
      "chars": "\0Ãšá»¤á»ªá»¬á»®\x07\b	\n\v\f\rá»¨á»°á»²á»¶á»¸Ãá»´\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~Ã€áº¢ÃƒÃáº áº¶áº¬Ãˆáººáº¼Ã‰áº¸á»†ÃŒá»ˆÄ¨Ãá»ŠÃ’á»ŽÃ•Ã“á»Œá»˜á»œá»žá» á»šá»¢Ã™á»¦Å¨Â Ä‚Ã‚ÃŠÃ”Æ Æ¯ÄÄƒÃ¢ÃªÃ´Æ¡Æ°Ä‘áº°Ì€Ì‰ÌƒÌÌ£Ã áº£Ã£Ã¡áº¡áº²áº±áº³áºµáº¯áº´áº®áº¦áº¨áºªáº¤á»€áº·áº§áº©áº«áº¥áº­Ã¨á»‚áº»áº½Ã©áº¹á»á»ƒá»…áº¿á»‡Ã¬á»‰á»„áº¾á»’Ä©Ã­á»‹Ã²á»”á»ÃµÃ³á»á»“á»•á»—á»‘á»™á»á»Ÿá»¡á»›á»£Ã¹á»–á»§Å©Ãºá»¥á»«á»­á»¯á»©á»±á»³á»·á»¹Ã½á»µá»"
    },
    "georgianacademy": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ¯áƒ°áƒ±áƒ²áƒ³áƒ´áƒµáƒ¶Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "georgianps": {
      "type": "_sbcs",
      "chars": "Â€Ââ€šÆ’â€žâ€¦â€ â€¡Ë†â€°Å â€¹Å’ÂÂŽÂÂâ€˜â€™â€œâ€â€¢â€“â€”Ëœâ„¢Å¡â€ºÅ“ÂÂžÅ¸Â Â¡Â¢Â£Â¤Â¥Â¦Â§Â¨Â©ÂªÂ«Â¬Â­Â®Â¯Â°Â±Â²Â³Â´ÂµÂ¶Â·Â¸Â¹ÂºÂ»Â¼Â½Â¾Â¿áƒáƒ‘áƒ’áƒ“áƒ”áƒ•áƒ–áƒ±áƒ—áƒ˜áƒ™áƒšáƒ›áƒœáƒ²áƒáƒžáƒŸáƒ áƒ¡áƒ¢áƒ³áƒ£áƒ¤áƒ¥áƒ¦áƒ§áƒ¨áƒ©áƒªáƒ«áƒ¬áƒ­áƒ®áƒ´áƒ¯áƒ°áƒµÃ¦Ã§Ã¨Ã©ÃªÃ«Ã¬Ã­Ã®Ã¯Ã°Ã±Ã²Ã³Ã´ÃµÃ¶Ã·Ã¸Ã¹ÃºÃ»Ã¼Ã½Ã¾Ã¿"
    },
    "pt154": {
      "type": "_sbcs",
      "chars": "Ò–Ò’Ó®Ò“â€žâ€¦Ò¶Ò®Ò²Ò¯Ò Ó¢Ò¢ÒšÒºÒ¸Ò—â€˜â€™â€œâ€â€¢â€“â€”Ò³Ò·Ò¡Ó£Ò£Ò›Ò»Ò¹Â ÐŽÑžÐˆÓ¨Ò˜Ò°Â§ÐÂ©Ó˜Â«Â¬Ó¯Â®ÒœÂ°Ò±Ð†Ñ–Ò™Ó©Â¶Â·Ñ‘â„–Ó™Â»Ñ˜ÒªÒ«ÒÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ"
    },
    "viscii": {
      "type": "_sbcs",
      "chars": "\0áº²áº´áºª\x07\b	\n\v\f\rá»¶á»¸\x1Bá»´ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~áº áº®áº°áº¶áº¤áº¦áº¨áº¬áº¼áº¸áº¾á»€á»‚á»„á»†á»á»’á»”á»–á»˜á»¢á»šá»œá»žá»Šá»Žá»Œá»ˆá»¦Å¨á»¤á»²Ã•áº¯áº±áº·áº¥áº§áº©áº­áº½áº¹áº¿á»á»ƒá»…á»‡á»‘á»“á»•á»—á» Æ á»™á»á»Ÿá»‹á»°á»¨á»ªá»¬Æ¡á»›Æ¯Ã€ÃÃ‚Ãƒáº¢Ä‚áº³áºµÃˆÃ‰ÃŠáººÃŒÃÄ¨á»³Äá»©Ã’Ã“Ã”áº¡á»·á»«á»­Ã™Ãšá»¹á»µÃá»¡Æ°Ã Ã¡Ã¢Ã£áº£Äƒá»¯áº«Ã¨Ã©Ãªáº»Ã¬Ã­Ä©á»‰Ä‘á»±Ã²Ã³Ã´Ãµá»á»á»¥Ã¹ÃºÅ©á»§Ã½á»£á»®"
    },
    "iso646cn": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#Â¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "iso646jp": {
      "type": "_sbcs",
      "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[Â¥]^_`abcdefghijklmnopqrstuvwxyz{|}â€¾ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "hproman8": {
      "type": "_sbcs",
      "chars": "Â€ÂÂ‚ÂƒÂ„Â…Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸÂ Ã€Ã‚ÃˆÃŠÃ‹ÃŽÃÂ´Ë‹Ë†Â¨ËœÃ™Ã›â‚¤Â¯ÃÃ½Â°Ã‡Ã§Ã‘Ã±Â¡Â¿Â¤Â£Â¥Â§Æ’Â¢Ã¢ÃªÃ´Ã»Ã¡Ã©Ã³ÃºÃ Ã¨Ã²Ã¹Ã¤Ã«Ã¶Ã¼Ã…Ã®Ã˜Ã†Ã¥Ã­Ã¸Ã¦Ã„Ã¬Ã–ÃœÃ‰Ã¯ÃŸÃ”ÃÃƒÃ£ÃÃ°ÃÃŒÃ“Ã’Ã•ÃµÅ Å¡ÃšÅ¸Ã¿ÃžÃ¾Â·ÂµÂ¶Â¾â€”Â¼Â½ÂªÂºÂ«â– Â»Â±ï¿½"
    },
    "macintosh": {
      "type": "_sbcs",
      "chars": "Ã„Ã…Ã‡Ã‰Ã‘Ã–ÃœÃ¡Ã Ã¢Ã¤Ã£Ã¥Ã§Ã©Ã¨ÃªÃ«Ã­Ã¬Ã®Ã¯Ã±Ã³Ã²Ã´Ã¶ÃµÃºÃ¹Ã»Ã¼â€ Â°Â¢Â£Â§â€¢Â¶ÃŸÂ®Â©â„¢Â´Â¨â‰ Ã†Ã˜âˆžÂ±â‰¤â‰¥Â¥Âµâˆ‚âˆ‘âˆÏ€âˆ«ÂªÂºâ„¦Ã¦Ã¸Â¿Â¡Â¬âˆšÆ’â‰ˆâˆ†Â«Â»â€¦Â Ã€ÃƒÃ•Å’Å“â€“â€”â€œâ€â€˜â€™Ã·â—ŠÃ¿Å¸â„Â¤â€¹â€ºï¬ï¬‚â€¡Â·â€šâ€žâ€°Ã‚ÃŠÃÃ‹ÃˆÃÃŽÃÃŒÃ“Ã”ï¿½Ã’ÃšÃ›Ã™Ä±Ë†ËœÂ¯Ë˜Ë™ËšÂ¸ËË›Ë‡"
    },
    "ascii": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½"
    },
    "tis620": {
      "type": "_sbcs",
      "chars": "ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½ï¿½à¸à¸‚à¸ƒà¸„à¸…à¸†à¸‡à¸ˆà¸‰à¸Šà¸‹à¸Œà¸à¸Žà¸à¸à¸‘à¸’à¸“à¸”à¸•à¸–à¸—à¸˜à¸™à¸šà¸›à¸œà¸à¸žà¸Ÿà¸ à¸¡à¸¢à¸£à¸¤à¸¥à¸¦à¸§à¸¨à¸©à¸ªà¸«à¸¬à¸­à¸®à¸¯à¸°à¸±à¸²à¸³à¸´à¸µà¸¶à¸·à¸¸à¸¹à¸ºï¿½ï¿½ï¿½ï¿½à¸¿à¹€à¹à¹‚à¹ƒà¹„à¹…à¹†à¹‡à¹ˆà¹‰à¹Šà¹‹à¹Œà¹à¹Žà¹à¹à¹‘à¹’à¹“à¹”à¹•à¹–à¹—à¹˜à¹™à¹šà¹›ï¿½ï¿½ï¿½ï¿½"
    }
  };
  return sbcsDataGenerated;
}
var dbcsCodec = {};
var hasRequiredDbcsCodec;
function requireDbcsCodec() {
  if (hasRequiredDbcsCodec) return dbcsCodec;
  hasRequiredDbcsCodec = 1;
  var Buffer2 = requireSafer().Buffer;
  dbcsCodec._dbcs = DBCSCodec;
  var UNASSIGNED = -1, GB18030_CODE = -2, SEQ_START = -10, NODE_START = -1e3, UNASSIGNED_NODE = new Array(256), DEF_CHAR = -1;
  for (var i = 0; i < 256; i++)
    UNASSIGNED_NODE[i] = UNASSIGNED;
  function DBCSCodec(codecOptions, iconv) {
    this.encodingName = codecOptions.encodingName;
    if (!codecOptions)
      throw new Error("DBCS codec is called without the data.");
    if (!codecOptions.table)
      throw new Error("Encoding '" + this.encodingName + "' has no data.");
    var mappingTable = codecOptions.table();
    this.decodeTables = [];
    this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
    this.decodeTableSeq = [];
    for (var i2 = 0; i2 < mappingTable.length; i2++)
      this._addDecodeChunk(mappingTable[i2]);
    this.defaultCharUnicode = iconv.defaultCharUnicode;
    this.encodeTable = [];
    this.encodeTableSeq = [];
    var skipEncodeChars = {};
    if (codecOptions.encodeSkipVals)
      for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
        var val = codecOptions.encodeSkipVals[i2];
        if (typeof val === "number")
          skipEncodeChars[val] = true;
        else
          for (var j2 = val.from; j2 <= val.to; j2++)
            skipEncodeChars[j2] = true;
      }
    this._fillEncodeTable(0, 0, skipEncodeChars);
    if (codecOptions.encodeAdd) {
      for (var uChar in codecOptions.encodeAdd)
        if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
          this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
    }
    this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
    if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    if (typeof codecOptions.gb18030 === "function") {
      this.gb18030 = codecOptions.gb18030();
      var thirdByteNodeIdx = this.decodeTables.length;
      var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      var fourthByteNodeIdx = this.decodeTables.length;
      var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);
      for (var i2 = 129; i2 <= 254; i2++) {
        var secondByteNodeIdx = NODE_START - this.decodeTables[0][i2];
        var secondByteNode = this.decodeTables[secondByteNodeIdx];
        for (var j2 = 48; j2 <= 57; j2++)
          secondByteNode[j2] = NODE_START - thirdByteNodeIdx;
      }
      for (var i2 = 129; i2 <= 254; i2++)
        thirdByteNode[i2] = NODE_START - fourthByteNodeIdx;
      for (var i2 = 48; i2 <= 57; i2++)
        fourthByteNode[i2] = GB18030_CODE;
    }
  }
  DBCSCodec.prototype.encoder = DBCSEncoder;
  DBCSCodec.prototype.decoder = DBCSDecoder;
  DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
    var bytes2 = [];
    for (; addr > 0; addr >>= 8)
      bytes2.push(addr & 255);
    if (bytes2.length == 0)
      bytes2.push(0);
    var node2 = this.decodeTables[0];
    for (var i2 = bytes2.length - 1; i2 > 0; i2--) {
      var val = node2[bytes2[i2]];
      if (val == UNASSIGNED) {
        node2[bytes2[i2]] = NODE_START - this.decodeTables.length;
        this.decodeTables.push(node2 = UNASSIGNED_NODE.slice(0));
      } else if (val <= NODE_START) {
        node2 = this.decodeTables[NODE_START - val];
      } else
        throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
    }
    return node2;
  };
  DBCSCodec.prototype._addDecodeChunk = function(chunk) {
    var curAddr = parseInt(chunk[0], 16);
    var writeTable = this._getDecodeTrieNode(curAddr);
    curAddr = curAddr & 255;
    for (var k = 1; k < chunk.length; k++) {
      var part = chunk[k];
      if (typeof part === "string") {
        for (var l = 0; l < part.length; ) {
          var code2 = part.charCodeAt(l++);
          if (55296 <= code2 && code2 < 56320) {
            var codeTrail = part.charCodeAt(l++);
            if (56320 <= codeTrail && codeTrail < 57344)
              writeTable[curAddr++] = 65536 + (code2 - 55296) * 1024 + (codeTrail - 56320);
            else
              throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
          } else if (4080 < code2 && code2 <= 4095) {
            var len = 4095 - code2 + 2;
            var seq = [];
            for (var m2 = 0; m2 < len; m2++)
              seq.push(part.charCodeAt(l++));
            writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
            this.decodeTableSeq.push(seq);
          } else
            writeTable[curAddr++] = code2;
        }
      } else if (typeof part === "number") {
        var charCode = writeTable[curAddr - 1] + 1;
        for (var l = 0; l < part; l++)
          writeTable[curAddr++] = charCode++;
      } else
        throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
    }
    if (curAddr > 255)
      throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
  };
  DBCSCodec.prototype._getEncodeBucket = function(uCode) {
    var high = uCode >> 8;
    if (this.encodeTable[high] === void 0)
      this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
    return this.encodeTable[high];
  };
  DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    if (bucket[low] <= SEQ_START)
      this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
    else if (bucket[low] == UNASSIGNED)
      bucket[low] = dbcsCode;
  };
  DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
    var uCode = seq[0];
    var bucket = this._getEncodeBucket(uCode);
    var low = uCode & 255;
    var node2;
    if (bucket[low] <= SEQ_START) {
      node2 = this.encodeTableSeq[SEQ_START - bucket[low]];
    } else {
      node2 = {};
      if (bucket[low] !== UNASSIGNED) node2[DEF_CHAR] = bucket[low];
      bucket[low] = SEQ_START - this.encodeTableSeq.length;
      this.encodeTableSeq.push(node2);
    }
    for (var j2 = 1; j2 < seq.length - 1; j2++) {
      var oldVal = node2[uCode];
      if (typeof oldVal === "object")
        node2 = oldVal;
      else {
        node2 = node2[uCode] = {};
        if (oldVal !== void 0)
          node2[DEF_CHAR] = oldVal;
      }
    }
    uCode = seq[seq.length - 1];
    node2[uCode] = dbcsCode;
  };
  DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
    var node2 = this.decodeTables[nodeIdx];
    for (var i2 = 0; i2 < 256; i2++) {
      var uCode = node2[i2];
      var mbCode = prefix + i2;
      if (skipEncodeChars[mbCode])
        continue;
      if (uCode >= 0)
        this._setEncodeChar(uCode, mbCode);
      else if (uCode <= NODE_START)
        this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);
      else if (uCode <= SEQ_START)
        this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
    }
  };
  function DBCSEncoder(options, codec) {
    this.leadSurrogate = -1;
    this.seqObj = void 0;
    this.encodeTable = codec.encodeTable;
    this.encodeTableSeq = codec.encodeTableSeq;
    this.defaultCharSingleByte = codec.defCharSB;
    this.gb18030 = codec.gb18030;
  }
  DBCSEncoder.prototype.write = function(str2) {
    var newBuf = Buffer2.alloc(str2.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j2 = 0;
    while (true) {
      if (nextChar === -1) {
        if (i2 == str2.length) break;
        var uCode = str2.charCodeAt(i2++);
      } else {
        var uCode = nextChar;
        nextChar = -1;
      }
      if (55296 <= uCode && uCode < 57344) {
        if (uCode < 56320) {
          if (leadSurrogate === -1) {
            leadSurrogate = uCode;
            continue;
          } else {
            leadSurrogate = uCode;
            uCode = UNASSIGNED;
          }
        } else {
          if (leadSurrogate !== -1) {
            uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
            leadSurrogate = -1;
          } else {
            uCode = UNASSIGNED;
          }
        }
      } else if (leadSurrogate !== -1) {
        nextChar = uCode;
        uCode = UNASSIGNED;
        leadSurrogate = -1;
      }
      var dbcsCode = UNASSIGNED;
      if (seqObj !== void 0 && uCode != UNASSIGNED) {
        var resCode = seqObj[uCode];
        if (typeof resCode === "object") {
          seqObj = resCode;
          continue;
        } else if (typeof resCode == "number") {
          dbcsCode = resCode;
        } else if (resCode == void 0) {
          resCode = seqObj[DEF_CHAR];
          if (resCode !== void 0) {
            dbcsCode = resCode;
            nextChar = uCode;
          }
        }
        seqObj = void 0;
      } else if (uCode >= 0) {
        var subtable = this.encodeTable[uCode >> 8];
        if (subtable !== void 0)
          dbcsCode = subtable[uCode & 255];
        if (dbcsCode <= SEQ_START) {
          seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
          continue;
        }
        if (dbcsCode == UNASSIGNED && this.gb18030) {
          var idx = findIdx(this.gb18030.uChars, uCode);
          if (idx != -1) {
            var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 12600);
            dbcsCode = dbcsCode % 12600;
            newBuf[j2++] = 48 + Math.floor(dbcsCode / 1260);
            dbcsCode = dbcsCode % 1260;
            newBuf[j2++] = 129 + Math.floor(dbcsCode / 10);
            dbcsCode = dbcsCode % 10;
            newBuf[j2++] = 48 + dbcsCode;
            continue;
          }
        }
      }
      if (dbcsCode === UNASSIGNED)
        dbcsCode = this.defaultCharSingleByte;
      if (dbcsCode < 256) {
        newBuf[j2++] = dbcsCode;
      } else if (dbcsCode < 65536) {
        newBuf[j2++] = dbcsCode >> 8;
        newBuf[j2++] = dbcsCode & 255;
      } else {
        newBuf[j2++] = dbcsCode >> 16;
        newBuf[j2++] = dbcsCode >> 8 & 255;
        newBuf[j2++] = dbcsCode & 255;
      }
    }
    this.seqObj = seqObj;
    this.leadSurrogate = leadSurrogate;
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.end = function() {
    if (this.leadSurrogate === -1 && this.seqObj === void 0)
      return;
    var newBuf = Buffer2.alloc(10), j2 = 0;
    if (this.seqObj) {
      var dbcsCode = this.seqObj[DEF_CHAR];
      if (dbcsCode !== void 0) {
        if (dbcsCode < 256) {
          newBuf[j2++] = dbcsCode;
        } else {
          newBuf[j2++] = dbcsCode >> 8;
          newBuf[j2++] = dbcsCode & 255;
        }
      }
      this.seqObj = void 0;
    }
    if (this.leadSurrogate !== -1) {
      newBuf[j2++] = this.defaultCharSingleByte;
      this.leadSurrogate = -1;
    }
    return newBuf.slice(0, j2);
  };
  DBCSEncoder.prototype.findIdx = findIdx;
  function DBCSDecoder(options, codec) {
    this.nodeIdx = 0;
    this.prevBuf = Buffer2.alloc(0);
    this.decodeTables = codec.decodeTables;
    this.decodeTableSeq = codec.decodeTableSeq;
    this.defaultCharUnicode = codec.defaultCharUnicode;
    this.gb18030 = codec.gb18030;
  }
  DBCSDecoder.prototype.write = function(buf) {
    var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length, seqStart = -this.prevBuf.length, uCode;
    if (prevBufOffset > 0)
      prevBuf = Buffer2.concat([prevBuf, buf.slice(0, 10)]);
    for (var i2 = 0, j2 = 0; i2 < buf.length; i2++) {
      var curByte = i2 >= 0 ? buf[i2] : prevBuf[i2 + prevBufOffset];
      var uCode = this.decodeTables[nodeIdx][curByte];
      if (uCode >= 0) ;
      else if (uCode === UNASSIGNED) {
        i2 = seqStart;
        uCode = this.defaultCharUnicode.charCodeAt(0);
      } else if (uCode === GB18030_CODE) {
        var curSeq = seqStart >= 0 ? buf.slice(seqStart, i2 + 1) : prevBuf.slice(seqStart + prevBufOffset, i2 + 1 + prevBufOffset);
        var ptr = (curSeq[0] - 129) * 12600 + (curSeq[1] - 48) * 1260 + (curSeq[2] - 129) * 10 + (curSeq[3] - 48);
        var idx = findIdx(this.gb18030.gbChars, ptr);
        uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
      } else if (uCode <= NODE_START) {
        nodeIdx = NODE_START - uCode;
        continue;
      } else if (uCode <= SEQ_START) {
        var seq = this.decodeTableSeq[SEQ_START - uCode];
        for (var k = 0; k < seq.length - 1; k++) {
          uCode = seq[k];
          newBuf[j2++] = uCode & 255;
          newBuf[j2++] = uCode >> 8;
        }
        uCode = seq[seq.length - 1];
      } else
        throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
      if (uCode > 65535) {
        uCode -= 65536;
        var uCodeLead = 55296 + Math.floor(uCode / 1024);
        newBuf[j2++] = uCodeLead & 255;
        newBuf[j2++] = uCodeLead >> 8;
        uCode = 56320 + uCode % 1024;
      }
      newBuf[j2++] = uCode & 255;
      newBuf[j2++] = uCode >> 8;
      nodeIdx = 0;
      seqStart = i2 + 1;
    }
    this.nodeIdx = nodeIdx;
    this.prevBuf = seqStart >= 0 ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);
    return newBuf.slice(0, j2).toString("ucs2");
  };
  DBCSDecoder.prototype.end = function() {
    var ret = "";
    while (this.prevBuf.length > 0) {
      ret += this.defaultCharUnicode;
      var buf = this.prevBuf.slice(1);
      this.prevBuf = Buffer2.alloc(0);
      this.nodeIdx = 0;
      if (buf.length > 0)
        ret += this.write(buf);
    }
    this.nodeIdx = 0;
    return ret;
  };
  function findIdx(table, val) {
    if (table[0] > val)
      return -1;
    var l = 0, r = table.length;
    while (l < r - 1) {
      var mid = l + Math.floor((r - l + 1) / 2);
      if (table[mid] <= val)
        l = mid;
      else
        r = mid;
    }
    return l;
  }
  return dbcsCodec;
}
const require$$0$2 = [
  [
    "0",
    "\0",
    128
  ],
  [
    "a1",
    "ï½¡",
    62
  ],
  [
    "8140",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—"
  ],
  [
    "8180",
    "Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "81b8",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "81c8",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "81da",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "81f0",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "81fc",
    "â—¯"
  ],
  [
    "824f",
    "ï¼",
    9
  ],
  [
    "8260",
    "ï¼¡",
    25
  ],
  [
    "8281",
    "ï½",
    25
  ],
  [
    "829f",
    "ã",
    82
  ],
  [
    "8340",
    "ã‚¡",
    62
  ],
  [
    "8380",
    "ãƒ ",
    22
  ],
  [
    "839f",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "83bf",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "8440",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "8470",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    7
  ],
  [
    "8480",
    "Ð¾",
    17
  ],
  [
    "849f",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "8740",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "875f",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "877e",
    "ã»"
  ],
  [
    "8780",
    "ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "889f",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "8940",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††"
  ],
  [
    "8980",
    "åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œæŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "8a40",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«"
  ],
  [
    "8a80",
    "æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "8b40",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘"
  ],
  [
    "8b80",
    "æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "8c40",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨"
  ],
  [
    "8c80",
    "åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "8d40",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™"
  ],
  [
    "8d80",
    "é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "8e40",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢"
  ],
  [
    "8e80",
    "æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "8f40",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³"
  ],
  [
    "8f80",
    "æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿå‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "9040",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨"
  ],
  [
    "9080",
    "é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "9140",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»"
  ],
  [
    "9180",
    "æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Žè‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "9240",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„"
  ],
  [
    "9280",
    "é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µå¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "9340",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬"
  ],
  [
    "9380",
    "å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "9440",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…"
  ],
  [
    "9480",
    "æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "9540",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·"
  ],
  [
    "9580",
    "æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "9640",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†"
  ],
  [
    "9680",
    "æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "9740",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²"
  ],
  [
    "9780",
    "æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "9840",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "989f",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "9940",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­"
  ],
  [
    "9980",
    "å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "9a40",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸"
  ],
  [
    "9a80",
    "å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "9b40",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€"
  ],
  [
    "9b80",
    "å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "9c40",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ "
  ],
  [
    "9c80",
    "æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚šæ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "9d40",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«"
  ],
  [
    "9d80",
    "æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "9e40",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Ž"
  ],
  [
    "9e80",
    "æ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "9f40",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯"
  ],
  [
    "9f80",
    "éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "e040",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒ"
  ],
  [
    "e080",
    "çƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e140",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿"
  ],
  [
    "e180",
    "ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e240",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°"
  ],
  [
    "e280",
    "çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e340",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·"
  ],
  [
    "e380",
    "ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼ºç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e440",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤"
  ],
  [
    "e480",
    "è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e540",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬"
  ],
  [
    "e580",
    "è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "e640",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§"
  ],
  [
    "e680",
    "è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "e740",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œ"
  ],
  [
    "e780",
    "è½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "e840",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™"
  ],
  [
    "e880",
    "é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™žé™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "e940",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒ"
  ],
  [
    "e980",
    "é¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "ea40",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯"
  ],
  [
    "ea80",
    "é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "ed40",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨"
  ],
  [
    "ed80",
    "ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "ee40",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™"
  ],
  [
    "ee80",
    "è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "eeef",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "f040",
    "î€€",
    62
  ],
  [
    "f080",
    "î€¿",
    124
  ],
  [
    "f140",
    "î‚¼",
    62
  ],
  [
    "f180",
    "îƒ»",
    124
  ],
  [
    "f240",
    "î…¸",
    62
  ],
  [
    "f280",
    "î†·",
    124
  ],
  [
    "f340",
    "îˆ´",
    62
  ],
  [
    "f380",
    "î‰³",
    124
  ],
  [
    "f440",
    "î‹°",
    62
  ],
  [
    "f480",
    "îŒ¯",
    124
  ],
  [
    "f540",
    "îŽ¬",
    62
  ],
  [
    "f580",
    "î«",
    124
  ],
  [
    "f640",
    "î‘¨",
    62
  ],
  [
    "f680",
    "î’§",
    124
  ],
  [
    "f740",
    "î”¤",
    62
  ],
  [
    "f780",
    "î•£",
    124
  ],
  [
    "f840",
    "î— ",
    62
  ],
  [
    "f880",
    "î˜Ÿ",
    124
  ],
  [
    "f940",
    "îšœ"
  ],
  [
    "fa40",
    "â…°",
    9,
    "â… ",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡âˆµçºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Š"
  ],
  [
    "fa80",
    "å…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯"
  ],
  [
    "fb40",
    "æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™"
  ],
  [
    "fb80",
    "ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡šé‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™"
  ],
  [
    "fc40",
    "é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ]
];
const require$$1 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8ea1",
    "ï½¡",
    62
  ],
  [
    "a1a1",
    "ã€€ã€ã€‚ï¼Œï¼Žãƒ»ï¼šï¼›ï¼Ÿï¼ã‚›ã‚œÂ´ï½€Â¨ï¼¾ï¿£ï¼¿ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼â€•â€ï¼ï¼¼ï½žâˆ¥ï½œâ€¦â€¥â€˜â€™â€œâ€ï¼ˆï¼‰ã€”ã€•ï¼»ï¼½ï½›ï½ã€ˆ",
    9,
    "ï¼‹ï¼Â±Ã—Ã·ï¼â‰ ï¼œï¼žâ‰¦â‰§âˆžâˆ´â™‚â™€Â°â€²â€³â„ƒï¿¥ï¼„ï¿ ï¿¡ï¼…ï¼ƒï¼†ï¼Šï¼ Â§â˜†â˜…â—‹â—â—Žâ—‡"
  ],
  [
    "a2a1",
    "â—†â–¡â– â–³â–²â–½â–¼â€»ã€’â†’â†â†‘â†“ã€“"
  ],
  [
    "a2ba",
    "âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©"
  ],
  [
    "a2ca",
    "âˆ§âˆ¨ï¿¢â‡’â‡”âˆ€âˆƒ"
  ],
  [
    "a2dc",
    "âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬"
  ],
  [
    "a2f2",
    "â„«â€°â™¯â™­â™ªâ€ â€¡Â¶"
  ],
  [
    "a2fe",
    "â—¯"
  ],
  [
    "a3b0",
    "ï¼",
    9
  ],
  [
    "a3c1",
    "ï¼¡",
    25
  ],
  [
    "a3e1",
    "ï½",
    25
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã‚¡",
    85
  ],
  [
    "a6a1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "a8a1",
    "â”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚"
  ],
  [
    "ada1",
    "â‘ ",
    19,
    "â… ",
    9
  ],
  [
    "adc0",
    "ã‰ãŒ”ãŒ¢ããŒ˜ãŒ§ãŒƒãŒ¶ã‘ã—ãŒãŒ¦ãŒ£ãŒ«ãŠãŒ»ãŽœãŽãŽžãŽŽãŽã„ãŽ¡"
  ],
  [
    "addf",
    "ã»ã€ã€Ÿâ„–ãâ„¡ãŠ¤",
    4,
    "ãˆ±ãˆ²ãˆ¹ã¾ã½ã¼â‰’â‰¡âˆ«âˆ®âˆ‘âˆšâŠ¥âˆ âˆŸâŠ¿âˆµâˆ©âˆª"
  ],
  [
    "b0a1",
    "äºœå”–å¨ƒé˜¿å“€æ„›æŒ¨å§¶é€¢è‘µèŒœç©æ‚ªæ¡æ¸¥æ—­è‘¦èŠ¦é¯µæ¢“åœ§æ–¡æ‰±å®›å§è™»é£´çµ¢ç¶¾é®Žæˆ–ç²Ÿè¢·å®‰åºµæŒ‰æš—æ¡ˆé—‡éžæä»¥ä¼Šä½ä¾å‰å›²å¤·å§”å¨å°‰æƒŸæ„æ…°æ˜“æ¤…ç‚ºç•ç•°ç§»ç¶­ç·¯èƒƒèŽè¡£è¬‚é•éºåŒ»äº•äº¥åŸŸè‚²éƒç£¯ä¸€å£±æº¢é€¸ç¨²èŒ¨èŠ‹é°¯å…å°å’½å“¡å› å§»å¼•é£²æ·«èƒ¤è”­"
  ],
  [
    "b1a1",
    "é™¢é™°éš éŸ»å‹å³å®‡çƒç¾½è¿‚é›¨å¯éµœçªºä¸‘ç¢“è‡¼æ¸¦å˜˜å”„æ¬è”šé°»å§¥åŽ©æµ¦ç“œé–å™‚äº‘é‹é›²èé¤Œå¡å–¶å¬°å½±æ˜ æ›³æ „æ°¸æ³³æ´©ç‘›ç›ˆç©Žé ´è‹±è¡›è© é‹­æ¶²ç–«ç›Šé§…æ‚¦è¬è¶Šé–²æ¦ŽåŽ­å††åœ’å °å¥„å®´å»¶æ€¨æŽ©æ´æ²¿æ¼”ç‚Žç„”ç…™ç‡•çŒ¿ç¸è‰¶è‹‘è–—é é‰›é´›å¡©æ–¼æ±šç”¥å‡¹å¤®å¥¥å¾€å¿œ"
  ],
  [
    "b2a1",
    "æŠ¼æ—ºæ¨ªæ¬§æ®´çŽ‹ç¿è¥–é´¬é´Žé»„å²¡æ²–è»å„„å±‹æ†¶è‡†æ¡¶ç‰¡ä¹™ä¿ºå¸æ©æ¸©ç©éŸ³ä¸‹åŒ–ä»®ä½•ä¼½ä¾¡ä½³åŠ å¯å˜‰å¤å«å®¶å¯¡ç§‘æš‡æžœæž¶æ­Œæ²³ç«ç‚ç¦ç¦¾ç¨¼ç®‡èŠ±è‹›èŒ„è·è¯è“è¦èª²å˜©è²¨è¿¦éŽéœžèšŠä¿„å³¨æˆ‘ç‰™ç”»è‡¥èŠ½è›¾è³€é›…é¤“é§•ä»‹ä¼šè§£å›žå¡Šå£Šå»»å¿«æ€ªæ‚”æ¢æ‡æˆ’æ‹æ”¹"
  ],
  [
    "b3a1",
    "é­æ™¦æ¢°æµ·ç°ç•Œçš†çµµèŠ¥èŸ¹é–‹éšŽè²å‡±åŠ¾å¤–å’³å®³å´–æ…¨æ¦‚æ¶¯ç¢è“‹è¡—è©²éŽ§éª¸æµ¬é¦¨è›™åž£æŸ¿è›ŽéˆŽåŠƒåš‡å„å»“æ‹¡æ’¹æ ¼æ ¸æ®»ç²ç¢ºç©«è¦šè§’èµ«è¼ƒéƒ­é–£éš”é©å­¦å²³æ¥½é¡é¡ŽæŽ›ç¬ æ¨«æ©¿æ¢¶é°æ½Ÿå‰²å–æ°æ‹¬æ´»æ¸‡æ»‘è‘›è¤è½„ä¸”é°¹å¶æ¤›æ¨ºéž„æ ªå…œç«ƒè’²é‡œéŽŒå™›é´¨æ ¢èŒ…è±"
  ],
  [
    "b4a1",
    "ç²¥åˆˆè‹…ç“¦ä¹¾ä¾ƒå† å¯’åˆŠå‹˜å‹§å·»å–šå ªå§¦å®Œå®˜å¯›å¹²å¹¹æ‚£æ„Ÿæ…£æ†¾æ›æ•¢æŸ‘æ¡“æ£ºæ¬¾æ­“æ±—æ¼¢æ¾—æ½…ç’°ç”˜ç›£çœ‹ç«¿ç®¡ç°¡ç·©ç¼¶ç¿°è‚è‰¦èŽžè¦³è«Œè²«é‚„é‘‘é–“é–‘é–¢é™¥éŸ“é¤¨èˆ˜ä¸¸å«å²¸å·ŒçŽ©ç™Œçœ¼å²©ç¿«è´‹é›é ‘é¡”é¡˜ä¼ä¼Žå±å–œå™¨åŸºå¥‡å¬‰å¯„å²å¸Œå¹¾å¿Œæ®æœºæ——æ—¢æœŸæ£‹æ£„"
  ],
  [
    "b5a1",
    "æ©Ÿå¸°æ¯…æ°—æ±½ç•¿ç¥ˆå­£ç¨€ç´€å¾½è¦è¨˜è²´èµ·è»Œè¼é£¢é¨Žé¬¼äº€å½å„€å¦“å®œæˆ¯æŠ€æ“¬æ¬ºçŠ ç–‘ç¥‡ç¾©èŸ»èª¼è­°æŽ¬èŠéž å‰åƒå–«æ¡”æ©˜è©°ç §æµé»å´å®¢è„šè™é€†ä¸˜ä¹…ä»‡ä¼‘åŠå¸å®®å¼“æ€¥æ•‘æœ½æ±‚æ±²æ³£ç¸çƒç©¶çª®ç¬ˆç´šç³¾çµ¦æ—§ç‰›åŽ»å±…å·¨æ‹’æ‹ æŒ™æ¸ è™šè¨±è·é‹¸æ¼ç¦¦é­šäº¨äº«äº¬"
  ],
  [
    "b6a1",
    "ä¾›ä¾ åƒ‘å…‡ç«¶å…±å‡¶å”åŒ¡å¿å«å–¬å¢ƒå³¡å¼·å½Šæ€¯ææ­æŒŸæ•™æ©‹æ³ç‹‚ç‹­çŸ¯èƒ¸è„…èˆˆè•Žéƒ·é¡éŸ¿é¥—é©šä»°å‡å°­æšæ¥­å±€æ›²æ¥µçŽ‰æ¡ç²åƒ…å‹¤å‡å·¾éŒ¦æ–¤æ¬£æ¬½ç´ç¦ç¦½ç­‹ç·ŠèŠ¹èŒè¡¿è¥Ÿè¬¹è¿‘é‡‘åŸéŠ€ä¹å€¶å¥åŒºç‹—çŽ–çŸ©è‹¦èº¯é§†é§ˆé§’å…·æ„šè™žå–°ç©ºå¶å¯“é‡éš…ä¸²æ«›é‡§å±‘å±ˆ"
  ],
  [
    "b7a1",
    "æŽ˜çªŸæ²“é´è½¡çªªç†Šéšˆç²‚æ —ç¹°æ¡‘é¬å‹²å›è–«è¨“ç¾¤è»éƒ¡å¦è¢ˆç¥ä¿‚å‚¾åˆ‘å…„å•“åœ­çªåž‹å¥‘å½¢å¾„æµæ…¶æ…§æ†©æŽ²æºæ•¬æ™¯æ¡‚æ¸“ç•¦ç¨½ç³»çµŒç¶™ç¹‹ç½«èŒŽèŠè›è¨ˆè©£è­¦è»½é šé¶èŠ¸è¿Žé¯¨åŠ‡æˆŸæ’ƒæ¿€éš™æ¡å‚‘æ¬ æ±ºæ½”ç©´çµè¡€è¨£æœˆä»¶å€¹å€¦å¥å…¼åˆ¸å‰£å–§åœå …å«Œå»ºæ†²æ‡¸æ‹³æ²"
  ],
  [
    "b8a1",
    "æ¤œæ¨©ç‰½çŠ¬çŒ®ç ”ç¡¯çµ¹çœŒè‚©è¦‹è¬™è³¢è»’é£éµé™ºé¡•é¨“é¹¸å…ƒåŽŸåŽ³å¹»å¼¦æ¸›æºçŽ„ç¾çµƒèˆ·è¨€è«ºé™ä¹Žå€‹å¤å‘¼å›ºå§‘å­¤å·±åº«å¼§æˆ¸æ•…æž¯æ¹–ç‹ç³Šè¢´è‚¡èƒ¡è°è™Žèª‡è·¨éˆ·é›‡é¡§é¼“äº”äº’ä¼åˆå‘‰å¾å¨¯å¾Œå¾¡æ‚Ÿæ¢§æªŽç‘šç¢èªžèª¤è­·é†ä¹žé¯‰äº¤ä½¼ä¾¯å€™å€–å…‰å…¬åŠŸåŠ¹å‹¾åŽšå£å‘"
  ],
  [
    "b9a1",
    "åŽå–‰å‘åž¢å¥½å­”å­å®å·¥å·§å··å¹¸åºƒåºšåº·å¼˜æ’æ…ŒæŠ—æ‹˜æŽ§æ”»æ˜‚æ™ƒæ›´æ­æ ¡æ¢—æ§‹æ±Ÿæ´ªæµ©æ¸¯æºç”²çš‡ç¡¬ç¨¿ç³ ç´…ç´˜çµžç¶±è€•è€ƒè‚¯è‚±è…”è†èˆªè’è¡Œè¡¡è¬›è²¢è³¼éƒŠé…µé‰±ç ¿é‹¼é–¤é™é …é¦™é«˜é´»å‰›åŠ«å·åˆå£•æ‹·æ¿ è±ªè½Ÿéº¹å…‹åˆ»å‘Šå›½ç©€é…·éµ é»’ç„æ¼‰è…°ç”‘å¿½æƒšéª¨ç‹›è¾¼"
  ],
  [
    "baa1",
    "æ­¤é ƒä»Šå›°å¤å¢¾å©šæ¨æ‡‡æ˜æ˜†æ ¹æ¢±æ··ç—•ç´ºè‰®é­‚äº›ä½å‰å”†åµ¯å·¦å·®æŸ»æ²™ç‘³ç ‚è©éŽ–è£Ÿååº§æŒ«å‚µå‚¬å†æœ€å“‰å¡žå¦»å®°å½©æ‰æŽ¡æ ½æ­³æ¸ˆç½é‡‡çŠ€ç •ç ¦ç¥­æ–Žç´°èœè£è¼‰éš›å‰¤åœ¨æç½ªè²¡å†´å‚é˜ªå ºæ¦Šè‚´å’²å´ŽåŸ¼ç¢•é·ºä½œå‰Šå’‹æ¾æ˜¨æœ”æŸµçª„ç­–ç´¢éŒ¯æ¡œé®­ç¬¹åŒ™å†Šåˆ·"
  ],
  [
    "bba1",
    "å¯Ÿæ‹¶æ’®æ“¦æœ­æ®ºè–©é›‘çšé¯–æŒéŒ†é®«çš¿æ™’ä¸‰å‚˜å‚å±±æƒ¨æ’’æ•£æ¡Ÿç‡¦çŠç”£ç®—çº‚èš•è®ƒè³›é…¸é¤æ–¬æš«æ®‹ä»•ä»”ä¼ºä½¿åˆºå¸å²å—£å››å£«å§‹å§‰å§¿å­å±å¸‚å¸«å¿—æ€æŒ‡æ”¯å­œæ–¯æ–½æ—¨æžæ­¢æ­»æ°ç…ç¥‰ç§ç³¸ç´™ç´«è‚¢è„‚è‡³è¦–è©žè©©è©¦èªŒè«®è³‡è³œé›Œé£¼æ­¯äº‹ä¼¼ä¾å…å­—å¯ºæ…ˆæŒæ™‚"
  ],
  [
    "bca1",
    "æ¬¡æ»‹æ²»çˆ¾ç’½ç—”ç£ç¤ºè€Œè€³è‡ªè’”è¾žæ±é¹¿å¼è­˜é´«ç«ºè»¸å®é›«ä¸ƒå±åŸ·å¤±å«‰å®¤æ‚‰æ¹¿æ¼†ç–¾è³ªå®Ÿè”€ç¯ å²æŸ´èŠå±¡è•Šç¸žèˆŽå†™å°„æ¨èµ¦æ–œç…®ç¤¾ç´—è€…è¬è»Šé®è›‡é‚ªå€Ÿå‹ºå°ºæ“ç¼çˆµé…Œé‡ˆéŒ«è‹¥å¯‚å¼±æƒ¹ä¸»å–å®ˆæ‰‹æœ±æ®Šç‹©ç ç¨®è…«è¶£é…’é¦–å„’å—å‘ªå¯¿æŽˆæ¨¹ç¶¬éœ€å›šåŽå‘¨"
  ],
  [
    "bda1",
    "å®—å°±å·žä¿®æ„æ‹¾æ´²ç§€ç§‹çµ‚ç¹ç¿’è‡­èˆŸè’è¡†è¥²è®è¹´è¼¯é€±é…‹é…¬é›†é†œä»€ä½å……åå¾“æˆŽæŸ”æ±æ¸‹ç£ç¸¦é‡éŠƒå”å¤™å®¿æ·‘ç¥ç¸®ç²›å¡¾ç†Ÿå‡ºè¡“è¿°ä¿Šå³»æ˜¥çž¬ç«£èˆœé§¿å‡†å¾ªæ—¬æ¥¯æ®‰æ·³æº–æ½¤ç›¾ç´”å·¡éµé†‡é †å‡¦åˆæ‰€æš‘æ›™æ¸šåº¶ç·’ç½²æ›¸è–¯è—·è«¸åŠ©å™å¥³åºå¾æ•é‹¤é™¤å‚·å„Ÿ"
  ],
  [
    "bea1",
    "å‹åŒ å‡å¬å“¨å•†å”±å˜—å¥¨å¦¾å¨¼å®µå°†å°å°‘å°šåº„åºŠå» å½°æ‰¿æŠ„æ‹›æŽŒæ·æ˜‡æ˜Œæ˜­æ™¶æ¾æ¢¢æ¨Ÿæ¨µæ²¼æ¶ˆæ¸‰æ¹˜ç„¼ç„¦ç…§ç—‡çœç¡ç¤ç¥¥ç§°ç« ç¬‘ç²§ç´¹è‚–è–è’‹è•‰è¡è£³è¨Ÿè¨¼è©”è©³è±¡è³žé†¤é‰¦é¾é˜éšœéž˜ä¸Šä¸ˆä¸žä¹—å†—å‰°åŸŽå ´å£Œå¬¢å¸¸æƒ…æ“¾æ¡æ–æµ„çŠ¶ç•³ç©£è’¸è­²é†¸éŒ å˜±åŸ´é£¾"
  ],
  [
    "bfa1",
    "æ‹­æ¤æ®–ç‡­ç¹”è·è‰²è§¦é£Ÿè•è¾±å°»ä¼¸ä¿¡ä¾µå”‡å¨ å¯å¯©å¿ƒæ…ŽæŒ¯æ–°æ™‹æ£®æ¦›æµ¸æ·±ç”³ç–¹çœŸç¥žç§¦ç´³è‡£èŠ¯è–ªè¦ªè¨ºèº«è¾›é€²é‡éœ‡äººä»åˆƒå¡µå£¬å°‹ç”šå°½è…Žè¨Šè¿…é™£é­ç¬¥è«é ˆé…¢å›³åŽ¨é€—å¹åž‚å¸¥æŽ¨æ°´ç‚Šç¡ç²‹ç¿ è¡°é‚é…”éŒéŒ˜éšç‘žé«„å´‡åµ©æ•°æž¢è¶¨é››æ®æ‰æ¤™è…é —é›€è£¾"
  ],
  [
    "c0a1",
    "æ¾„æ‘ºå¯¸ä¸–ç€¬ç•æ˜¯å‡„åˆ¶å‹¢å§“å¾æ€§æˆæ”¿æ•´æ˜Ÿæ™´æ£²æ –æ­£æ¸…ç‰²ç”Ÿç››ç²¾è–å£°è£½è¥¿èª èª“è«‹é€é†’é’é™æ–‰ç¨Žè„†éš»å¸­æƒœæˆšæ–¥æ˜”æžçŸ³ç©ç±ç¸¾è„Šè²¬èµ¤è·¡è¹Ÿç¢©åˆ‡æ‹™æŽ¥æ‘‚æŠ˜è¨­çªƒç¯€èª¬é›ªçµ¶èˆŒè‰ä»™å…ˆåƒå å®£å°‚å°–å·æˆ¦æ‰‡æ’°æ “æ ´æ³‰æµ…æ´—æŸ“æ½œç…Žç…½æ—‹ç©¿ç®­ç·š"
  ],
  [
    "c1a1",
    "ç¹Šç¾¨è…ºèˆ›èˆ¹è–¦è©®è³Žè·µé¸é·éŠ­éŠ‘é–ƒé®®å‰å–„æ¼¸ç„¶å…¨ç¦…ç¹•è†³ç³Žå™Œå¡‘å²¨æŽªæ›¾æ›½æ¥šç‹™ç–ç–Žç¤Žç¥–ç§Ÿç²—ç´ çµ„è˜‡è¨´é˜»é¡é¼ åƒ§å‰µåŒå¢å€‰å–ªå£®å¥çˆ½å®‹å±¤åŒæƒ£æƒ³æœæŽƒæŒ¿æŽ»æ“æ—©æ›¹å·£æ§æ§½æ¼•ç‡¥äº‰ç—©ç›¸çª“ç³Ÿç·ç¶œè¡è‰è˜è‘¬è’¼è—»è£…èµ°é€é­éŽ—éœœé¨’åƒå¢—æ†Ž"
  ],
  [
    "c2a1",
    "è‡“è”µè´ˆé€ ä¿ƒå´å‰‡å³æ¯æ‰æŸæ¸¬è¶³é€Ÿä¿—å±žè³Šæ—ç¶šå’è¢–å…¶æƒå­˜å­«å°Šææ‘éœä»–å¤šå¤ªæ±°è©‘å”¾å •å¦¥æƒ°æ‰“æŸèˆµæ¥•é™€é§„é¨¨ä½“å †å¯¾è€å²±å¸¯å¾…æ€ æ…‹æˆ´æ›¿æ³°æ»žèƒŽè…¿è‹”è¢‹è²¸é€€é€®éšŠé»›é¯›ä»£å°å¤§ç¬¬é†é¡Œé·¹æ»ç€§å“å•„å®…æ‰˜æŠžæ‹“æ²¢æ¿¯ç¢è¨—é¸æ¿è«¾èŒ¸å‡§è›¸åª"
  ],
  [
    "c3a1",
    "å©ä½†é”è¾°å¥ªè„±å·½ç«ªè¾¿æ£šè°·ç‹¸é±ˆæ¨½èª°ä¸¹å˜å˜†å¦æ‹…æŽ¢æ—¦æ­Žæ·¡æ¹›ç‚­çŸ­ç«¯ç®ªç¶»è€½èƒ†è›‹èª•é›å›£å£‡å¼¾æ–­æš–æª€æ®µç”·è«‡å€¤çŸ¥åœ°å¼›æ¥æ™ºæ± ç—´ç¨šç½®è‡´èœ˜é…é¦³ç¯‰ç•œç«¹ç­‘è“„é€ç§©çª’èŒ¶å«¡ç€ä¸­ä»²å®™å¿ æŠ½æ˜¼æŸ±æ³¨è™«è¡·è¨»é…Žé‹³é§æ¨—ç€¦çŒªè‹§è‘—è²¯ä¸å…†å‡‹å–‹å¯µ"
  ],
  [
    "c4a1",
    "å¸–å¸³åºå¼”å¼µå½«å¾´æ‡²æŒ‘æš¢æœæ½®ç‰’ç”ºçœºè´è„¹è…¸è¶èª¿è«œè¶…è·³éŠšé•·é ‚é³¥å‹…æ—ç›´æœ•æ²ˆçè³ƒéŽ®é™³æ´¥å¢œæ¤Žæ§Œè¿½éŽšç—›é€šå¡šæ ‚æŽ´æ§»ä½ƒæ¼¬æŸ˜è¾»è”¦ç¶´é”æ¤¿æ½°åªå£·å¬¬ç´¬çˆªåŠé‡£é¶´äº­ä½Žåœåµå‰ƒè²žå‘ˆå ¤å®šå¸åº•åº­å»·å¼Ÿæ‚ŒæŠµæŒºææ¢¯æ±€ç¢‡ç¦Žç¨‹ç· è‰‡è¨‚è«¦è¹„é€“"
  ],
  [
    "c5a1",
    "é‚¸é„­é‡˜é¼Žæ³¥æ‘˜æ“¢æ•µæ»´çš„ç¬›é©é‘æººå“²å¾¹æ’¤è½è¿­é‰„å…¸å¡«å¤©å±•åº—æ·»çºç”œè²¼è»¢é¡›ç‚¹ä¼æ®¿æ¾±ç”°é›»å…Žåå µå¡—å¦¬å± å¾’æ–—æœæ¸¡ç™»èŸè³­é€”éƒ½éç ¥ç ºåŠªåº¦åœŸå¥´æ€’å€’å…šå†¬å‡åˆ€å”å¡”å¡˜å¥—å®•å³¶å¶‹æ‚¼æŠ•æ­æ±æ¡ƒæ¢¼æ£Ÿç›—æ·˜æ¹¯æ¶›ç¯ç‡ˆå½“ç—˜ç¥·ç­‰ç­”ç­’ç³–çµ±åˆ°"
  ],
  [
    "c6a1",
    "è‘£è•©è—¤è¨Žè¬„è±†è¸é€ƒé€é™é™¶é ­é¨°é—˜åƒå‹•åŒå ‚å°Žæ†§æ’žæ´žçž³ç«¥èƒ´è„é“éŠ…å³ é´‡åŒ¿å¾—å¾³æ¶œç‰¹ç£ç¦¿ç¯¤æ¯’ç‹¬èª­æ ƒæ©¡å‡¸çªæ¤´å±Šé³¶è‹«å¯…é…‰ç€žå™¸å±¯æƒ‡æ•¦æ²Œè±šéé “å‘‘æ›‡éˆå¥ˆé‚£å†…ä¹å‡ªè–™è¬Žç˜æºé‹æ¥¢é¦´ç¸„ç•·å—æ¥ è»Ÿé›£æ±äºŒå°¼å¼è¿©åŒ‚è³‘è‚‰è™¹å»¿æ—¥ä¹³å…¥"
  ],
  [
    "c7a1",
    "å¦‚å°¿éŸ®ä»»å¦Šå¿èªæ¿¡ç¦°ç¥¢å¯§è‘±çŒ«ç†±å¹´å¿µæ»æ’šç‡ƒç²˜ä¹ƒå»¼ä¹‹åŸœåš¢æ‚©æ¿ƒç´èƒ½è„³è†¿è¾²è¦—èš¤å·´æŠŠæ’­è¦‡æ·æ³¢æ´¾ç¶ç ´å©†ç½µèŠ­é¦¬ä¿³å»ƒæ‹æŽ’æ•—æ¯ç›ƒç‰ŒèƒŒè‚ºè¼©é…å€åŸ¹åª’æ¢…æ¥³ç…¤ç‹½è²·å£²è³ é™ªé€™è¿ç§¤çŸ§è©ä¼¯å‰¥åšæ‹æŸæ³Šç™½ç®”ç²•èˆ¶è–„è¿«æ›æ¼ çˆ†ç¸›èŽ«é§éº¦"
  ],
  [
    "c8a1",
    "å‡½ç®±ç¡²ç®¸è‚‡ç­ˆæ«¨å¹¡è‚Œç•‘ç• å…«é‰¢æºŒç™ºé†—é«ªä¼ç½°æŠœç­é–¥é³©å™ºå¡™è›¤éš¼ä¼´åˆ¤åŠåå›å¸†æ¬æ–‘æ¿æ°¾æ±Žç‰ˆçŠ¯ç­ç•”ç¹èˆ¬è—©è²©ç¯„é‡†ç…©é ’é£¯æŒ½æ™©ç•ªç›¤ç£è•ƒè›®åŒªå‘å¦å¦ƒåº‡å½¼æ‚²æ‰‰æ‰¹æŠ«æ–æ¯”æ³Œç–²çš®ç¢‘ç§˜ç·‹ç½·è‚¥è¢«èª¹è²»é¿éžé£›æ¨‹ç°¸å‚™å°¾å¾®æž‡æ¯˜çµçœ‰ç¾Ž"
  ],
  [
    "c9a1",
    "é¼»æŸŠç¨—åŒ¹ç–‹é«­å½¦è†è±è‚˜å¼¼å¿…ç•¢ç­†é€¼æ¡§å§«åª›ç´ç™¾è¬¬ä¿µå½ªæ¨™æ°·æ¼‚ç“¢ç¥¨è¡¨è©•è±¹å»Ÿæç—…ç§’è‹—éŒ¨é‹²è’œè›­é°­å“å½¬æ–Œæµœç€•è²§è³“é »æ•ç“¶ä¸ä»˜åŸ å¤«å©¦å¯Œå†¨å¸ƒåºœæ€–æ‰¶æ•·æ–§æ™®æµ®çˆ¶ç¬¦è…è†šèŠ™è­œè² è³¦èµ´é˜œé™„ä¾®æ’«æ­¦èˆžè‘¡è•ªéƒ¨å°æ¥“é¢¨è‘ºè•—ä¼å‰¯å¾©å¹…æœ"
  ],
  [
    "caa1",
    "ç¦è…¹è¤‡è¦†æ·µå¼—æ‰•æ²¸ä»ç‰©é®’åˆ†å»å™´å¢³æ†¤æ‰®ç„šå¥®ç²‰ç³žç´›é›°æ–‡èžä¸™ä½µå…µå¡€å¹£å¹³å¼ŠæŸ„ä¸¦è”½é–‰é™›ç±³é åƒ»å£ç™–ç¢§åˆ¥çž¥è”‘ç®†åå¤‰ç‰‡ç¯‡ç·¨è¾ºè¿”éä¾¿å‹‰å¨©å¼éž­ä¿èˆ—é‹ªåœƒæ•æ­©ç”«è£œè¼”ç©‚å‹Ÿå¢“æ…•æˆŠæš®æ¯ç°¿è©å€£ä¿¸åŒ…å‘†å ±å¥‰å®å³°å³¯å´©åº–æŠ±æ§æ”¾æ–¹æœ‹"
  ],
  [
    "cba1",
    "æ³•æ³¡çƒ¹ç ²ç¸«èƒžèŠ³èŒè“¬èœ‚è¤’è¨ªè±Šé‚¦é‹’é£½é³³éµ¬ä¹äº¡å‚å‰–åŠå¦¨å¸½å¿˜å¿™æˆ¿æš´æœ›æŸæ£’å†’ç´¡è‚ªè†¨è¬€è²Œè²¿é‰¾é˜²å é ¬åŒ—åƒ•åœå¢¨æ’²æœ´ç‰§ç¦ç©†é‡¦å‹ƒæ²¡æ®†å €å¹Œå¥”æœ¬ç¿»å‡¡ç›†æ‘©ç£¨é­”éº»åŸ‹å¦¹æ˜§æžšæ¯Žå“©æ§™å¹•è†œæž•é®ªæŸ¾é±’æ¡äº¦ä¿£åˆæŠ¹æœ«æ²«è¿„ä¾­ç¹­éº¿ä¸‡æ…¢æº€"
  ],
  [
    "cca1",
    "æ¼«è”“å‘³æœªé­…å·³ç®•å²¬å¯†èœœæ¹Šè“‘ç¨”è„ˆå¦™ç²æ°‘çœ å‹™å¤¢ç„¡ç‰ŸçŸ›éœ§éµ¡æ¤‹å©¿å¨˜å†¥åå‘½æ˜Žç›Ÿè¿·éŠ˜é³´å§ªç‰æ»…å…æ£‰ç¶¿ç·¬é¢éººæ‘¸æ¨¡èŒ‚å¦„å­Ÿæ¯›çŒ›ç›²ç¶²è€—è’™å„²æœ¨é»™ç›®æ¢å‹¿é¤…å°¤æˆ»ç±¾è²°å•æ‚¶ç´‹é–€åŒä¹Ÿå†¶å¤œçˆºè€¶é‡Žå¼¥çŸ¢åŽ„å½¹ç´„è–¬è¨³èºé–æŸ³è–®é‘“æ„‰æ„ˆæ²¹ç™’"
  ],
  [
    "cda1",
    "è«­è¼¸å”¯ä½‘å„ªå‹‡å‹å®¥å¹½æ‚ æ†‚æ–æœ‰æŸšæ¹§æ¶ŒçŒ¶çŒ·ç”±ç¥è£•èª˜éŠé‚‘éƒµé›„èžå¤•äºˆä½™ä¸Žèª‰è¼¿é å‚­å¹¼å¦–å®¹åº¸æšæºæ“æ›œæ¥Šæ§˜æ´‹æº¶ç†”ç”¨çª¯ç¾Šè€€è‘‰è“‰è¦è¬¡è¸Šé¥é™½é¤Šæ…¾æŠ‘æ¬²æ²ƒæµ´ç¿Œç¿¼æ·€ç¾…èžºè£¸æ¥èŽ±é ¼é›·æ´›çµ¡è½é…ªä¹±åµåµæ¬„æ¿«è—è˜­è¦§åˆ©åå±¥æŽæ¢¨ç†ç’ƒ"
  ],
  [
    "cea1",
    "ç—¢è£è£¡é‡Œé›¢é™¸å¾‹çŽ‡ç«‹è‘ŽæŽ ç•¥åŠ‰æµæºœç‰ç•™ç¡«ç²’éš†ç«œé¾ä¾¶æ…®æ—…è™œäº†äº®åƒšä¸¡å‡Œå¯®æ–™æ¢æ¶¼çŒŸç™‚çž­ç¨œç³§è‰¯è«’é¼é‡é™µé ˜åŠ›ç·‘å€«åŽ˜æž—æ·‹ç‡ç³è‡¨è¼ªéš£é±—éºŸç‘ å¡æ¶™ç´¯é¡žä»¤ä¼¶ä¾‹å†·åŠ±å¶ºæ€œçŽ²ç¤¼è‹“éˆ´éš·é›¶éœŠéº—é½¢æš¦æ­´åˆ—åŠ£çƒˆè£‚å»‰æ‹æ†æ¼£ç…‰ç°¾ç·´è¯"
  ],
  [
    "cfa1",
    "è“®é€£éŒ¬å‘‚é­¯æ«“ç‚‰è³‚è·¯éœ²åŠ´å©å»Šå¼„æœ—æ¥¼æ¦”æµªæ¼ç‰¢ç‹¼ç¯­è€è¾è‹éƒŽå…­éº“ç¦„è‚‹éŒ²è«–å€­å’Œè©±æ­ªè³„è„‡æƒ‘æž é·²äº™äº˜é°è©«è—è•¨æ¤€æ¹¾ç¢—è…•"
  ],
  [
    "d0a1",
    "å¼Œä¸ä¸•ä¸ªä¸±ä¸¶ä¸¼ä¸¿ä¹‚ä¹–ä¹˜äº‚äº…è±«äºŠèˆ’å¼äºŽäºžäºŸäº äº¢äº°äº³äº¶ä»Žä»ä»„ä»†ä»‚ä»—ä»žä»­ä»Ÿä»·ä¼‰ä½šä¼°ä½›ä½ä½—ä½‡ä½¶ä¾ˆä¾ä¾˜ä½»ä½©ä½°ä¾‘ä½¯ä¾†ä¾–å„˜ä¿”ä¿Ÿä¿Žä¿˜ä¿›ä¿‘ä¿šä¿ä¿¤ä¿¥å€šå€¨å€”å€ªå€¥å€…ä¼œä¿¶å€¡å€©å€¬ä¿¾ä¿¯å€‘å€†åƒå‡æœƒå•ååˆåšå–å¬å¸å‚€å‚šå‚…å‚´å‚²"
  ],
  [
    "d1a1",
    "åƒ‰åƒŠå‚³åƒ‚åƒ–åƒžåƒ¥åƒ­åƒ£åƒ®åƒ¹åƒµå„‰å„å„‚å„–å„•å„”å„šå„¡å„ºå„·å„¼å„»å„¿å…€å…’å…Œå…”å…¢ç«¸å…©å…ªå…®å†€å†‚å›˜å†Œå†‰å†å†‘å†“å†•å†–å†¤å†¦å†¢å†©å†ªå†«å†³å†±å†²å†°å†µå†½å‡…å‡‰å‡›å‡ è™•å‡©å‡­å‡°å‡µå‡¾åˆ„åˆ‹åˆ”åˆŽåˆ§åˆªåˆ®åˆ³åˆ¹å‰å‰„å‰‹å‰Œå‰žå‰”å‰ªå‰´å‰©å‰³å‰¿å‰½åŠåŠ”åŠ’å‰±åŠˆåŠ‘è¾¨"
  ],
  [
    "d2a1",
    "è¾§åŠ¬åŠ­åŠ¼åŠµå‹å‹å‹—å‹žå‹£å‹¦é£­å‹ å‹³å‹µå‹¸å‹¹åŒ†åŒˆç”¸åŒåŒåŒåŒ•åŒšåŒ£åŒ¯åŒ±åŒ³åŒ¸å€å†å…ä¸—å‰åå‡–åžå©å®å¤˜å»å·åŽ‚åŽ–åŽ åŽ¦åŽ¥åŽ®åŽ°åŽ¶åƒç°’é›™åŸæ›¼ç‡®å®å¨å­åºåå½å‘€å¬å­å¼å®å¶å©åå‘Žå’å‘µå’Žå‘Ÿå‘±å‘·å‘°å’’å‘»å’€å‘¶å’„å’å’†å“‡å’¢å’¸å’¥å’¬å“„å“ˆå’¨"
  ],
  [
    "d3a1",
    "å’«å“‚å’¤å’¾å’¼å“˜å“¥å“¦å”å””å“½å“®å“­å“ºå“¢å”¹å•€å•£å•Œå”®å•œå•…å•–å•—å”¸å”³å•å–™å–€å’¯å–Šå–Ÿå•»å•¾å–˜å–žå–®å•¼å–ƒå–©å–‡å–¨å—šå—…å—Ÿå—„å—œå—¤å—”å˜”å—·å˜–å—¾å—½å˜›å—¹å™Žå™ç‡Ÿå˜´å˜¶å˜²å˜¸å™«å™¤å˜¯å™¬å™ªåš†åš€åšŠåš åš”åšåš¥åš®åš¶åš´å›‚åš¼å›å›ƒå›€å›ˆå›Žå›‘å›“å›—å›®å›¹åœ€å›¿åœ„åœ‰"
  ],
  [
    "d4a1",
    "åœˆåœ‹åœåœ“åœ˜åœ–å—‡åœœåœ¦åœ·åœ¸åŽåœ»å€åå©åŸ€åžˆå¡å¿åž‰åž“åž åž³åž¤åžªåž°åŸƒåŸ†åŸ”åŸ’åŸ“å ŠåŸ–åŸ£å ‹å ™å å¡²å ¡å¡¢å¡‹å¡°æ¯€å¡’å ½å¡¹å¢…å¢¹å¢Ÿå¢«å¢ºå£žå¢»å¢¸å¢®å£…å£“å£‘å£—å£™å£˜å£¥å£œå£¤å£Ÿå£¯å£ºå£¹å£»å£¼å£½å¤‚å¤Šå¤å¤›æ¢¦å¤¥å¤¬å¤­å¤²å¤¸å¤¾ç«’å¥•å¥å¥Žå¥šå¥˜å¥¢å¥ å¥§å¥¬å¥©"
  ],
  [
    "d5a1",
    "å¥¸å¦å¦ä½žä¾«å¦£å¦²å§†å§¨å§œå¦å§™å§šå¨¥å¨Ÿå¨‘å¨œå¨‰å¨šå©€å©¬å©‰å¨µå¨¶å©¢å©ªåªšåª¼åª¾å«‹å«‚åª½å«£å«—å«¦å«©å«–å«ºå«»å¬Œå¬‹å¬–å¬²å«å¬ªå¬¶å¬¾å­ƒå­…å­€å­‘å­•å­šå­›å­¥å­©å­°å­³å­µå­¸æ–ˆå­ºå®€å®ƒå®¦å®¸å¯ƒå¯‡å¯‰å¯”å¯å¯¤å¯¦å¯¢å¯žå¯¥å¯«å¯°å¯¶å¯³å°…å°‡å°ˆå°å°“å° å°¢å°¨å°¸å°¹å±å±†å±Žå±“"
  ],
  [
    "d6a1",
    "å±å±å­±å±¬å±®ä¹¢å±¶å±¹å²Œå²‘å²”å¦›å²«å²»å²¶å²¼å²·å³…å²¾å³‡å³™å³©å³½å³ºå³­å¶Œå³ªå´‹å´•å´—åµœå´Ÿå´›å´‘å´”å´¢å´šå´™å´˜åµŒåµ’åµŽåµ‹åµ¬åµ³åµ¶å¶‡å¶„å¶‚å¶¢å¶å¶¬å¶®å¶½å¶å¶·å¶¼å·‰å·å·“å·’å·–å·›å·«å·²å·µå¸‹å¸šå¸™å¸‘å¸›å¸¶å¸·å¹„å¹ƒå¹€å¹Žå¹—å¹”å¹Ÿå¹¢å¹¤å¹‡å¹µå¹¶å¹ºéº¼å¹¿åº å»å»‚å»ˆå»å»"
  ],
  [
    "d7a1",
    "å»–å»£å»å»šå»›å»¢å»¡å»¨å»©å»¬å»±å»³å»°å»´å»¸å»¾å¼ƒå¼‰å½å½œå¼‹å¼‘å¼–å¼©å¼­å¼¸å½å½ˆå½Œå½Žå¼¯å½‘å½–å½—å½™å½¡å½­å½³å½·å¾ƒå¾‚å½¿å¾Šå¾ˆå¾‘å¾‡å¾žå¾™å¾˜å¾ å¾¨å¾­å¾¼å¿–å¿»å¿¤å¿¸å¿±å¿æ‚³å¿¿æ€¡æ æ€™æ€æ€©æ€Žæ€±æ€›æ€•æ€«æ€¦æ€æ€ºæšææªæ·æŸæŠæ†ææ£æƒæ¤æ‚æ¬æ«æ™æ‚æ‚æƒ§æ‚ƒæ‚š"
  ],
  [
    "d8a1",
    "æ‚„æ‚›æ‚–æ‚—æ‚’æ‚§æ‚‹æƒ¡æ‚¸æƒ æƒ“æ‚´å¿°æ‚½æƒ†æ‚µæƒ˜æ…æ„•æ„†æƒ¶æƒ·æ„€æƒ´æƒºæ„ƒæ„¡æƒ»æƒ±æ„æ„Žæ…‡æ„¾æ„¨æ„§æ…Šæ„¿æ„¼æ„¬æ„´æ„½æ…‚æ…„æ…³æ…·æ…˜æ…™æ…šæ…«æ…´æ…¯æ…¥æ…±æ…Ÿæ…æ…“æ…µæ†™æ†–æ†‡æ†¬æ†”æ†šæ†Šæ†‘æ†«æ†®æ‡Œæ‡Šæ‡‰æ‡·æ‡ˆæ‡ƒæ‡†æ†ºæ‡‹ç½¹æ‡æ‡¦æ‡£æ‡¶æ‡ºæ‡´æ‡¿æ‡½æ‡¼æ‡¾æˆ€æˆˆæˆ‰æˆæˆŒæˆ”æˆ›"
  ],
  [
    "d9a1",
    "æˆžæˆ¡æˆªæˆ®æˆ°æˆ²æˆ³æ‰æ‰Žæ‰žæ‰£æ‰›æ‰ æ‰¨æ‰¼æŠ‚æŠ‰æ‰¾æŠ’æŠ“æŠ–æ‹”æŠƒæŠ”æ‹—æ‹‘æŠ»æ‹æ‹¿æ‹†æ“”æ‹ˆæ‹œæ‹Œæ‹Šæ‹‚æ‹‡æŠ›æ‹‰æŒŒæ‹®æ‹±æŒ§æŒ‚æŒˆæ‹¯æ‹µææŒ¾ææœææŽ–æŽŽæŽ€æŽ«æ¶æŽ£æŽæŽ‰æŽŸæŽµæ«æ©æŽ¾æ©æ€æ†æ£æ‰æ’æ¶æ„æ–æ´æ†æ“æ¦æ¶æ”æ—æ¨ææ‘§æ‘¯æ‘¶æ‘Žæ”ªæ’•æ’“æ’¥æ’©æ’ˆæ’¼"
  ],
  [
    "daa1",
    "æ“šæ“’æ“…æ“‡æ’»æ“˜æ“‚æ“±æ“§èˆ‰æ“ æ“¡æŠ¬æ“£æ“¯æ”¬æ“¶æ“´æ“²æ“ºæ”€æ“½æ”˜æ”œæ”…æ”¤æ”£æ”«æ”´æ”µæ”·æ”¶æ”¸ç•‹æ•ˆæ•–æ••æ•æ•˜æ•žæ•æ•²æ•¸æ–‚æ–ƒè®Šæ–›æ–Ÿæ–«æ–·æ—ƒæ—†æ—æ—„æ—Œæ—’æ—›æ—™æ— æ—¡æ—±æ²æ˜Šæ˜ƒæ—»æ³æ˜µæ˜¶æ˜´æ˜œæ™æ™„æ™‰æ™æ™žæ™æ™¤æ™§æ™¨æ™Ÿæ™¢æ™°æšƒæšˆæšŽæš‰æš„æš˜æšæ›æš¹æ›‰æš¾æš¼"
  ],
  [
    "dba1",
    "æ›„æš¸æ›–æ›šæ› æ˜¿æ›¦æ›©æ›°æ›µæ›·æœæœ–æœžæœ¦æœ§éœ¸æœ®æœ¿æœ¶ææœ¸æœ·æ†æžæ æ™æ£æ¤æž‰æ°æž©æ¼æªæžŒæž‹æž¦æž¡æž…æž·æŸ¯æž´æŸ¬æž³æŸ©æž¸æŸ¤æŸžæŸæŸ¢æŸ®æž¹æŸŽæŸ†æŸ§æªœæ žæ¡†æ ©æ¡€æ¡æ ²æ¡Žæ¢³æ «æ¡™æ¡£æ¡·æ¡¿æ¢Ÿæ¢æ¢­æ¢”æ¢æ¢›æ¢ƒæª®æ¢¹æ¡´æ¢µæ¢ æ¢ºæ¤æ¢æ¡¾æ¤æ£Šæ¤ˆæ£˜æ¤¢æ¤¦æ£¡æ¤Œæ£"
  ],
  [
    "dca1",
    "æ£”æ£§æ£•æ¤¶æ¤’æ¤„æ£—æ££æ¤¥æ£¹æ£ æ£¯æ¤¨æ¤ªæ¤šæ¤£æ¤¡æ£†æ¥¹æ¥·æ¥œæ¥¸æ¥«æ¥”æ¥¾æ¥®æ¤¹æ¥´æ¤½æ¥™æ¤°æ¥¡æ¥žæ¥æ¦æ¥ªæ¦²æ¦®æ§æ¦¿æ§æ§“æ¦¾æ§Žå¯¨æ§Šæ§æ¦»æ§ƒæ¦§æ¨®æ¦‘æ¦ æ¦œæ¦•æ¦´æ§žæ§¨æ¨‚æ¨›æ§¿æ¬Šæ§¹æ§²æ§§æ¨…æ¦±æ¨žæ§­æ¨”æ§«æ¨Šæ¨’æ«æ¨£æ¨“æ©„æ¨Œæ©²æ¨¶æ©¸æ©‡æ©¢æ©™æ©¦æ©ˆæ¨¸æ¨¢æªæªæª æª„æª¢æª£"
  ],
  [
    "dda1",
    "æª—è˜—æª»æ«ƒæ«‚æª¸æª³æª¬æ«žæ«‘æ«Ÿæªªæ«šæ«ªæ«»æ¬…è˜–æ«ºæ¬’æ¬–é¬±æ¬Ÿæ¬¸æ¬·ç›œæ¬¹é£®æ­‡æ­ƒæ­‰æ­æ­™æ­”æ­›æ­Ÿæ­¡æ­¸æ­¹æ­¿æ®€æ®„æ®ƒæ®æ®˜æ®•æ®žæ®¤æ®ªæ®«æ®¯æ®²æ®±æ®³æ®·æ®¼æ¯†æ¯‹æ¯“æ¯Ÿæ¯¬æ¯«æ¯³æ¯¯éº¾æ°ˆæ°“æ°”æ°›æ°¤æ°£æ±žæ±•æ±¢æ±ªæ²‚æ²æ²šæ²æ²›æ±¾æ±¨æ±³æ²’æ²æ³„æ³±æ³“æ²½æ³—æ³…æ³æ²®æ²±æ²¾"
  ],
  [
    "dea1",
    "æ²ºæ³›æ³¯æ³™æ³ªæ´Ÿè¡æ´¶æ´«æ´½æ´¸æ´™æ´µæ´³æ´’æ´Œæµ£æ¶“æµ¤æµšæµ¹æµ™æ¶Žæ¶•æ¿¤æ¶…æ·¹æ¸•æ¸Šæ¶µæ·‡æ·¦æ¶¸æ·†æ·¬æ·žæ·Œæ·¨æ·’æ·…æ·ºæ·™æ·¤æ·•æ·ªæ·®æ¸­æ¹®æ¸®æ¸™æ¹²æ¹Ÿæ¸¾æ¸£æ¹«æ¸«æ¹¶æ¹æ¸Ÿæ¹ƒæ¸ºæ¹Žæ¸¤æ»¿æ¸æ¸¸æº‚æºªæº˜æ»‰æº·æ»“æº½æº¯æ»„æº²æ»”æ»•æºæº¥æ»‚æºŸæ½æ¼‘çŒæ»¬æ»¸æ»¾æ¼¿æ»²æ¼±æ»¯æ¼²æ»Œ"
  ],
  [
    "dfa1",
    "æ¼¾æ¼“æ»·æ¾†æ½ºæ½¸æ¾æ¾€æ½¯æ½›æ¿³æ½­æ¾‚æ½¼æ½˜æ¾Žæ¾‘æ¿‚æ½¦æ¾³æ¾£æ¾¡æ¾¤æ¾¹æ¿†æ¾ªæ¿Ÿæ¿•æ¿¬æ¿”æ¿˜æ¿±æ¿®æ¿›ç€‰ç€‹æ¿ºç€‘ç€ç€æ¿¾ç€›ç€šæ½´ç€ç€˜ç€Ÿç€°ç€¾ç€²ç‘ç£ç‚™ç‚’ç‚¯çƒ±ç‚¬ç‚¸ç‚³ç‚®çƒŸçƒ‹çƒçƒ™ç„‰çƒ½ç„œç„™ç…¥ç…•ç†ˆç…¦ç…¢ç…Œç…–ç…¬ç†ç‡»ç†„ç†•ç†¨ç†¬ç‡—ç†¹ç†¾ç‡’ç‡‰ç‡”ç‡Žç‡ ç‡¬ç‡§ç‡µç‡¼"
  ],
  [
    "e0a1",
    "ç‡¹ç‡¿çˆçˆçˆ›çˆ¨çˆ­çˆ¬çˆ°çˆ²çˆ»çˆ¼çˆ¿ç‰€ç‰†ç‰‹ç‰˜ç‰´ç‰¾çŠ‚çŠçŠ‡çŠ’çŠ–çŠ¢çŠ§çŠ¹çŠ²ç‹ƒç‹†ç‹„ç‹Žç‹’ç‹¢ç‹ ç‹¡ç‹¹ç‹·å€çŒ—çŒŠçŒœçŒ–çŒçŒ´çŒ¯çŒ©çŒ¥çŒ¾çŽçé»˜ç—çªç¨ç°ç¸çµç»çºçˆçŽ³çŽçŽ»ç€ç¥ç®çžç’¢ç…ç‘¯ç¥ç¸ç²çºç‘•ç¿ç‘Ÿç‘™ç‘ç‘œç‘©ç‘°ç‘£ç‘ªç‘¶ç‘¾ç’‹ç’žç’§ç“Šç“ç“”ç±"
  ],
  [
    "e1a1",
    "ç“ ç“£ç“§ç“©ç“®ç“²ç“°ç“±ç“¸ç“·ç”„ç”ƒç”…ç”Œç”Žç”ç”•ç”“ç”žç”¦ç”¬ç”¼ç•„ç•ç•Šç•‰ç•›ç•†ç•šç•©ç•¤ç•§ç•«ç•­ç•¸ç•¶ç–†ç–‡ç•´ç–Šç–‰ç–‚ç–”ç–šç–ç–¥ç–£ç—‚ç–³ç—ƒç–µç–½ç–¸ç–¼ç–±ç—ç—Šç—’ç—™ç—£ç—žç—¾ç—¿ç—¼ç˜ç—°ç—ºç—²ç—³ç˜‹ç˜ç˜‰ç˜Ÿç˜§ç˜ ç˜¡ç˜¢ç˜¤ç˜´ç˜°ç˜»ç™‡ç™ˆç™†ç™œç™˜ç™¡ç™¢ç™¨ç™©ç™ªç™§ç™¬ç™°"
  ],
  [
    "e2a1",
    "ç™²ç™¶ç™¸ç™¼çš€çšƒçšˆçš‹çšŽçš–çš“çš™çššçš°çš´çš¸çš¹çšºç›‚ç›ç›–ç›’ç›žç›¡ç›¥ç›§ç›ªè˜¯ç›»çœˆçœ‡çœ„çœ©çœ¤çœžçœ¥çœ¦çœ›çœ·çœ¸ç‡çšç¨ç«ç›ç¥ç¿ç¾ç¹çžŽçž‹çž‘çž çžžçž°çž¶çž¹çž¿çž¼çž½çž»çŸ‡çŸçŸ—çŸšçŸœçŸ£çŸ®çŸ¼ç Œç ’ç¤¦ç  ç¤ªç¡…ç¢Žç¡´ç¢†ç¡¼ç¢šç¢Œç¢£ç¢µç¢ªç¢¯ç£‘ç£†ç£‹ç£”ç¢¾ç¢¼ç£…ç£Šç£¬"
  ],
  [
    "e3a1",
    "ç£§ç£šç£½ç£´ç¤‡ç¤’ç¤‘ç¤™ç¤¬ç¤«ç¥€ç¥ ç¥—ç¥Ÿç¥šç¥•ç¥“ç¥ºç¥¿ç¦Šç¦ç¦§é½‹ç¦ªç¦®ç¦³ç¦¹ç¦ºç§‰ç§•ç§§ç§¬ç§¡ç§£ç¨ˆç¨ç¨˜ç¨™ç¨ ç¨Ÿç¦€ç¨±ç¨»ç¨¾ç¨·ç©ƒç©—ç©‰ç©¡ç©¢ç©©é¾ç©°ç©¹ç©½çªˆçª—çª•çª˜çª–çª©ç«ˆçª°çª¶ç«…ç«„çª¿é‚ƒç«‡ç«Šç«ç«ç«•ç«“ç«™ç«šç«ç«¡ç«¢ç«¦ç«­ç«°ç¬‚ç¬ç¬Šç¬†ç¬³ç¬˜ç¬™ç¬žç¬µç¬¨ç¬¶ç­"
  ],
  [
    "e4a1",
    "ç­ºç¬„ç­ç¬‹ç­Œç­…ç­µç­¥ç­´ç­§ç­°ç­±ç­¬ç­®ç®ç®˜ç®Ÿç®ç®œç®šç®‹ç®’ç®ç­ç®™ç¯‹ç¯ç¯Œç¯ç®´ç¯†ç¯ç¯©ç°‘ç°”ç¯¦ç¯¥ç± ç°€ç°‡ç°“ç¯³ç¯·ç°—ç°ç¯¶ç°£ç°§ç°ªç°Ÿç°·ç°«ç°½ç±Œç±ƒç±”ç±ç±€ç±ç±˜ç±Ÿç±¤ç±–ç±¥ç±¬ç±µç²ƒç²ç²¤ç²­ç²¢ç²«ç²¡ç²¨ç²³ç²²ç²±ç²®ç²¹ç²½ç³€ç³…ç³‚ç³˜ç³’ç³œç³¢é¬»ç³¯ç³²ç³´ç³¶ç³ºç´†"
  ],
  [
    "e5a1",
    "ç´‚ç´œç´•ç´Šçµ…çµ‹ç´®ç´²ç´¿ç´µçµ†çµ³çµ–çµŽçµ²çµ¨çµ®çµçµ£ç¶“ç¶‰çµ›ç¶çµ½ç¶›ç¶ºç¶®ç¶£ç¶µç·‡ç¶½ç¶«ç¸½ç¶¢ç¶¯ç·œç¶¸ç¶Ÿç¶°ç·˜ç·ç·¤ç·žç·»ç·²ç·¡ç¸…ç¸Šç¸£ç¸¡ç¸’ç¸±ç¸Ÿç¸‰ç¸‹ç¸¢ç¹†ç¹¦ç¸»ç¸µç¸¹ç¹ƒç¸·ç¸²ç¸ºç¹§ç¹ç¹–ç¹žç¹™ç¹šç¹¹ç¹ªç¹©ç¹¼ç¹»çºƒç·•ç¹½è¾®ç¹¿çºˆçº‰çºŒçº’çºçº“çº”çº–çºŽçº›çºœç¼¸ç¼º"
  ],
  [
    "e6a1",
    "ç½…ç½Œç½ç½Žç½ç½‘ç½•ç½”ç½˜ç½Ÿç½ ç½¨ç½©ç½§ç½¸ç¾‚ç¾†ç¾ƒç¾ˆç¾‡ç¾Œç¾”ç¾žç¾ç¾šç¾£ç¾¯ç¾²ç¾¹ç¾®ç¾¶ç¾¸è­±ç¿…ç¿†ç¿Šç¿•ç¿”ç¿¡ç¿¦ç¿©ç¿³ç¿¹é£œè€†è€„è€‹è€’è€˜è€™è€œè€¡è€¨è€¿è€»èŠè†è’è˜èšèŸè¢è¨è³è²è°è¶è¹è½è¿è‚„è‚†è‚…è‚›è‚“è‚šè‚­å†è‚¬èƒ›èƒ¥èƒ™èƒèƒ„èƒšèƒ–è„‰èƒ¯èƒ±è„›è„©è„£è„¯è…‹"
  ],
  [
    "e7a1",
    "éš‹è…†è„¾è…“è…‘èƒ¼è…±è…®è…¥è…¦è…´è†ƒè†ˆè†Šè†€è†‚è† è†•è†¤è†£è…Ÿè†“è†©è†°è†µè†¾è†¸è†½è‡€è‡‚è†ºè‡‰è‡è‡‘è‡™è‡˜è‡ˆè‡šè‡Ÿè‡ è‡§è‡ºè‡»è‡¾èˆèˆ‚èˆ…èˆ‡èˆŠèˆèˆèˆ–èˆ©èˆ«èˆ¸èˆ³è‰€è‰™è‰˜è‰è‰šè‰Ÿè‰¤è‰¢è‰¨è‰ªè‰«èˆ®è‰±è‰·è‰¸è‰¾èŠèŠ’èŠ«èŠŸèŠ»èŠ¬è‹¡è‹£è‹Ÿè‹’è‹´è‹³è‹ºèŽ“èŒƒè‹»è‹¹è‹žèŒ†è‹œèŒ‰è‹™"
  ],
  [
    "e8a1",
    "èŒµèŒ´èŒ–èŒ²èŒ±è€èŒ¹èè…èŒ¯èŒ«èŒ—èŒ˜èŽ…èŽšèŽªèŽŸèŽ¢èŽ–èŒ£èŽŽèŽ‡èŽŠè¼èŽµè³èµèŽ èŽ‰èŽ¨è´è“è«èŽè½èƒè˜è‹èè·è‡è è²èè¢è èŽ½è¸è”†è»è‘­èªè¼è•šè’„è‘·è‘«è’­è‘®è’‚è‘©è‘†è¬è‘¯è‘¹èµè“Šè‘¢è’¹è’¿è’Ÿè“™è“è’»è“šè“è“è“†è“–è’¡è”¡è“¿è“´è”—è”˜è”¬è”Ÿè”•è””è“¼è•€è•£è•˜è•ˆ"
  ],
  [
    "e9a1",
    "è•è˜‚è•‹è••è–€è–¤è–ˆè–‘è–Šè–¨è•­è–”è–›è—ªè–‡è–œè•·è•¾è–è—‰è–ºè—è–¹è—è—•è—è—¥è—œè—¹è˜Šè˜“è˜‹è—¾è—ºè˜†è˜¢è˜šè˜°è˜¿è™ä¹•è™”è™Ÿè™§è™±èš“èš£èš©èšªèš‹èšŒèš¶èš¯è›„è›†èš°è›‰è £èš«è›”è›žè›©è›¬è›Ÿè››è›¯èœ’èœ†èœˆèœ€èœƒè›»èœ‘èœ‰èœè›¹èœŠèœ´èœ¿èœ·èœ»èœ¥èœ©èœšè èŸè¸èŒèŽè´è—è¨è®è™"
  ],
  [
    "eaa1",
    "è“è£èªè …èž¢èžŸèž‚èž¯èŸ‹èž½èŸ€èŸé›–èž«èŸ„èž³èŸ‡èŸ†èž»èŸ¯èŸ²èŸ è è èŸ¾èŸ¶èŸ·è ŽèŸ’è ‘è –è •è ¢è ¡è ±è ¶è ¹è §è »è¡„è¡‚è¡’è¡™è¡žè¡¢è¡«è¢è¡¾è¢žè¡µè¡½è¢µè¡²è¢‚è¢—è¢’è¢®è¢™è¢¢è¢è¢¤è¢°è¢¿è¢±è£ƒè£„è£”è£˜è£™è£è£¹è¤‚è£¼è£´è£¨è£²è¤„è¤Œè¤Šè¤“è¥ƒè¤žè¤¥è¤ªè¤«è¥è¥„è¤»è¤¶è¤¸è¥Œè¤è¥ è¥ž"
  ],
  [
    "eba1",
    "è¥¦è¥¤è¥­è¥ªè¥¯è¥´è¥·è¥¾è¦ƒè¦ˆè¦Šè¦“è¦˜è¦¡è¦©è¦¦è¦¬è¦¯è¦²è¦ºè¦½è¦¿è§€è§šè§œè§è§§è§´è§¸è¨ƒè¨–è¨è¨Œè¨›è¨è¨¥è¨¶è©è©›è©’è©†è©ˆè©¼è©­è©¬è©¢èª…èª‚èª„èª¨èª¡èª‘èª¥èª¦èªšèª£è«„è«è«‚è«šè««è«³è«§è«¤è«±è¬”è« è«¢è«·è«žè«›è¬Œè¬‡è¬šè«¡è¬–è¬è¬—è¬ è¬³éž«è¬¦è¬«è¬¾è¬¨è­è­Œè­è­Žè­‰è­–è­›è­šè­«"
  ],
  [
    "eca1",
    "è­Ÿè­¬è­¯è­´è­½è®€è®Œè®Žè®’è®“è®–è®™è®šè°ºè±è°¿è±ˆè±Œè±Žè±è±•è±¢è±¬è±¸è±ºè²‚è²‰è²…è²Šè²è²Žè²”è±¼è²˜æˆè²­è²ªè²½è²²è²³è²®è²¶è³ˆè³è³¤è³£è³šè³½è³ºè³»è´„è´…è´Šè´‡è´è´è´é½Žè´“è³è´”è´–èµ§èµ­èµ±èµ³è¶è¶™è·‚è¶¾è¶ºè·è·šè·–è·Œè·›è·‹è·ªè·«è·Ÿè·£è·¼è¸ˆè¸‰è·¿è¸è¸žè¸è¸Ÿè¹‚è¸µè¸°è¸´è¹Š"
  ],
  [
    "eda1",
    "è¹‡è¹‰è¹Œè¹è¹ˆè¹™è¹¤è¹ è¸ªè¹£è¹•è¹¶è¹²è¹¼èºèº‡èº…èº„èº‹èºŠèº“èº‘èº”èº™èºªèº¡èº¬èº°è»†èº±èº¾è»…è»ˆè»‹è»›è»£è»¼è»»è»«è»¾è¼Šè¼…è¼•è¼’è¼™è¼“è¼œè¼Ÿè¼›è¼Œè¼¦è¼³è¼»è¼¹è½…è½‚è¼¾è½Œè½‰è½†è½Žè½—è½œè½¢è½£è½¤è¾œè¾Ÿè¾£è¾­è¾¯è¾·è¿šè¿¥è¿¢è¿ªè¿¯é‚‡è¿´é€…è¿¹è¿ºé€‘é€•é€¡é€é€žé€–é€‹é€§é€¶é€µé€¹è¿¸"
  ],
  [
    "eea1",
    "ééé‘é’é€Žé‰é€¾é–é˜éžé¨é¯é¶éš¨é²é‚‚é½é‚é‚€é‚Šé‚‰é‚é‚¨é‚¯é‚±é‚µéƒ¢éƒ¤æ‰ˆéƒ›é„‚é„’é„™é„²é„°é…Šé…–é…˜é…£é…¥é…©é…³é…²é†‹é†‰é†‚é†¢é†«é†¯é†ªé†µé†´é†ºé‡€é‡é‡‰é‡‹é‡é‡–é‡Ÿé‡¡é‡›é‡¼é‡µé‡¶éˆžé‡¿éˆ”éˆ¬éˆ•éˆ‘é‰žé‰—é‰…é‰‰é‰¤é‰ˆéŠ•éˆ¿é‰‹é‰éŠœéŠ–éŠ“éŠ›é‰šé‹éŠ¹éŠ·é‹©éŒé‹ºé„éŒ®"
  ],
  [
    "efa1",
    "éŒ™éŒ¢éŒšéŒ£éŒºéŒµéŒ»éœé é¼é®é–éŽ°éŽ¬éŽ­éŽ”éŽ¹é–é—é¨é¥é˜éƒéééˆé¤éšé”é“éƒé‡éé¶é«éµé¡éºé‘é‘’é‘„é‘›é‘ é‘¢é‘žé‘ªéˆ©é‘°é‘µé‘·é‘½é‘šé‘¼é‘¾é’é‘¿é–‚é–‡é–Šé–”é––é–˜é–™é– é–¨é–§é–­é–¼é–»é–¹é–¾é—Šæ¿¶é—ƒé—é—Œé—•é—”é—–é—œé—¡é—¥é—¢é˜¡é˜¨é˜®é˜¯é™‚é™Œé™é™‹é™·é™œé™ž"
  ],
  [
    "f0a1",
    "é™é™Ÿé™¦é™²é™¬éšéš˜éš•éš—éšªéš§éš±éš²éš°éš´éš¶éš¸éš¹é›Žé›‹é›‰é›è¥é›œéœé›•é›¹éœ„éœ†éœˆéœ“éœŽéœ‘éœéœ–éœ™éœ¤éœªéœ°éœ¹éœ½éœ¾é„é†éˆé‚é‰éœé é¤é¦é¨å‹’é«é±é¹éž…é¼éžéºéž†éž‹éžéžéžœéž¨éž¦éž£éž³éž´éŸƒéŸ†éŸˆéŸ‹éŸœéŸ­é½éŸ²ç«ŸéŸ¶éŸµé é Œé ¸é ¤é ¡é ·é ½é¡†é¡é¡‹é¡«é¡¯é¡°"
  ],
  [
    "f1a1",
    "é¡±é¡´é¡³é¢ªé¢¯é¢±é¢¶é£„é£ƒé£†é£©é£«é¤ƒé¤‰é¤’é¤”é¤˜é¤¡é¤é¤žé¤¤é¤ é¤¬é¤®é¤½é¤¾é¥‚é¥‰é¥…é¥é¥‹é¥‘é¥’é¥Œé¥•é¦—é¦˜é¦¥é¦­é¦®é¦¼é§Ÿé§›é§é§˜é§‘é§­é§®é§±é§²é§»é§¸é¨é¨é¨…é§¢é¨™é¨«é¨·é©…é©‚é©€é©ƒé¨¾é©•é©é©›é©—é©Ÿé©¢é©¥é©¤é©©é©«é©ªéª­éª°éª¼é«€é«é«‘é«“é«”é«žé«Ÿé«¢é«£é«¦é«¯é««é«®é«´é«±é«·"
  ],
  [
    "f2a1",
    "é«»é¬†é¬˜é¬šé¬Ÿé¬¢é¬£é¬¥é¬§é¬¨é¬©é¬ªé¬®é¬¯é¬²é­„é­ƒé­é­é­Žé­‘é­˜é­´é®“é®ƒé®‘é®–é®—é®Ÿé® é®¨é®´é¯€é¯Šé®¹é¯†é¯é¯‘é¯’é¯£é¯¢é¯¤é¯”é¯¡é°ºé¯²é¯±é¯°é°•é°”é°‰é°“é°Œé°†é°ˆé°’é°Šé°„é°®é°›é°¥é°¤é°¡é°°é±‡é°²é±†é°¾é±šé± é±§é±¶é±¸é³§é³¬é³°é´‰é´ˆé³«é´ƒé´†é´ªé´¦é¶¯é´£é´Ÿéµ„é´•é´’éµé´¿é´¾éµ†éµˆ"
  ],
  [
    "f3a1",
    "éµéµžéµ¤éµ‘éµéµ™éµ²é¶‰é¶‡é¶«éµ¯éµºé¶šé¶¤é¶©é¶²é·„é·é¶»é¶¸é¶ºé·†é·é·‚é·™é·“é·¸é·¦é·­é·¯é·½é¸šé¸›é¸žé¹µé¹¹é¹½éºéºˆéº‹éºŒéº’éº•éº‘éºéº¥éº©éº¸éºªéº­é¡é»Œé»Žé»é»é»”é»œé»žé»é» é»¥é»¨é»¯é»´é»¶é»·é»¹é»»é»¼é»½é¼‡é¼ˆçš·é¼•é¼¡é¼¬é¼¾é½Šé½’é½”é½£é½Ÿé½ é½¡é½¦é½§é½¬é½ªé½·é½²é½¶é¾•é¾œé¾ "
  ],
  [
    "f4a1",
    "å ¯æ§‡é™ç‘¤å‡œç†™"
  ],
  [
    "f9a1",
    "çºŠè¤œéˆéŠˆè“œä¿‰ç‚»æ˜±æ£ˆé‹¹æ›»å½…ä¸¨ä»¡ä»¼ä¼€ä¼ƒä¼¹ä½–ä¾’ä¾Šä¾šä¾”ä¿å€å€¢ä¿¿å€žå†å°å‚å‚”åƒ´åƒ˜å…Šå…¤å†å†¾å‡¬åˆ•åŠœåŠ¦å‹€å‹›åŒ€åŒ‡åŒ¤å²åŽ“åŽ²åï¨Žå’œå’Šå’©å“¿å–†å™å¥åž¬åŸˆåŸ‡ï¨ï¨å¢žå¢²å¤‹å¥“å¥›å¥å¥£å¦¤å¦ºå­–å¯€ç”¯å¯˜å¯¬å°žå²¦å²ºå³µå´§åµ“ï¨‘åµ‚åµ­å¶¸å¶¹å·å¼¡å¼´å½§å¾·"
  ],
  [
    "faa1",
    "å¿žææ‚…æ‚Šæƒžæƒ•æ„ æƒ²æ„‘æ„·æ„°æ†˜æˆ“æŠ¦æµæ‘ æ’æ“Žæ•Žæ˜€æ˜•æ˜»æ˜‰æ˜®æ˜žæ˜¤æ™¥æ™—æ™™ï¨’æ™³æš™æš æš²æš¿æ›ºæœŽï¤©æ¦æž»æ¡’æŸ€æ æ¡„æ£ï¨“æ¥¨ï¨”æ¦˜æ§¢æ¨°æ©«æ©†æ©³æ©¾æ«¢æ«¤æ¯–æ°¿æ±œæ²†æ±¯æ³šæ´„æ¶‡æµ¯æ¶–æ¶¬æ·æ·¸æ·²æ·¼æ¸¹æ¹œæ¸§æ¸¼æº¿æ¾ˆæ¾µæ¿µç€…ç€‡ç€¨ç‚…ç‚«ç„ç„„ç…œç…†ç…‡ï¨•ç‡ç‡¾çŠ±"
  ],
  [
    "fba1",
    "çŠ¾çŒ¤ï¨–ç·çŽ½ç‰ç–ç£ç’ç‡çµç¦çªç©ç®ç‘¢ç’‰ç’Ÿç”ç•¯çš‚çšœçšžçš›çš¦ï¨—ç†åŠ¯ç ¡ç¡Žç¡¤ç¡ºç¤°ï¨˜ï¨™ï¨šç¦”ï¨›ç¦›ç«‘ç«§ï¨œç««ç®žï¨çµˆçµœç¶·ç¶ ç·–ç¹’ç½‡ç¾¡ï¨žèŒè¢è¿è‡è¶è‘ˆè’´è•“è•™è•«ï¨Ÿè–°ï¨ ï¨¡è ‡è£µè¨’è¨·è©¹èª§èª¾è«Ÿï¨¢è«¶è­“è­¿è³°è³´è´’èµ¶ï¨£è»ï¨¤ï¨¥é§éƒžï¨¦é„•é„§é‡š"
  ],
  [
    "fca1",
    "é‡—é‡žé‡­é‡®é‡¤é‡¥éˆ†éˆéˆŠéˆºé‰€éˆ¼é‰Žé‰™é‰‘éˆ¹é‰§éŠ§é‰·é‰¸é‹§é‹—é‹™é‹ï¨§é‹•é‹ é‹“éŒ¥éŒ¡é‹»ï¨¨éŒžé‹¿éŒéŒ‚é°é—éŽ¤é†éžé¸é±é‘…é‘ˆé–’ï§œï¨©éšéš¯éœ³éœ»éƒééé‘é•é¡—é¡¥ï¨ªï¨«é¤§ï¨¬é¦žé©Žé«™é«œé­µé­²é®é®±é®»é°€éµ°éµ«ï¨­é¸™é»‘"
  ],
  [
    "fcf1",
    "â…°",
    9,
    "ï¿¢ï¿¤ï¼‡ï¼‚"
  ],
  [
    "8fa2af",
    "Ë˜Ë‡Â¸Ë™ËÂ¯Ë›Ëšï½žÎ„Î…"
  ],
  [
    "8fa2c2",
    "Â¡Â¦Â¿"
  ],
  [
    "8fa2eb",
    "ÂºÂªÂ©Â®â„¢Â¤â„–"
  ],
  [
    "8fa6e1",
    "Î†ÎˆÎ‰ÎŠÎª"
  ],
  [
    "8fa6e7",
    "ÎŒ"
  ],
  [
    "8fa6e9",
    "ÎŽÎ«"
  ],
  [
    "8fa6ec",
    "Î"
  ],
  [
    "8fa6f1",
    "Î¬Î­Î®Î¯ÏŠÎÏŒÏ‚ÏÏ‹Î°ÏŽ"
  ],
  [
    "8fa7c2",
    "Ð‚",
    10,
    "ÐŽÐ"
  ],
  [
    "8fa7f2",
    "Ñ’",
    10,
    "ÑžÑŸ"
  ],
  [
    "8fa9a1",
    "Ã†Ä"
  ],
  [
    "8fa9a4",
    "Ä¦"
  ],
  [
    "8fa9a6",
    "Ä²"
  ],
  [
    "8fa9a8",
    "ÅÄ¿"
  ],
  [
    "8fa9ab",
    "ÅŠÃ˜Å’"
  ],
  [
    "8fa9af",
    "Å¦Ãž"
  ],
  [
    "8fa9c1",
    "Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å‚Å€Å‰Å‹Ã¸Å“ÃŸÅ§Ã¾"
  ],
  [
    "8faaa1",
    "ÃÃ€Ã„Ã‚Ä‚ÇÄ€Ä„Ã…ÃƒÄ†ÄˆÄŒÃ‡ÄŠÄŽÃ‰ÃˆÃ‹ÃŠÄšÄ–Ä’Ä˜"
  ],
  [
    "8faaba",
    "ÄœÄžÄ¢Ä Ä¤ÃÃŒÃÃŽÇÄ°ÄªÄ®Ä¨Ä´Ä¶Ä¹Ä½Ä»ÅƒÅ‡Å…Ã‘Ã“Ã’Ã–Ã”Ç‘ÅÅŒÃ•Å”Å˜Å–ÅšÅœÅ ÅžÅ¤Å¢ÃšÃ™ÃœÃ›Å¬Ç“Å°ÅªÅ²Å®Å¨Ç—Ç›Ç™Ç•Å´ÃÅ¸Å¶Å¹Å½Å»"
  ],
  [
    "8faba1",
    "Ã¡Ã Ã¤Ã¢ÄƒÇŽÄÄ…Ã¥Ã£Ä‡Ä‰ÄÃ§Ä‹ÄÃ©Ã¨Ã«ÃªÄ›Ä—Ä“Ä™ÇµÄÄŸ"
  ],
  [
    "8fabbd",
    "Ä¡Ä¥Ã­Ã¬Ã¯Ã®Ç"
  ],
  [
    "8fabc5",
    "Ä«Ä¯Ä©ÄµÄ·ÄºÄ¾Ä¼Å„ÅˆÅ†Ã±Ã³Ã²Ã¶Ã´Ç’Å‘ÅÃµÅ•Å™Å—Å›ÅÅ¡ÅŸÅ¥Å£ÃºÃ¹Ã¼Ã»Å­Ç”Å±Å«Å³Å¯Å©Ç˜ÇœÇšÇ–ÅµÃ½Ã¿Å·ÅºÅ¾Å¼"
  ],
  [
    "8fb0a1",
    "ä¸‚ä¸„ä¸…ä¸Œä¸’ä¸Ÿä¸£ä¸¤ä¸¨ä¸«ä¸®ä¸¯ä¸°ä¸µä¹€ä¹ä¹„ä¹‡ä¹‘ä¹šä¹œä¹£ä¹¨ä¹©ä¹´ä¹µä¹¹ä¹¿äºäº–äº—äºäº¯äº¹ä»ƒä»ä»šä»›ä» ä»¡ä»¢ä»¨ä»¯ä»±ä»³ä»µä»½ä»¾ä»¿ä¼€ä¼‚ä¼ƒä¼ˆä¼‹ä¼Œä¼’ä¼•ä¼–ä¼—ä¼™ä¼®ä¼±ä½ ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾ä½€ä½‚ä½ˆä½‰ä½‹ä½Œä½’ä½”ä½–ä½˜ä½Ÿä½£ä½ªä½¬ä½®ä½±ä½·ä½¸ä½¹ä½ºä½½ä½¾ä¾ä¾‚ä¾„"
  ],
  [
    "8fb1a1",
    "ä¾…ä¾‰ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾”ä¾—ä¾™ä¾šä¾žä¾Ÿä¾²ä¾·ä¾¹ä¾»ä¾¼ä¾½ä¾¾ä¿€ä¿ä¿…ä¿†ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿ä¿’ä¿œä¿ ä¿¢ä¿°ä¿²ä¿¼ä¿½ä¿¿å€€å€å€„å€‡å€Šå€Œå€Žå€å€“å€—å€˜å€›å€œå€å€žå€¢å€§å€®å€°å€²å€³å€µå€åå‚å…å†åŠåŒåŽå‘å’å“å—å™åŸå å¢å£å¦å§åªå­å°å±å€»å‚å‚ƒå‚„å‚†å‚Šå‚Žå‚å‚"
  ],
  [
    "8fb2a1",
    "å‚’å‚“å‚”å‚–å‚›å‚œå‚ž",
    4,
    "å‚ªå‚¯å‚°å‚¹å‚ºå‚½åƒ€åƒƒåƒ„åƒ‡åƒŒåƒŽåƒåƒ“åƒ”åƒ˜åƒœåƒåƒŸåƒ¢åƒ¤åƒ¦åƒ¨åƒ©åƒ¯åƒ±åƒ¶åƒºåƒ¾å„ƒå„†å„‡å„ˆå„‹å„Œå„å„Žåƒ²å„å„—å„™å„›å„œå„å„žå„£å„§å„¨å„¬å„­å„¯å„±å„³å„´å„µå„¸å„¹å…‚å…Šå…å…“å…•å…—å…˜å…Ÿå…¤å…¦å…¾å†ƒå†„å†‹å†Žå†˜å†å†¡å†£å†­å†¸å†ºå†¼å†¾å†¿å‡‚"
  ],
  [
    "8fb3a1",
    "å‡ˆå‡å‡‘å‡’å‡“å‡•å‡˜å‡žå‡¢å‡¥å‡®å‡²å‡³å‡´å‡·åˆåˆ‚åˆ…åˆ’åˆ“åˆ•åˆ–åˆ˜åˆ¢åˆ¨åˆ±åˆ²åˆµåˆ¼å‰…å‰‰å‰•å‰—å‰˜å‰šå‰œå‰Ÿå‰ å‰¡å‰¦å‰®å‰·å‰¸å‰¹åŠ€åŠ‚åŠ…åŠŠåŠŒåŠ“åŠ•åŠ–åŠ—åŠ˜åŠšåŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ¯åŠ°åŠ¶åŠ·åŠ¸åŠºåŠ»åŠ½å‹€å‹„å‹†å‹ˆå‹Œå‹å‹‘å‹”å‹–å‹›å‹œå‹¡å‹¥å‹¨å‹©å‹ªå‹¬å‹°å‹±å‹´å‹¶å‹·åŒ€åŒƒåŒŠåŒ‹"
  ],
  [
    "8fb4a1",
    "åŒŒåŒ‘åŒ“åŒ˜åŒ›åŒœåŒžåŒŸåŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ°åŒ²åŒµåŒ¼åŒ½åŒ¾å‚åŒå‹å™å›å¡å£å¥å¬å­å²å¹å¾åŽƒåŽ‡åŽˆåŽŽåŽ“åŽ”åŽ™åŽåŽ¡åŽ¤åŽªåŽ«åŽ¯åŽ²åŽ´åŽµåŽ·åŽ¸åŽºåŽ½å€å…åå’å“å•åšååžå å¦å§åµå‚å“åšå¡å§å¨åªå¯å±å´åµå‘ƒå‘„å‘‡å‘å‘å‘žå‘¢å‘¤å‘¦å‘§å‘©å‘«å‘­å‘®å‘´å‘¿"
  ],
  [
    "8fb5a1",
    "å’å’ƒå’…å’ˆå’‰å’å’‘å’•å’–å’œå’Ÿå’¡å’¦å’§å’©å’ªå’­å’®å’±å’·å’¹å’ºå’»å’¿å“†å“Šå“å“Žå“ å“ªå“¬å“¯å“¶å“¼å“¾å“¿å”€å”å”…å”ˆå”‰å”Œå”å”Žå”•å”ªå”«å”²å”µå”¶å”»å”¼å”½å•å•‡å•‰å•Šå•å•å•‘å•˜å•šå•›å•žå• å•¡å•¤å•¦å•¿å–å–‚å–†å–ˆå–Žå–å–‘å–’å–“å–”å–—å–£å–¤å–­å–²å–¿å—å—ƒå—†å—‰å—‹å—Œå—Žå—‘å—’"
  ],
  [
    "8fb6a1",
    "å—“å——å—˜å—›å—žå—¢å—©å—¶å—¿å˜…å˜ˆå˜Šå˜",
    5,
    "å˜™å˜¬å˜°å˜³å˜µå˜·å˜¹å˜»å˜¼å˜½å˜¿å™€å™å™ƒå™„å™†å™‰å™‹å™å™å™”å™žå™ å™¡å™¢å™£å™¦å™©å™­å™¯å™±å™²å™µåš„åš…åšˆåš‹åšŒåš•åš™åššåšåšžåšŸåš¦åš§åš¨åš©åš«åš¬åš­åš±åš³åš·åš¾å›…å›‰å›Šå›‹å›å›å›Œå›å›™å›œå›å›Ÿå›¡å›¤",
    4,
    "å›±å›«å›­"
  ],
  [
    "8fb7a1",
    "å›¶å›·åœåœ‚åœ‡åœŠåœŒåœ‘åœ•åœšåœ›åœåœ åœ¢åœ£åœ¤åœ¥åœ©åœªåœ¬åœ®åœ¯åœ³åœ´åœ½åœ¾åœ¿å…å†åŒåå’å¢å¥å§å¨å«å­",
    4,
    "å³å´åµå·å¹åºå»å¼å¾åžåžƒåžŒåž”åž—åž™åžšåžœåžåžžåžŸåž¡åž•åž§åž¨åž©åž¬åž¸åž½åŸ‡åŸˆåŸŒåŸåŸ•åŸåŸžåŸ¤åŸ¦åŸ§åŸ©åŸ­åŸ°åŸµåŸ¶åŸ¸åŸ½åŸ¾åŸ¿å ƒå „å ˆå ‰åŸ¡"
  ],
  [
    "8fb8a1",
    "å Œå å ›å žå Ÿå  å ¦å §å ­å ²å ¹å ¿å¡‰å¡Œå¡å¡å¡å¡•å¡Ÿå¡¡å¡¤å¡§å¡¨å¡¸å¡¼å¡¿å¢€å¢å¢‡å¢ˆå¢‰å¢Šå¢Œå¢å¢å¢å¢”å¢–å¢å¢ å¢¡å¢¢å¢¦å¢©å¢±å¢²å£„å¢¼å£‚å£ˆå£å£Žå£å£’å£”å£–å£šå£å£¡å£¢å£©å£³å¤…å¤†å¤‹å¤Œå¤’å¤“å¤”è™å¤å¤¡å¤£å¤¤å¤¨å¤¯å¤°å¤³å¤µå¤¶å¤¿å¥ƒå¥†å¥’å¥“å¥™å¥›å¥å¥žå¥Ÿå¥¡å¥£å¥«å¥­"
  ],
  [
    "8fb9a1",
    "å¥¯å¥²å¥µå¥¶å¥¹å¥»å¥¼å¦‹å¦Œå¦Žå¦’å¦•å¦—å¦Ÿå¦¤å¦§å¦­å¦®å¦¯å¦°å¦³å¦·å¦ºå¦¼å§å§ƒå§„å§ˆå§Šå§å§’å§å§žå§Ÿå§£å§¤å§§å§®å§¯å§±å§²å§´å§·å¨€å¨„å¨Œå¨å¨Žå¨’å¨“å¨žå¨£å¨¤å¨§å¨¨å¨ªå¨­å¨°å©„å©…å©‡å©ˆå©Œå©å©•å©žå©£å©¥å©§å©­å©·å©ºå©»å©¾åª‹åªåª“åª–åª™åªœåªžåªŸåª åª¢åª§åª¬åª±åª²åª³åªµåª¸åªºåª»åª¿"
  ],
  [
    "8fbaa1",
    "å«„å«†å«ˆå«å«šå«œå« å«¥å«ªå«®å«µå«¶å«½å¬€å¬å¬ˆå¬—å¬´å¬™å¬›å¬å¬¡å¬¥å¬­å¬¸å­å­‹å­Œå­’å­–å­žå­¨å­®å­¯å­¼å­½å­¾å­¿å®å®„å®†å®Šå®Žå®å®‘å®“å®”å®–å®¨å®©å®¬å®­å®¯å®±å®²å®·å®ºå®¼å¯€å¯å¯å¯å¯–",
    4,
    "å¯ å¯¯å¯±å¯´å¯½å°Œå°—å°žå°Ÿå°£å°¦å°©å°«å°¬å°®å°°å°²å°µå°¶å±™å±šå±œå±¢å±£å±§å±¨å±©"
  ],
  [
    "8fbba1",
    "å±­å±°å±´å±µå±ºå±»å±¼å±½å²‡å²ˆå²Šå²å²’å²å²Ÿå² å²¢å²£å²¦å²ªå²²å²´å²µå²ºå³‰å³‹å³’å³å³—å³®å³±å³²å³´å´å´†å´å´’å´«å´£å´¤å´¦å´§å´±å´´å´¹å´½å´¿åµ‚åµƒåµ†åµˆåµ•åµ‘åµ™åµŠåµŸåµ åµ¡åµ¢åµ¤åµªåµ­åµ°åµ¹åµºåµ¾åµ¿å¶å¶ƒå¶ˆå¶Šå¶’å¶“å¶”å¶•å¶™å¶›å¶Ÿå¶ å¶§å¶«å¶°å¶´å¶¸å¶¹å·ƒå·‡å·‹å·å·Žå·˜å·™å· å·¤"
  ],
  [
    "8fbca1",
    "å·©å·¸å·¹å¸€å¸‡å¸å¸’å¸”å¸•å¸˜å¸Ÿå¸ å¸®å¸¨å¸²å¸µå¸¾å¹‹å¹å¹‰å¹‘å¹–å¹˜å¹›å¹œå¹žå¹¨å¹ª",
    4,
    "å¹°åº€åº‹åºŽåº¢åº¤åº¥åº¨åºªåº¬åº±åº³åº½åº¾åº¿å»†å»Œå»‹å»Žå»‘å»’å»”å»•å»œå»žå»¥å»«å¼‚å¼†å¼‡å¼ˆå¼Žå¼™å¼œå¼å¼¡å¼¢å¼£å¼¤å¼¨å¼«å¼¬å¼®å¼°å¼´å¼¶å¼»å¼½å¼¿å½€å½„å½…å½‡å½å½å½”å½˜å½›å½ å½£å½¤å½§"
  ],
  [
    "8fbda1",
    "å½¯å½²å½´å½µå½¸å½ºå½½å½¾å¾‰å¾å¾å¾–å¾œå¾å¾¢å¾§å¾«å¾¤å¾¬å¾¯å¾°å¾±å¾¸å¿„å¿‡å¿ˆå¿‰å¿‹å¿",
    4,
    "å¿žå¿¡å¿¢å¿¨å¿©å¿ªå¿¬å¿­å¿®å¿¯å¿²å¿³å¿¶å¿ºå¿¼æ€‡æ€Šæ€æ€“æ€”æ€—æ€˜æ€šæ€Ÿæ€¤æ€­æ€³æ€µæ€æ‡æˆæ‰æŒæ‘æ”æ–æ—ææ¡æ§æ±æ¾æ¿æ‚‚æ‚†æ‚ˆæ‚Šæ‚Žæ‚‘æ‚“æ‚•æ‚˜æ‚æ‚žæ‚¢æ‚¤æ‚¥æ‚¨æ‚°æ‚±æ‚·"
  ],
  [
    "8fbea1",
    "æ‚»æ‚¾æƒ‚æƒ„æƒˆæƒ‰æƒŠæƒ‹æƒŽæƒæƒ”æƒ•æƒ™æƒ›æƒæƒžæƒ¢æƒ¥æƒ²æƒµæƒ¸æƒ¼æƒ½æ„‚æ„‡æ„Šæ„Œæ„",
    4,
    "æ„–æ„—æ„™æ„œæ„žæ„¢æ„ªæ„«æ„°æ„±æ„µæ„¶æ„·æ„¹æ…æ……æ…†æ…‰æ…žæ… æ…¬æ…²æ…¸æ…»æ…¼æ…¿æ†€æ†æ†ƒæ†„æ†‹æ†æ†’æ†“æ†—æ†˜æ†œæ†æ†Ÿæ† æ†¥æ†¨æ†ªæ†­æ†¸æ†¹æ†¼æ‡€æ‡æ‡‚æ‡Žæ‡æ‡•æ‡œæ‡æ‡žæ‡Ÿæ‡¡æ‡¢æ‡§æ‡©æ‡¥"
  ],
  [
    "8fbfa1",
    "æ‡¬æ‡­æ‡¯æˆæˆƒæˆ„æˆ‡æˆ“æˆ•æˆœæˆ æˆ¢æˆ£æˆ§æˆ©æˆ«æˆ¹æˆ½æ‰‚æ‰ƒæ‰„æ‰†æ‰Œæ‰æ‰‘æ‰’æ‰”æ‰–æ‰šæ‰œæ‰¤æ‰­æ‰¯æ‰³æ‰ºæ‰½æŠæŠŽæŠæŠæŠ¦æŠ¨æŠ³æŠ¶æŠ·æŠºæŠ¾æŠ¿æ‹„æ‹Žæ‹•æ‹–æ‹šæ‹ªæ‹²æ‹´æ‹¼æ‹½æŒƒæŒ„æŒŠæŒ‹æŒæŒæŒ“æŒ–æŒ˜æŒ©æŒªæŒ­æŒµæŒ¶æŒ¹æŒ¼ææ‚æƒæ„æ†æŠæ‹æŽæ’æ“æ”æ˜æ›æ¥æ¦æ¬æ­æ±æ´æµ"
  ],
  [
    "8fc0a1",
    "æ¸æ¼æ½æ¿æŽ‚æŽ„æŽ‡æŽŠæŽæŽ”æŽ•æŽ™æŽšæŽžæŽ¤æŽ¦æŽ­æŽ®æŽ¯æŽ½ææ…æˆæŽæ‘æ“æ”æ•æœæ æ¥æªæ¬æ²æ³æµæ¸æ¹æ‰æŠææ’æ”æ˜æžæ æ¢æ¤æ¥æ©æªæ¯æ°æµæ½æ¿æ‘‹æ‘æ‘‘æ‘’æ‘“æ‘”æ‘šæ‘›æ‘œæ‘æ‘Ÿæ‘ æ‘¡æ‘£æ‘­æ‘³æ‘´æ‘»æ‘½æ’…æ’‡æ’æ’æ’‘æ’˜æ’™æ’›æ’æ’Ÿæ’¡æ’£æ’¦æ’¨æ’¬æ’³æ’½æ’¾æ’¿"
  ],
  [
    "8fc1a1",
    "æ“„æ“‰æ“Šæ“‹æ“Œæ“Žæ“æ“‘æ“•æ“—æ“¤æ“¥æ“©æ“ªæ“­æ“°æ“µæ“·æ“»æ“¿æ”æ”„æ”ˆæ”‰æ”Šæ”æ”“æ””æ”–æ”™æ”›æ”žæ”Ÿæ”¢æ”¦æ”©æ”®æ”±æ”ºæ”¼æ”½æ•ƒæ•‡æ•‰æ•æ•’æ•”æ•Ÿæ• æ•§æ•«æ•ºæ•½æ–æ–…æ–Šæ–’æ–•æ–˜æ–æ– æ–£æ–¦æ–®æ–²æ–³æ–´æ–¿æ—‚æ—ˆæ—‰æ—Žæ—æ—”æ—–æ—˜æ—Ÿæ—°æ—²æ—´æ—µæ—¹æ—¾æ—¿æ˜€æ˜„æ˜ˆæ˜‰æ˜æ˜‘æ˜’æ˜•æ˜–æ˜"
  ],
  [
    "8fc2a1",
    "æ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜±æ˜³æ˜¹æ˜·æ™€æ™…æ™†æ™Šæ™Œæ™‘æ™Žæ™—æ™˜æ™™æ™›æ™œæ™ æ™¡æ›»æ™ªæ™«æ™¬æ™¾æ™³æ™µæ™¿æ™·æ™¸æ™¹æ™»æš€æ™¼æš‹æšŒæšæšæš’æš™æššæš›æšœæšŸæš æš¤æš­æš±æš²æšµæš»æš¿æ›€æ›‚æ›ƒæ›ˆæ›Œæ›Žæ›æ›”æ››æ›Ÿæ›¨æ›«æ›¬æ›®æ›ºæœ…æœ‡æœŽæœ“æœ™æœœæœ æœ¢æœ³æœ¾æ…æ‡æˆæŒæ”æ•æ"
  ],
  [
    "8fc3a1",
    "æ¦æ¬æ®æ´æ¶æ»æžæž„æžŽæžæž‘æž“æž–æž˜æž™æž›æž°æž±æž²æžµæž»æž¼æž½æŸ¹æŸ€æŸ‚æŸƒæŸ…æŸˆæŸ‰æŸ’æŸ—æŸ™æŸœæŸ¡æŸ¦æŸ°æŸ²æŸ¶æŸ·æ¡’æ ”æ ™æ æ Ÿæ ¨æ §æ ¬æ ­æ ¯æ °æ ±æ ³æ »æ ¿æ¡„æ¡…æ¡Šæ¡Œæ¡•æ¡—æ¡˜æ¡›æ¡«æ¡®",
    4,
    "æ¡µæ¡¹æ¡ºæ¡»æ¡¼æ¢‚æ¢„æ¢†æ¢ˆæ¢–æ¢˜æ¢šæ¢œæ¢¡æ¢£æ¢¥æ¢©æ¢ªæ¢®æ¢²æ¢»æ£…æ£ˆæ£Œæ£"
  ],
  [
    "8fc4a1",
    "æ£æ£‘æ£“æ£–æ£™æ£œæ£æ£¥æ£¨æ£ªæ£«æ£¬æ£­æ£°æ£±æ£µæ£¶æ£»æ£¼æ£½æ¤†æ¤‰æ¤Šæ¤æ¤‘æ¤“æ¤–æ¤—æ¤±æ¤³æ¤µæ¤¸æ¤»æ¥‚æ¥…æ¥‰æ¥Žæ¥—æ¥›æ¥£æ¥¤æ¥¥æ¥¦æ¥¨æ¥©æ¥¬æ¥°æ¥±æ¥²æ¥ºæ¥»æ¥¿æ¦€æ¦æ¦’æ¦–æ¦˜æ¦¡æ¦¥æ¦¦æ¦¨æ¦«æ¦­æ¦¯æ¦·æ¦¸æ¦ºæ¦¼æ§…æ§ˆæ§‘æ§–æ§—æ§¢æ§¥æ§®æ§¯æ§±æ§³æ§µæ§¾æ¨€æ¨æ¨ƒæ¨æ¨‘æ¨•æ¨šæ¨æ¨ æ¨¤æ¨¨æ¨°æ¨²"
  ],
  [
    "8fc5a1",
    "æ¨´æ¨·æ¨»æ¨¾æ¨¿æ©…æ©†æ©‰æ©Šæ©Žæ©æ©‘æ©’æ©•æ©–æ©›æ©¤æ©§æ©ªæ©±æ©³æ©¾æªæªƒæª†æª‡æª‰æª‹æª‘æª›æªæªžæªŸæª¥æª«æª¯æª°æª±æª´æª½æª¾æª¿æ«†æ«‰æ«ˆæ«Œæ«æ«”æ«•æ«–æ«œæ«æ«¤æ«§æ«¬æ«°æ«±æ«²æ«¼æ«½æ¬‚æ¬ƒæ¬†æ¬‡æ¬‰æ¬æ¬æ¬‘æ¬—æ¬›æ¬žæ¬¤æ¬¨æ¬«æ¬¬æ¬¯æ¬µæ¬¶æ¬»æ¬¿æ­†æ­Šæ­æ­’æ­–æ­˜æ­æ­ æ­§æ­«æ­®æ­°æ­µæ­½"
  ],
  [
    "8fc6a1",
    "æ­¾æ®‚æ®…æ®—æ®›æ®Ÿæ® æ®¢æ®£æ®¨æ®©æ®¬æ®­æ®®æ®°æ®¸æ®¹æ®½æ®¾æ¯ƒæ¯„æ¯‰æ¯Œæ¯–æ¯šæ¯¡æ¯£æ¯¦æ¯§æ¯®æ¯±æ¯·æ¯¹æ¯¿æ°‚æ°„æ°…æ°‰æ°æ°Žæ°æ°’æ°™æ°Ÿæ°¦æ°§æ°¨æ°¬æ°®æ°³æ°µæ°¶æ°ºæ°»æ°¿æ±Šæ±‹æ±æ±æ±’æ±”æ±™æ±›æ±œæ±«æ±­æ±¯æ±´æ±¶æ±¸æ±¹æ±»æ²…æ²†æ²‡æ²‰æ²”æ²•æ²—æ²˜æ²œæ²Ÿæ²°æ²²æ²´æ³‚æ³†æ³æ³æ³æ³‘æ³’æ³”æ³–"
  ],
  [
    "8fc7a1",
    "æ³šæ³œæ³ æ³§æ³©æ³«æ³¬æ³®æ³²æ³´æ´„æ´‡æ´Šæ´Žæ´æ´‘æ´“æ´šæ´¦æ´§æ´¨æ±§æ´®æ´¯æ´±æ´¹æ´¼æ´¿æµ—æµžæµŸæµ¡æµ¥æµ§æµ¯æµ°æµ¼æ¶‚æ¶‡æ¶‘æ¶’æ¶”æ¶–æ¶—æ¶˜æ¶ªæ¶¬æ¶´æ¶·æ¶¹æ¶½æ¶¿æ·„æ·ˆæ·Šæ·Žæ·æ·–æ·›æ·æ·Ÿæ· æ·¢æ·¥æ·©æ·¯æ·°æ·´æ·¶æ·¼æ¸€æ¸„æ¸žæ¸¢æ¸§æ¸²æ¸¶æ¸¹æ¸»æ¸¼æ¹„æ¹…æ¹ˆæ¹‰æ¹‹æ¹æ¹‘æ¹’æ¹“æ¹”æ¹—æ¹œæ¹æ¹ž"
  ],
  [
    "8fc8a1",
    "æ¹¢æ¹£æ¹¨æ¹³æ¹»æ¹½æºæº“æº™æº æº§æº­æº®æº±æº³æº»æº¿æ»€æ»æ»ƒæ»‡æ»ˆæ»Šæ»æ»Žæ»æ»«æ»­æ»®æ»¹æ»»æ»½æ¼„æ¼ˆæ¼Šæ¼Œæ¼æ¼–æ¼˜æ¼šæ¼›æ¼¦æ¼©æ¼ªæ¼¯æ¼°æ¼³æ¼¶æ¼»æ¼¼æ¼­æ½æ½‘æ½’æ½“æ½—æ½™æ½šæ½æ½žæ½¡æ½¢æ½¨æ½¬æ½½æ½¾æ¾ƒæ¾‡æ¾ˆæ¾‹æ¾Œæ¾æ¾æ¾’æ¾“æ¾”æ¾–æ¾šæ¾Ÿæ¾ æ¾¥æ¾¦æ¾§æ¾¨æ¾®æ¾¯æ¾°æ¾µæ¾¶æ¾¼æ¿…æ¿‡æ¿ˆæ¿Š"
  ],
  [
    "8fc9a1",
    "æ¿šæ¿žæ¿¨æ¿©æ¿°æ¿µæ¿¹æ¿¼æ¿½ç€€ç€…ç€†ç€‡ç€ç€—ç€ ç€£ç€¯ç€´ç€·ç€¹ç€¼çƒç„çˆç‰çŠç‹ç”ç•ççžçŽç¤ç¥ç¬ç®çµç¶ç¾ç‚ç‚…ç‚†ç‚”",
    4,
    "ç‚›ç‚¤ç‚«ç‚°ç‚±ç‚´ç‚·çƒŠçƒ‘çƒ“çƒ”çƒ•çƒ–çƒ˜çƒœçƒ¤çƒºç„ƒ",
    4,
    "ç„‹ç„Œç„ç„žç„ ç„«ç„­ç„¯ç„°ç„±ç„¸ç…ç……ç…†ç…‡ç…Šç…‹ç…ç…’ç…—ç…šç…œç…žç… "
  ],
  [
    "8fcaa1",
    "ç…¨ç…¹ç†€ç†…ç†‡ç†Œç†’ç†šç†›ç† ç†¢ç†¯ç†°ç†²ç†³ç†ºç†¿ç‡€ç‡ç‡„ç‡‹ç‡Œç‡“ç‡–ç‡™ç‡šç‡œç‡¸ç‡¾çˆ€çˆ‡çˆˆçˆ‰çˆ“çˆ—çˆšçˆçˆŸçˆ¤çˆ«çˆ¯çˆ´çˆ¸çˆ¹ç‰ç‰‚ç‰ƒç‰…ç‰Žç‰ç‰ç‰“ç‰•ç‰–ç‰šç‰œç‰žç‰ ç‰£ç‰¨ç‰«ç‰®ç‰¯ç‰±ç‰·ç‰¸ç‰»ç‰¼ç‰¿çŠ„çŠ‰çŠçŠŽçŠ“çŠ›çŠ¨çŠ­çŠ®çŠ±çŠ´çŠ¾ç‹ç‹‡ç‹‰ç‹Œç‹•ç‹–ç‹˜ç‹Ÿç‹¥ç‹³ç‹´ç‹ºç‹»"
  ],
  [
    "8fcba1",
    "ç‹¾çŒ‚çŒ„çŒ…çŒ‡çŒ‹çŒçŒ’çŒ“çŒ˜çŒ™çŒžçŒ¢çŒ¤çŒ§çŒ¨çŒ¬çŒ±çŒ²çŒµçŒºçŒ»çŒ½çƒççç’ç–ç˜ççžçŸç ç¦ç§ç©ç«ç¬ç®ç¯ç±ç·ç¹ç¼çŽ€çŽçŽƒçŽ…çŽ†çŽŽçŽçŽ“çŽ•çŽ—çŽ˜çŽœçŽžçŽŸçŽ çŽ¢çŽ¥çŽ¦çŽªçŽ«çŽ­çŽµçŽ·çŽ¹çŽ¼çŽ½çŽ¿ç…ç†ç‰ç‹çŒçç’ç“ç–ç™çç¡ç£ç¦ç§ç©ç´çµç·ç¹çºç»ç½"
  ],
  [
    "8fcca1",
    "ç¿ç€çç„ç‡çŠç‘çšç›ç¤ç¦ç¨",
    9,
    "ç¹ç‘€ç‘ƒç‘„ç‘†ç‘‡ç‘‹ç‘ç‘‘ç‘’ç‘—ç‘ç‘¢ç‘¦ç‘§ç‘¨ç‘«ç‘­ç‘®ç‘±ç‘²ç’€ç’ç’…ç’†ç’‡ç’‰ç’ç’ç’‘ç’’ç’˜ç’™ç’šç’œç’Ÿç’ ç’¡ç’£ç’¦ç’¨ç’©ç’ªç’«ç’®ç’¯ç’±ç’²ç’µç’¹ç’»ç’¿ç“ˆç“‰ç“Œç“ç““ç“˜ç“šç“›ç“žç“Ÿç“¤ç“¨ç“ªç“«ç“¯ç“´ç“ºç“»ç“¼ç“¿ç”†"
  ],
  [
    "8fcda1",
    "ç”’ç”–ç”—ç” ç”¡ç”¤ç”§ç”©ç”ªç”¯ç”¶ç”¹ç”½ç”¾ç”¿ç•€ç•ƒç•‡ç•ˆç•Žç•ç•’ç•—ç•žç•Ÿç•¡ç•¯ç•±ç•¹",
    5,
    "ç–ç–…ç–ç–’ç–“ç–•ç–™ç–œç–¢ç–¤ç–´ç–ºç–¿ç—€ç—ç—„ç—†ç—Œç—Žç—ç——ç—œç—Ÿç— ç—¡ç—¤ç—§ç—¬ç—®ç—¯ç—±ç—¹ç˜€ç˜‚ç˜ƒç˜„ç˜‡ç˜ˆç˜Šç˜Œç˜ç˜’ç˜“ç˜•ç˜–ç˜™ç˜›ç˜œç˜ç˜žç˜£ç˜¥ç˜¦ç˜©ç˜­ç˜²ç˜³ç˜µç˜¸ç˜¹"
  ],
  [
    "8fcea1",
    "ç˜ºç˜¼ç™Šç™€ç™ç™ƒç™„ç™…ç™‰ç™‹ç™•ç™™ç™Ÿç™¤ç™¥ç™­ç™®ç™¯ç™±ç™´çšçš…çšŒçšçš•çš›çšœçšçšŸçš çš¢",
    6,
    "çšªçš­çš½ç›ç›…ç›‰ç›‹ç›Œç›Žç›”ç›™ç› ç›¦ç›¨ç›¬ç›°ç›±ç›¶ç›¹ç›¼çœ€çœ†çœŠçœŽçœ’çœ”çœ•çœ—çœ™çœšçœœçœ¢çœ¨çœ­çœ®çœ¯çœ´çœµçœ¶çœ¹çœ½çœ¾ç‚ç…ç†çŠççŽçç’ç–ç—çœçžçŸç ç¢"
  ],
  [
    "8fcfa1",
    "ç¤ç§çªç¬ç°ç²ç³ç´çºç½çž€çž„çžŒçžçž”çž•çž–çžšçžŸçž¢çž§çžªçž®çž¯çž±çžµçž¾çŸƒçŸ‰çŸ‘çŸ’çŸ•çŸ™çŸžçŸŸçŸ çŸ¤çŸ¦çŸªçŸ¬çŸ°çŸ±çŸ´çŸ¸çŸ»ç …ç †ç ‰ç ç Žç ‘ç ç ¡ç ¢ç £ç ­ç ®ç °ç µç ·ç¡ƒç¡„ç¡‡ç¡ˆç¡Œç¡Žç¡’ç¡œç¡žç¡ ç¡¡ç¡£ç¡¤ç¡¨ç¡ªç¡®ç¡ºç¡¾ç¢Šç¢ç¢”ç¢˜ç¢¡ç¢ç¢žç¢Ÿç¢¤ç¢¨ç¢¬ç¢­ç¢°ç¢±ç¢²ç¢³"
  ],
  [
    "8fd0a1",
    "ç¢»ç¢½ç¢¿ç£‡ç£ˆç£‰ç£Œç£Žç£’ç£“ç£•ç£–ç£¤ç£›ç£Ÿç£ ç£¡ç£¦ç£ªç£²ç£³ç¤€ç£¶ç£·ç£ºç£»ç£¿ç¤†ç¤Œç¤ç¤šç¤œç¤žç¤Ÿç¤ ç¤¥ç¤§ç¤©ç¤­ç¤±ç¤´ç¤µç¤»ç¤½ç¤¿ç¥„ç¥…ç¥†ç¥Šç¥‹ç¥ç¥‘ç¥”ç¥˜ç¥›ç¥œç¥§ç¥©ç¥«ç¥²ç¥¹ç¥»ç¥¼ç¥¾ç¦‹ç¦Œç¦‘ç¦“ç¦”ç¦•ç¦–ç¦˜ç¦›ç¦œç¦¡ç¦¨ç¦©ç¦«ç¦¯ç¦±ç¦´ç¦¸ç¦»ç§‚ç§„ç§‡ç§ˆç§Šç§ç§”ç§–ç§šç§ç§ž"
  ],
  [
    "8fd1a1",
    "ç§ ç§¢ç§¥ç§ªç§«ç§­ç§±ç§¸ç§¼ç¨‚ç¨ƒç¨‡ç¨‰ç¨Šç¨Œç¨‘ç¨•ç¨›ç¨žç¨¡ç¨§ç¨«ç¨­ç¨¯ç¨°ç¨´ç¨µç¨¸ç¨¹ç¨ºç©„ç©…ç©‡ç©ˆç©Œç©•ç©–ç©™ç©œç©ç©Ÿç© ç©¥ç©§ç©ªç©­ç©µç©¸ç©¾çª€çª‚çª…çª†çªŠçª‹çªçª‘çª”çªžçª çª£çª¬çª³çªµçª¹çª»çª¼ç«†ç«‰ç«Œç«Žç«‘ç«›ç«¨ç«©ç««ç«¬ç«±ç«´ç«»ç«½ç«¾ç¬‡ç¬”ç¬Ÿç¬£ç¬§ç¬©ç¬ªç¬«ç¬­ç¬®ç¬¯ç¬°"
  ],
  [
    "8fd2a1",
    "ç¬±ç¬´ç¬½ç¬¿ç­€ç­ç­‡ç­Žç­•ç­ ç­¤ç­¦ç­©ç­ªç­­ç­¯ç­²ç­³ç­·ç®„ç®‰ç®Žç®ç®‘ç®–ç®›ç®žç® ç®¥ç®¬ç®¯ç®°ç®²ç®µç®¶ç®ºç®»ç®¼ç®½ç¯‚ç¯…ç¯ˆç¯Šç¯”ç¯–ç¯—ç¯™ç¯šç¯›ç¯¨ç¯ªç¯²ç¯´ç¯µç¯¸ç¯¹ç¯ºç¯¼ç¯¾ç°ç°‚ç°ƒç°„ç°†ç°‰ç°‹ç°Œç°Žç°ç°™ç°›ç° ç°¥ç°¦ç°¨ç°¬ç°±ç°³ç°´ç°¶ç°¹ç°ºç±†ç±Šç±•ç±‘ç±’ç±“ç±™",
    5
  ],
  [
    "8fd3a1",
    "ç±¡ç±£ç±§ç±©ç±­ç±®ç±°ç±²ç±¹ç±¼ç±½ç²†ç²‡ç²ç²”ç²žç² ç²¦ç²°ç²¶ç²·ç²ºç²»ç²¼ç²¿ç³„ç³‡ç³ˆç³‰ç³ç³ç³“ç³”ç³•ç³—ç³™ç³šç³ç³¦ç³©ç³«ç³µç´ƒç´‡ç´ˆç´‰ç´ç´‘ç´’ç´“ç´–ç´ç´žç´£ç´¦ç´ªç´­ç´±ç´¼ç´½ç´¾çµ€çµçµ‡çµˆçµçµ‘çµ“çµ—çµ™çµšçµœçµçµ¥çµ§çµªçµ°çµ¸çµºçµ»çµ¿ç¶ç¶‚ç¶ƒç¶…ç¶†ç¶ˆç¶‹ç¶Œç¶ç¶‘ç¶–ç¶—ç¶"
  ],
  [
    "8fd4a1",
    "ç¶žç¶¦ç¶§ç¶ªç¶³ç¶¶ç¶·ç¶¹ç·‚",
    4,
    "ç·Œç·ç·Žç·—ç·™ç¸€ç·¢ç·¥ç·¦ç·ªç·«ç·­ç·±ç·µç·¶ç·¹ç·ºç¸ˆç¸ç¸‘ç¸•ç¸—ç¸œç¸ç¸ ç¸§ç¸¨ç¸¬ç¸­ç¸¯ç¸³ç¸¶ç¸¿ç¹„ç¹…ç¹‡ç¹Žç¹ç¹’ç¹˜ç¹Ÿç¹¡ç¹¢ç¹¥ç¹«ç¹®ç¹¯ç¹³ç¹¸ç¹¾çºçº†çº‡çºŠçºçº‘çº•çº˜çºšçºçºžç¼¼ç¼»ç¼½ç¼¾ç¼¿ç½ƒç½„ç½‡ç½ç½’ç½“ç½›ç½œç½ç½¡ç½£ç½¤ç½¥ç½¦ç½­"
  ],
  [
    "8fd5a1",
    "ç½±ç½½ç½¾ç½¿ç¾€ç¾‹ç¾ç¾ç¾ç¾‘ç¾–ç¾—ç¾œç¾¡ç¾¢ç¾¦ç¾ªç¾­ç¾´ç¾¼ç¾¿ç¿€ç¿ƒç¿ˆç¿Žç¿ç¿›ç¿Ÿç¿£ç¿¥ç¿¨ç¿¬ç¿®ç¿¯ç¿²ç¿ºç¿½ç¿¾ç¿¿è€‡è€ˆè€Šè€è€Žè€è€‘è€“è€”è€–è€è€žè€Ÿè€ è€¤è€¦è€¬è€®è€°è€´è€µè€·è€¹è€ºè€¼è€¾è€è„è è¤è¦è­è±èµè‚è‚ˆè‚Žè‚œè‚žè‚¦è‚§è‚«è‚¸è‚¹èƒˆèƒèƒèƒ’èƒ”èƒ•èƒ—èƒ˜èƒ èƒ­èƒ®"
  ],
  [
    "8fd6a1",
    "èƒ°èƒ²èƒ³èƒ¶èƒ¹èƒºèƒ¾è„ƒè„‹è„–è„—è„˜è„œè„žè„ è„¤è„§è„¬è„°è„µè„ºè„¼è……è…‡è…Šè…Œè…’è…—è… è…¡è…§è…¨è…©è…­è…¯è…·è†è†è†„è†…è††è†‹è†Žè†–è†˜è†›è†žè†¢è†®è†²è†´è†»è‡‹è‡ƒè‡…è‡Šè‡Žè‡è‡•è‡—è‡›è‡è‡žè‡¡è‡¤è‡«è‡¬è‡°è‡±è‡²è‡µè‡¶è‡¸è‡¹è‡½è‡¿èˆ€èˆƒèˆèˆ“èˆ”èˆ™èˆšèˆèˆ¡èˆ¢èˆ¨èˆ²èˆ´èˆºè‰ƒè‰„è‰…è‰†"
  ],
  [
    "8fd7a1",
    "è‰‹è‰Žè‰è‰‘è‰–è‰œè‰ è‰£è‰§è‰­è‰´è‰»è‰½è‰¿èŠ€èŠèŠƒèŠ„èŠ‡èŠ‰èŠŠèŠŽèŠ‘èŠ”èŠ–èŠ˜èŠšèŠ›èŠ èŠ¡èŠ£èŠ¤èŠ§èŠ¨èŠ©èŠªèŠ®èŠ°èŠ²èŠ´èŠ·èŠºèŠ¼èŠ¾èŠ¿è‹†è‹è‹•è‹šè‹ è‹¢è‹¤è‹¨è‹ªè‹­è‹¯è‹¶è‹·è‹½è‹¾èŒ€èŒèŒ‡èŒˆèŒŠèŒ‹è”èŒ›èŒèŒžèŒŸèŒ¡èŒ¢èŒ¬èŒ­èŒ®èŒ°èŒ³èŒ·èŒºèŒ¼èŒ½è‚èƒè„è‡èèŽè‘è•è–è—è°è¸"
  ],
  [
    "8fd8a1",
    "è½è¿èŽ€èŽ‚èŽ„èŽ†èŽèŽ’èŽ”èŽ•èŽ˜èŽ™èŽ›èŽœèŽèŽ¦èŽ§èŽ©èŽ¬èŽ¾èŽ¿è€è‡è‰èèè‘è”èè“è¨èªè¶è¸è¹è¼èè†èŠèè‘è•è™èŽ­è¯è¹è‘…è‘‡è‘ˆè‘Šè‘è‘è‘‘è‘’è‘–è‘˜è‘™è‘šè‘œè‘ è‘¤è‘¥è‘§è‘ªè‘°è‘³è‘´è‘¶è‘¸è‘¼è‘½è’è’…è’’è’“è’•è’žè’¦è’¨è’©è’ªè’¯è’±è’´è’ºè’½è’¾è“€è“‚è“‡è“ˆè“Œè“è““"
  ],
  [
    "8fd9a1",
    "è“œè“§è“ªè“¯è“°è“±è“²è“·è”²è“ºè“»è“½è”‚è”ƒè”‡è”Œè”Žè”è”œè”žè”¢è”£è”¤è”¥è”§è”ªè”«è”¯è”³è”´è”¶è”¿è•†è•",
    4,
    "è•–è•™è•œ",
    6,
    "è•¤è•«è•¯è•¹è•ºè•»è•½è•¿è–è–…è–†è–‰è–‹è–Œè–è–“è–˜è–è–Ÿè– è–¢è–¥è–§è–´è–¶è–·è–¸è–¼è–½è–¾è–¿è—‚è—‡è—Šè—‹è—Žè–­è—˜è—šè—Ÿè— è—¦è—¨è—­è—³è—¶è—¼"
  ],
  [
    "8fdaa1",
    "è—¿è˜€è˜„è˜…è˜è˜Žè˜è˜‘è˜’è˜˜è˜™è˜›è˜žè˜¡è˜§è˜©è˜¶è˜¸è˜ºè˜¼è˜½è™€è™‚è™†è™’è™“è™–è™—è™˜è™™è™è™ ",
    4,
    "è™©è™¬è™¯è™µè™¶è™·è™ºèšèš‘èš–èš˜èššèšœèš¡èš¦èš§èš¨èš­èš±èš³èš´èšµèš·èš¸èš¹èš¿è›€è›è›ƒè›…è›‘è›’è›•è›—è›šè›œè› è›£è›¥è›§èšˆè›ºè›¼è›½èœ„èœ…èœ‡èœ‹èœŽèœèœèœ“èœ”èœ™èœžèœŸèœ¡èœ£"
  ],
  [
    "8fdba1",
    "èœ¨èœ®èœ¯èœ±èœ²èœ¹èœºèœ¼èœ½èœ¾è€èƒè…èè˜èè¡è¤è¥è¯è±è²è»èžƒ",
    6,
    "èž‹èžŒèžèž“èž•èž—èž˜èž™èžžèž èž£èž§èž¬èž­èž®èž±èžµèž¾èž¿èŸèŸˆèŸ‰èŸŠèŸŽèŸ•èŸ–èŸ™èŸšèŸœèŸŸèŸ¢èŸ£èŸ¤èŸªèŸ«èŸ­èŸ±èŸ³èŸ¸èŸºèŸ¿è è ƒè †è ‰è Šè ‹è è ™è ’è “è ”è ˜è šè ›è œè žè Ÿè ¨è ­è ®è °è ²è µ"
  ],
  [
    "8fdca1",
    "è ºè ¼è¡è¡ƒè¡…è¡ˆè¡‰è¡Šè¡‹è¡Žè¡‘è¡•è¡–è¡˜è¡šè¡œè¡Ÿè¡ è¡¤è¡©è¡±è¡¹è¡»è¢€è¢˜è¢šè¢›è¢œè¢Ÿè¢ è¢¨è¢ªè¢ºè¢½è¢¾è£€è£Š",
    4,
    "è£‘è£’è£“è£›è£žè£§è£¯è£°è£±è£µè£·è¤è¤†è¤è¤Žè¤è¤•è¤–è¤˜è¤™è¤šè¤œè¤ è¤¦è¤§è¤¨è¤°è¤±è¤²è¤µè¤¹è¤ºè¤¾è¥€è¥‚è¥…è¥†è¥‰è¥è¥’è¥—è¥šè¥›è¥œè¥¡è¥¢è¥£è¥«è¥®è¥°è¥³è¥µè¥º"
  ],
  [
    "8fdda1",
    "è¥»è¥¼è¥½è¦‰è¦è¦è¦”è¦•è¦›è¦œè¦Ÿè¦ è¦¥è¦°è¦´è¦µè¦¶è¦·è¦¼è§”",
    4,
    "è§¥è§©è§«è§­è§±è§³è§¶è§¹è§½è§¿è¨„è¨…è¨‡è¨è¨‘è¨’è¨”è¨•è¨žè¨ è¨¢è¨¤è¨¦è¨«è¨¬è¨¯è¨µè¨·è¨½è¨¾è©€è©ƒè©…è©‡è©‰è©è©Žè©“è©–è©—è©˜è©œè©è©¡è©¥è©§è©µè©¶è©·è©¹è©ºè©»è©¾è©¿èª€èªƒèª†èª‹èªèªèª’èª–èª—èª™èªŸèª§èª©èª®èª¯èª³"
  ],
  [
    "8fdea1",
    "èª¶èª·èª»èª¾è«ƒè«†è«ˆè«‰è«Šè«‘è«“è«”è«•è«—è«è«Ÿè«¬è«°è«´è«µè«¶è«¼è«¿è¬…è¬†è¬‹è¬‘è¬œè¬žè¬Ÿè¬Šè¬­è¬°è¬·è¬¼è­‚",
    4,
    "è­ˆè­’è­“è­”è­™è­è­žè­£è­­è­¶è­¸è­¹è­¼è­¾è®è®„è®…è®‹è®è®è®”è®•è®œè®žè®Ÿè°¸è°¹è°½è°¾è±…è±‡è±‰è±‹è±è±‘è±“è±”è±—è±˜è±›è±è±™è±£è±¤è±¦è±¨è±©è±­è±³è±µè±¶è±»è±¾è²†"
  ],
  [
    "8fdfa1",
    "è²‡è²‹è²è²’è²“è²™è²›è²œè²¤è²¹è²ºè³…è³†è³‰è³‹è³è³–è³•è³™è³è³¡è³¨è³¬è³¯è³°è³²è³µè³·è³¸è³¾è³¿è´è´ƒè´‰è´’è´—è´›èµ¥èµ©èµ¬èµ®èµ¿è¶‚è¶„è¶ˆè¶è¶è¶‘è¶•è¶žè¶Ÿè¶ è¶¦è¶«è¶¬è¶¯è¶²è¶µè¶·è¶¹è¶»è·€è·…è·†è·‡è·ˆè·Šè·Žè·‘è·”è·•è·—è·™è·¤è·¥è·§è·¬è·°è¶¼è·±è·²è·´è·½è¸è¸„è¸…è¸†è¸‹è¸‘è¸”è¸–è¸ è¸¡è¸¢"
  ],
  [
    "8fe0a1",
    "è¸£è¸¦è¸§è¸±è¸³è¸¶è¸·è¸¸è¸¹è¸½è¹€è¹è¹‹è¹è¹Žè¹è¹”è¹›è¹œè¹è¹žè¹¡è¹¢è¹©è¹¬è¹­è¹¯è¹°è¹±è¹¹è¹ºè¹»èº‚èºƒèº‰èºèº’èº•èºšèº›èºèºžèº¢èº§èº©èº­èº®èº³èºµèººèº»è»€è»è»ƒè»„è»‡è»è»‘è»”è»œè»¨è»®è»°è»±è»·è»¹è»ºè»­è¼€è¼‚è¼‡è¼ˆè¼è¼è¼–è¼—è¼˜è¼žè¼ è¼¡è¼£è¼¥è¼§è¼¨è¼¬è¼­è¼®è¼´è¼µè¼¶è¼·è¼ºè½€è½"
  ],
  [
    "8fe1a1",
    "è½ƒè½‡è½è½‘",
    4,
    "è½˜è½è½žè½¥è¾è¾ è¾¡è¾¤è¾¥è¾¦è¾µè¾¶è¾¸è¾¾è¿€è¿è¿†è¿Šè¿‹è¿è¿è¿’è¿“è¿•è¿ è¿£è¿¤è¿¨è¿®è¿±è¿µè¿¶è¿»è¿¾é€‚é€„é€ˆé€Œé€˜é€›é€¨é€©é€¯é€ªé€¬é€­é€³é€´é€·é€¿éƒé„éŒé›éé¢é¦é§é¬é°é´é¹é‚…é‚ˆé‚‹é‚Œé‚Žé‚é‚•é‚—é‚˜é‚™é‚›é‚ é‚¡é‚¢é‚¥é‚°é‚²é‚³é‚´é‚¶é‚½éƒŒé‚¾éƒƒ"
  ],
  [
    "8fe2a1",
    "éƒ„éƒ…éƒ‡éƒˆéƒ•éƒ—éƒ˜éƒ™éƒœéƒéƒŸéƒ¥éƒ’éƒ¶éƒ«éƒ¯éƒ°éƒ´éƒ¾éƒ¿é„€é„„é„…é„†é„ˆé„é„é„”é„–é„—é„˜é„šé„œé„žé„ é„¥é„¢é„£é„§é„©é„®é„¯é„±é„´é„¶é„·é„¹é„ºé„¼é„½é…ƒé…‡é…ˆé…é…“é…—é…™é…šé…›é…¡é…¤é…§é…­é…´é…¹é…ºé…»é†é†ƒé†…é††é†Šé†Žé†‘é†“é†”é†•é†˜é†žé†¡é†¦é†¨é†¬é†­é†®é†°é†±é†²é†³é†¶é†»é†¼é†½é†¿"
  ],
  [
    "8fe3a1",
    "é‡‚é‡ƒé‡…é‡“é‡”é‡—é‡™é‡šé‡žé‡¤é‡¥é‡©é‡ªé‡¬",
    5,
    "é‡·é‡¹é‡»é‡½éˆ€éˆéˆ„éˆ…éˆ†éˆ‡éˆ‰éˆŠéˆŒéˆéˆ’éˆ“éˆ–éˆ˜éˆœéˆéˆ£éˆ¤éˆ¥éˆ¦éˆ¨éˆ®éˆ¯éˆ°éˆ³éˆµéˆ¶éˆ¸éˆ¹éˆºéˆ¼éˆ¾é‰€é‰‚é‰ƒé‰†é‰‡é‰Šé‰é‰Žé‰é‰‘é‰˜é‰™é‰œé‰é‰ é‰¡é‰¥é‰§é‰¨é‰©é‰®é‰¯é‰°é‰µ",
    4,
    "é‰»é‰¼é‰½é‰¿éŠˆéŠ‰éŠŠéŠéŠŽéŠ’éŠ—"
  ],
  [
    "8fe4a1",
    "éŠ™éŠŸéŠ éŠ¤éŠ¥éŠ§éŠ¨éŠ«éŠ¯éŠ²éŠ¶éŠ¸éŠºéŠ»éŠ¼éŠ½éŠ¿",
    4,
    "é‹…é‹†é‹‡é‹ˆé‹‹é‹Œé‹é‹Žé‹é‹“é‹•é‹—é‹˜é‹™é‹œé‹é‹Ÿé‹ é‹¡é‹£é‹¥é‹§é‹¨é‹¬é‹®é‹°é‹¹é‹»é‹¿éŒ€éŒ‚éŒˆéŒéŒ‘éŒ”éŒ•éŒœéŒéŒžéŒŸéŒ¡éŒ¤éŒ¥éŒ§éŒ©éŒªéŒ³éŒ´éŒ¶éŒ·é‡éˆé‰éé‘é’é•é—é˜éšéžé¤é¥é§é©éªé­é¯é°é±é³é´é¶"
  ],
  [
    "8fe5a1",
    "éºé½é¿éŽ€éŽéŽ‚éŽˆéŽŠéŽ‹éŽéŽéŽ’éŽ•éŽ˜éŽ›éŽžéŽ¡éŽ£éŽ¤éŽ¦éŽ¨éŽ«éŽ´éŽµéŽ¶éŽºéŽ©éé„é…é†é‡é‰",
    4,
    "é“é™éœéžéŸé¢é¦é§é¹é·é¸éºé»é½éé‚é„éˆé‰ééŽéé•é–é—éŸé®é¯é±é²é³é´é»é¿é½é‘ƒé‘…é‘ˆé‘Šé‘Œé‘•é‘™é‘œé‘Ÿé‘¡é‘£é‘¨é‘«é‘­é‘®é‘¯é‘±é‘²é’„é’ƒé•¸é•¹"
  ],
  [
    "8fe6a1",
    "é•¾é–„é–ˆé–Œé–é–Žé–é–žé–Ÿé–¡é–¦é–©é–«é–¬é–´é–¶é–ºé–½é–¿é—†é—ˆé—‰é—‹é—é—‘é—’é—“é—™é—šé—é—žé—Ÿé— é—¤é—¦é˜é˜žé˜¢é˜¤é˜¥é˜¦é˜¬é˜±é˜³é˜·é˜¸é˜¹é˜ºé˜¼é˜½é™é™’é™”é™–é™—é™˜é™¡é™®é™´é™»é™¼é™¾é™¿éšéš‚éšƒéš„éš‰éš‘éš–éššéšéšŸéš¤éš¥éš¦éš©éš®éš¯éš³éšºé›Šé›’å¶²é›˜é›šé›é›žé›Ÿé›©é›¯é›±é›ºéœ‚"
  ],
  [
    "8fe7a1",
    "éœƒéœ…éœ‰éœšéœ›éœéœ¡éœ¢éœ£éœ¨éœ±éœ³ééƒéŠéŽéé•é—é˜éšé›é£é§éªé®é³é¶é·é¸é»é½é¿éž€éž‰éž•éž–éž—éž™éžšéžžéžŸéž¢éž¬éž®éž±éž²éžµéž¶éž¸éž¹éžºéž¼éž¾éž¿éŸéŸ„éŸ…éŸ‡éŸ‰éŸŠéŸŒéŸéŸŽéŸéŸ‘éŸ”éŸ—éŸ˜éŸ™éŸéŸžéŸ éŸ›éŸ¡éŸ¤éŸ¯éŸ±éŸ´éŸ·éŸ¸éŸºé ‡é Šé ™é é Žé ”é –é œé žé  é £é ¦"
  ],
  [
    "8fe8a1",
    "é «é ®é ¯é °é ²é ³é µé ¥é ¾é¡„é¡‡é¡Šé¡‘é¡’é¡“é¡–é¡—é¡™é¡šé¡¢é¡£é¡¥é¡¦é¡ªé¡¬é¢«é¢­é¢®é¢°é¢´é¢·é¢¸é¢ºé¢»é¢¿é£‚é£…é£ˆé£Œé£¡é££é£¥é£¦é£§é£ªé£³é£¶é¤‚é¤‡é¤ˆé¤‘é¤•é¤–é¤—é¤šé¤›é¤œé¤Ÿé¤¢é¤¦é¤§é¤«é¤±",
    4,
    "é¤¹é¤ºé¤»é¤¼é¥€é¥é¥†é¥‡é¥ˆé¥é¥Žé¥”é¥˜é¥™é¥›é¥œé¥žé¥Ÿé¥ é¦›é¦é¦Ÿé¦¦é¦°é¦±é¦²é¦µ"
  ],
  [
    "8fe9a1",
    "é¦¹é¦ºé¦½é¦¿é§ƒé§‰é§“é§”é§™é§šé§œé§žé§§é§ªé§«é§¬é§°é§´é§µé§¹é§½é§¾é¨‚é¨ƒé¨„é¨‹é¨Œé¨é¨‘é¨–é¨žé¨ é¨¢é¨£é¨¤é¨§é¨­é¨®é¨³é¨µé¨¶é¨¸é©‡é©é©„é©Šé©‹é©Œé©Žé©‘é©”é©–é©éªªéª¬éª®éª¯éª²éª´éªµéª¶éª¹éª»éª¾éª¿é«é«ƒé«†é«ˆé«Žé«é«’é«•é«–é«—é«›é«œé« é«¤é«¥é«§é«©é«¬é«²é«³é«µé«¹é«ºé«½é«¿",
    4
  ],
  [
    "8feaa1",
    "é¬„é¬…é¬ˆé¬‰é¬‹é¬Œé¬é¬Žé¬é¬’é¬–é¬™é¬›é¬œé¬ é¬¦é¬«é¬­é¬³é¬´é¬µé¬·é¬¹é¬ºé¬½é­ˆé­‹é­Œé­•é­–é­—é­›é­žé­¡é­£é­¥é­¦é­¨é­ª",
    4,
    "é­³é­µé­·é­¸é­¹é­¿é®€é®„é®…é®†é®‡é®‰é®Šé®‹é®é®é®é®”é®šé®é®žé®¦é®§é®©é®¬é®°é®±é®²é®·é®¸é®»é®¼é®¾é®¿é¯é¯‡é¯ˆé¯Žé¯é¯—é¯˜é¯é¯Ÿé¯¥é¯§é¯ªé¯«é¯¯é¯³é¯·é¯¸"
  ],
  [
    "8feba1",
    "é¯¹é¯ºé¯½é¯¿é°€é°‚é°‹é°é°‘é°–é°˜é°™é°šé°œé°žé°¢é°£é°¦",
    4,
    "é°±é°µé°¶é°·é°½é±é±ƒé±„é±…é±‰é±Šé±Žé±é±é±“é±”é±–é±˜é±›é±é±žé±Ÿé±£é±©é±ªé±œé±«é±¨é±®é±°é±²é±µé±·é±»é³¦é³²é³·é³¹é´‹é´‚é´‘é´—é´˜é´œé´é´žé´¯é´°é´²é´³é´´é´ºé´¼éµ…é´½éµ‚éµƒéµ‡éµŠéµ“éµ”éµŸéµ£éµ¢éµ¥éµ©éµªéµ«éµ°éµ¶éµ·éµ»"
  ],
  [
    "8feca1",
    "éµ¼éµ¾é¶ƒé¶„é¶†é¶Šé¶é¶Žé¶’é¶“é¶•é¶–é¶—é¶˜é¶¡é¶ªé¶¬é¶®é¶±é¶µé¶¹é¶¼é¶¿é·ƒé·‡é·‰é·Šé·”é·•é·–é·—é·šé·žé·Ÿé· é·¥é·§é·©é·«é·®é·°é·³é·´é·¾é¸Šé¸‚é¸‡é¸Žé¸é¸‘é¸’é¸•é¸–é¸™é¸œé¸é¹ºé¹»é¹¼éº€éº‚éºƒéº„éº…éº‡éºŽéºéº–éº˜éº›éºžéº¤éº¨éº¬éº®éº¯éº°éº³éº´éºµé»†é»ˆé»‹é»•é»Ÿé»¤é»§é»¬é»­é»®é»°é»±é»²é»µ"
  ],
  [
    "8feda1",
    "é»¸é»¿é¼‚é¼ƒé¼‰é¼é¼é¼‘é¼’é¼”é¼–é¼—é¼™é¼šé¼›é¼Ÿé¼¢é¼¦é¼ªé¼«é¼¯é¼±é¼²é¼´é¼·é¼¹é¼ºé¼¼é¼½é¼¿é½é½ƒ",
    4,
    "é½“é½•é½–é½—é½˜é½šé½é½žé½¨é½©é½­",
    4,
    "é½³é½µé½ºé½½é¾é¾é¾‘é¾’é¾”é¾–é¾—é¾žé¾¡é¾¢é¾£é¾¥"
  ]
];
const require$$2$1 = [
  [
    "0",
    "\0",
    127,
    "â‚¬"
  ],
  [
    "8140",
    "ä¸‚ä¸„ä¸…ä¸†ä¸ä¸’ä¸—ä¸Ÿä¸ ä¸¡ä¸£ä¸¦ä¸©ä¸®ä¸¯ä¸±ä¸³ä¸µä¸·ä¸¼ä¹€ä¹ä¹‚ä¹„ä¹†ä¹Šä¹‘ä¹•ä¹—ä¹šä¹›ä¹¢ä¹£ä¹¤ä¹¥ä¹§ä¹¨ä¹ª",
    5,
    "ä¹²ä¹´",
    9,
    "ä¹¿",
    6,
    "äº‡äºŠ"
  ],
  [
    "8180",
    "äºäº–äº—äº™äºœäºäºžäº£äºªäº¯äº°äº±äº´äº¶äº·äº¸äº¹äº¼äº½äº¾ä»ˆä»Œä»ä»ä»’ä»šä»›ä»œä» ä»¢ä»¦ä»§ä»©ä»­ä»®ä»¯ä»±ä»´ä»¸ä»¹ä»ºä»¼ä»¾ä¼€ä¼‚",
    6,
    "ä¼‹ä¼Œä¼’",
    4,
    "ä¼œä¼ä¼¡ä¼£ä¼¨ä¼©ä¼¬ä¼­ä¼®ä¼±ä¼³ä¼µä¼·ä¼¹ä¼»ä¼¾",
    4,
    "ä½„ä½…ä½‡",
    5,
    "ä½’ä½”ä½–ä½¡ä½¢ä½¦ä½¨ä½ªä½«ä½­ä½®ä½±ä½²ä½µä½·ä½¸ä½¹ä½ºä½½ä¾€ä¾ä¾‚ä¾…ä¾†ä¾‡ä¾Šä¾Œä¾Žä¾ä¾’ä¾“ä¾•ä¾–ä¾˜ä¾™ä¾šä¾œä¾žä¾Ÿä¾¡ä¾¢"
  ],
  [
    "8240",
    "ä¾¤ä¾«ä¾­ä¾°",
    4,
    "ä¾¶",
    8,
    "ä¿€ä¿ä¿‚ä¿†ä¿‡ä¿ˆä¿‰ä¿‹ä¿Œä¿ä¿’",
    4,
    "ä¿™ä¿›ä¿ ä¿¢ä¿¤ä¿¥ä¿§ä¿«ä¿¬ä¿°ä¿²ä¿´ä¿µä¿¶ä¿·ä¿¹ä¿»ä¿¼ä¿½ä¿¿",
    11
  ],
  [
    "8280",
    "å€‹å€Žå€å€‘å€“å€•å€–å€—å€›å€å€žå€ å€¢å€£å€¤å€§å€«å€¯",
    10,
    "å€»å€½å€¿å€åå‚å„å…å†å‰åŠå‹åå",
    4,
    "å–å—å˜å™å›å",
    7,
    "å¦",
    5,
    "å­",
    8,
    "å¸å¹åºå¼å½å‚å‚‚å‚ƒå‚„å‚†å‚‡å‚‰å‚Šå‚‹å‚Œå‚Ž",
    20,
    "å‚¤å‚¦å‚ªå‚«å‚­",
    4,
    "å‚³",
    6,
    "å‚¼"
  ],
  [
    "8340",
    "å‚½",
    17,
    "åƒ",
    5,
    "åƒ—åƒ˜åƒ™åƒ›",
    10,
    "åƒ¨åƒ©åƒªåƒ«åƒ¯åƒ°åƒ±åƒ²åƒ´åƒ¶",
    4,
    "åƒ¼",
    9,
    "å„ˆ"
  ],
  [
    "8380",
    "å„‰å„Šå„Œ",
    5,
    "å„“",
    13,
    "å„¢",
    28,
    "å…‚å…‡å…Šå…Œå…Žå…å…å…’å…“å…—å…˜å…™å…›å…",
    4,
    "å…£å…¤å…¦å…§å…©å…ªå…¯å…²å…ºå…¾å…¿å†ƒå†„å††å†‡å†Šå†‹å†Žå†å†å†‘å†“å†”å†˜å†šå†å†žå†Ÿå†¡å†£å†¦",
    4,
    "å†­å†®å†´å†¸å†¹å†ºå†¾å†¿å‡å‡‚å‡ƒå‡…å‡ˆå‡Šå‡å‡Žå‡å‡’",
    5
  ],
  [
    "8440",
    "å‡˜å‡™å‡šå‡œå‡žå‡Ÿå‡¢å‡£å‡¥",
    5,
    "å‡¬å‡®å‡±å‡²å‡´å‡·å‡¾åˆ„åˆ…åˆ‰åˆ‹åˆŒåˆåˆåˆ“åˆ”åˆ•åˆœåˆžåˆŸåˆ¡åˆ¢åˆ£åˆ¥åˆ¦åˆ§åˆªåˆ¬åˆ¯åˆ±åˆ²åˆ´åˆµåˆ¼åˆ¾å‰„",
    5,
    "å‰‹å‰Žå‰å‰’å‰“å‰•å‰—å‰˜"
  ],
  [
    "8480",
    "å‰™å‰šå‰›å‰å‰Ÿå‰ å‰¢å‰£å‰¤å‰¦å‰¨å‰«å‰¬å‰­å‰®å‰°å‰±å‰³",
    9,
    "å‰¾åŠ€åŠƒ",
    4,
    "åŠ‰",
    6,
    "åŠ‘åŠ’åŠ”",
    6,
    "åŠœåŠ¤åŠ¥åŠ¦åŠ§åŠ®åŠ¯åŠ°åŠ´",
    9,
    "å‹€å‹å‹‚å‹„å‹…å‹†å‹ˆå‹Šå‹Œå‹å‹Žå‹å‹‘å‹“å‹”å‹•å‹—å‹™",
    5,
    "å‹ å‹¡å‹¢å‹£å‹¥",
    10,
    "å‹±",
    7,
    "å‹»å‹¼å‹½åŒåŒ‚åŒƒåŒ„åŒ‡åŒ‰åŒŠåŒ‹åŒŒåŒŽ"
  ],
  [
    "8540",
    "åŒ‘åŒ’åŒ“åŒ”åŒ˜åŒ›åŒœåŒžåŒŸåŒ¢åŒ¤åŒ¥åŒ§åŒ¨åŒ©åŒ«åŒ¬åŒ­åŒ¯",
    9,
    "åŒ¼åŒ½å€å‚å„å†å‹åŒååå”å˜å™å›åå¥å¨åªå¬å­å²å¶å¹å»å¼å½å¾åŽ€åŽåŽƒåŽ‡åŽˆåŽŠåŽŽåŽ"
  ],
  [
    "8580",
    "åŽ",
    4,
    "åŽ–åŽ—åŽ™åŽ›åŽœåŽžåŽ åŽ¡åŽ¤åŽ§åŽªåŽ«åŽ¬åŽ­åŽ¯",
    6,
    "åŽ·åŽ¸åŽ¹åŽºåŽ¼åŽ½åŽ¾å€åƒ",
    4,
    "åŽååå’å“å•åšåœååžå¡å¢å§å´åºå¾å¿å€å‚å…å‡å‹å”å˜å™åšåœå¢å¤å¥åªå°å³å¶å·åºå½å¿å‘å‘‚å‘„å‘…å‘‡å‘‰å‘Œå‘å‘Žå‘å‘‘å‘šå‘",
    4,
    "å‘£å‘¥å‘§å‘©",
    7,
    "å‘´å‘¹å‘ºå‘¾å‘¿å’å’ƒå’…å’‡å’ˆå’‰å’Šå’å’‘å’“å’—å’˜å’œå’žå’Ÿå’ å’¡"
  ],
  [
    "8640",
    "å’¢å’¥å’®å’°å’²å’µå’¶å’·å’¹å’ºå’¼å’¾å“ƒå“…å“Šå“‹å“–å“˜å“›å“ ",
    4,
    "å“«å“¬å“¯å“°å“±å“´",
    5,
    "å“»å“¾å”€å”‚å”ƒå”„å”…å”ˆå”Š",
    4,
    "å”’å”“å”•",
    5,
    "å”œå”å”žå”Ÿå”¡å”¥å”¦"
  ],
  [
    "8680",
    "å”¨å”©å”«å”­å”²å”´å”µå”¶å”¸å”¹å”ºå”»å”½å•€å•‚å•…å•‡å•ˆå•‹",
    4,
    "å•‘å•’å•“å•”å•—",
    4,
    "å•å•žå•Ÿå• å•¢å•£å•¨å•©å•«å•¯",
    5,
    "å•¹å•ºå•½å•¿å–…å–†å–Œå–å–Žå–å–’å–“å–•å––å–—å–šå–›å–žå– ",
    6,
    "å–¨",
    8,
    "å–²å–´å–¶å–¸å–ºå–¼å–¿",
    4,
    "å—†å—‡å—ˆå—Šå—‹å—Žå—å—å—•å——",
    4,
    "å—žå— å—¢å—§å—©å—­å—®å—°å—±å—´å—¶å—¸",
    4,
    "å—¿å˜‚å˜ƒå˜„å˜…"
  ],
  [
    "8740",
    "å˜†å˜‡å˜Šå˜‹å˜å˜",
    7,
    "å˜™å˜šå˜œå˜å˜ å˜¡å˜¢å˜¥å˜¦å˜¨å˜©å˜ªå˜«å˜®å˜¯å˜°å˜³å˜µå˜·å˜¸å˜ºå˜¼å˜½å˜¾å™€",
    11,
    "å™",
    4,
    "å™•å™–å™šå™›å™",
    4
  ],
  [
    "8780",
    "å™£å™¥å™¦å™§å™­å™®å™¯å™°å™²å™³å™´å™µå™·å™¸å™¹å™ºå™½",
    7,
    "åš‡",
    6,
    "åšåš‘åš’åš”",
    14,
    "åš¤",
    10,
    "åš°",
    6,
    "åš¸åš¹åšºåš»åš½",
    12,
    "å›‹",
    8,
    "å›•å›–å›˜å›™å›œå›£å›¥",
    5,
    "å›¬å›®å›¯å›²å›³å›¶å›·å›¸å›»å›¼åœ€åœåœ‚åœ…åœ‡åœ‹",
    6
  ],
  [
    "8840",
    "åœ’",
    9,
    "åœåœžåœ åœ¡åœ¢åœ¤åœ¥åœ¦åœ§åœ«åœ±åœ²åœ´",
    4,
    "åœ¼åœ½åœ¿ååƒå„å…å†åˆå‰å‹å’",
    4,
    "å˜å™å¢å£å¥å§å¬å®å°å±å²å´åµå¸å¹åºå½å¾å¿åž€"
  ],
  [
    "8880",
    "åžåž‡åžˆåž‰åžŠåž",
    4,
    "åž”",
    6,
    "åžœåžåžžåžŸåž¥åž¨åžªåž¬åž¯åž°åž±åž³åžµåž¶åž·åž¹",
    8,
    "åŸ„",
    6,
    "åŸŒåŸåŸåŸ‘åŸ“åŸ–åŸ—åŸ›åŸœåŸžåŸ¡åŸ¢åŸ£åŸ¥",
    7,
    "åŸ®åŸ°åŸ±åŸ²åŸ³åŸµåŸ¶åŸ·åŸ»åŸ¼åŸ¾åŸ¿å å ƒå „å …å ˆå ‰å Šå Œå Žå å å ’å “å ”å –å —å ˜å šå ›å œå å Ÿå ¢å £å ¥",
    4,
    "å «",
    4,
    "å ±å ²å ³å ´å ¶",
    7
  ],
  [
    "8940",
    "å ¾",
    5,
    "å¡…",
    6,
    "å¡Žå¡å¡å¡’å¡“å¡•å¡–å¡—å¡™",
    4,
    "å¡Ÿ",
    5,
    "å¡¦",
    4,
    "å¡­",
    16,
    "å¡¿å¢‚å¢„å¢†å¢‡å¢ˆå¢Šå¢‹å¢Œ"
  ],
  [
    "8980",
    "å¢",
    4,
    "å¢”",
    4,
    "å¢›å¢œå¢å¢ ",
    7,
    "å¢ª",
    17,
    "å¢½å¢¾å¢¿å£€å£‚å£ƒå£„å£†",
    10,
    "å£’å£“å£”å£–",
    13,
    "å£¥",
    5,
    "å£­å£¯å£±å£²å£´å£µå£·å£¸å£º",
    7,
    "å¤ƒå¤…å¤†å¤ˆ",
    4,
    "å¤Žå¤å¤‘å¤’å¤“å¤—å¤˜å¤›å¤å¤žå¤ å¤¡å¤¢å¤£å¤¦å¤¨å¤¬å¤°å¤²å¤³å¤µå¤¶å¤»"
  ],
  [
    "8a40",
    "å¤½å¤¾å¤¿å¥€å¥ƒå¥…å¥†å¥Šå¥Œå¥å¥å¥’å¥“å¥™å¥›",
    4,
    "å¥¡å¥£å¥¤å¥¦",
    12,
    "å¥µå¥·å¥ºå¥»å¥¼å¥¾å¥¿å¦€å¦…å¦‰å¦‹å¦Œå¦Žå¦å¦å¦‘å¦”å¦•å¦˜å¦šå¦›å¦œå¦å¦Ÿå¦ å¦¡å¦¢å¦¦"
  ],
  [
    "8a80",
    "å¦§å¦¬å¦­å¦°å¦±å¦³",
    5,
    "å¦ºå¦¼å¦½å¦¿",
    6,
    "å§‡å§ˆå§‰å§Œå§å§Žå§å§•å§–å§™å§›å§ž",
    4,
    "å§¤å§¦å§§å§©å§ªå§«å§­",
    11,
    "å§ºå§¼å§½å§¾å¨€å¨‚å¨Šå¨‹å¨å¨Žå¨å¨å¨’å¨”å¨•å¨–å¨—å¨™å¨šå¨›å¨å¨žå¨¡å¨¢å¨¤å¨¦å¨§å¨¨å¨ª",
    6,
    "å¨³å¨µå¨·",
    4,
    "å¨½å¨¾å¨¿å©",
    4,
    "å©‡å©ˆå©‹",
    9,
    "å©–å©—å©˜å©™å©›",
    5
  ],
  [
    "8b40",
    "å©¡å©£å©¤å©¥å©¦å©¨å©©å©«",
    8,
    "å©¸å©¹å©»å©¼å©½å©¾åª€",
    17,
    "åª“",
    6,
    "åªœ",
    13,
    "åª«åª¬"
  ],
  [
    "8b80",
    "åª­",
    4,
    "åª´åª¶åª·åª¹",
    4,
    "åª¿å«€å«ƒ",
    5,
    "å«Šå«‹å«",
    4,
    "å«“å«•å«—å«™å«šå«›å«å«žå«Ÿå«¢å«¤å«¥å«§å«¨å«ªå«¬",
    4,
    "å«²",
    22,
    "å¬Š",
    11,
    "å¬˜",
    25,
    "å¬³å¬µå¬¶å¬¸",
    7,
    "å­",
    6
  ],
  [
    "8c40",
    "å­ˆ",
    7,
    "å­’å­–å­žå­ å­¡å­§å­¨å­«å­­å­®å­¯å­²å­´å­¶å­·å­¸å­¹å­»å­¼å­¾å­¿å®‚å®†å®Šå®å®Žå®å®‘å®’å®”å®–å®Ÿå®§å®¨å®©å®¬å®­å®®å®¯å®±å®²å®·å®ºå®»å®¼å¯€å¯å¯ƒå¯ˆå¯‰å¯Šå¯‹å¯å¯Žå¯"
  ],
  [
    "8c80",
    "å¯‘å¯”",
    8,
    "å¯ å¯¢å¯£å¯¦å¯§å¯©",
    4,
    "å¯¯å¯±",
    6,
    "å¯½å¯¾å°€å°‚å°ƒå°…å°‡å°ˆå°‹å°Œå°å°Žå°å°’å°“å°—å°™å°›å°žå°Ÿå° å°¡å°£å°¦å°¨å°©å°ªå°«å°­å°®å°¯å°°å°²å°³å°µå°¶å°·å±ƒå±„å±†å±‡å±Œå±å±’å±“å±”å±–å±—å±˜å±šå±›å±œå±å±Ÿå±¢å±¤å±§",
    6,
    "å±°å±²",
    6,
    "å±»å±¼å±½å±¾å²€å²ƒ",
    4,
    "å²‰å²Šå²‹å²Žå²å²’å²“å²•å²",
    4,
    "å²¤",
    4
  ],
  [
    "8d40",
    "å²ªå²®å²¯å²°å²²å²´å²¶å²¹å²ºå²»å²¼å²¾å³€å³‚å³ƒå³…",
    5,
    "å³Œ",
    5,
    "å³“",
    5,
    "å³š",
    6,
    "å³¢å³£å³§å³©å³«å³¬å³®å³¯å³±",
    9,
    "å³¼",
    4
  ],
  [
    "8d80",
    "å´å´„å´…å´ˆ",
    5,
    "å´",
    4,
    "å´•å´—å´˜å´™å´šå´œå´å´Ÿ",
    4,
    "å´¥å´¨å´ªå´«å´¬å´¯",
    4,
    "å´µ",
    7,
    "å´¿",
    7,
    "åµˆåµ‰åµ",
    10,
    "åµ™åµšåµœåµž",
    10,
    "åµªåµ­åµ®åµ°åµ±åµ²åµ³åµµ",
    12,
    "å¶ƒ",
    21,
    "å¶šå¶›å¶œå¶žå¶Ÿå¶ "
  ],
  [
    "8e40",
    "å¶¡",
    21,
    "å¶¸",
    12,
    "å·†",
    6,
    "å·Ž",
    12,
    "å·œå·Ÿå· å·£å·¤å·ªå·¬å·­"
  ],
  [
    "8e80",
    "å·°å·µå·¶å·¸",
    4,
    "å·¿å¸€å¸„å¸‡å¸‰å¸Šå¸‹å¸å¸Žå¸’å¸“å¸—å¸ž",
    7,
    "å¸¨",
    4,
    "å¸¯å¸°å¸²",
    4,
    "å¸¹å¸ºå¸¾å¸¿å¹€å¹å¹ƒå¹†",
    5,
    "å¹",
    6,
    "å¹–",
    4,
    "å¹œå¹å¹Ÿå¹ å¹£",
    14,
    "å¹µå¹·å¹¹å¹¾åºåº‚åºƒåº…åºˆåº‰åºŒåºåºŽåº’åº˜åº›åºåº¡åº¢åº£åº¤åº¨",
    4,
    "åº®",
    4,
    "åº´åººåº»åº¼åº½åº¿",
    6
  ],
  [
    "8f40",
    "å»†å»‡å»ˆå»‹",
    5,
    "å»”å»•å»—å»˜å»™å»šå»œ",
    11,
    "å»©å»«",
    8,
    "å»µå»¸å»¹å»»å»¼å»½å¼…å¼†å¼‡å¼‰å¼Œå¼å¼Žå¼å¼’å¼”å¼–å¼™å¼šå¼œå¼å¼žå¼¡å¼¢å¼£å¼¤"
  ],
  [
    "8f80",
    "å¼¨å¼«å¼¬å¼®å¼°å¼²",
    6,
    "å¼»å¼½å¼¾å¼¿å½",
    14,
    "å½‘å½”å½™å½šå½›å½œå½žå½Ÿå½ å½£å½¥å½§å½¨å½«å½®å½¯å½²å½´å½µå½¶å½¸å½ºå½½å½¾å½¿å¾ƒå¾†å¾å¾Žå¾å¾‘å¾“å¾”å¾–å¾šå¾›å¾å¾žå¾Ÿå¾ å¾¢",
    5,
    "å¾©å¾«å¾¬å¾¯",
    5,
    "å¾¶å¾¸å¾¹å¾ºå¾»å¾¾",
    4,
    "å¿‡å¿ˆå¿Šå¿‹å¿Žå¿“å¿”å¿•å¿šå¿›å¿œå¿žå¿Ÿå¿¢å¿£å¿¥å¿¦å¿¨å¿©å¿¬å¿¯å¿°å¿²å¿³å¿´å¿¶å¿·å¿¹å¿ºå¿¼æ€‡"
  ],
  [
    "9040",
    "æ€ˆæ€‰æ€‹æ€Œæ€æ€‘æ€“æ€—æ€˜æ€šæ€žæ€Ÿæ€¢æ€£æ€¤æ€¬æ€­æ€®æ€°",
    4,
    "æ€¶",
    4,
    "æ€½æ€¾æ€æ„",
    6,
    "æŒæŽææ‘æ“æ”æ–æ—æ˜æ›æœæžæŸæ æ¡æ¥æ¦æ®æ±æ²æ´æµæ·æ¾æ‚€"
  ],
  [
    "9080",
    "æ‚æ‚‚æ‚…æ‚†æ‚‡æ‚ˆæ‚Šæ‚‹æ‚Žæ‚æ‚æ‚‘æ‚“æ‚•æ‚—æ‚˜æ‚™æ‚œæ‚žæ‚¡æ‚¢æ‚¤æ‚¥æ‚§æ‚©æ‚ªæ‚®æ‚°æ‚³æ‚µæ‚¶æ‚·æ‚¹æ‚ºæ‚½",
    7,
    "æƒ‡æƒˆæƒ‰æƒŒ",
    4,
    "æƒ’æƒ“æƒ”æƒ–æƒ—æƒ™æƒ›æƒžæƒ¡",
    4,
    "æƒªæƒ±æƒ²æƒµæƒ·æƒ¸æƒ»",
    4,
    "æ„‚æ„ƒæ„„æ„…æ„‡æ„Šæ„‹æ„Œæ„",
    4,
    "æ„–æ„—æ„˜æ„™æ„›æ„œæ„æ„žæ„¡æ„¢æ„¥æ„¨æ„©æ„ªæ„¬",
    18,
    "æ…€",
    6
  ],
  [
    "9140",
    "æ…‡æ…‰æ…‹æ…æ…æ…æ…’æ…“æ…”æ…–",
    6,
    "æ…žæ…Ÿæ… æ…¡æ…£æ…¤æ…¥æ…¦æ…©",
    6,
    "æ…±æ…²æ…³æ…´æ…¶æ…¸",
    18,
    "æ†Œæ†æ†",
    4,
    "æ†•"
  ],
  [
    "9180",
    "æ†–",
    6,
    "æ†ž",
    8,
    "æ†ªæ†«æ†­",
    9,
    "æ†¸",
    5,
    "æ†¿æ‡€æ‡æ‡ƒ",
    4,
    "æ‡‰æ‡Œ",
    4,
    "æ‡“æ‡•",
    16,
    "æ‡§",
    13,
    "æ‡¶",
    8,
    "æˆ€",
    5,
    "æˆ‡æˆ‰æˆ“æˆ”æˆ™æˆœæˆæˆžæˆ æˆ£æˆ¦æˆ§æˆ¨æˆ©æˆ«æˆ­æˆ¯æˆ°æˆ±æˆ²æˆµæˆ¶æˆ¸",
    4,
    "æ‰‚æ‰„æ‰…æ‰†æ‰Š"
  ],
  [
    "9240",
    "æ‰æ‰æ‰•æ‰–æ‰—æ‰™æ‰šæ‰œ",
    6,
    "æ‰¤æ‰¥æ‰¨æ‰±æ‰²æ‰´æ‰µæ‰·æ‰¸æ‰ºæ‰»æ‰½æŠæŠ‚æŠƒæŠ…æŠ†æŠ‡æŠˆæŠ‹",
    5,
    "æŠ”æŠ™æŠœæŠæŠžæŠ£æŠ¦æŠ§æŠ©æŠªæŠ­æŠ®æŠ¯æŠ°æŠ²æŠ³æŠ´æŠ¶æŠ·æŠ¸æŠºæŠ¾æ‹€æ‹"
  ],
  [
    "9280",
    "æ‹ƒæ‹‹æ‹æ‹‘æ‹•æ‹æ‹žæ‹ æ‹¡æ‹¤æ‹ªæ‹«æ‹°æ‹²æ‹µæ‹¸æ‹¹æ‹ºæ‹»æŒ€æŒƒæŒ„æŒ…æŒ†æŒŠæŒ‹æŒŒæŒæŒæŒæŒ’æŒ“æŒ”æŒ•æŒ—æŒ˜æŒ™æŒœæŒ¦æŒ§æŒ©æŒ¬æŒ­æŒ®æŒ°æŒ±æŒ³",
    5,
    "æŒ»æŒ¼æŒ¾æŒ¿æ€ææ„æ‡æˆæŠæ‘æ’æ“æ”æ–",
    7,
    "æ æ¤æ¥æ¦æ¨æªæ«æ¬æ¯æ°æ²æ³æ´æµæ¸æ¹æ¼æ½æ¾æ¿æŽæŽƒæŽ„æŽ…æŽ†æŽ‹æŽæŽ‘æŽ“æŽ”æŽ•æŽ—æŽ™",
    6,
    "æŽ¡æŽ¤æŽ¦æŽ«æŽ¯æŽ±æŽ²æŽµæŽ¶æŽ¹æŽ»æŽ½æŽ¿æ€"
  ],
  [
    "9340",
    "ææ‚æƒæ…æ‡æˆæŠæ‹æŒæ‘æ“æ”æ•æ—",
    6,
    "æŸæ¢æ¤",
    4,
    "æ«æ¬æ®æ¯æ°æ±æ³æµæ·æ¹æºæ»æ¼æ¾æƒæ„æ†",
    4,
    "ææŽæ‘æ’æ•",
    5,
    "ææŸæ¢æ£æ¤"
  ],
  [
    "9380",
    "æ¥æ§æ¨æ©æ«æ®",
    5,
    "æµ",
    4,
    "æ»æ¼æ¾æ‘€æ‘‚æ‘ƒæ‘‰æ‘‹",
    6,
    "æ‘“æ‘•æ‘–æ‘—æ‘™",
    4,
    "æ‘Ÿ",
    7,
    "æ‘¨æ‘ªæ‘«æ‘¬æ‘®",
    9,
    "æ‘»",
    6,
    "æ’ƒæ’†æ’ˆ",
    8,
    "æ’“æ’”æ’—æ’˜æ’šæ’›æ’œæ’æ’Ÿ",
    4,
    "æ’¥æ’¦æ’§æ’¨æ’ªæ’«æ’¯æ’±æ’²æ’³æ’´æ’¶æ’¹æ’»æ’½æ’¾æ’¿æ“æ“ƒæ“„æ“†",
    6,
    "æ“æ“‘æ““æ“”æ“•æ“–æ“™æ“š"
  ],
  [
    "9440",
    "æ“›æ“œæ“æ“Ÿæ“ æ“¡æ“£æ“¥æ“§",
    24,
    "æ”",
    7,
    "æ”Š",
    7,
    "æ”“",
    4,
    "æ”™",
    8
  ],
  [
    "9480",
    "æ”¢æ”£æ”¤æ”¦",
    4,
    "æ”¬æ”­æ”°æ”±æ”²æ”³æ”·æ”ºæ”¼æ”½æ•€",
    4,
    "æ•†æ•‡æ•Šæ•‹æ•æ•Žæ•æ•’æ•“æ•”æ•—æ•˜æ•šæ•œæ•Ÿæ• æ•¡æ•¤æ•¥æ•§æ•¨æ•©æ•ªæ•­æ•®æ•¯æ•±æ•³æ•µæ•¶æ•¸",
    14,
    "æ–ˆæ–‰æ–Šæ–æ–Žæ–æ–’æ–”æ–•æ––æ–˜æ–šæ–æ–žæ– æ–¢æ–£æ–¦æ–¨æ–ªæ–¬æ–®æ–±",
    7,
    "æ–ºæ–»æ–¾æ–¿æ—€æ—‚æ—‡æ—ˆæ—‰æ—Šæ—æ—æ—‘æ—“æ—”æ—•æ—˜",
    7,
    "æ—¡æ—£æ—¤æ—ªæ—«"
  ],
  [
    "9540",
    "æ—²æ—³æ—´æ—µæ—¸æ—¹æ—»",
    4,
    "æ˜æ˜„æ˜…æ˜‡æ˜ˆæ˜‰æ˜‹æ˜æ˜æ˜‘æ˜’æ˜–æ˜—æ˜˜æ˜šæ˜›æ˜œæ˜žæ˜¡æ˜¢æ˜£æ˜¤æ˜¦æ˜©æ˜ªæ˜«æ˜¬æ˜®æ˜°æ˜²æ˜³æ˜·",
    4,
    "æ˜½æ˜¿æ™€æ™‚æ™„",
    6,
    "æ™æ™Žæ™æ™‘æ™˜"
  ],
  [
    "9580",
    "æ™™æ™›æ™œæ™æ™žæ™ æ™¢æ™£æ™¥æ™§æ™©",
    4,
    "æ™±æ™²æ™³æ™µæ™¸æ™¹æ™»æ™¼æ™½æ™¿æš€æšæšƒæš…æš†æšˆæš‰æšŠæš‹æšæšŽæšæšæš’æš“æš”æš•æš˜",
    4,
    "æšž",
    8,
    "æš©",
    4,
    "æš¯",
    4,
    "æšµæš¶æš·æš¸æšºæš»æš¼æš½æš¿",
    25,
    "æ›šæ›ž",
    7,
    "æ›§æ›¨æ›ª",
    5,
    "æ›±æ›µæ›¶æ›¸æ›ºæ›»æ›½æœæœ‚æœƒ"
  ],
  [
    "9640",
    "æœ„æœ…æœ†æœ‡æœŒæœŽæœæœ‘æœ’æœ“æœ–æœ˜æœ™æœšæœœæœžæœ ",
    5,
    "æœ§æœ©æœ®æœ°æœ²æœ³æœ¶æœ·æœ¸æœ¹æœ»æœ¼æœ¾æœ¿ææ„æ…æ‡æŠæ‹ææ’æ”æ•æ—",
    4,
    "ææ¢æ£æ¤æ¦æ§æ«æ¬æ®æ±æ´æ¶"
  ],
  [
    "9680",
    "æ¸æ¹æºæ»æ½æž€æž‚æžƒæž…æž†æžˆæžŠæžŒæžæžŽæžæž‘æž’æž“æž”æž–æž™æž›æžŸæž æž¡æž¤æž¦æž©æž¬æž®æž±æž²æž´æž¹",
    7,
    "æŸ‚æŸ…",
    9,
    "æŸ•æŸ–æŸ—æŸ›æŸŸæŸ¡æŸ£æŸ¤æŸ¦æŸ§æŸ¨æŸªæŸ«æŸ­æŸ®æŸ²æŸµ",
    7,
    "æŸ¾æ æ ‚æ ƒæ „æ †æ æ æ ’æ ”æ •æ ˜",
    4,
    "æ žæ Ÿæ  æ ¢",
    6,
    "æ «",
    6,
    "æ ´æ µæ ¶æ ºæ »æ ¿æ¡‡æ¡‹æ¡æ¡æ¡’æ¡–",
    5
  ],
  [
    "9740",
    "æ¡œæ¡æ¡žæ¡Ÿæ¡ªæ¡¬",
    7,
    "æ¡µæ¡¸",
    8,
    "æ¢‚æ¢„æ¢‡",
    7,
    "æ¢æ¢‘æ¢’æ¢”æ¢•æ¢–æ¢˜",
    9,
    "æ¢£æ¢¤æ¢¥æ¢©æ¢ªæ¢«æ¢¬æ¢®æ¢±æ¢²æ¢´æ¢¶æ¢·æ¢¸"
  ],
  [
    "9780",
    "æ¢¹",
    6,
    "æ£æ£ƒ",
    5,
    "æ£Šæ£Œæ£Žæ£æ£æ£‘æ£“æ£”æ£–æ£—æ£™æ£›",
    4,
    "æ£¡æ£¢æ£¤",
    9,
    "æ£¯æ£²æ£³æ£´æ£¶æ£·æ£¸æ£»æ£½æ£¾æ£¿æ¤€æ¤‚æ¤ƒæ¤„æ¤†",
    4,
    "æ¤Œæ¤æ¤‘æ¤“",
    11,
    "æ¤¡æ¤¢æ¤£æ¤¥",
    7,
    "æ¤®æ¤¯æ¤±æ¤²æ¤³æ¤µæ¤¶æ¤·æ¤¸æ¤ºæ¤»æ¤¼æ¤¾æ¥€æ¥æ¥ƒ",
    16,
    "æ¥•æ¥–æ¥˜æ¥™æ¥›æ¥œæ¥Ÿ"
  ],
  [
    "9840",
    "æ¥¡æ¥¢æ¥¤æ¥¥æ¥§æ¥¨æ¥©æ¥ªæ¥¬æ¥­æ¥¯æ¥°æ¥²",
    4,
    "æ¥ºæ¥»æ¥½æ¥¾æ¥¿æ¦æ¦ƒæ¦…æ¦Šæ¦‹æ¦Œæ¦Ž",
    5,
    "æ¦–æ¦—æ¦™æ¦šæ¦",
    9,
    "æ¦©æ¦ªæ¦¬æ¦®æ¦¯æ¦°æ¦²æ¦³æ¦µæ¦¶æ¦¸æ¦¹æ¦ºæ¦¼æ¦½"
  ],
  [
    "9880",
    "æ¦¾æ¦¿æ§€æ§‚",
    7,
    "æ§‹æ§æ§æ§‘æ§’æ§“æ§•",
    5,
    "æ§œæ§æ§žæ§¡",
    11,
    "æ§®æ§¯æ§°æ§±æ§³",
    9,
    "æ§¾æ¨€",
    9,
    "æ¨‹",
    11,
    "æ¨™",
    5,
    "æ¨ æ¨¢",
    5,
    "æ¨©æ¨«æ¨¬æ¨­æ¨®æ¨°æ¨²æ¨³æ¨´æ¨¶",
    6,
    "æ¨¿",
    4,
    "æ©…æ©†æ©ˆ",
    7,
    "æ©‘",
    6,
    "æ©š"
  ],
  [
    "9940",
    "æ©œ",
    4,
    "æ©¢æ©£æ©¤æ©¦",
    10,
    "æ©²",
    6,
    "æ©ºæ©»æ©½æ©¾æ©¿æªæª‚æªƒæª…",
    8,
    "æªæª’",
    4,
    "æª˜",
    7,
    "æª¡",
    5
  ],
  [
    "9980",
    "æª§æª¨æªªæª­",
    114,
    "æ¬¥æ¬¦æ¬¨",
    6
  ],
  [
    "9a40",
    "æ¬¯æ¬°æ¬±æ¬³æ¬´æ¬µæ¬¶æ¬¸æ¬»æ¬¼æ¬½æ¬¿æ­€æ­æ­‚æ­„æ­…æ­ˆæ­Šæ­‹æ­",
    11,
    "æ­š",
    7,
    "æ­¨æ­©æ­«",
    13,
    "æ­ºæ­½æ­¾æ­¿æ®€æ®…æ®ˆ"
  ],
  [
    "9a80",
    "æ®Œæ®Žæ®æ®æ®‘æ®”æ®•æ®—æ®˜æ®™æ®œ",
    4,
    "æ®¢",
    7,
    "æ®«",
    7,
    "æ®¶æ®¸",
    6,
    "æ¯€æ¯ƒæ¯„æ¯†",
    4,
    "æ¯Œæ¯Žæ¯æ¯‘æ¯˜æ¯šæ¯œ",
    4,
    "æ¯¢",
    7,
    "æ¯¬æ¯­æ¯®æ¯°æ¯±æ¯²æ¯´æ¯¶æ¯·æ¯¸æ¯ºæ¯»æ¯¼æ¯¾",
    6,
    "æ°ˆ",
    4,
    "æ°Žæ°’æ°—æ°œæ°æ°žæ° æ°£æ°¥æ°«æ°¬æ°­æ°±æ°³æ°¶æ°·æ°¹æ°ºæ°»æ°¼æ°¾æ°¿æ±ƒæ±„æ±…æ±ˆæ±‹",
    4,
    "æ±‘æ±’æ±“æ±–æ±˜"
  ],
  [
    "9b40",
    "æ±™æ±šæ±¢æ±£æ±¥æ±¦æ±§æ±«",
    4,
    "æ±±æ±³æ±µæ±·æ±¸æ±ºæ±»æ±¼æ±¿æ²€æ²„æ²‡æ²Šæ²‹æ²æ²Žæ²‘æ²’æ²•æ²–æ²—æ²˜æ²šæ²œæ²æ²žæ² æ²¢æ²¨æ²¬æ²¯æ²°æ²´æ²µæ²¶æ²·æ²ºæ³€æ³æ³‚æ³ƒæ³†æ³‡æ³ˆæ³‹æ³æ³Žæ³æ³‘æ³’æ³˜"
  ],
  [
    "9b80",
    "æ³™æ³šæ³œæ³æ³Ÿæ³¤æ³¦æ³§æ³©æ³¬æ³­æ³²æ³´æ³¹æ³¿æ´€æ´‚æ´ƒæ´…æ´†æ´ˆæ´‰æ´Šæ´æ´æ´æ´‘æ´“æ´”æ´•æ´–æ´˜æ´œæ´æ´Ÿ",
    5,
    "æ´¦æ´¨æ´©æ´¬æ´­æ´¯æ´°æ´´æ´¶æ´·æ´¸æ´ºæ´¿æµ€æµ‚æµ„æµ‰æµŒæµæµ•æµ–æµ—æµ˜æµ›æµæµŸæµ¡æµ¢æµ¤æµ¥æµ§æµ¨æµ«æµ¬æµ­æµ°æµ±æµ²æµ³æµµæµ¶æµ¹æµºæµ»æµ½",
    4,
    "æ¶ƒæ¶„æ¶†æ¶‡æ¶Šæ¶‹æ¶æ¶æ¶æ¶’æ¶–",
    4,
    "æ¶œæ¶¢æ¶¥æ¶¬æ¶­æ¶°æ¶±æ¶³æ¶´æ¶¶æ¶·æ¶¹",
    5,
    "æ·æ·‚æ·ƒæ·ˆæ·‰æ·Š"
  ],
  [
    "9c40",
    "æ·æ·Žæ·æ·æ·’æ·“æ·”æ·•æ·—æ·šæ·›æ·œæ·Ÿæ·¢æ·£æ·¥æ·§æ·¨æ·©æ·ªæ·­æ·¯æ·°æ·²æ·´æ·µæ·¶æ·¸æ·ºæ·½",
    7,
    "æ¸†æ¸‡æ¸ˆæ¸‰æ¸‹æ¸æ¸’æ¸“æ¸•æ¸˜æ¸™æ¸›æ¸œæ¸žæ¸Ÿæ¸¢æ¸¦æ¸§æ¸¨æ¸ªæ¸¬æ¸®æ¸°æ¸±æ¸³æ¸µ"
  ],
  [
    "9c80",
    "æ¸¶æ¸·æ¸¹æ¸»",
    7,
    "æ¹…",
    7,
    "æ¹æ¹æ¹‘æ¹’æ¹•æ¹—æ¹™æ¹šæ¹œæ¹æ¹žæ¹ ",
    10,
    "æ¹¬æ¹­æ¹¯",
    14,
    "æº€æºæº‚æº„æº‡æºˆæºŠ",
    4,
    "æº‘",
    6,
    "æº™æºšæº›æºæºžæº æº¡æº£æº¤æº¦æº¨æº©æº«æº¬æº­æº®æº°æº³æºµæº¸æº¹æº¼æº¾æº¿æ»€æ»ƒæ»„æ»…æ»†æ»ˆæ»‰æ»Šæ»Œæ»æ»Žæ»æ»’æ»–æ»˜æ»™æ»›æ»œæ»æ»£æ»§æ»ª",
    5
  ],
  [
    "9d40",
    "æ»°æ»±æ»²æ»³æ»µæ»¶æ»·æ»¸æ»º",
    7,
    "æ¼ƒæ¼„æ¼…æ¼‡æ¼ˆæ¼Š",
    4,
    "æ¼æ¼‘æ¼’æ¼–",
    9,
    "æ¼¡æ¼¢æ¼£æ¼¥æ¼¦æ¼§æ¼¨æ¼¬æ¼®æ¼°æ¼²æ¼´æ¼µæ¼·",
    6,
    "æ¼¿æ½€æ½æ½‚"
  ],
  [
    "9d80",
    "æ½ƒæ½„æ½…æ½ˆæ½‰æ½Šæ½Œæ½Ž",
    9,
    "æ½™æ½šæ½›æ½æ½Ÿæ½ æ½¡æ½£æ½¤æ½¥æ½§",
    5,
    "æ½¯æ½°æ½±æ½³æ½µæ½¶æ½·æ½¹æ½»æ½½",
    6,
    "æ¾…æ¾†æ¾‡æ¾Šæ¾‹æ¾",
    12,
    "æ¾æ¾žæ¾Ÿæ¾ æ¾¢",
    4,
    "æ¾¨",
    10,
    "æ¾´æ¾µæ¾·æ¾¸æ¾º",
    5,
    "æ¿æ¿ƒ",
    5,
    "æ¿Š",
    6,
    "æ¿“",
    10,
    "æ¿Ÿæ¿¢æ¿£æ¿¤æ¿¥"
  ],
  [
    "9e40",
    "æ¿¦",
    7,
    "æ¿°",
    32,
    "ç€’",
    7,
    "ç€œ",
    6,
    "ç€¤",
    6
  ],
  [
    "9e80",
    "ç€«",
    9,
    "ç€¶ç€·ç€¸ç€º",
    17,
    "ççŽç",
    13,
    "çŸ",
    11,
    "ç®ç±ç²ç³ç´ç·ç¹çºç»ç½ç‚ç‚‚ç‚ƒç‚„ç‚†ç‚‡ç‚ˆç‚‹ç‚Œç‚ç‚ç‚ç‚‘ç‚“ç‚—ç‚˜ç‚šç‚›ç‚ž",
    12,
    "ç‚°ç‚²ç‚´ç‚µç‚¶ç‚ºç‚¾ç‚¿çƒ„çƒ…çƒ†çƒ‡çƒ‰çƒ‹",
    12,
    "çƒš"
  ],
  [
    "9f40",
    "çƒœçƒçƒžçƒ çƒ¡çƒ¢çƒ£çƒ¥çƒªçƒ®çƒ°",
    6,
    "çƒ¸çƒºçƒ»çƒ¼çƒ¾",
    10,
    "ç„‹",
    4,
    "ç„‘ç„’ç„”ç„—ç„›",
    10,
    "ç„§",
    7,
    "ç„²ç„³ç„´"
  ],
  [
    "9f80",
    "ç„µç„·",
    13,
    "ç…†ç…‡ç…ˆç…‰ç…‹ç…ç…",
    12,
    "ç…ç…Ÿ",
    4,
    "ç…¥ç…©",
    4,
    "ç…¯ç…°ç…±ç…´ç…µç…¶ç…·ç…¹ç…»ç…¼ç…¾",
    5,
    "ç†…",
    4,
    "ç†‹ç†Œç†ç†Žç†ç†‘ç†’ç†“ç†•ç†–ç†—ç†š",
    4,
    "ç†¡",
    6,
    "ç†©ç†ªç†«ç†­",
    5,
    "ç†´ç†¶ç†·ç†¸ç†º",
    8,
    "ç‡„",
    9,
    "ç‡",
    4
  ],
  [
    "a040",
    "ç‡–",
    9,
    "ç‡¡ç‡¢ç‡£ç‡¤ç‡¦ç‡¨",
    5,
    "ç‡¯",
    9,
    "ç‡º",
    11,
    "çˆ‡",
    19
  ],
  [
    "a080",
    "çˆ›çˆœçˆž",
    9,
    "çˆ©çˆ«çˆ­çˆ®çˆ¯çˆ²çˆ³çˆ´çˆºçˆ¼çˆ¾ç‰€",
    6,
    "ç‰‰ç‰Šç‰‹ç‰Žç‰ç‰ç‰‘ç‰“ç‰”ç‰•ç‰—ç‰˜ç‰šç‰œç‰žç‰ ç‰£ç‰¤ç‰¥ç‰¨ç‰ªç‰«ç‰¬ç‰­ç‰°ç‰±ç‰³ç‰´ç‰¶ç‰·ç‰¸ç‰»ç‰¼ç‰½çŠ‚çŠƒçŠ…",
    4,
    "çŠŒçŠŽçŠçŠ‘çŠ“",
    11,
    "çŠ ",
    11,
    "çŠ®çŠ±çŠ²çŠ³çŠµçŠº",
    6,
    "ç‹…ç‹†ç‹‡ç‹‰ç‹Šç‹‹ç‹Œç‹ç‹‘ç‹“ç‹”ç‹•ç‹–ç‹˜ç‹šç‹›"
  ],
  [
    "a1a1",
    "ã€€ã€ã€‚Â·Ë‰Ë‡Â¨ã€ƒã€…â€”ï½žâ€–â€¦â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
    7,
    "ã€–ã€—ã€ã€‘Â±Ã—Ã·âˆ¶âˆ§âˆ¨âˆ‘âˆâˆªâˆ©âˆˆâˆ·âˆšâŠ¥âˆ¥âˆ âŒ’âŠ™âˆ«âˆ®â‰¡â‰Œâ‰ˆâˆ½âˆâ‰ â‰®â‰¯â‰¤â‰¥âˆžâˆµâˆ´â™‚â™€Â°â€²â€³â„ƒï¼„Â¤ï¿ ï¿¡â€°Â§â„–â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â€»â†’â†â†‘â†“ã€“"
  ],
  [
    "a2a1",
    "â…°",
    9
  ],
  [
    "a2b1",
    "â’ˆ",
    19,
    "â‘´",
    19,
    "â‘ ",
    9
  ],
  [
    "a2e5",
    "ãˆ ",
    9
  ],
  [
    "a2f1",
    "â… ",
    11
  ],
  [
    "a3a1",
    "ï¼ï¼‚ï¼ƒï¿¥ï¼…",
    88,
    "ï¿£"
  ],
  [
    "a4a1",
    "ã",
    82
  ],
  [
    "a5a1",
    "ã‚¡",
    85
  ],
  [
    "a6a1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a6c1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a6e0",
    "ï¸µï¸¶ï¸¹ï¸ºï¸¿ï¹€ï¸½ï¸¾ï¹ï¹‚ï¹ƒï¹„"
  ],
  [
    "a6ee",
    "ï¸»ï¸¼ï¸·ï¸¸ï¸±"
  ],
  [
    "a6f4",
    "ï¸³ï¸´"
  ],
  [
    "a7a1",
    "Ð",
    5,
    "ÐÐ–",
    25
  ],
  [
    "a7d1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "a840",
    "ËŠË‹Ë™â€“â€•â€¥â€µâ„…â„‰â†–â†—â†˜â†™âˆ•âˆŸâˆ£â‰’â‰¦â‰§âŠ¿â•",
    35,
    "â–",
    6
  ],
  [
    "a880",
    "â–ˆ",
    7,
    "â–“â–”â–•â–¼â–½â—¢â—£â—¤â—¥â˜‰âŠ•ã€’ã€ã€ž"
  ],
  [
    "a8a1",
    "ÄÃ¡ÇŽÃ Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜ÇšÇœÃ¼ÃªÉ‘"
  ],
  [
    "a8bd",
    "Å„Åˆ"
  ],
  [
    "a8c0",
    "É¡"
  ],
  [
    "a8c5",
    "ã„…",
    36
  ],
  [
    "a940",
    "ã€¡",
    8,
    "ãŠ£ãŽŽãŽãŽœãŽãŽžãŽ¡ã„ãŽã‘ã’ã•ï¸°ï¿¢ï¿¤"
  ],
  [
    "a959",
    "â„¡ãˆ±"
  ],
  [
    "a95c",
    "â€"
  ],
  [
    "a960",
    "ãƒ¼ã‚›ã‚œãƒ½ãƒ¾ã€†ã‚ã‚žï¹‰",
    9,
    "ï¹”ï¹•ï¹–ï¹—ï¹™",
    8
  ],
  [
    "a980",
    "ï¹¢",
    4,
    "ï¹¨ï¹©ï¹ªï¹«"
  ],
  [
    "a996",
    "ã€‡"
  ],
  [
    "a9a4",
    "â”€",
    75
  ],
  [
    "aa40",
    "ç‹œç‹ç‹Ÿç‹¢",
    5,
    "ç‹ªç‹«ç‹µç‹¶ç‹¹ç‹½ç‹¾ç‹¿çŒ€çŒ‚çŒ„",
    5,
    "çŒ‹çŒŒçŒçŒçŒçŒ‘çŒ’çŒ”çŒ˜çŒ™çŒšçŒŸçŒ çŒ£çŒ¤çŒ¦çŒ§çŒ¨çŒ­çŒ¯çŒ°çŒ²çŒ³çŒµçŒ¶çŒºçŒ»çŒ¼çŒ½ç€",
    8
  ],
  [
    "aa80",
    "ç‰çŠç‹çŒçŽçç‘ç“ç”ç•ç–ç˜",
    7,
    "ç¡",
    10,
    "ç®ç°ç±"
  ],
  [
    "ab40",
    "ç²",
    11,
    "ç¿",
    4,
    "çŽ…çŽ†çŽˆçŽŠçŽŒçŽçŽçŽçŽ’çŽ“çŽ”çŽ•çŽ—çŽ˜çŽ™çŽšçŽœçŽçŽžçŽ çŽ¡çŽ£",
    5,
    "çŽªçŽ¬çŽ­çŽ±çŽ´çŽµçŽ¶çŽ¸çŽ¹çŽ¼çŽ½çŽ¾çŽ¿ççƒ",
    4
  ],
  [
    "ab80",
    "ç‹çŒçŽç’",
    6,
    "çšç›çœççŸç¡ç¢ç£ç¤ç¦ç¨çªç«ç¬ç®ç¯ç°ç±ç³",
    4
  ],
  [
    "ac40",
    "ç¸",
    10,
    "ç„ç‡çˆç‹çŒççŽç‘",
    8,
    "çœ",
    5,
    "ç£ç¤ç§ç©ç«ç­ç¯ç±ç²ç·",
    4,
    "ç½ç¾ç¿ç‘€ç‘‚",
    11
  ],
  [
    "ac80",
    "ç‘Ž",
    6,
    "ç‘–ç‘˜ç‘ç‘ ",
    12,
    "ç‘®ç‘¯ç‘±",
    4,
    "ç‘¸ç‘¹ç‘º"
  ],
  [
    "ad40",
    "ç‘»ç‘¼ç‘½ç‘¿ç’‚ç’„ç’…ç’†ç’ˆç’‰ç’Šç’Œç’ç’ç’‘",
    10,
    "ç’ç’Ÿ",
    7,
    "ç’ª",
    15,
    "ç’»",
    12
  ],
  [
    "ad80",
    "ç“ˆ",
    9,
    "ç““",
    8,
    "ç“ç“Ÿç“¡ç“¥ç“§",
    6,
    "ç“°ç“±ç“²"
  ],
  [
    "ae40",
    "ç“³ç“µç“¸",
    6,
    "ç”€ç”ç”‚ç”ƒç”…",
    7,
    "ç”Žç”ç”’ç””ç”•ç”–ç”—ç”›ç”ç”žç” ",
    4,
    "ç”¦ç”§ç”ªç”®ç”´ç”¶ç”¹ç”¼ç”½ç”¿ç•ç•‚ç•ƒç•„ç•†ç•‡ç•‰ç•Šç•ç•ç•‘ç•’ç•“ç••ç•–ç•—ç•˜"
  ],
  [
    "ae80",
    "ç•",
    7,
    "ç•§ç•¨ç•©ç•«",
    6,
    "ç•³ç•µç•¶ç•·ç•º",
    4,
    "ç–€ç–ç–‚ç–„ç–…ç–‡"
  ],
  [
    "af40",
    "ç–ˆç–‰ç–Šç–Œç–ç–Žç–ç–“ç–•ç–˜ç–›ç–œç–žç–¢ç–¦",
    4,
    "ç–­ç–¶ç–·ç–ºç–»ç–¿ç—€ç—ç—†ç—‹ç—Œç—Žç—ç—ç—‘ç—“ç——ç—™ç—šç—œç—ç—Ÿç— ç—¡ç—¥ç—©ç—¬ç—­ç—®ç—¯ç—²ç—³ç—µç—¶ç—·ç—¸ç—ºç—»ç—½ç—¾ç˜‚ç˜„ç˜†ç˜‡"
  ],
  [
    "af80",
    "ç˜ˆç˜‰ç˜‹ç˜ç˜Žç˜ç˜‘ç˜’ç˜“ç˜”ç˜–ç˜šç˜œç˜ç˜žç˜¡ç˜£ç˜§ç˜¨ç˜¬ç˜®ç˜¯ç˜±ç˜²ç˜¶ç˜·ç˜¹ç˜ºç˜»ç˜½ç™ç™‚ç™„"
  ],
  [
    "b040",
    "ç™…",
    6,
    "ç™Ž",
    5,
    "ç™•ç™—",
    4,
    "ç™ç™Ÿç™ ç™¡ç™¢ç™¤",
    6,
    "ç™¬ç™­ç™®ç™°",
    7,
    "ç™¹ç™ºç™¼ç™¿çš€çšçšƒçš…çš‰çšŠçšŒçšçšçšçš’çš”çš•çš—çš˜çššçš›"
  ],
  [
    "b080",
    "çšœ",
    7,
    "çš¥",
    8,
    "çš¯çš°çš³çšµ",
    9,
    "ç›€ç›ç›ƒå•Šé˜¿åŸƒæŒ¨å“Žå”‰å“€çš‘ç™Œè”¼çŸ®è‰¾ç¢çˆ±éš˜éžæ°¨å®‰ä¿ºæŒ‰æš—å²¸èƒºæ¡ˆè‚®æ˜‚ç›Žå‡¹æ•–ç†¬ç¿±è¢„å‚²å¥¥æ‡Šæ¾³èŠ­æŒæ‰’å­å§ç¬†å…«ç–¤å·´æ‹”è·‹é¶æŠŠè€™åéœ¸ç½¢çˆ¸ç™½æŸç™¾æ‘†ä½°è´¥æ‹œç¨—æ–‘ç­æ¬æ‰³èˆ¬é¢æ¿ç‰ˆæ‰®æ‹Œä¼´ç“£åŠåŠžç»Šé‚¦å¸®æ¢†æ¦œè†€ç»‘æ£’ç£…èšŒé•‘å‚è°¤è‹žèƒžåŒ…è¤’å‰¥"
  ],
  [
    "b140",
    "ç›„ç›‡ç›‰ç›‹ç›Œç›“ç›•ç›™ç›šç›œç›ç›žç› ",
    4,
    "ç›¦",
    7,
    "ç›°ç›³ç›µç›¶ç›·ç›ºç›»ç›½ç›¿çœ€çœ‚çœƒçœ…çœ†çœŠçœŒçœŽ",
    10,
    "çœ›çœœçœçœžçœ¡çœ£çœ¤çœ¥çœ§çœªçœ«"
  ],
  [
    "b180",
    "çœ¬çœ®çœ°",
    4,
    "çœ¹çœ»çœ½çœ¾çœ¿ç‚ç„ç…ç†çˆ",
    7,
    "ç’",
    7,
    "çœè–„é›¹ä¿å ¡é¥±å®æŠ±æŠ¥æš´è±¹é²çˆ†æ¯ç¢‘æ‚²å‘åŒ—è¾ˆèƒŒè´é’¡å€ç‹ˆå¤‡æƒ«ç„™è¢«å¥”è‹¯æœ¬ç¬¨å´©ç»·ç”­æ³µè¹¦è¿¸é€¼é¼»æ¯”é„™ç¬”å½¼ç¢§è“–è”½æ¯•æ¯™æ¯–å¸åº‡ç—¹é—­æ•å¼Šå¿…è¾Ÿå£è‡‚é¿é™›éž­è¾¹ç¼–è´¬æ‰ä¾¿å˜åžè¾¨è¾©è¾«éæ ‡å½ªè†˜è¡¨é³–æ†‹åˆ«ç˜ªå½¬æ–Œæ¿’æ»¨å®¾æ‘ˆå…µå†°æŸ„ä¸™ç§‰é¥¼ç‚³"
  ],
  [
    "b240",
    "ççžçŸç ç¤ç§ç©çªç­",
    11,
    "çºç»ç¼çžçž‚çžƒçž†",
    5,
    "çžçžçž“",
    11,
    "çž¡çž£çž¤çž¦çž¨çž«çž­çž®çž¯çž±çž²çž´çž¶",
    4
  ],
  [
    "b280",
    "çž¼çž¾çŸ€",
    12,
    "çŸŽ",
    8,
    "çŸ˜çŸ™çŸšçŸ",
    4,
    "çŸ¤ç—…å¹¶çŽ»è æ’­æ‹¨é’µæ³¢åšå‹ƒæé“‚ç®”ä¼¯å¸›èˆ¶è„–è†Šæ¸¤æ³Šé©³æ•åœå“ºè¡¥åŸ ä¸å¸ƒæ­¥ç°¿éƒ¨æ€–æ“¦çŒœè£ææ‰è´¢ç¬è¸©é‡‡å½©èœè”¡é¤å‚èš•æ®‹æƒ­æƒ¨ç¿è‹èˆ±ä»“æ²§è—æ“ç³™æ§½æ›¹è‰åŽ•ç­–ä¾§å†Œæµ‹å±‚è¹­æ’å‰èŒ¬èŒ¶æŸ¥ç¢´æ½å¯Ÿå²”å·®è¯§æ‹†æŸ´è±ºæ€æŽºè‰é¦‹è°—ç¼ é“²äº§é˜é¢¤æ˜ŒçŒ–"
  ],
  [
    "b340",
    "çŸ¦çŸ¨çŸªçŸ¯çŸ°çŸ±çŸ²çŸ´çŸµçŸ·çŸ¹çŸºçŸ»çŸ¼ç ƒ",
    5,
    "ç Šç ‹ç Žç ç ç “ç •ç ™ç ›ç žç  ç ¡ç ¢ç ¤ç ¨ç ªç «ç ®ç ¯ç ±ç ²ç ³ç µç ¶ç ½ç ¿ç¡ç¡‚ç¡ƒç¡„ç¡†ç¡ˆç¡‰ç¡Šç¡‹ç¡ç¡ç¡‘ç¡“ç¡”ç¡˜ç¡™ç¡š"
  ],
  [
    "b380",
    "ç¡›ç¡œç¡ž",
    11,
    "ç¡¯",
    7,
    "ç¡¸ç¡¹ç¡ºç¡»ç¡½",
    6,
    "åœºå°å¸¸é•¿å¿è‚ åŽ‚æ•žç•…å”±å€¡è¶…æŠ„é’žæœå˜²æ½®å·¢åµç‚’è½¦æ‰¯æ’¤æŽ£å½»æ¾ˆéƒ´è‡£è¾°å°˜æ™¨å¿±æ²‰é™ˆè¶è¡¬æ’‘ç§°åŸŽæ©™æˆå‘ˆä¹˜ç¨‹æƒ©æ¾„è¯šæ‰¿é€žéª‹ç§¤åƒç—´æŒåŒ™æ± è¿Ÿå¼›é©°è€»é½¿ä¾ˆå°ºèµ¤ç¿…æ–¥ç‚½å……å†²è™«å´‡å® æŠ½é…¬ç•´è¸Œç¨ æ„ç­¹ä»‡ç»¸çž…ä¸‘è‡­åˆå‡ºæ©±åŽ¨èº‡é”„é›æ»é™¤æ¥š"
  ],
  [
    "b440",
    "ç¢„ç¢…ç¢†ç¢ˆç¢Šç¢‹ç¢ç¢ç¢’ç¢”ç¢•ç¢–ç¢™ç¢ç¢žç¢ ç¢¢ç¢¤ç¢¦ç¢¨",
    7,
    "ç¢µç¢¶ç¢·ç¢¸ç¢ºç¢»ç¢¼ç¢½ç¢¿ç£€ç£‚ç£ƒç£„ç£†ç£‡ç£ˆç£Œç£ç£Žç£ç£‘ç£’ç£“ç£–ç£—ç£˜ç£š",
    9
  ],
  [
    "b480",
    "ç£¤ç£¥ç£¦ç£§ç£©ç£ªç£«ç£­",
    4,
    "ç£³ç£µç£¶ç£¸ç£¹ç£»",
    5,
    "ç¤‚ç¤ƒç¤„ç¤†",
    6,
    "ç¡€å‚¨çŸ—æè§¦å¤„æ£å·ç©¿æ¤½ä¼ èˆ¹å–˜ä¸²ç–®çª—å¹¢åºŠé—¯åˆ›å¹ç‚Šæ¶é”¤åž‚æ˜¥æ¤¿é†‡å”‡æ·³çº¯è ¢æˆ³ç»°ç–µèŒ¨ç£é›Œè¾žæ…ˆç“·è¯æ­¤åˆºèµæ¬¡èªè‘±å›±åŒ†ä»Žä¸›å‡‘ç²—é†‹ç°‡ä¿ƒè¹¿ç¯¡çªœæ‘§å´”å‚¬è„†ç˜ç²¹æ·¬ç¿ æ‘å­˜å¯¸ç£‹æ’®æ“æŽªæŒ«é”™æ­è¾¾ç­”ç˜©æ‰“å¤§å‘†æ­¹å‚£æˆ´å¸¦æ®†ä»£è´·è¢‹å¾…é€®"
  ],
  [
    "b540",
    "ç¤",
    5,
    "ç¤”",
    9,
    "ç¤Ÿ",
    4,
    "ç¤¥",
    14,
    "ç¤µ",
    4,
    "ç¤½ç¤¿ç¥‚ç¥ƒç¥„ç¥…ç¥‡ç¥Š",
    8,
    "ç¥”ç¥•ç¥˜ç¥™ç¥¡ç¥£"
  ],
  [
    "b580",
    "ç¥¤ç¥¦ç¥©ç¥ªç¥«ç¥¬ç¥®ç¥°",
    6,
    "ç¥¹ç¥»",
    4,
    "ç¦‚ç¦ƒç¦†ç¦‡ç¦ˆç¦‰ç¦‹ç¦Œç¦ç¦Žç¦ç¦‘ç¦’æ€ è€½æ‹…ä¸¹å•éƒ¸æŽ¸èƒ†æ—¦æ°®ä½†æƒ®æ·¡è¯žå¼¹è›‹å½“æŒ¡å…šè¡æ¡£åˆ€æ£è¹ˆå€’å²›ç¥·å¯¼åˆ°ç¨»æ‚¼é“ç›—å¾·å¾—çš„è¹¬ç¯ç™»ç­‰çžªå‡³é‚“å ¤ä½Žæ»´è¿ªæ•Œç¬›ç‹„æ¶¤ç¿Ÿå«¡æŠµåº•åœ°è’‚ç¬¬å¸å¼Ÿé€’ç¼”é¢ æŽ‚æ»‡ç¢˜ç‚¹å…¸é›åž«ç”µä½ƒç”¸åº—æƒ¦å¥ æ·€æ®¿ç¢‰å¼é›•å‡‹åˆæŽ‰åŠé’“è°ƒè·Œçˆ¹ç¢Ÿè¶è¿­è°å "
  ],
  [
    "b640",
    "ç¦“",
    6,
    "ç¦›",
    11,
    "ç¦¨",
    10,
    "ç¦´",
    4,
    "ç¦¼ç¦¿ç§‚ç§„ç§…ç§‡ç§ˆç§Šç§Œç§Žç§ç§ç§“ç§”ç§–ç§—ç§™",
    5,
    "ç§ ç§¡ç§¢ç§¥ç§¨ç§ª"
  ],
  [
    "b680",
    "ç§¬ç§®ç§±",
    6,
    "ç§¹ç§ºç§¼ç§¾ç§¿ç¨ç¨„ç¨…ç¨‡ç¨ˆç¨‰ç¨Šç¨Œç¨",
    4,
    "ç¨•ç¨–ç¨˜ç¨™ç¨›ç¨œä¸ç›¯å®é’‰é¡¶é¼Žé”­å®šè®¢ä¸¢ä¸œå†¬è‘£æ‡‚åŠ¨æ ‹ä¾—æ«å†»æ´žå…œæŠ–æ–—é™¡è±†é€—ç—˜éƒ½ç£æ¯’çŠŠç‹¬è¯»å µç¹èµŒæœé•€è‚šåº¦æ¸¡å¦’ç«¯çŸ­é”»æ®µæ–­ç¼Žå †å…‘é˜Ÿå¯¹å¢©å¨è¹²æ•¦é¡¿å›¤é’ç›¾éæŽ‡å“†å¤šå¤ºåž›èº²æœµè·ºèˆµå‰æƒ°å •è›¾å³¨é¹…ä¿„é¢è®¹å¨¥æ¶åŽ„æ‰¼éé„‚é¥¿æ©è€Œå„¿è€³å°”é¥µæ´±äºŒ"
  ],
  [
    "b740",
    "ç¨ç¨Ÿç¨¡ç¨¢ç¨¤",
    14,
    "ç¨´ç¨µç¨¶ç¨¸ç¨ºç¨¾ç©€",
    5,
    "ç©‡",
    9,
    "ç©’",
    4,
    "ç©˜",
    16
  ],
  [
    "b780",
    "ç©©",
    6,
    "ç©±ç©²ç©³ç©µç©»ç©¼ç©½ç©¾çª‚çª…çª‡çª‰çªŠçª‹çªŒçªŽçªçªçª“çª”çª™çªšçª›çªžçª¡çª¢è´°å‘ç½šç­ä¼ä¹é˜€æ³•çè—©å¸†ç•ªç¿»æ¨ŠçŸ¾é’’ç¹å‡¡çƒ¦åè¿”èŒƒè´©çŠ¯é¥­æ³›åŠèŠ³æ–¹è‚ªæˆ¿é˜²å¦¨ä»¿è®¿çººæ”¾è²éžå•¡é£žè‚¥åŒªè¯½å è‚ºåºŸæ²¸è´¹èŠ¬é…šå©æ°›åˆ†çº·åŸç„šæ±¾ç²‰å¥‹ä»½å¿¿æ„¤ç²ªä¸°å°æž«èœ‚å³°é”‹é£Žç–¯çƒ½é€¢å†¯ç¼è®½å¥‰å‡¤ä½›å¦å¤«æ•·è‚¤å­µæ‰¶æ‹‚è¾å¹…æ°Ÿç¬¦ä¼ä¿˜æœ"
  ],
  [
    "b840",
    "çª£çª¤çª§çª©çªªçª«çª®",
    4,
    "çª´",
    10,
    "ç«€",
    10,
    "ç«Œ",
    9,
    "ç«—ç«˜ç«šç«›ç«œç«ç«¡ç«¢ç«¤ç«§",
    5,
    "ç«®ç«°ç«±ç«²ç«³"
  ],
  [
    "b880",
    "ç«´",
    4,
    "ç«»ç«¼ç«¾ç¬€ç¬ç¬‚ç¬…ç¬‡ç¬‰ç¬Œç¬ç¬Žç¬ç¬’ç¬“ç¬–ç¬—ç¬˜ç¬šç¬œç¬ç¬Ÿç¬¡ç¬¢ç¬£ç¬§ç¬©ç¬­æµ®æ¶ªç¦è¢±å¼—ç”«æŠšè¾…ä¿¯é‡œæ–§è„¯è…‘åºœè…èµ´å‰¯è¦†èµ‹å¤å‚…ä»˜é˜œçˆ¶è…¹è´Ÿå¯Œè®£é™„å¦‡ç¼šå’å™¶å˜Žè¯¥æ”¹æ¦‚é’™ç›–æº‰å¹²ç”˜æ†æŸ‘ç«¿è‚èµ¶æ„Ÿç§†æ•¢èµ£å†ˆåˆšé’¢ç¼¸è‚›çº²å²—æ¸¯æ ç¯™çš‹é«˜è†ç¾”ç³•æžé•ç¨¿å‘Šå“¥æ­Œææˆˆé¸½èƒ³ç–™å‰²é©è‘›æ ¼è›¤é˜éš”é“¬ä¸ªå„ç»™æ ¹è·Ÿè€•æ›´åºšç¾¹"
  ],
  [
    "b940",
    "ç¬¯ç¬°ç¬²ç¬´ç¬µç¬¶ç¬·ç¬¹ç¬»ç¬½ç¬¿",
    5,
    "ç­†ç­ˆç­Šç­ç­Žç­“ç­•ç­—ç­™ç­œç­žç­Ÿç­¡ç­£",
    10,
    "ç­¯ç­°ç­³ç­´ç­¶ç­¸ç­ºç­¼ç­½ç­¿ç®ç®‚ç®ƒç®„ç®†",
    6,
    "ç®Žç®"
  ],
  [
    "b980",
    "ç®‘ç®’ç®“ç®–ç®˜ç®™ç®šç®›ç®žç®Ÿç® ç®£ç®¤ç®¥ç®®ç®¯ç®°ç®²ç®³ç®µç®¶ç®·ç®¹",
    7,
    "ç¯‚ç¯ƒç¯„åŸ‚è€¿æ¢—å·¥æ”»åŠŸæ­é¾šä¾›èº¬å…¬å®«å¼“å·©æ±žæ‹±è´¡å…±é’©å‹¾æ²Ÿè‹Ÿç‹—åž¢æž„è´­å¤Ÿè¾œè‡å’•ç®ä¼°æ²½å­¤å§‘é¼“å¤è›Šéª¨è°·è‚¡æ•…é¡¾å›ºé›‡åˆ®ç“œå‰å¯¡æŒ‚è¤‚ä¹–æ‹æ€ªæ£ºå…³å®˜å† è§‚ç®¡é¦†ç½æƒ¯çŒè´¯å…‰å¹¿é€›ç‘°è§„åœ­ç¡…å½’é¾Ÿé—ºè½¨é¬¼è¯¡ç™¸æ¡‚æŸœè·ªè´µåˆ½è¾Šæ»šæ£é”…éƒ­å›½æžœè£¹è¿‡å“ˆ"
  ],
  [
    "ba40",
    "ç¯…ç¯ˆç¯‰ç¯Šç¯‹ç¯ç¯Žç¯ç¯ç¯’ç¯”",
    4,
    "ç¯›ç¯œç¯žç¯Ÿç¯ ç¯¢ç¯£ç¯¤ç¯§ç¯¨ç¯©ç¯«ç¯¬ç¯­ç¯¯ç¯°ç¯²",
    4,
    "ç¯¸ç¯¹ç¯ºç¯»ç¯½ç¯¿",
    7,
    "ç°ˆç°‰ç°Šç°ç°Žç°",
    5,
    "ç°—ç°˜ç°™"
  ],
  [
    "ba80",
    "ç°š",
    4,
    "ç° ",
    5,
    "ç°¨ç°©ç°«",
    12,
    "ç°¹",
    5,
    "ç±‚éª¸å­©æµ·æ°¦äº¥å®³éª‡é…£æ†¨é‚¯éŸ©å«æ¶µå¯’å‡½å–Šç½•ç¿°æ’¼ææ—±æ†¾æ‚ç„Šæ±—æ±‰å¤¯æ­èˆªå£•åšŽè±ªæ¯«éƒå¥½è€—å·æµ©å‘µå–è·èæ ¸ç¦¾å’Œä½•åˆç›’è²‰é˜‚æ²³æ¶¸èµ«è¤é¹¤è´ºå˜¿é»‘ç—•å¾ˆç‹ æ¨å“¼äº¨æ¨ªè¡¡æ’è½°å“„çƒ˜è™¹é¸¿æ´ªå®å¼˜çº¢å–‰ä¾¯çŒ´å¼åŽšå€™åŽå‘¼ä¹Žå¿½ç‘šå£¶è‘«èƒ¡è´ç‹ç³Šæ¹–"
  ],
  [
    "bb40",
    "ç±ƒ",
    9,
    "ç±Ž",
    36,
    "ç±µ",
    5,
    "ç±¾",
    9
  ],
  [
    "bb80",
    "ç²ˆç²Š",
    6,
    "ç²“ç²”ç²–ç²™ç²šç²›ç² ç²¡ç²£ç²¦ç²§ç²¨ç²©ç²«ç²¬ç²­ç²¯ç²°ç²´",
    4,
    "ç²ºç²»å¼§è™Žå”¬æŠ¤äº’æ²ªæˆ·èŠ±å“—åŽçŒ¾æ»‘ç”»åˆ’åŒ–è¯æ§å¾Šæ€€æ·®åæ¬¢çŽ¯æ¡“è¿˜ç¼“æ¢æ‚£å”¤ç—ªè±¢ç„•æ¶£å®¦å¹»è’æ…Œé»„ç£ºè—ç°§çš‡å‡°æƒ¶ç…Œæ™ƒå¹Œæè°Žç°æŒ¥è¾‰å¾½æ¢è›”å›žæ¯æ‚”æ…§å‰æƒ æ™¦è´¿ç§½ä¼šçƒ©æ±‡è®³è¯²ç»˜è¤æ˜å©šé­‚æµ‘æ··è±æ´»ä¼™ç«èŽ·æˆ–æƒ‘éœè´§ç¥¸å‡»åœ¾åŸºæœºç•¸ç¨½ç§¯ç®•"
  ],
  [
    "bc40",
    "ç²¿ç³€ç³‚ç³ƒç³„ç³†ç³‰ç³‹ç³Ž",
    6,
    "ç³˜ç³šç³›ç³ç³žç³¡",
    6,
    "ç³©",
    5,
    "ç³°",
    7,
    "ç³¹ç³ºç³¼",
    13,
    "ç´‹",
    5
  ],
  [
    "bc80",
    "ç´‘",
    14,
    "ç´¡ç´£ç´¤ç´¥ç´¦ç´¨ç´©ç´ªç´¬ç´­ç´®ç´°",
    6,
    "è‚Œé¥¥è¿¹æ¿€è®¥é¸¡å§¬ç»©ç¼‰å‰æžæ£˜è¾‘ç±é›†åŠæ€¥ç–¾æ±²å³å«‰çº§æŒ¤å‡ è„Šå·±è“ŸæŠ€å†€å­£ä¼Žç¥­å‰‚æ‚¸æµŽå¯„å¯‚è®¡è®°æ—¢å¿Œé™…å¦“ç»§çºªå˜‰æž·å¤¹ä½³å®¶åŠ èšé¢Šè´¾ç”²é’¾å‡ç¨¼ä»·æž¶é©¾å«æ­¼ç›‘åšå°–ç¬ºé—´ç…Žå…¼è‚©è‰°å¥¸ç¼„èŒ§æ£€æŸ¬ç¢±ç¡·æ‹£æ¡ç®€ä¿­å‰ªå‡èæ§›é‰´è·µè´±è§é”®ç®­ä»¶"
  ],
  [
    "bd40",
    "ç´·",
    54,
    "çµ¯",
    7
  ],
  [
    "bd80",
    "çµ¸",
    32,
    "å¥èˆ°å‰‘é¥¯æ¸æº…æ¶§å»ºåƒµå§œå°†æµ†æ±Ÿç–†è’‹æ¡¨å¥–è®²åŒ é…±é™è•‰æ¤’ç¤ç„¦èƒ¶äº¤éƒŠæµ‡éª„å¨‡åš¼æ…é“°çŸ«ä¾¥è„šç‹¡è§’é¥ºç¼´ç»žå‰¿æ•™é…µè½¿è¾ƒå«çª–æ­æŽ¥çš†ç§¸è¡—é˜¶æˆªåŠ«èŠ‚æ¡”æ°æ·ç«ç«­æ´ç»“è§£å§æˆ’è—‰èŠ¥ç•Œå€Ÿä»‹ç–¥è¯«å±Šå·¾ç­‹æ–¤é‡‘ä»Šæ´¥è¥Ÿç´§é”¦ä»…è°¨è¿›é³æ™‹ç¦è¿‘çƒ¬æµ¸"
  ],
  [
    "be40",
    "ç¶™",
    12,
    "ç¶§",
    6,
    "ç¶¯",
    42
  ],
  [
    "be80",
    "ç·š",
    32,
    "å°½åŠ²è†å…¢èŒŽç›æ™¶é²¸äº¬æƒŠç²¾ç²³ç»äº•è­¦æ™¯é¢ˆé™å¢ƒæ•¬é•œå¾„ç—‰é–ç«Ÿç«žå‡€ç‚¯çª˜æªç©¶çº çŽ–éŸ­ä¹…ç¸ä¹é…’åŽ©æ•‘æ—§è‡¼èˆ…å’Žå°±ç–šéž æ‹˜ç‹™ç–½å±…é©¹èŠå±€å’€çŸ©ä¸¾æ²®èšæ‹’æ®å·¨å…·è·è¸žé”¯ä¿±å¥æƒ§ç‚¬å‰§æé¹ƒå¨Ÿå€¦çœ·å·ç»¢æ’…æ”«æŠ‰æŽ˜å€”çˆµè§‰å†³è¯€ç»å‡èŒé’§å†›å›å³»"
  ],
  [
    "bf40",
    "ç·»",
    62
  ],
  [
    "bf80",
    "ç¸ºç¸¼",
    4,
    "ç¹‚",
    4,
    "ç¹ˆ",
    21,
    "ä¿Šç«£æµšéƒ¡éªå–€å’–å¡å’¯å¼€æ©æ¥·å‡¯æ…¨åˆŠå ªå‹˜åŽç çœ‹åº·æ…·ç³ æ‰›æŠ—äº¢ç‚•è€ƒæ‹·çƒ¤é å·è‹›æŸ¯æ£µç£•é¢—ç§‘å£³å’³å¯æ¸´å…‹åˆ»å®¢è¯¾è‚¯å•ƒåž¦æ³å‘å­ç©ºæå­”æŽ§æŠ å£æ‰£å¯‡æž¯å“­çªŸè‹¦é…·åº“è£¤å¤¸åž®æŒŽè·¨èƒ¯å—ç­·ä¾©å¿«å®½æ¬¾åŒ¡ç­ç‹‚æ¡†çŸ¿çœ¶æ—·å†µäºç›”å²¿çª¥è‘µå¥Žé­å‚€"
  ],
  [
    "c040",
    "ç¹ž",
    35,
    "çºƒ",
    23,
    "çºœçºçºž"
  ],
  [
    "c080",
    "çº®çº´çº»çº¼ç»–ç»¤ç»¬ç»¹ç¼Šç¼ç¼žç¼·ç¼¹ç¼»",
    6,
    "ç½ƒç½†",
    9,
    "ç½’ç½“é¦ˆæ„§æºƒå¤æ˜†æ†å›°æ‹¬æ‰©å»“é˜”åžƒæ‹‰å–‡èœ¡è…Šè¾£å•¦èŽ±æ¥èµ–è“å©ªæ æ‹¦ç¯®é˜‘å…°æ¾œè°°æ½è§ˆæ‡’ç¼†çƒ‚æ»¥ç…æ¦”ç‹¼å»ŠéƒŽæœ—æµªæžåŠ³ç‰¢è€ä½¬å§¥é…ªçƒ™æ¶å‹’ä¹é›·é•­è•¾ç£Šç´¯å„¡åž’æ“‚è‚‹ç±»æ³ªæ£±æ¥žå†·åŽ˜æ¢¨çŠé»Žç¯±ç‹¸ç¦»æ¼“ç†æŽé‡Œé²¤ç¤¼èŽ‰è”åæ —ä¸½åŽ‰åŠ±ç ¾åŽ†åˆ©å‚ˆä¾‹ä¿"
  ],
  [
    "c140",
    "ç½–ç½™ç½›ç½œç½ç½žç½ ç½£",
    4,
    "ç½«ç½¬ç½­ç½¯ç½°ç½³ç½µç½¶ç½·ç½¸ç½ºç½»ç½¼ç½½ç½¿ç¾€ç¾‚",
    7,
    "ç¾‹ç¾ç¾",
    4,
    "ç¾•",
    4,
    "ç¾›ç¾œç¾ ç¾¢ç¾£ç¾¥ç¾¦ç¾¨",
    6,
    "ç¾±"
  ],
  [
    "c180",
    "ç¾³",
    4,
    "ç¾ºç¾»ç¾¾ç¿€ç¿‚ç¿ƒç¿„ç¿†ç¿‡ç¿ˆç¿‰ç¿‹ç¿ç¿",
    4,
    "ç¿–ç¿—ç¿™",
    5,
    "ç¿¢ç¿£ç—¢ç«‹ç²’æ²¥éš¶åŠ›ç’ƒå“©ä¿©è”èŽ²è¿žé•°å»‰æ€œæ¶Ÿå¸˜æ•›è„¸é“¾æ‹ç‚¼ç»ƒç²®å‡‰æ¢ç²±è‰¯ä¸¤è¾†é‡æ™¾äº®è°…æ’©èŠåƒšç–—ç‡Žå¯¥è¾½æ½¦äº†æ’‚é•£å»–æ–™åˆ—è£‚çƒˆåŠ£çŒŽç³æž—ç£·éœ–ä¸´é‚»é³žæ·‹å‡›èµåæ‹ŽçŽ²è±é›¶é¾„é“ƒä¼¶ç¾šå‡Œçµé™µå²­é¢†å¦ä»¤æºœç‰æ¦´ç¡«é¦ç•™åˆ˜ç˜¤æµæŸ³å…­é¾™è‹å’™ç¬¼çª¿"
  ],
  [
    "c240",
    "ç¿¤ç¿§ç¿¨ç¿ªç¿«ç¿¬ç¿­ç¿¯ç¿²ç¿´",
    6,
    "ç¿½ç¿¾ç¿¿è€‚è€‡è€ˆè€‰è€Šè€Žè€è€‘è€“è€šè€›è€è€žè€Ÿè€¡è€£è€¤è€«",
    5,
    "è€²è€´è€¹è€ºè€¼è€¾è€èè„è…è‡èˆè‰èŽèèè‘è“è•è–è—"
  ],
  [
    "c280",
    "è™è›",
    13,
    "è«",
    5,
    "è²",
    11,
    "éš†åž„æ‹¢é™‡æ¥¼å¨„æ‚ç¯“æ¼é™‹èŠ¦å¢é¢…åºç‚‰æŽ³å¤è™é²éº“ç¢Œéœ²è·¯èµ‚é¹¿æ½žç¦„å½•é™†æˆ®é©´å•é“ä¾£æ—…å±¥å±¡ç¼•è™‘æ°¯å¾‹çŽ‡æ»¤ç»¿å³¦æŒ›å­ªæ»¦åµä¹±æŽ ç•¥æŠ¡è½®ä¼¦ä»‘æ²¦çº¶è®ºèèžºç½—é€»é”£ç®©éª¡è£¸è½æ´›éª†ç»œå¦ˆéº»çŽ›ç èš‚é©¬éª‚å˜›å—åŸ‹ä¹°éº¦å–è¿ˆè„‰çž’é¦’è›®æ»¡è”“æ›¼æ…¢æ¼«"
  ],
  [
    "c340",
    "è¾è‚è‚‚è‚…è‚ˆè‚Šè‚",
    5,
    "è‚”è‚•è‚—è‚™è‚žè‚£è‚¦è‚§è‚¨è‚¬è‚°è‚³è‚µè‚¶è‚¸è‚¹è‚»èƒ…èƒ‡",
    4,
    "èƒ",
    6,
    "èƒ˜èƒŸèƒ èƒ¢èƒ£èƒ¦èƒ®èƒµèƒ·èƒ¹èƒ»èƒ¾èƒ¿è„€è„è„ƒè„„è„…è„‡è„ˆè„‹"
  ],
  [
    "c380",
    "è„Œè„•è„—è„™è„›è„œè„è„Ÿ",
    12,
    "è„­è„®è„°è„³è„´è„µè„·è„¹",
    4,
    "è„¿è°©èŠ’èŒ«ç›²æ°“å¿™èŽ½çŒ«èŒ…é”šæ¯›çŸ›é“†å¯èŒ‚å†’å¸½è²Œè´¸ä¹ˆçŽ«æžšæ¢…é…¶éœ‰ç…¤æ²¡çœ‰åª’é•æ¯ç¾Žæ˜§å¯å¦¹åªšé—¨é—·ä»¬èŒè’™æª¬ç›Ÿé”°çŒ›æ¢¦å­Ÿçœ¯é†šé¡ç³œè¿·è°œå¼¥ç±³ç§˜è§…æ³Œèœœå¯†å¹‚æ£‰çœ ç»µå†•å…å‹‰å¨©ç¼…é¢è‹—æçž„è—ç§’æ¸ºåº™å¦™è”‘ç­æ°‘æŠ¿çš¿æ•æ‚¯é—½æ˜ŽèžŸé¸£é“­åå‘½è°¬æ‘¸"
  ],
  [
    "c440",
    "è…€",
    5,
    "è…‡è…‰è…è…Žè…è…’è…–è…—è…˜è…›",
    4,
    "è…¡è…¢è…£è…¤è…¦è…¨è…ªè…«è…¬è…¯è…²è…³è…µè…¶è…·è…¸è†è†ƒ",
    4,
    "è†‰è†‹è†Œè†è†Žè†è†’",
    5,
    "è†™è†šè†ž",
    4,
    "è†¤è†¥"
  ],
  [
    "c480",
    "è†§è†©è†«",
    7,
    "è†´",
    5,
    "è†¼è†½è†¾è†¿è‡„è‡…è‡‡è‡ˆè‡‰è‡‹è‡",
    6,
    "æ‘¹è˜‘æ¨¡è†œç£¨æ‘©é­”æŠ¹æœ«èŽ«å¢¨é»˜æ²«æ¼ å¯žé™Œè°‹ç‰ŸæŸæ‹‡ç‰¡äº©å§†æ¯å¢“æš®å¹•å‹Ÿæ…•æœ¨ç›®ç¦ç‰§ç©†æ‹¿å“ªå‘é’ é‚£å¨œçº³æ°–ä¹ƒå¥¶è€å¥ˆå—ç”·éš¾å›ŠæŒ è„‘æ¼é—¹æ·–å‘¢é¦å†…å«©èƒ½å¦®éœ“å€ªæ³¥å°¼æ‹Ÿä½ åŒ¿è…»é€†æººè”«æ‹ˆå¹´ç¢¾æ’µæ»å¿µå¨˜é…¿é¸Ÿå°¿æè‚å­½å•®é•Šé•æ¶…æ‚¨æŸ ç‹žå‡å®"
  ],
  [
    "c540",
    "è‡”",
    14,
    "è‡¤è‡¥è‡¦è‡¨è‡©è‡«è‡®",
    4,
    "è‡µ",
    5,
    "è‡½è‡¿èˆƒèˆ‡",
    4,
    "èˆŽèˆèˆ‘èˆ“èˆ•",
    5,
    "èˆèˆ èˆ¤èˆ¥èˆ¦èˆ§èˆ©èˆ®èˆ²èˆºèˆ¼èˆ½èˆ¿"
  ],
  [
    "c580",
    "è‰€è‰è‰‚è‰ƒè‰…è‰†è‰ˆè‰Šè‰Œè‰è‰Žè‰",
    7,
    "è‰™è‰›è‰œè‰è‰žè‰ ",
    7,
    "è‰©æ‹§æ³žç‰›æ‰­é’®çº½è„“æµ“å†œå¼„å¥´åŠªæ€’å¥³æš–è™ç–ŸæŒªæ‡¦ç³¯è¯ºå“¦æ¬§é¸¥æ®´è—•å‘•å¶æ²¤å•ªè¶´çˆ¬å¸•æ€•ç¶æ‹æŽ’ç‰Œå¾˜æ¹ƒæ´¾æ”€æ½˜ç›˜ç£ç›¼ç•”åˆ¤å›ä¹“åºžæ—è€ªèƒ–æŠ›å’†åˆ¨ç‚®è¢è·‘æ³¡å‘¸èƒšåŸ¹è£´èµ”é™ªé…ä½©æ²›å–·ç›†ç °æŠ¨çƒ¹æ¾Žå½­è“¬æ£šç¡¼ç¯·è†¨æœ‹é¹æ§ç¢°å¯ç ’éœ¹æ‰¹æŠ«åŠˆçµæ¯—"
  ],
  [
    "c640",
    "è‰ªè‰«è‰¬è‰­è‰±è‰µè‰¶è‰·è‰¸è‰»è‰¼èŠ€èŠèŠƒèŠ…èŠ†èŠ‡èŠ‰èŠŒèŠèŠ“èŠ”èŠ•èŠ–èŠšèŠ›èŠžèŠ èŠ¢èŠ£èŠ§èŠ²èŠµèŠ¶èŠºèŠ»èŠ¼èŠ¿è‹€è‹‚è‹ƒè‹…è‹†è‹‰è‹è‹–è‹™è‹šè‹è‹¢è‹§è‹¨è‹©è‹ªè‹¬è‹­è‹®è‹°è‹²è‹³è‹µè‹¶è‹¸"
  ],
  [
    "c680",
    "è‹ºè‹¼",
    4,
    "èŒŠèŒ‹èŒèŒèŒ’èŒ“èŒ–èŒ˜èŒ™èŒ",
    9,
    "èŒ©èŒªèŒ®èŒ°èŒ²èŒ·èŒ»èŒ½å•¤è„¾ç–²çš®åŒ¹ç—žåƒ»å±è­¬ç¯‡åç‰‡éª—é£˜æ¼‚ç“¢ç¥¨æ’‡çž¥æ‹¼é¢‘è´«å“è˜ä¹’åªè‹¹èå¹³å‡­ç“¶è¯„å±å¡æ³¼é¢‡å©†ç ´é­„è¿«ç²•å‰–æ‰‘é“ºä»†èŽ†è‘¡è©è’²åŸ”æœ´åœƒæ™®æµ¦è°±æ›ç€‘æœŸæ¬ºæ –æˆšå¦»ä¸ƒå‡„æ¼†æŸ’æ²å…¶æ£‹å¥‡æ­§ç•¦å´Žè„é½æ——ç¥ˆç¥éª‘èµ·å²‚ä¹žä¼å¯å¥‘ç Œå™¨æ°”è¿„å¼ƒæ±½æ³£è®«æŽ"
  ],
  [
    "c740",
    "èŒ¾èŒ¿èè‚è„è…èˆèŠ",
    4,
    "è“è•",
    4,
    "èè¢è°",
    6,
    "è¹èºè¾",
    6,
    "èŽ‡èŽˆèŽŠèŽ‹èŽŒèŽèŽèŽèŽ‘èŽ”èŽ•èŽ–èŽ—èŽ™èŽšèŽèŽŸèŽ¡",
    6,
    "èŽ¬èŽ­èŽ®"
  ],
  [
    "c780",
    "èŽ¯èŽµèŽ»èŽ¾èŽ¿è‚èƒè„è†èˆè‰è‹èèŽèè‘è’è“è•è—è™èšè›èžè¢è£è¤è¦è§è¨è«è¬è­æ°æ´½ç‰µæ‰¦é’Žé“…åƒè¿ç­¾ä»Ÿè°¦ä¹¾é»”é’±é’³å‰æ½œé£æµ…è°´å ‘åµŒæ¬ æ­‰æžªå‘›è…”ç¾Œå¢™è”·å¼ºæŠ¢æ©‡é”¹æ•²æ‚„æ¡¥çž§ä¹”ä¾¨å·§éž˜æ’¬ç¿˜å³­ä¿çªåˆ‡èŒ„ä¸”æ€¯çªƒé’¦ä¾µäº²ç§¦ç´å‹¤èŠ¹æ“’ç¦½å¯æ²é’è½»æ°¢å€¾å¿æ¸…æ“Žæ™´æ°°æƒ…é¡·è¯·åº†ç¼ç©·ç§‹ä¸˜é‚±çƒæ±‚å›šé…‹æ³…è¶‹åŒºè›†æ›²èº¯å±ˆé©±æ¸ "
  ],
  [
    "c840",
    "è®è¯è³",
    4,
    "èºè»è¼è¾è¿è€è‚è…è‡èˆè‰èŠèè’",
    5,
    "è™èšè›èž",
    5,
    "è©",
    7,
    "è²",
    5,
    "è¹èºè»è¾",
    7,
    "è‘‡è‘ˆè‘‰"
  ],
  [
    "c880",
    "è‘Š",
    6,
    "è‘’",
    4,
    "è‘˜è‘è‘žè‘Ÿè‘ è‘¢è‘¤",
    4,
    "è‘ªè‘®è‘¯è‘°è‘²è‘´è‘·è‘¹è‘»è‘¼å–å¨¶é¾‹è¶£åŽ»åœˆé¢§æƒé†›æ³‰å…¨ç—Šæ‹³çŠ¬åˆ¸åŠç¼ºç‚”ç˜¸å´é¹Šæ¦·ç¡®é›€è£™ç¾¤ç„¶ç‡ƒå†‰æŸ“ç“¤å£¤æ”˜åš·è®©é¥¶æ‰°ç»•æƒ¹çƒ­å£¬ä»äººå¿éŸ§ä»»è®¤åˆƒå¦Šçº«æ‰”ä»æ—¥æˆŽèŒ¸è“‰è£èžç†”æº¶å®¹ç»’å†—æ‰æŸ”è‚‰èŒ¹è •å„’å­ºå¦‚è¾±ä¹³æ±å…¥è¤¥è½¯é˜®è•Šç‘žé”é—°æ¶¦è‹¥å¼±æ’’æ´’è¨è…®é³ƒå¡žèµ›ä¸‰å"
  ],
  [
    "c940",
    "è‘½",
    4,
    "è’ƒè’„è’…è’†è’Šè’è’",
    7,
    "è’˜è’šè’›è’è’žè’Ÿè’ è’¢",
    12,
    "è’°è’±è’³è’µè’¶è’·è’»è’¼è’¾è“€è“‚è“ƒè“…è“†è“‡è“ˆè“‹è“Œè“Žè“è“’è“”è“•è“—"
  ],
  [
    "c980",
    "è“˜",
    4,
    "è“žè“¡è“¢è“¤è“§",
    4,
    "è“­è“®è“¯è“±",
    10,
    "è“½è“¾è”€è”è”‚ä¼žæ•£æ¡‘å—“ä¸§æ”éªšæ‰«å«‚ç‘Ÿè‰²æ¶©æ£®åƒ§èŽŽç ‚æ€åˆ¹æ²™çº±å‚»å•¥ç…žç­›æ™’çŠè‹«æ‰å±±åˆ ç…½è¡«é—ªé™•æ“…èµ¡è†³å–„æ±•æ‰‡ç¼®å¢’ä¼¤å•†èµæ™Œä¸Šå°šè£³æ¢¢æŽç¨çƒ§èŠå‹ºéŸ¶å°‘å“¨é‚µç»å¥¢èµŠè›‡èˆŒèˆèµ¦æ‘„å°„æ…‘æ¶‰ç¤¾è®¾ç ·ç”³å‘»ä¼¸èº«æ·±å¨ ç»…ç¥žæ²ˆå®¡å©¶ç”šè‚¾æ…Žæ¸—å£°ç”Ÿç”¥ç‰²å‡ç»³"
  ],
  [
    "ca40",
    "è”ƒ",
    8,
    "è”è”Žè”è”è”’è””è”•è”–è”˜è”™è”›è”œè”è”žè” è”¢",
    8,
    "è”­",
    9,
    "è”¾",
    4,
    "è•„è•…è•†è•‡è•‹",
    10
  ],
  [
    "ca80",
    "è•—è•˜è•šè•›è•œè•è•Ÿ",
    4,
    "è•¥è•¦è•§è•©",
    8,
    "è•³è•µè•¶è•·è•¸è•¼è•½è•¿è–€è–çœç››å‰©èƒœåœ£å¸ˆå¤±ç‹®æ–½æ¹¿è¯—å°¸è™±åçŸ³æ‹¾æ—¶ä»€é£Ÿèš€å®žè¯†å²çŸ¢ä½¿å±Žé©¶å§‹å¼ç¤ºå£«ä¸–æŸ¿äº‹æ‹­èª“é€åŠ¿æ˜¯å—œå™¬é€‚ä»•ä¾é‡Šé¥°æ°å¸‚æƒå®¤è§†è¯•æ”¶æ‰‹é¦–å®ˆå¯¿æŽˆå”®å—ç˜¦å…½è”¬æž¢æ¢³æ®ŠæŠ’è¾“å”èˆ’æ·‘ç–ä¹¦èµŽå­°ç†Ÿè–¯æš‘æ›™ç½²èœ€é»é¼ å±žæœ¯è¿°æ ‘æŸæˆç«–å¢…åº¶æ•°æ¼±"
  ],
  [
    "cb40",
    "è–‚è–ƒè–†è–ˆ",
    6,
    "è–",
    10,
    "è–",
    6,
    "è–¥è–¦è–§è–©è–«è–¬è–­è–±",
    5,
    "è–¸è–º",
    6,
    "è—‚",
    6,
    "è—Š",
    4,
    "è—‘è—’"
  ],
  [
    "cb80",
    "è—”è—–",
    5,
    "è—",
    6,
    "è—¥è—¦è—§è—¨è—ª",
    14,
    "æ•åˆ·è€æ‘”è¡°ç”©å¸…æ “æ‹´éœœåŒçˆ½è°æ°´ç¡ç¨Žå®çž¬é¡ºèˆœè¯´ç¡•æœ”çƒæ–¯æ’•å˜¶æ€ç§å¸ä¸æ­»è‚†å¯ºå—£å››ä¼ºä¼¼é¥²å·³æ¾è€¸æ€‚é¢‚é€å®‹è®¼è¯µæœè‰˜æ“žå—½è‹é…¥ä¿—ç´ é€Ÿç²Ÿåƒ³å¡‘æº¯å®¿è¯‰è‚ƒé…¸è’œç®—è™½éš‹éšç»¥é«“ç¢Žå²ç©—é‚éš§ç¥Ÿå­™æŸç¬‹è“‘æ¢­å”†ç¼©çç´¢é”æ‰€å¡Œä»–å®ƒå¥¹å¡”"
  ],
  [
    "cc40",
    "è—¹è—ºè—¼è—½è—¾è˜€",
    4,
    "è˜†",
    10,
    "è˜’è˜“è˜”è˜•è˜—",
    15,
    "è˜¨è˜ª",
    13,
    "è˜¹è˜ºè˜»è˜½è˜¾è˜¿è™€"
  ],
  [
    "cc80",
    "è™",
    11,
    "è™’è™“è™•",
    4,
    "è™›è™œè™è™Ÿè™ è™¡è™£",
    7,
    "ç­æŒžè¹‹è¸èƒŽè‹”æŠ¬å°æ³°é…žå¤ªæ€æ±°åæ‘Šè´ªç˜«æ»©å›æª€ç—°æ½­è°­è°ˆå¦æ¯¯è¢’ç¢³æŽ¢å¹ç‚­æ±¤å¡˜æªå ‚æ£ è†›å”ç³–å€˜èººæ·Œè¶Ÿçƒ«æŽæ¶›æ»”ç»¦è„æ¡ƒé€ƒæ·˜é™¶è®¨å¥—ç‰¹è—¤è…¾ç–¼èªŠæ¢¯å‰”è¸¢é”‘æé¢˜è¹„å•¼ä½“æ›¿åšæƒ•æ¶•å‰ƒå±‰å¤©æ·»å¡«ç”°ç”œæ¬èˆ”è…†æŒ‘æ¡è¿¢çœºè·³è´´é“å¸–åŽ…å¬çƒƒ"
  ],
  [
    "cd40",
    "è™­è™¯è™°è™²",
    6,
    "èšƒ",
    6,
    "èšŽ",
    4,
    "èš”èš–",
    5,
    "èšž",
    4,
    "èš¥èš¦èš«èš­èš®èš²èš³èš·èš¸èš¹èš»",
    4,
    "è›è›‚è›ƒè›…è›ˆè›Œè›è›’è›“è›•è›–è›—è›šè›œ"
  ],
  [
    "cd80",
    "è›è› è›¡è›¢è›£è›¥è›¦è›§è›¨è›ªè›«è›¬è›¯è›µè›¶è›·è›ºè›»è›¼è›½è›¿èœèœ„èœ…èœ†èœ‹èœŒèœŽèœèœèœ‘èœ”èœ–æ±€å»·åœäº­åº­æŒºè‰‡é€šæ¡é…®çž³åŒé“œå½¤ç«¥æ¡¶æ…ç­’ç»Ÿç—›å·æŠ•å¤´é€å‡¸ç§ƒçªå›¾å¾’é€”æ¶‚å± åœŸåå…”æ¹å›¢æŽ¨é¢“è…¿èœ•è¤ªé€€åžå±¯è‡€æ‹–æ‰˜è„±é¸µé™€é©®é©¼æ¤­å¦¥æ‹“å”¾æŒ–å“‡è›™æ´¼å¨ƒç“¦è¢œæ­ªå¤–è±Œå¼¯æ¹¾çŽ©é¡½ä¸¸çƒ·å®Œç¢—æŒ½æ™šçš–æƒ‹å®›å©‰ä¸‡è…•æ±ªçŽ‹äº¡æž‰ç½‘å¾€æ—ºæœ›å¿˜å¦„å¨"
  ],
  [
    "ce40",
    "èœ™èœ›èœèœŸèœ èœ¤èœ¦èœ§èœ¨èœªèœ«èœ¬èœ­èœ¯èœ°èœ²èœ³èœµèœ¶èœ¸èœ¹èœºèœ¼èœ½è€",
    6,
    "èŠè‹èèèè‘è’è”è•è–è˜èš",
    5,
    "è¡è¢è¦",
    7,
    "è¯è±è²è³èµ"
  ],
  [
    "ce80",
    "è·è¸è¹èºè¿èž€èžèž„èž†èž‡èž‰èžŠèžŒèžŽ",
    4,
    "èž”èž•èž–èž˜",
    6,
    "èž ",
    4,
    "å·å¾®å±éŸ¦è¿æ¡…å›´å”¯æƒŸä¸ºæ½ç»´è‹‡èŽå§”ä¼Ÿä¼ªå°¾çº¬æœªè”šå‘³ç•èƒƒå–‚é­ä½æ¸­è°“å°‰æ…°å«ç˜Ÿæ¸©èšŠæ–‡é—»çº¹å»ç¨³ç´Šé—®å—¡ç¿ç“®æŒèœ—æ¶¡çªæˆ‘æ–¡å§æ¡æ²ƒå·«å‘œé’¨ä¹Œæ±¡è¯¬å±‹æ— èŠœæ¢§å¾å´æ¯‹æ­¦äº”æ‚åˆèˆžä¼ä¾®åžæˆŠé›¾æ™¤ç‰©å‹¿åŠ¡æ‚Ÿè¯¯æ˜”ç†™æžè¥¿ç¡’çŸ½æ™°å˜»å¸é”¡ç‰º"
  ],
  [
    "cf40",
    "èž¥èž¦èž§èž©èžªèž®èž°èž±èž²èž´èž¶èž·èž¸èž¹èž»èž¼èž¾èž¿èŸ",
    4,
    "èŸ‡èŸˆèŸ‰èŸŒ",
    4,
    "èŸ”",
    6,
    "èŸœèŸèŸžèŸŸèŸ¡èŸ¢èŸ£èŸ¤èŸ¦èŸ§èŸ¨èŸ©èŸ«èŸ¬èŸ­èŸ¯",
    9
  ],
  [
    "cf80",
    "èŸºèŸ»èŸ¼èŸ½èŸ¿è €è è ‚è „",
    5,
    "è ‹",
    7,
    "è ”è —è ˜è ™è šè œ",
    4,
    "è £ç¨€æ¯å¸Œæ‚‰è†å¤•æƒœç†„çƒ¯æºªæ±çŠ€æª„è¢­å¸­ä¹ åª³å–œé“£æ´—ç³»éš™æˆç»†çžŽè™¾åŒ£éœžè¾–æš‡å³¡ä¾ ç‹­ä¸‹åŽ¦å¤å“æŽ€é”¨å…ˆä»™é²œçº¤å’¸è´¤è¡”èˆ·é—²æ¶Žå¼¦å«Œæ˜¾é™©çŽ°çŒ®åŽ¿è…ºé¦…ç¾¡å®ªé™·é™çº¿ç›¸åŽ¢é•¶é¦™ç®±è¥„æ¹˜ä¹¡ç¿”ç¥¥è¯¦æƒ³å“äº«é¡¹å··æ©¡åƒå‘è±¡è§ç¡éœ„å‰Šå“®åš£é”€æ¶ˆå®µæ·†æ™“"
  ],
  [
    "d040",
    "è ¤",
    13,
    "è ³",
    5,
    "è ºè »è ½è ¾è ¿è¡è¡‚è¡ƒè¡†",
    5,
    "è¡Ž",
    5,
    "è¡•è¡–è¡˜è¡š",
    6,
    "è¡¦è¡§è¡ªè¡­è¡¯è¡±è¡³è¡´è¡µè¡¶è¡¸è¡¹è¡º"
  ],
  [
    "d080",
    "è¡»è¡¼è¢€è¢ƒè¢†è¢‡è¢‰è¢Šè¢Œè¢Žè¢è¢è¢‘è¢“è¢”è¢•è¢—",
    4,
    "è¢",
    4,
    "è¢£è¢¥",
    5,
    "å°å­æ ¡è‚–å•¸ç¬‘æ•ˆæ¥”äº›æ­‡èŽéž‹åæŒŸæºé‚ªæ–œèƒè°å†™æ¢°å¸èŸ¹æ‡ˆæ³„æ³»è°¢å±‘è–ªèŠ¯é”Œæ¬£è¾›æ–°å¿»å¿ƒä¿¡è¡…æ˜Ÿè…¥çŒ©æƒºå…´åˆ‘åž‹å½¢é‚¢è¡Œé†’å¹¸ææ€§å§“å…„å‡¶èƒ¸åŒˆæ±¹é›„ç†Šä¼‘ä¿®ç¾žæœ½å—…é”ˆç§€è¢–ç»£å¢ŸæˆŒéœ€è™šå˜˜é¡»å¾è®¸è“„é…—å™æ—­åºç•œæ¤çµ®å©¿ç»ªç»­è½©å–§å®£æ‚¬æ—‹çŽ„"
  ],
  [
    "d140",
    "è¢¬è¢®è¢¯è¢°è¢²",
    4,
    "è¢¸è¢¹è¢ºè¢»è¢½è¢¾è¢¿è£€è£ƒè£„è£‡è£ˆè£Šè£‹è£Œè£è£è£è£‘è£“è£–è£—è£š",
    4,
    "è£ è£¡è£¦è£§è£©",
    6,
    "è£²è£µè£¶è£·è£ºè£»è£½è£¿è¤€è¤è¤ƒ",
    5
  ],
  [
    "d180",
    "è¤‰è¤‹",
    4,
    "è¤‘è¤”",
    4,
    "è¤œ",
    4,
    "è¤¢è¤£è¤¤è¤¦è¤§è¤¨è¤©è¤¬è¤­è¤®è¤¯è¤±è¤²è¤³è¤µè¤·é€‰ç™£çœ©ç»šé´è–›å­¦ç©´é›ªè¡€å‹‹ç†å¾ªæ—¬è¯¢å¯»é©¯å·¡æ®‰æ±›è®­è®¯é€Šè¿…åŽ‹æŠ¼é¸¦é¸­å‘€ä¸«èŠ½ç‰™èšœå´–è¡™æ¶¯é›…å“‘äºšè®¶ç„‰å’½é˜‰çƒŸæ·¹ç›ä¸¥ç ”èœ’å²©å»¶è¨€é¢œé˜Žç‚Žæ²¿å¥„æŽ©çœ¼è¡æ¼”è‰³å °ç‡•åŽŒç šé›å”å½¦ç„°å®´è°šéªŒæ®ƒå¤®é¸¯ç§§æ¨æ‰¬ä½¯ç–¡ç¾Šæ´‹é˜³æ°§ä»°ç—’å…»æ ·æ¼¾é‚€è…°å¦–ç‘¶"
  ],
  [
    "d240",
    "è¤¸",
    8,
    "è¥‚è¥ƒè¥…",
    24,
    "è¥ ",
    5,
    "è¥§",
    19,
    "è¥¼"
  ],
  [
    "d280",
    "è¥½è¥¾è¦€è¦‚è¦„è¦…è¦‡",
    26,
    "æ‘‡å°§é¥çª‘è°£å§šå’¬èˆ€è¯è¦è€€æ¤°å™Žè€¶çˆ·é‡Žå†¶ä¹Ÿé¡µæŽ–ä¸šå¶æ›³è…‹å¤œæ¶²ä¸€å£¹åŒ»æ–é“±ä¾ä¼Šè¡£é¢å¤·é—ç§»ä»ªèƒ°ç–‘æ²‚å®œå§¨å½æ¤…èšå€šå·²ä¹™çŸ£ä»¥è‰ºæŠ‘æ˜“é‚‘å±¹äº¿å½¹è‡†é€¸è‚„ç–«äº¦è£”æ„æ¯…å¿†ä¹‰ç›Šæº¢è¯£è®®è°Šè¯‘å¼‚ç¿¼ç¿Œç»ŽèŒµè«å› æ®·éŸ³é˜´å§»åŸé“¶æ·«å¯…é¥®å°¹å¼•éš"
  ],
  [
    "d340",
    "è¦¢",
    30,
    "è§ƒè§è§“è§”è§•è§—è§˜è§™è§›è§è§Ÿè§ è§¡è§¢è§¤è§§è§¨è§©è§ªè§¬è§­è§®è§°è§±è§²è§´",
    6
  ],
  [
    "d380",
    "è§»",
    4,
    "è¨",
    5,
    "è¨ˆ",
    21,
    "å°è‹±æ¨±å©´é¹°åº”ç¼¨èŽ¹è¤è¥è§è‡è¿Žèµ¢ç›ˆå½±é¢–ç¡¬æ˜ å“Ÿæ‹¥ä½£è‡ƒç—ˆåº¸é›è¸Šè›¹å’æ³³æ¶Œæ°¸æ¿å‹‡ç”¨å¹½ä¼˜æ‚ å¿§å°¤ç”±é‚®é“€çŠ¹æ²¹æ¸¸é…‰æœ‰å‹å³ä½‘é‡‰è¯±åˆå¹¼è¿‚æ·¤äºŽç›‚æ¦†è™žæ„šèˆ†ä½™ä¿žé€¾é±¼æ„‰æ¸æ¸”éš…äºˆå¨±é›¨ä¸Žå±¿ç¦¹å®‡è¯­ç¾½çŽ‰åŸŸèŠ‹éƒåé‡å–»å³ªå¾¡æ„ˆæ¬²ç‹±è‚²èª‰"
  ],
  [
    "d440",
    "è¨ž",
    31,
    "è¨¿",
    8,
    "è©‰",
    21
  ],
  [
    "d480",
    "è©Ÿ",
    25,
    "è©º",
    6,
    "æµ´å¯“è£•é¢„è±«é©­é¸³æ¸Šå†¤å…ƒåž£è¢åŽŸæ´è¾•å›­å‘˜åœ†çŒ¿æºç¼˜è¿œè‹‘æ„¿æ€¨é™¢æ›°çº¦è¶Šè·ƒé’¥å²³ç²¤æœˆæ‚¦é˜…è€˜äº‘éƒ§åŒ€é™¨å…è¿è•´é…æ™•éŸµå­•åŒç ¸æ‚æ ½å“‰ç¾å®°è½½å†åœ¨å’±æ”’æš‚èµžèµƒè„è‘¬é­ç³Ÿå‡¿è—»æž£æ—©æ¾¡èš¤èºå™ªé€ çš‚ç¶ç‡¥è´£æ‹©åˆ™æ³½è´¼æ€Žå¢žæ†Žæ›¾èµ æ‰Žå–³æ¸£æœ­è½§"
  ],
  [
    "d540",
    "èª",
    7,
    "èª‹",
    7,
    "èª”",
    46
  ],
  [
    "d580",
    "è«ƒ",
    32,
    "é“¡é—¸çœ¨æ …æ¦¨å’‹ä¹ç‚¸è¯ˆæ‘˜æ–‹å®…çª„å€ºå¯¨çž»æ¯¡è©¹ç²˜æ²¾ç›æ–©è¾—å´­å±•è˜¸æ ˆå æˆ˜ç«™æ¹›ç»½æ¨Ÿç« å½°æ¼³å¼ æŽŒæ¶¨æ–ä¸ˆå¸è´¦ä»—èƒ€ç˜´éšœæ‹›æ˜­æ‰¾æ²¼èµµç…§ç½©å…†è‚‡å¬é®æŠ˜å“²è›°è¾™è€…é”—è”—è¿™æµ™çæ–ŸçœŸç”„ç §è‡»è´žé’ˆä¾¦æž•ç–¹è¯Šéœ‡æŒ¯é•‡é˜µè’¸æŒ£çå¾ç‹°äº‰æ€”æ•´æ‹¯æ­£æ”¿"
  ],
  [
    "d640",
    "è«¤",
    34,
    "è¬ˆ",
    27
  ],
  [
    "d680",
    "è¬¤è¬¥è¬§",
    30,
    "å¸§ç—‡éƒ‘è¯èŠæžæ”¯å±èœ˜çŸ¥è‚¢è„‚æ±ä¹‹ç»‡èŒç›´æ¤æ®–æ‰§å€¼ä¾„å€æŒ‡æ­¢è¶¾åªæ—¨çº¸å¿—æŒšæŽ·è‡³è‡´ç½®å¸œå³™åˆ¶æ™ºç§©ç¨šè´¨ç‚™ç—”æ»žæ²»çª’ä¸­ç›…å¿ é’Ÿè¡·ç»ˆç§è‚¿é‡ä»²ä¼—èˆŸå‘¨å·žæ´²è¯Œç²¥è½´è‚˜å¸šå’’çš±å®™æ˜¼éª¤ç æ ªè››æœ±çŒªè¯¸è¯›é€ç«¹çƒ›ç…®æ‹„çž©å˜±ä¸»è‘—æŸ±åŠ©è›€è´®é“¸ç­‘"
  ],
  [
    "d740",
    "è­†",
    31,
    "è­§",
    4,
    "è­­",
    25
  ],
  [
    "d780",
    "è®‡",
    24,
    "è®¬è®±è®»è¯‡è¯è¯ªè°‰è°žä½æ³¨ç¥é©»æŠ“çˆªæ‹½ä¸“ç –è½¬æ’°èµšç¯†æ¡©åº„è£…å¦†æ’žå£®çŠ¶æ¤Žé”¥è¿½èµ˜å ç¼€è°†å‡†æ‰æ‹™å“æ¡Œç¢èŒé…Œå•„ç€ç¼æµŠå…¹å’¨èµ„å§¿æ»‹æ·„å­œç´«ä»”ç±½æ»“å­è‡ªæ¸å­—é¬ƒæ£•è¸ªå®—ç»¼æ€»çºµé‚¹èµ°å¥æç§Ÿè¶³å’æ—ç¥–è¯…é˜»ç»„é’»çº‚å˜´é†‰æœ€ç½ªå°Šéµæ˜¨å·¦ä½æŸžåšä½œååº§"
  ],
  [
    "d840",
    "è°¸",
    8,
    "è±‚è±ƒè±„è±…è±ˆè±Šè±‹è±",
    7,
    "è±–è±—è±˜è±™è±›",
    5,
    "è±£",
    6,
    "è±¬",
    6,
    "è±´è±µè±¶è±·è±»",
    6,
    "è²ƒè²„è²†è²‡"
  ],
  [
    "d880",
    "è²ˆè²‹è²",
    6,
    "è²•è²–è²—è²™",
    20,
    "äºä¸Œå…€ä¸å»¿å…ä¸•äº˜ä¸žé¬²å­¬å™©ä¸¨ç¦ºä¸¿åŒ•ä¹‡å¤­çˆ»å®æ°å›Ÿèƒ¤é¦—æ¯“ç¾é¼—ä¸¶äºŸé¼ä¹œä¹©äº“èŠˆå­›å•¬å˜ä»„åŽåŽåŽ£åŽ¥åŽ®é¥èµåŒšåµåŒ¦åŒ®åŒ¾èµœå¦å£åˆ‚åˆˆåˆŽåˆ­åˆ³åˆ¿å‰€å‰Œå‰žå‰¡å‰œè’¯å‰½åŠ‚åŠåŠåŠ“å†‚ç½”äº»ä»ƒä»‰ä»‚ä»¨ä»¡ä»«ä»žä¼›ä»³ä¼¢ä½¤ä»µä¼¥ä¼§ä¼‰ä¼«ä½žä½§æ”¸ä½šä½"
  ],
  [
    "d940",
    "è²®",
    62
  ],
  [
    "d980",
    "è³­",
    32,
    "ä½Ÿä½—ä¼²ä¼½ä½¶ä½´ä¾‘ä¾‰ä¾ƒä¾ä½¾ä½»ä¾ªä½¼ä¾¬ä¾”ä¿¦ä¿¨ä¿ªä¿…ä¿šä¿£ä¿œä¿‘ä¿Ÿä¿¸å€©åŒä¿³å€¬å€å€®å€­ä¿¾å€œå€Œå€¥å€¨å¾åƒå•åˆåŽå¬å»å‚¥å‚§å‚©å‚ºåƒ–å„†åƒ­åƒ¬åƒ¦åƒ®å„‡å„‹ä»æ°½ä½˜ä½¥ä¿Žé¾ æ±†ç±´å…®å·½é»‰é¦˜å†å¤”å‹¹åŒè¨‡åŒå‡«å¤™å…•äº å…–äº³è¡®è¢¤äºµè„”è£’ç¦€å¬´è ƒç¾¸å†«å†±å†½å†¼"
  ],
  [
    "da40",
    "è´Ž",
    14,
    "è´ èµ‘èµ’èµ—èµŸèµ¥èµ¨èµ©èµªèµ¬èµ®èµ¯èµ±èµ²èµ¸",
    8,
    "è¶‚è¶ƒè¶†è¶‡è¶ˆè¶‰è¶Œ",
    4,
    "è¶’è¶“è¶•",
    9,
    "è¶ è¶¡"
  ],
  [
    "da80",
    "è¶¢è¶¤",
    12,
    "è¶²è¶¶è¶·è¶¹è¶»è¶½è·€è·è·‚è·…è·‡è·ˆè·‰è·Šè·è·è·’è·“è·”å‡‡å†–å†¢å†¥è® è®¦è®§è®ªè®´è®µè®·è¯‚è¯ƒè¯‹è¯è¯Žè¯’è¯“è¯”è¯–è¯˜è¯™è¯œè¯Ÿè¯ è¯¤è¯¨è¯©è¯®è¯°è¯³è¯¶è¯¹è¯¼è¯¿è°€è°‚è°„è°‡è°Œè°è°‘è°’è°”è°•è°–è°™è°›è°˜è°è°Ÿè° è°¡è°¥è°§è°ªè°«è°®è°¯è°²è°³è°µè°¶å©åºé˜é˜¢é˜¡é˜±é˜ªé˜½é˜¼é™‚é™‰é™”é™Ÿé™§é™¬é™²é™´éšˆéšéš—éš°é‚—é‚›é‚é‚™é‚¬é‚¡é‚´é‚³é‚¶é‚º"
  ],
  [
    "db40",
    "è·•è·˜è·™è·œè· è·¡è·¢è·¥è·¦è·§è·©è·­è·®è·°è·±è·²è·´è·¶è·¼è·¾",
    6,
    "è¸†è¸‡è¸ˆè¸‹è¸è¸Žè¸è¸‘è¸’è¸“è¸•",
    7,
    "è¸ è¸¡è¸¤",
    4,
    "è¸«è¸­è¸°è¸²è¸³è¸´è¸¶è¸·è¸¸è¸»è¸¼è¸¾"
  ],
  [
    "db80",
    "è¸¿è¹ƒè¹…è¹†è¹Œ",
    4,
    "è¹“",
    5,
    "è¹š",
    11,
    "è¹§è¹¨è¹ªè¹«è¹®è¹±é‚¸é‚°éƒéƒ…é‚¾éƒéƒ„éƒ‡éƒ“éƒ¦éƒ¢éƒœéƒ—éƒ›éƒ«éƒ¯éƒ¾é„„é„¢é„žé„£é„±é„¯é„¹é…ƒé…†åˆå¥‚åŠ¢åŠ¬åŠ­åŠ¾å“¿å‹å‹–å‹°åŸç‡®çŸå»´å‡µå‡¼é¬¯åŽ¶å¼ç•šå·¯åŒåž©åž¡å¡¾å¢¼å£…å£‘åœ©åœ¬åœªåœ³åœ¹åœ®åœ¯åœåœ»å‚å©åž…å«åž†å¼å»å¨å­å¶å³åž­åž¤åžŒåž²åŸåž§åž´åž“åž åŸ•åŸ˜åŸšåŸ™åŸ’åž¸åŸ´åŸ¯åŸ¸åŸ¤åŸ"
  ],
  [
    "dc40",
    "è¹³è¹µè¹·",
    4,
    "è¹½è¹¾èº€èº‚èºƒèº„èº†èºˆ",
    6,
    "èº‘èº’èº“èº•",
    6,
    "èºèºŸ",
    11,
    "èº­èº®èº°èº±èº³",
    6,
    "èº»",
    7
  ],
  [
    "dc80",
    "è»ƒ",
    10,
    "è»",
    21,
    "å ‹å åŸ½åŸ­å €å žå ™å¡„å  å¡¥å¡¬å¢å¢‰å¢šå¢€é¦¨é¼™æ‡¿è‰¹è‰½è‰¿èŠèŠŠèŠ¨èŠ„èŠŽèŠ‘èŠ—èŠ™èŠ«èŠ¸èŠ¾èŠ°è‹ˆè‹Šè‹£èŠ˜èŠ·èŠ®è‹‹è‹Œè‹èŠ©èŠ´èŠ¡èŠªèŠŸè‹„è‹ŽèŠ¤è‹¡èŒ‰è‹·è‹¤èŒèŒ‡è‹œè‹´è‹’è‹˜èŒŒè‹»è‹“èŒ‘èŒšèŒ†èŒ”èŒ•è‹ è‹•èŒœè‘è›èœèŒˆèŽ’èŒ¼èŒ´èŒ±èŽ›èžèŒ¯èè‡èƒèŸè€èŒ—è èŒ­èŒºèŒ³è¦è¥"
  ],
  [
    "dd40",
    "è»¥",
    62
  ],
  [
    "dd80",
    "è¼¤",
    32,
    "è¨èŒ›è©è¬èªè­è®èŽ°è¸èŽ³èŽ´èŽ èŽªèŽ“èŽœèŽ…è¼èŽ¶èŽ©è½èŽ¸è»èŽ˜èŽžèŽ¨èŽºèŽ¼èèè¥è˜å ‡è˜è‹èè½è–èœè¸è‘è†è”èŸèèƒè¸è¹èªè…è€è¦è°è¡è‘œè‘‘è‘šè‘™è‘³è’‡è’ˆè‘ºè’‰è‘¸è¼è‘†è‘©è‘¶è’Œè’Žè±è‘­è“è“è“è“¦è’½è““è“Šè’¿è’ºè“ è’¡è’¹è’´è’—è“¥è“£è”Œç”è”¸è“°è”¹è”Ÿè”º"
  ],
  [
    "de40",
    "è½…",
    32,
    "è½ªè¾€è¾Œè¾’è¾è¾ è¾¡è¾¢è¾¤è¾¥è¾¦è¾§è¾ªè¾¬è¾­è¾®è¾¯è¾²è¾³è¾´è¾µè¾·è¾¸è¾ºè¾»è¾¼è¾¿è¿€è¿ƒè¿†"
  ],
  [
    "de80",
    "è¿‰",
    4,
    "è¿è¿’è¿–è¿—è¿šè¿ è¿¡è¿£è¿§è¿¬è¿¯è¿±è¿²è¿´è¿µè¿¶è¿ºè¿»è¿¼è¿¾è¿¿é€‡é€ˆé€Œé€Žé€“é€•é€˜è•–è”»è“¿è“¼è•™è•ˆè•¨è•¤è•žè•ºçž¢è•ƒè•²è•»è–¤è–¨è–‡è–è•¹è–®è–œè–…è–¹è–·è–°è—“è—è—œè—¿è˜§è˜…è˜©è˜–è˜¼å»¾å¼ˆå¤¼å¥è€·å¥•å¥šå¥˜åŒå°¢å°¥å°¬å°´æ‰Œæ‰ªæŠŸæŠ»æ‹Šæ‹šæ‹—æ‹®æŒ¢æ‹¶æŒ¹æ‹æƒæŽ­æ¶æ±æºæŽŽæŽ´æ­æŽ¬æŽŠæ©æŽ®æŽ¼æ²æ¸æ æ¿æ„æžæŽæ‘’æ†æŽ¾æ‘…æ‘æ‹æ›æ æŒæ¦æ¡æ‘žæ’„æ‘­æ’–"
  ],
  [
    "df40",
    "é€™é€œé€£é€¤é€¥é€§",
    5,
    "é€°",
    4,
    "é€·é€¹é€ºé€½é€¿é€éƒé…é†éˆ",
    4,
    "éŽé”é•é–é™éšéœ",
    5,
    "é¤é¦é§é©éªé«é¬é¯",
    4,
    "é¶",
    6,
    "é¾é‚"
  ],
  [
    "df80",
    "é‚„é‚…é‚†é‚‡é‚‰é‚Šé‚Œ",
    4,
    "é‚’é‚”é‚–é‚˜é‚šé‚œé‚žé‚Ÿé‚ é‚¤é‚¥é‚§é‚¨é‚©é‚«é‚­é‚²é‚·é‚¼é‚½é‚¿éƒ€æ‘ºæ’·æ’¸æ’™æ’ºæ“€æ“æ“—æ“¤æ“¢æ”‰æ”¥æ”®å¼‹å¿’ç”™å¼‘åŸå±å½å©å¨å»å’å–å†å‘‹å‘’å‘“å‘”å‘–å‘ƒå¡å‘—å‘™å£å²å’‚å’”å‘·å‘±å‘¤å’šå’›å’„å‘¶å‘¦å’å“å’­å“‚å’´å“’å’§å’¦å““å“”å‘²å’£å“•å’»å’¿å“Œå“™å“šå“œå’©å’ªå’¤å“å“å“žå”›å“§å” å“½å””å“³å”¢å”£å”å”‘å”§å”ªå•§å–å–µå•‰å•­å•å••å”¿å•å”¼"
  ],
  [
    "e040",
    "éƒ‚éƒƒéƒ†éƒˆéƒ‰éƒ‹éƒŒéƒéƒ’éƒ”éƒ•éƒ–éƒ˜éƒ™éƒšéƒžéƒŸéƒ éƒ£éƒ¤éƒ¥éƒ©éƒªéƒ¬éƒ®éƒ°éƒ±éƒ²éƒ³éƒµéƒ¶éƒ·éƒ¹éƒºéƒ»éƒ¼éƒ¿é„€é„é„ƒé„…",
    19,
    "é„šé„›é„œ"
  ],
  [
    "e080",
    "é„é„Ÿé„ é„¡é„¤",
    10,
    "é„°é„²",
    6,
    "é„º",
    8,
    "é…„å”·å•–å•µå•¶å•·å”³å”°å•œå–‹å—’å–ƒå–±å–¹å–ˆå–å–Ÿå•¾å—–å–‘å•»å—Ÿå–½å–¾å–”å–™å—ªå—·å—‰å˜Ÿå—‘å—«å—¬å—”å—¦å—å—„å—¯å—¥å—²å—³å—Œå—å—¨å—µå—¤è¾”å˜žå˜ˆå˜Œå˜å˜¤å˜£å—¾å˜€å˜§å˜­å™˜å˜¹å™—å˜¬å™å™¢å™™å™œå™Œå™”åš†å™¤å™±å™«å™»å™¼åš…åš“åš¯å›”å›—å›å›¡å›µå›«å›¹å›¿åœ„åœŠåœ‰åœœå¸å¸™å¸”å¸‘å¸±å¸»å¸¼"
  ],
  [
    "e140",
    "é……é…‡é…ˆé…‘é…“é…”é…•é…–é…˜é…™é…›é…œé…Ÿé… é…¦é…§é…¨é…«é…­é…³é…ºé…»é…¼é†€",
    4,
    "é††é†ˆé†Šé†Žé†é†“",
    6,
    "é†œ",
    5,
    "é†¤",
    5,
    "é†«é†¬é†°é†±é†²é†³é†¶é†·é†¸é†¹é†»"
  ],
  [
    "e180",
    "é†¼",
    10,
    "é‡ˆé‡‹é‡é‡’",
    9,
    "é‡",
    8,
    "å¸·å¹„å¹”å¹›å¹žå¹¡å²Œå±ºå²å²å²–å²ˆå²˜å²™å²‘å²šå²œå²µå²¢å²½å²¬å²«å²±å²£å³å²·å³„å³’å³¤å³‹å³¥å´‚å´ƒå´§å´¦å´®å´¤å´žå´†å´›åµ˜å´¾å´´å´½åµ¬åµ›åµ¯åµåµ«åµ‹åµŠåµ©åµ´å¶‚å¶™å¶è±³å¶·å·…å½³å½·å¾‚å¾‡å¾‰å¾Œå¾•å¾™å¾œå¾¨å¾­å¾µå¾¼è¡¢å½¡çŠ­çŠ°çŠ´çŠ·çŠ¸ç‹ƒç‹ç‹Žç‹ç‹’ç‹¨ç‹¯ç‹©ç‹²ç‹´ç‹·çŒç‹³çŒƒç‹º"
  ],
  [
    "e240",
    "é‡¦",
    62
  ],
  [
    "e280",
    "éˆ¥",
    32,
    "ç‹»çŒ—çŒ“çŒ¡çŒŠçŒžçŒçŒ•çŒ¢çŒ¹çŒ¥çŒ¬çŒ¸çŒ±ççç—ç ç¬ç¯ç¾èˆ›å¤¥é£§å¤¤å¤‚é¥£é¥§",
    5,
    "é¥´é¥·é¥½é¦€é¦„é¦‡é¦Šé¦é¦é¦‘é¦“é¦”é¦•åº€åº‘åº‹åº–åº¥åº åº¹åºµåº¾åº³èµ“å»’å»‘å»›å»¨å»ªè†ºå¿„å¿‰å¿–å¿æ€ƒå¿®æ€„å¿¡å¿¤å¿¾æ€…æ€†å¿ªå¿­å¿¸æ€™æ€µæ€¦æ€›æ€æ€æ€©æ€«æ€Šæ€¿æ€¡æ¸æ¹æ»æºæ‚"
  ],
  [
    "e340",
    "é‰†",
    45,
    "é‰µ",
    16
  ],
  [
    "e380",
    "éŠ†",
    7,
    "éŠ",
    24,
    "æªæ½æ‚–æ‚šæ‚­æ‚æ‚ƒæ‚’æ‚Œæ‚›æƒ¬æ‚»æ‚±æƒæƒ˜æƒ†æƒšæ‚´æ„ æ„¦æ„•æ„£æƒ´æ„€æ„Žæ„«æ…Šæ…µæ†¬æ†”æ†§æ†·æ‡”æ‡µå¿éš³é—©é—«é—±é—³é—µé—¶é—¼é—¾é˜ƒé˜„é˜†é˜ˆé˜Šé˜‹é˜Œé˜é˜é˜’é˜•é˜–é˜—é˜™é˜šä¸¬çˆ¿æˆ•æ°µæ±”æ±œæ±Šæ²£æ²…æ²æ²”æ²Œæ±¨æ±©æ±´æ±¶æ²†æ²©æ³æ³”æ²­æ³·æ³¸æ³±æ³—æ²²æ³ æ³–æ³ºæ³«æ³®æ²±æ³“æ³¯æ³¾"
  ],
  [
    "e440",
    "éŠ¨",
    5,
    "éŠ¯",
    24,
    "é‹‰",
    31
  ],
  [
    "e480",
    "é‹©",
    32,
    "æ´¹æ´§æ´Œæµƒæµˆæ´‡æ´„æ´™æ´Žæ´«æµæ´®æ´µæ´šæµæµ’æµ”æ´³æ¶‘æµ¯æ¶žæ¶ æµžæ¶“æ¶”æµœæµ æµ¼æµ£æ¸šæ·‡æ·…æ·žæ¸Žæ¶¿æ· æ¸‘æ·¦æ·æ·™æ¸–æ¶«æ¸Œæ¶®æ¸«æ¹®æ¹Žæ¹«æº²æ¹Ÿæº†æ¹“æ¹”æ¸²æ¸¥æ¹„æ»Ÿæº±æº˜æ» æ¼­æ»¢æº¥æº§æº½æº»æº·æ»—æº´æ»æºæ»‚æºŸæ½¢æ½†æ½‡æ¼¤æ¼•æ»¹æ¼¯æ¼¶æ½‹æ½´æ¼ªæ¼‰æ¼©æ¾‰æ¾æ¾Œæ½¸æ½²æ½¼æ½ºæ¿‘"
  ],
  [
    "e540",
    "éŒŠ",
    51,
    "éŒ¿",
    10
  ],
  [
    "e580",
    "éŠ",
    31,
    "é«æ¿‰æ¾§æ¾¹æ¾¶æ¿‚æ¿¡æ¿®æ¿žæ¿ æ¿¯ç€šç€£ç€›ç€¹ç€µççžå®€å®„å®•å®“å®¥å®¸ç”¯éªžæ´å¯¤å¯®è¤°å¯°è¹‡è¬‡è¾¶è¿“è¿•è¿¥è¿®è¿¤è¿©è¿¦è¿³è¿¨é€…é€„é€‹é€¦é€‘é€é€–é€¡é€µé€¶é€­é€¯é„é‘é’éé¨é˜é¢é›æš¹é´é½é‚‚é‚ˆé‚ƒé‚‹å½å½—å½–å½˜å°»å’«å±å±™å­±å±£å±¦ç¾¼å¼ªå¼©å¼­è‰´å¼¼é¬»å±®å¦å¦ƒå¦å¦©å¦ªå¦£"
  ],
  [
    "e640",
    "é¬",
    34,
    "éŽ",
    27
  ],
  [
    "e680",
    "éŽ¬",
    29,
    "é‹éŒéå¦—å§Šå¦«å¦žå¦¤å§’å¦²å¦¯å§—å¦¾å¨…å¨†å§å¨ˆå§£å§˜å§¹å¨Œå¨‰å¨²å¨´å¨‘å¨£å¨“å©€å©§å©Šå©•å¨¼å©¢å©µèƒ¬åªªåª›å©·å©ºåª¾å««åª²å«’å«”åª¸å« å«£å«±å«–å«¦å«˜å«œå¬‰å¬—å¬–å¬²å¬·å­€å°•å°œå­šå­¥å­³å­‘å­“å­¢é©µé©·é©¸é©ºé©¿é©½éª€éªéª…éªˆéªŠéªéª’éª“éª–éª˜éª›éªœéªéªŸéª éª¢éª£éª¥éª§çºŸçº¡çº£çº¥çº¨çº©"
  ],
  [
    "e740",
    "éŽ",
    7,
    "é—",
    54
  ],
  [
    "e780",
    "éŽ",
    32,
    "çº­çº°çº¾ç»€ç»ç»‚ç»‰ç»‹ç»Œç»ç»”ç»—ç»›ç» ç»¡ç»¨ç»«ç»®ç»¯ç»±ç»²ç¼ç»¶ç»ºç»»ç»¾ç¼ç¼‚ç¼ƒç¼‡ç¼ˆç¼‹ç¼Œç¼ç¼‘ç¼’ç¼—ç¼™ç¼œç¼›ç¼Ÿç¼¡",
    6,
    "ç¼ªç¼«ç¼¬ç¼­ç¼¯",
    4,
    "ç¼µå¹ºç•¿å·›ç”¾é‚•çŽŽçŽ‘çŽ®çŽ¢çŽŸçç‚ç‘çŽ·çŽ³ç€ç‰çˆç¥ç™é¡¼çŠç©ç§çžçŽºç²ççªç‘›ç¦ç¥ç¨ç°ç®ç¬"
  ],
  [
    "e840",
    "é¯",
    14,
    "é¿",
    43,
    "é‘¬é‘­é‘®é‘¯"
  ],
  [
    "e880",
    "é‘°",
    20,
    "é’‘é’–é’˜é“‡é“é““é“”é“šé“¦é“»é”œé” ç›çšç‘ç‘œç‘—ç‘•ç‘™ç‘·ç‘­ç‘¾ç’œç’Žç’€ç’ç’‡ç’‹ç’žç’¨ç’©ç’ç’§ç“’ç’ºéŸªéŸ«éŸ¬æŒæ“æžæˆæ©æž¥æž‡æªæ³æž˜æž§æµæž¨æžžæž­æž‹æ·æ¼æŸ°æ ‰æŸ˜æ ŠæŸ©æž°æ ŒæŸ™æžµæŸšæž³æŸæ €æŸƒæž¸æŸ¢æ ŽæŸæŸ½æ ²æ ³æ¡ æ¡¡æ¡Žæ¡¢æ¡„æ¡¤æ¢ƒæ æ¡•æ¡¦æ¡æ¡§æ¡€æ ¾æ¡Šæ¡‰æ ©æ¢µæ¢æ¡´æ¡·æ¢“æ¡«æ£‚æ¥®æ£¼æ¤Ÿæ¤ æ£¹"
  ],
  [
    "e940",
    "é”§é”³é”½é•ƒé•ˆé•‹é••é•šé• é•®é•´é•µé•·",
    7,
    "é–€",
    42
  ],
  [
    "e980",
    "é–«",
    32,
    "æ¤¤æ£°æ¤‹æ¤æ¥—æ££æ¤æ¥±æ¤¹æ¥ æ¥‚æ¥æ¦„æ¥«æ¦€æ¦˜æ¥¸æ¤´æ§Œæ¦‡æ¦ˆæ§Žæ¦‰æ¥¦æ¥£æ¥¹æ¦›æ¦§æ¦»æ¦«æ¦­æ§”æ¦±æ§æ§Šæ§Ÿæ¦•æ§ æ¦æ§¿æ¨¯æ§­æ¨—æ¨˜æ©¥æ§²æ©„æ¨¾æª æ©æ©›æ¨µæªŽæ©¹æ¨½æ¨¨æ©˜æ©¼æª‘æªæª©æª—æª«çŒ·ç’æ®æ®‚æ®‡æ®„æ®’æ®“æ®æ®šæ®›æ®¡æ®ªè½«è½­è½±è½²è½³è½µè½¶è½¸è½·è½¹è½ºè½¼è½¾è¾è¾‚è¾„è¾‡è¾‹"
  ],
  [
    "ea40",
    "é—Œ",
    27,
    "é—¬é—¿é˜‡é˜“é˜˜é˜›é˜žé˜ é˜£",
    6,
    "é˜«é˜¬é˜­é˜¯é˜°é˜·é˜¸é˜¹é˜ºé˜¾é™é™ƒé™Šé™Žé™é™‘é™’é™“é™–é™—"
  ],
  [
    "ea80",
    "é™˜é™™é™šé™œé™é™žé™ é™£é™¥é™¦é™«é™­",
    4,
    "é™³é™¸",
    12,
    "éš‡éš‰éšŠè¾è¾Žè¾è¾˜è¾šè»Žæˆ‹æˆ—æˆ›æˆŸæˆ¢æˆ¡æˆ¥æˆ¤æˆ¬è‡§ç“¯ç“´ç“¿ç”ç”‘ç”“æ”´æ—®æ—¯æ—°æ˜Šæ˜™æ²æ˜ƒæ˜•æ˜€ç‚…æ›·æ˜æ˜´æ˜±æ˜¶æ˜µè€†æ™Ÿæ™”æ™æ™æ™–æ™¡æ™—æ™·æš„æšŒæš§æšæš¾æ››æ›œæ›¦æ›©è´²è´³è´¶è´»è´½èµ€èµ…èµ†èµˆèµ‰èµ‡èµèµ•èµ™è§‡è§Šè§‹è§Œè§Žè§è§è§‘ç‰®çŠŸç‰ç‰¦ç‰¯ç‰¾ç‰¿çŠ„çŠ‹çŠçŠçŠ’æŒˆæŒ²æŽ°"
  ],
  [
    "eb40",
    "éšŒéšŽéš‘éš’éš“éš•éš–éššéš›éš",
    9,
    "éš¨",
    7,
    "éš±éš²éš´éšµéš·éš¸éšºéš»éš¿é›‚é›ƒé›ˆé›Šé›‹é›é›‘é›“é›”é›–",
    9,
    "é›¡",
    6,
    "é›«"
  ],
  [
    "eb80",
    "é›¬é›­é›®é›°é›±é›²é›´é›µé›¸é›ºé›»é›¼é›½é›¿éœ‚éœƒéœ…éœŠéœ‹éœŒéœéœ‘éœ’éœ”éœ•éœ—",
    4,
    "éœéœŸéœ æ¿æ“˜è€„æ¯ªæ¯³æ¯½æ¯µæ¯¹æ°…æ°‡æ°†æ°æ°•æ°˜æ°™æ°šæ°¡æ°©æ°¤æ°ªæ°²æ”µæ••æ•«ç‰ç‰’ç‰–çˆ°è™¢åˆ–è‚Ÿè‚œè‚“è‚¼æœŠè‚½è‚±è‚«è‚­è‚´è‚·èƒ§èƒ¨èƒ©èƒªèƒ›èƒ‚èƒ„èƒ™èƒèƒ—æœèƒèƒ«èƒ±èƒ´èƒ­è„è„Žèƒ²èƒ¼æœ•è„’è±šè„¶è„žè„¬è„˜è„²è…ˆè…Œè…“è…´è…™è…šè…±è… è…©è…¼è…½è…­è…§å¡åªµè†ˆè†‚è†‘æ»•è†£è†ªè‡Œæœ¦è‡Šè†»"
  ],
  [
    "ec40",
    "éœ¡",
    8,
    "éœ«éœ¬éœ®éœ¯éœ±éœ³",
    4,
    "éœºéœ»éœ¼éœ½éœ¿",
    18,
    "é”é•é—é˜éšéœééŸé£é¤é¦é§é¨éª",
    7
  ],
  [
    "ec80",
    "é²éµé·",
    4,
    "é½",
    7,
    "éž†",
    4,
    "éžŒéžŽéžéžéž“éž•éž–éž—éž™",
    4,
    "è‡è†¦æ¬¤æ¬·æ¬¹æ­ƒæ­†æ­™é£‘é£’é£“é£•é£™é£šæ®³å½€æ¯‚è§³æ–é½‘æ–“æ–¼æ—†æ—„æ—ƒæ—Œæ—Žæ—’æ—–ç‚€ç‚œç‚–ç‚ç‚»çƒ€ç‚·ç‚«ç‚±çƒ¨çƒŠç„ç„“ç„–ç„¯ç„±ç…³ç…œç…¨ç……ç…²ç…Šç…¸ç…ºç†˜ç†³ç†µç†¨ç† ç‡ ç‡”ç‡§ç‡¹çˆçˆ¨ç¬ç„˜ç…¦ç†¹æˆ¾æˆ½æ‰ƒæ‰ˆæ‰‰ç¤»ç¥€ç¥†ç¥‰ç¥›ç¥œç¥“ç¥šç¥¢ç¥—ç¥ ç¥¯ç¥§ç¥ºç¦…ç¦Šç¦šç¦§ç¦³å¿‘å¿"
  ],
  [
    "ed40",
    "éžžéžŸéž¡éž¢éž¤",
    6,
    "éž¬éž®éž°éž±éž³éžµ",
    46
  ],
  [
    "ed80",
    "éŸ¤éŸ¥éŸ¨éŸ®",
    4,
    "éŸ´éŸ·",
    23,
    "æ€¼ææšæ§ææ™æ£æ‚«æ„†æ„æ…æ†©æ†æ‡‹æ‡‘æˆ†è‚€è¿æ²“æ³¶æ·¼çŸ¶çŸ¸ç €ç ‰ç —ç ˜ç ‘æ–«ç ­ç œç ç ¹ç ºç »ç Ÿç ¼ç ¥ç ¬ç £ç ©ç¡Žç¡­ç¡–ç¡—ç ¦ç¡ç¡‡ç¡Œç¡ªç¢›ç¢“ç¢šç¢‡ç¢œç¢¡ç¢£ç¢²ç¢¹ç¢¥ç£”ç£™ç£‰ç£¬ç£²ç¤…ç£´ç¤“ç¤¤ç¤žç¤´é¾›é»¹é»»é»¼ç›±çœ„çœç›¹çœ‡çœˆçœšçœ¢çœ™çœ­çœ¦çœµçœ¸çç‘ç‡çƒçšç¨"
  ],
  [
    "ee40",
    "é ",
    62
  ],
  [
    "ee80",
    "é¡Ž",
    32,
    "ç¢ç¥ç¿çžç½çž€çžŒçž‘çžŸçž çž°çžµçž½ç”ºç•€ç•Žç•‹ç•ˆç•›ç•²ç•¹ç–ƒç½˜ç½¡ç½Ÿè©ˆç½¨ç½´ç½±ç½¹ç¾ç½¾ç›ç›¥è ²é’…é’†é’‡é’‹é’Šé’Œé’é’é’é’”é’—é’•é’šé’›é’œé’£é’¤é’«é’ªé’­é’¬é’¯é’°é’²é’´é’¶",
    4,
    "é’¼é’½é’¿é“„é“ˆ",
    6,
    "é“é“‘é“’é“•é“–é“—é“™é“˜é“›é“žé“Ÿé“ é“¢é“¤é“¥é“§é“¨é“ª"
  ],
  [
    "ef40",
    "é¡¯",
    5,
    "é¢‹é¢Žé¢’é¢•é¢™é¢£é¢¨",
    37,
    "é£é£é£”é£–é£—é£›é£œé£é£ ",
    4
  ],
  [
    "ef80",
    "é£¥é£¦é£©",
    30,
    "é“©é“«é“®é“¯é“³é“´é“µé“·é“¹é“¼é“½é“¿é”ƒé”‚é”†é”‡é”‰é”Šé”é”Žé”é”’",
    4,
    "é”˜é”›é”é”žé”Ÿé”¢é”ªé”«é”©é”¬é”±é”²é”´é”¶é”·é”¸é”¼é”¾é”¿é•‚é”µé•„é•…é•†é•‰é•Œé•Žé•é•’é•“é•”é•–é•—é•˜é•™é•›é•žé•Ÿé•é•¡é•¢é•¤",
    8,
    "é•¯é•±é•²é•³é”ºçŸ§çŸ¬é›‰ç§•ç§­ç§£ç§«ç¨†åµ‡ç¨ƒç¨‚ç¨žç¨”"
  ],
  [
    "f040",
    "é¤ˆ",
    4,
    "é¤Žé¤é¤‘",
    28,
    "é¤¯",
    26
  ],
  [
    "f080",
    "é¥Š",
    9,
    "é¥–",
    12,
    "é¥¤é¥¦é¥³é¥¸é¥¹é¥»é¥¾é¦‚é¦ƒé¦‰ç¨¹ç¨·ç©‘é»é¦¥ç©°çšˆçšŽçš“çš™çš¤ç“žç“ ç”¬é¸ é¸¢é¸¨",
    4,
    "é¸²é¸±é¸¶é¸¸é¸·é¸¹é¸ºé¸¾é¹é¹‚é¹„é¹†é¹‡é¹ˆé¹‰é¹‹é¹Œé¹Žé¹‘é¹•é¹—é¹šé¹›é¹œé¹žé¹£é¹¦",
    6,
    "é¹±é¹­é¹³ç–’ç–”ç––ç– ç–ç–¬ç–£ç–³ç–´ç–¸ç—„ç–±ç–°ç—ƒç—‚ç—–ç—ç—£ç—¨ç—¦ç—¤ç—«ç—§ç˜ƒç—±ç—¼ç—¿ç˜ç˜€ç˜…ç˜Œç˜—ç˜Šç˜¥ç˜˜ç˜•ç˜™"
  ],
  [
    "f140",
    "é¦Œé¦Žé¦š",
    10,
    "é¦¦é¦§é¦©",
    47
  ],
  [
    "f180",
    "é§™",
    32,
    "ç˜›ç˜¼ç˜¢ç˜ ç™€ç˜­ç˜°ç˜¿ç˜µç™ƒç˜¾ç˜³ç™ç™žç™”ç™œç™–ç™«ç™¯ç¿Šç«¦ç©¸ç©¹çª€çª†çªˆçª•çª¦çª çª¬çª¨çª­çª³è¡¤è¡©è¡²è¡½è¡¿è¢‚è¢¢è£†è¢·è¢¼è£‰è£¢è£Žè££è£¥è£±è¤šè£¼è£¨è£¾è£°è¤¡è¤™è¤“è¤›è¤Šè¤´è¤«è¤¶è¥è¥¦è¥»ç–‹èƒ¥çš²çš´çŸœè€’è€”è€–è€œè€ è€¢è€¥è€¦è€§è€©è€¨è€±è€‹è€µèƒè†èè’è©è±è¦ƒé¡¸é¢€é¢ƒ"
  ],
  [
    "f240",
    "é§º",
    62
  ],
  [
    "f280",
    "é¨¹",
    32,
    "é¢‰é¢Œé¢é¢é¢”é¢šé¢›é¢žé¢Ÿé¢¡é¢¢é¢¥é¢¦è™è™”è™¬è™®è™¿è™ºè™¼è™»èš¨èšèš‹èš¬èšèš§èš£èšªèš“èš©èš¶è›„èšµè›Žèš°èšºèš±èš¯è›‰è›èš´è›©è›±è›²è›­è›³è›èœ“è›žè›´è›Ÿè›˜è›‘èœƒèœ‡è›¸èœˆèœŠèœèœ‰èœ£èœ»èœžèœ¥èœ®èœšèœ¾èˆèœ´èœ±èœ©èœ·èœ¿èž‚èœ¢è½è¾è»è è°èŒè®èž‹è“è£è¼è¤è™è¥èž“èž¯èž¨èŸ’"
  ],
  [
    "f340",
    "é©š",
    17,
    "é©²éªƒéª‰éªéªŽéª”éª•éª™éª¦éª©",
    6,
    "éª²éª³éª´éªµéª¹éª»éª½éª¾éª¿é«ƒé«„é«†",
    4,
    "é«é«Žé«é«é«’é«”é«•é«–é«—é«™é«šé«›é«œ"
  ],
  [
    "f380",
    "é«é«žé« é«¢é«£é«¤é«¥é«§é«¨é«©é«ªé«¬é«®é«°",
    8,
    "é«ºé«¼",
    6,
    "é¬„é¬…é¬†èŸ†èžˆèž…èž­èž—èžƒèž«èŸ¥èž¬èžµèž³èŸ‹èŸ“èž½èŸ‘èŸ€èŸŠèŸ›èŸªèŸ èŸ®è –è “èŸ¾è Šè ›è ¡è ¹è ¼ç¼¶ç½‚ç½„ç½…èˆç«ºç«½ç¬ˆç¬ƒç¬„ç¬•ç¬Šç¬«ç¬ç­‡ç¬¸ç¬ªç¬™ç¬®ç¬±ç¬ ç¬¥ç¬¤ç¬³ç¬¾ç¬žç­˜ç­šç­…ç­µç­Œç­ç­ ç­®ç­»ç­¢ç­²ç­±ç®ç®¦ç®§ç®¸ç®¬ç®ç®¨ç®…ç®ªç®œç®¢ç®«ç®´ç¯‘ç¯ç¯Œç¯ç¯šç¯¥ç¯¦ç¯ªç°Œç¯¾ç¯¼ç°ç°–ç°‹"
  ],
  [
    "f440",
    "é¬‡é¬‰",
    5,
    "é¬é¬‘é¬’é¬”",
    10,
    "é¬ é¬¡é¬¢é¬¤",
    10,
    "é¬°é¬±é¬³",
    7,
    "é¬½é¬¾é¬¿é­€é­†é­Šé­‹é­Œé­Žé­é­’é­“é­•",
    5
  ],
  [
    "f480",
    "é­›",
    32,
    "ç°Ÿç°ªç°¦ç°¸ç±ç±€è‡¾èˆèˆ‚èˆ„è‡¬è¡„èˆ¡èˆ¢èˆ£èˆ­èˆ¯èˆ¨èˆ«èˆ¸èˆ»èˆ³èˆ´èˆ¾è‰„è‰‰è‰‹è‰è‰šè‰Ÿè‰¨è¡¾è¢…è¢ˆè£˜è£Ÿè¥žç¾ç¾Ÿç¾§ç¾¯ç¾°ç¾²ç±¼æ•‰ç²‘ç²ç²œç²žç²¢ç²²ç²¼ç²½ç³ç³‡ç³Œç³ç³ˆç³…ç³—ç³¨è‰®æš¨ç¾¿ç¿Žç¿•ç¿¥ç¿¡ç¿¦ç¿©ç¿®ç¿³ç³¸çµ·ç¶¦ç¶®ç¹‡çº›éº¸éº´èµ³è¶„è¶”è¶‘è¶±èµ§èµ­è±‡è±‰é…Šé…é…Žé…é…¤"
  ],
  [
    "f540",
    "é­¼",
    62
  ],
  [
    "f580",
    "é®»",
    32,
    "é…¢é…¡é…°é…©é…¯é…½é…¾é…²é…´é…¹é†Œé†…é†é†é†‘é†¢é†£é†ªé†­é†®é†¯é†µé†´é†ºè±•é¹¾è¶¸è·«è¸…è¹™è¹©è¶µè¶¿è¶¼è¶ºè·„è·–è·—è·šè·žè·Žè·è·›è·†è·¬è··è·¸è·£è·¹è·»è·¤è¸‰è·½è¸”è¸è¸Ÿè¸¬è¸®è¸£è¸¯è¸ºè¹€è¸¹è¸µè¸½è¸±è¹‰è¹è¹‚è¹‘è¹’è¹Šè¹°è¹¶è¹¼è¹¯è¹´èº…èºèº”èºèºœèºžè±¸è²‚è²Šè²…è²˜è²”æ–›è§–è§žè§šè§œ"
  ],
  [
    "f640",
    "é¯œ",
    62
  ],
  [
    "f680",
    "é°›",
    32,
    "è§¥è§«è§¯è¨¾è¬¦é“é›©é›³é›¯éœ†éœéœˆéœéœŽéœªéœ­éœ°éœ¾é¾€é¾ƒé¾…",
    5,
    "é¾Œé»¾é¼‹é¼éš¹éš¼éš½é›Žé›’çž¿é› éŠŽéŠ®é‹ˆéŒ¾éªéŠéŽé¾é‘«é±¿é²‚é²…é²†é²‡é²ˆç¨£é²‹é²Žé²é²‘é²’é²”é²•é²šé²›é²ž",
    5,
    "é²¥",
    4,
    "é²«é²­é²®é²°",
    7,
    "é²ºé²»é²¼é²½é³„é³…é³†é³‡é³Šé³‹"
  ],
  [
    "f740",
    "é°¼",
    62
  ],
  [
    "f780",
    "é±»é±½é±¾é²€é²ƒé²„é²‰é²Šé²Œé²é²“é²–é²—é²˜é²™é²é²ªé²¬é²¯é²¹é²¾",
    4,
    "é³ˆé³‰é³‘é³’é³šé³›é³ é³¡é³Œ",
    4,
    "é³“é³”é³•é³—é³˜é³™é³œé³é³Ÿé³¢é¼éž…éž‘éž’éž”éž¯éž«éž£éž²éž´éª±éª°éª·é¹˜éª¶éªºéª¼é«é«€é«…é«‚é«‹é«Œé«‘é­…é­ƒé­‡é­‰é­ˆé­é­‘é£¨é¤é¤®é¥•é¥”é«Ÿé«¡é«¦é«¯é««é«»é«­é«¹é¬ˆé¬é¬“é¬Ÿé¬£éº½éº¾ç¸»éº‚éº‡éºˆéº‹éº’é–éºéºŸé»›é»œé»é» é»Ÿé»¢é»©é»§é»¥é»ªé»¯é¼¢é¼¬é¼¯é¼¹é¼·é¼½é¼¾é½„"
  ],
  [
    "f840",
    "é³£",
    62
  ],
  [
    "f880",
    "é´¢",
    32
  ],
  [
    "f940",
    "éµƒ",
    62
  ],
  [
    "f980",
    "é¶‚",
    32
  ],
  [
    "fa40",
    "é¶£",
    62
  ],
  [
    "fa80",
    "é·¢",
    32
  ],
  [
    "fb40",
    "é¸ƒ",
    27,
    "é¸¤é¸§é¸®é¸°é¸´é¸»é¸¼é¹€é¹é¹é¹’é¹“é¹”é¹–é¹™é¹é¹Ÿé¹ é¹¡é¹¢é¹¥é¹®é¹¯é¹²é¹´",
    9,
    "éº€"
  ],
  [
    "fb80",
    "éºéºƒéº„éº…éº†éº‰éºŠéºŒ",
    5,
    "éº”",
    8,
    "éºžéº ",
    5,
    "éº§éº¨éº©éºª"
  ],
  [
    "fc40",
    "éº«",
    8,
    "éºµéº¶éº·éº¹éººéº¼éº¿",
    4,
    "é»…é»†é»‡é»ˆé»Šé»‹é»Œé»é»’é»“é»•é»–é»—é»™é»šé»žé»¡é»£é»¤é»¦é»¨é»«é»¬é»­é»®é»°",
    8,
    "é»ºé»½é»¿",
    6
  ],
  [
    "fc80",
    "é¼†",
    4,
    "é¼Œé¼é¼‘é¼’é¼”é¼•é¼–é¼˜é¼š",
    5,
    "é¼¡é¼£",
    8,
    "é¼­é¼®é¼°é¼±"
  ],
  [
    "fd40",
    "é¼²",
    4,
    "é¼¸é¼ºé¼¼é¼¿",
    4,
    "é½…",
    10,
    "é½’",
    38
  ],
  [
    "fd80",
    "é½¹",
    5,
    "é¾é¾‚é¾",
    11,
    "é¾œé¾é¾žé¾¡",
    4,
    "ï¤¬ï¥¹ï¦•ï§§ï§±"
  ],
  [
    "fe40",
    "ï¨Œï¨ï¨Žï¨ï¨‘ï¨“ï¨”ï¨˜ï¨Ÿï¨ ï¨¡ï¨£ï¨¤ï¨§ï¨¨ï¨©"
  ]
];
const require$$3$1 = [
  [
    "a140",
    "î“†",
    62
  ],
  [
    "a180",
    "î”…",
    32
  ],
  [
    "a240",
    "î”¦",
    62
  ],
  [
    "a280",
    "î•¥",
    32
  ],
  [
    "a2ab",
    "î¦",
    5
  ],
  [
    "a2e3",
    "â‚¬î­"
  ],
  [
    "a2ef",
    "î®î¯"
  ],
  [
    "a2fd",
    "î°î±"
  ],
  [
    "a340",
    "î–†",
    62
  ],
  [
    "a380",
    "î—…",
    31,
    "ã€€"
  ],
  [
    "a440",
    "î—¦",
    62
  ],
  [
    "a480",
    "î˜¥",
    32
  ],
  [
    "a4f4",
    "î²",
    10
  ],
  [
    "a540",
    "î™†",
    62
  ],
  [
    "a580",
    "îš…",
    32
  ],
  [
    "a5f7",
    "î½",
    7
  ],
  [
    "a640",
    "îš¦",
    62
  ],
  [
    "a680",
    "î›¥",
    32
  ],
  [
    "a6b9",
    "îž…",
    7
  ],
  [
    "a6d9",
    "îž",
    6
  ],
  [
    "a6ec",
    "îž”îž•"
  ],
  [
    "a6f3",
    "îž–"
  ],
  [
    "a6f6",
    "îž—",
    8
  ],
  [
    "a740",
    "îœ†",
    62
  ],
  [
    "a780",
    "î…",
    32
  ],
  [
    "a7c2",
    "îž ",
    14
  ],
  [
    "a7f2",
    "îž¯",
    12
  ],
  [
    "a896",
    "îž¼",
    10
  ],
  [
    "a8bc",
    "îŸ‡"
  ],
  [
    "a8bf",
    "Ç¹"
  ],
  [
    "a8c1",
    "îŸ‰îŸŠîŸ‹îŸŒ"
  ],
  [
    "a8ea",
    "îŸ",
    20
  ],
  [
    "a958",
    "îŸ¢"
  ],
  [
    "a95b",
    "îŸ£"
  ],
  [
    "a95d",
    "îŸ¤îŸ¥îŸ¦"
  ],
  [
    "a989",
    "ã€¾â¿°",
    11
  ],
  [
    "a997",
    "îŸ´",
    12
  ],
  [
    "a9f0",
    "î ",
    14
  ],
  [
    "aaa1",
    "î€€",
    93
  ],
  [
    "aba1",
    "îž",
    93
  ],
  [
    "aca1",
    "î‚¼",
    93
  ],
  [
    "ada1",
    "î„š",
    93
  ],
  [
    "aea1",
    "î…¸",
    93
  ],
  [
    "afa1",
    "î‡–",
    93
  ],
  [
    "d7fa",
    "î ",
    4
  ],
  [
    "f8a1",
    "îˆ´",
    93
  ],
  [
    "f9a1",
    "îŠ’",
    93
  ],
  [
    "faa1",
    "î‹°",
    93
  ],
  [
    "fba1",
    "îŽ",
    93
  ],
  [
    "fca1",
    "îŽ¬",
    93
  ],
  [
    "fda1",
    "îŠ",
    93
  ],
  [
    "fe50",
    "âºî –î —î ˜âº„ã‘³ã‘‡âºˆâº‹î žã–žã˜šã˜ŽâºŒâº—ã¥®ã¤˜î ¦ã§ã§Ÿã©³ã§î «î ¬ã­Žã±®ã³ âº§î ±î ²âºªä–ä…Ÿâº®äŒ·âº³âº¶âº·î »äŽ±äŽ¬âº»ää“–ä™¡ä™Œî¡ƒ"
  ],
  [
    "fe80",
    "äœ£äœ©ä¼äžâ»Šä¥‡ä¥ºä¥½ä¦‚ä¦ƒä¦…ä¦†ä¦Ÿä¦›ä¦·ä¦¶î¡”î¡•ä²£ä²Ÿä² ä²¡ä±·ä²¢ä´“",
    6,
    "ä¶®î¡¤î‘¨",
    93
  ]
];
const uChars = [
  128,
  165,
  169,
  178,
  184,
  216,
  226,
  235,
  238,
  244,
  248,
  251,
  253,
  258,
  276,
  284,
  300,
  325,
  329,
  334,
  364,
  463,
  465,
  467,
  469,
  471,
  473,
  475,
  477,
  506,
  594,
  610,
  712,
  716,
  730,
  930,
  938,
  962,
  970,
  1026,
  1104,
  1106,
  8209,
  8215,
  8218,
  8222,
  8231,
  8241,
  8244,
  8246,
  8252,
  8365,
  8452,
  8454,
  8458,
  8471,
  8482,
  8556,
  8570,
  8596,
  8602,
  8713,
  8720,
  8722,
  8726,
  8731,
  8737,
  8740,
  8742,
  8748,
  8751,
  8760,
  8766,
  8777,
  8781,
  8787,
  8802,
  8808,
  8816,
  8854,
  8858,
  8870,
  8896,
  8979,
  9322,
  9372,
  9548,
  9588,
  9616,
  9622,
  9634,
  9652,
  9662,
  9672,
  9676,
  9680,
  9702,
  9735,
  9738,
  9793,
  9795,
  11906,
  11909,
  11913,
  11917,
  11928,
  11944,
  11947,
  11951,
  11956,
  11960,
  11964,
  11979,
  12284,
  12292,
  12312,
  12319,
  12330,
  12351,
  12436,
  12447,
  12535,
  12543,
  12586,
  12842,
  12850,
  12964,
  13200,
  13215,
  13218,
  13253,
  13263,
  13267,
  13270,
  13384,
  13428,
  13727,
  13839,
  13851,
  14617,
  14703,
  14801,
  14816,
  14964,
  15183,
  15471,
  15585,
  16471,
  16736,
  17208,
  17325,
  17330,
  17374,
  17623,
  17997,
  18018,
  18212,
  18218,
  18301,
  18318,
  18760,
  18811,
  18814,
  18820,
  18823,
  18844,
  18848,
  18872,
  19576,
  19620,
  19738,
  19887,
  40870,
  59244,
  59336,
  59367,
  59413,
  59417,
  59423,
  59431,
  59437,
  59443,
  59452,
  59460,
  59478,
  59493,
  63789,
  63866,
  63894,
  63976,
  63986,
  64016,
  64018,
  64021,
  64025,
  64034,
  64037,
  64042,
  65074,
  65093,
  65107,
  65112,
  65127,
  65132,
  65375,
  65510,
  65536
];
const gbChars = [
  0,
  36,
  38,
  45,
  50,
  81,
  89,
  95,
  96,
  100,
  103,
  104,
  105,
  109,
  126,
  133,
  148,
  172,
  175,
  179,
  208,
  306,
  307,
  308,
  309,
  310,
  311,
  312,
  313,
  341,
  428,
  443,
  544,
  545,
  558,
  741,
  742,
  749,
  750,
  805,
  819,
  820,
  7922,
  7924,
  7925,
  7927,
  7934,
  7943,
  7944,
  7945,
  7950,
  8062,
  8148,
  8149,
  8152,
  8164,
  8174,
  8236,
  8240,
  8262,
  8264,
  8374,
  8380,
  8381,
  8384,
  8388,
  8390,
  8392,
  8393,
  8394,
  8396,
  8401,
  8406,
  8416,
  8419,
  8424,
  8437,
  8439,
  8445,
  8482,
  8485,
  8496,
  8521,
  8603,
  8936,
  8946,
  9046,
  9050,
  9063,
  9066,
  9076,
  9092,
  9100,
  9108,
  9111,
  9113,
  9131,
  9162,
  9164,
  9218,
  9219,
  11329,
  11331,
  11334,
  11336,
  11346,
  11361,
  11363,
  11366,
  11370,
  11372,
  11375,
  11389,
  11682,
  11686,
  11687,
  11692,
  11694,
  11714,
  11716,
  11723,
  11725,
  11730,
  11736,
  11982,
  11989,
  12102,
  12336,
  12348,
  12350,
  12384,
  12393,
  12395,
  12397,
  12510,
  12553,
  12851,
  12962,
  12973,
  13738,
  13823,
  13919,
  13933,
  14080,
  14298,
  14585,
  14698,
  15583,
  15847,
  16318,
  16434,
  16438,
  16481,
  16729,
  17102,
  17122,
  17315,
  17320,
  17402,
  17418,
  17859,
  17909,
  17911,
  17915,
  17916,
  17936,
  17939,
  17961,
  18664,
  18703,
  18814,
  18962,
  19043,
  33469,
  33470,
  33471,
  33484,
  33485,
  33490,
  33497,
  33501,
  33505,
  33513,
  33520,
  33536,
  33550,
  37845,
  37921,
  37948,
  38029,
  38038,
  38064,
  38065,
  38066,
  38069,
  38075,
  38076,
  38078,
  39108,
  39109,
  39113,
  39114,
  39115,
  39116,
  39265,
  39394,
  189e3
];
const require$$4$1 = {
  uChars,
  gbChars
};
const require$$5 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "8141",
    "ê°‚ê°ƒê°…ê°†ê°‹",
    4,
    "ê°˜ê°žê°Ÿê°¡ê°¢ê°£ê°¥",
    6,
    "ê°®ê°²ê°³ê°´"
  ],
  [
    "8161",
    "ê°µê°¶ê°·ê°ºê°»ê°½ê°¾ê°¿ê±",
    9,
    "ê±Œê±Ž",
    5,
    "ê±•"
  ],
  [
    "8181",
    "ê±–ê±—ê±™ê±šê±›ê±",
    18,
    "ê±²ê±³ê±µê±¶ê±¹ê±»",
    4,
    "ê²‚ê²‡ê²ˆê²ê²Žê²ê²‘ê²’ê²“ê²•",
    6,
    "ê²žê²¢",
    5,
    "ê²«ê²­ê²®ê²±",
    6,
    "ê²ºê²¾ê²¿ê³€ê³‚ê³ƒê³…ê³†ê³‡ê³‰ê³Šê³‹ê³",
    7,
    "ê³–ê³˜",
    7,
    "ê³¢ê³£ê³¥ê³¦ê³©ê³«ê³­ê³®ê³²ê³´ê³·",
    4,
    "ê³¾ê³¿ê´ê´‚ê´ƒê´…ê´‡",
    4,
    "ê´Žê´ê´’ê´“"
  ],
  [
    "8241",
    "ê´”ê´•ê´–ê´—ê´™ê´šê´›ê´ê´žê´Ÿê´¡",
    7,
    "ê´ªê´«ê´®",
    5
  ],
  [
    "8261",
    "ê´¶ê´·ê´¹ê´ºê´»ê´½",
    6,
    "êµ†êµˆêµŠ",
    5,
    "êµ‘êµ’êµ“êµ•êµ–êµ—"
  ],
  [
    "8281",
    "êµ™",
    7,
    "êµ¢êµ¤",
    7,
    "êµ®êµ¯êµ±êµ²êµ·êµ¸êµ¹êµºêµ¾ê¶€ê¶ƒ",
    4,
    "ê¶Šê¶‹ê¶ê¶Žê¶ê¶‘",
    10,
    "ê¶ž",
    5,
    "ê¶¥",
    17,
    "ê¶¸",
    7,
    "ê·‚ê·ƒê·…ê·†ê·‡ê·‰",
    6,
    "ê·’ê·”",
    7,
    "ê·ê·žê·Ÿê·¡ê·¢ê·£ê·¥",
    18
  ],
  [
    "8341",
    "ê·ºê·»ê·½ê·¾ê¸‚",
    5,
    "ê¸Šê¸Œê¸Ž",
    5,
    "ê¸•",
    7
  ],
  [
    "8361",
    "ê¸",
    18,
    "ê¸²ê¸³ê¸µê¸¶ê¸¹ê¸»ê¸¼"
  ],
  [
    "8381",
    "ê¸½ê¸¾ê¸¿ê¹‚ê¹„ê¹‡ê¹ˆê¹‰ê¹‹ê¹ê¹‘ê¹’ê¹“ê¹•ê¹—",
    4,
    "ê¹žê¹¢ê¹£ê¹¤ê¹¦ê¹§ê¹ªê¹«ê¹­ê¹®ê¹¯ê¹±",
    6,
    "ê¹ºê¹¾",
    5,
    "êº†",
    5,
    "êº",
    46,
    "êº¿ê»ê»‚ê»ƒê»…",
    6,
    "ê»Žê»’",
    5,
    "ê»šê»›ê»",
    8
  ],
  [
    "8441",
    "ê»¦ê»§ê»©ê»ªê»¬ê»®",
    5,
    "ê»µê»¶ê»·ê»¹ê»ºê»»ê»½",
    8
  ],
  [
    "8461",
    "ê¼†ê¼‰ê¼Šê¼‹ê¼Œê¼Žê¼ê¼‘",
    18
  ],
  [
    "8481",
    "ê¼¤",
    7,
    "ê¼®ê¼¯ê¼±ê¼³ê¼µ",
    6,
    "ê¼¾ê½€ê½„ê½…ê½†ê½‡ê½Š",
    5,
    "ê½‘",
    10,
    "ê½ž",
    5,
    "ê½¦",
    18,
    "ê½º",
    5,
    "ê¾ê¾‚ê¾ƒê¾…ê¾†ê¾‡ê¾‰",
    6,
    "ê¾’ê¾“ê¾”ê¾–",
    5,
    "ê¾",
    26,
    "ê¾ºê¾»ê¾½ê¾¾"
  ],
  [
    "8541",
    "ê¾¿ê¿",
    5,
    "ê¿Šê¿Œê¿",
    4,
    "ê¿•",
    6,
    "ê¿",
    4
  ],
  [
    "8561",
    "ê¿¢",
    5,
    "ê¿ª",
    5,
    "ê¿²ê¿³ê¿µê¿¶ê¿·ê¿¹",
    6,
    "ë€‚ë€ƒ"
  ],
  [
    "8581",
    "ë€…",
    6,
    "ë€ë€Žë€ë€‘ë€’ë€“ë€•",
    6,
    "ë€ž",
    9,
    "ë€©",
    26,
    "ë†ë‡ë‰ë‹ëëëë‘ë’ë–ë˜ëšë›ëœëž",
    29,
    "ë¾ë¿ë‚ë‚‚ë‚ƒë‚…",
    6,
    "ë‚Žë‚ë‚’",
    5,
    "ë‚›ë‚ë‚žë‚£ë‚¤"
  ],
  [
    "8641",
    "ë‚¥ë‚¦ë‚§ë‚ªë‚°ë‚²ë‚¶ë‚·ë‚¹ë‚ºë‚»ë‚½",
    6,
    "ëƒ†ëƒŠ",
    5,
    "ëƒ’"
  ],
  [
    "8661",
    "ëƒ“ëƒ•ëƒ–ëƒ—ëƒ™",
    6,
    "ëƒ¡ëƒ¢ëƒ£ëƒ¤ëƒ¦",
    10
  ],
  [
    "8681",
    "ëƒ±",
    22,
    "ë„Šë„ë„Žë„ë„‘ë„”ë„•ë„–ë„—ë„šë„ž",
    4,
    "ë„¦ë„§ë„©ë„ªë„«ë„­",
    6,
    "ë„¶ë„º",
    5,
    "ë…‚ë…ƒë……ë…†ë…‡ë…‰",
    6,
    "ë…’ë…“ë…–ë…—ë…™ë…šë…›ë…ë…žë…Ÿë…¡",
    22,
    "ë…ºë…»ë…½ë…¾ë…¿ë†ë†ƒ",
    4,
    "ë†Šë†Œë†Žë†ë†ë†‘ë†•ë†–ë†—ë†™ë†šë†›ë†"
  ],
  [
    "8741",
    "ë†ž",
    9,
    "ë†©",
    15
  ],
  [
    "8761",
    "ë†¹",
    18,
    "ë‡ë‡Žë‡ë‡‘ë‡’ë‡“ë‡•"
  ],
  [
    "8781",
    "ë‡–",
    5,
    "ë‡žë‡ ",
    7,
    "ë‡ªë‡«ë‡­ë‡®ë‡¯ë‡±",
    7,
    "ë‡ºë‡¼ë‡¾",
    5,
    "ëˆ†ëˆ‡ëˆ‰ëˆŠëˆ",
    6,
    "ëˆ–ëˆ˜ëˆš",
    5,
    "ëˆ¡",
    18,
    "ëˆµ",
    6,
    "ëˆ½",
    26,
    "ë‰™ë‰šë‰›ë‰ë‰žë‰Ÿë‰¡",
    6,
    "ë‰ª",
    4
  ],
  [
    "8841",
    "ë‰¯",
    4,
    "ë‰¶",
    5,
    "ë‰½",
    6,
    "ëŠ†ëŠ‡ëŠˆëŠŠ",
    4
  ],
  [
    "8861",
    "ëŠëŠ’ëŠ“ëŠ•ëŠ–ëŠ—ëŠ›",
    4,
    "ëŠ¢ëŠ¤ëŠ§ëŠ¨ëŠ©ëŠ«ëŠ­ëŠ®ëŠ¯ëŠ±ëŠ²ëŠ³ëŠµëŠ¶ëŠ·"
  ],
  [
    "8881",
    "ëŠ¸",
    15,
    "ë‹Šë‹‹ë‹ë‹Žë‹ë‹‘ë‹“",
    4,
    "ë‹šë‹œë‹žë‹Ÿë‹ ë‹¡ë‹£ë‹§ë‹©ë‹ªë‹°ë‹±ë‹²ë‹¶ë‹¼ë‹½ë‹¾ëŒ‚ëŒƒëŒ…ëŒ†ëŒ‡ëŒ‰",
    6,
    "ëŒ’ëŒ–",
    5,
    "ëŒ",
    54,
    "ë—ë™ëšëë ë¡ë¢ë£"
  ],
  [
    "8941",
    "ë¦ë¨ëªë¬ë­ë¯ë²ë³ëµë¶ë·ë¹",
    6,
    "ëŽ‚ëŽ†",
    5,
    "ëŽ"
  ],
  [
    "8961",
    "ëŽŽëŽëŽ‘ëŽ’ëŽ“ëŽ•",
    10,
    "ëŽ¢",
    5,
    "ëŽ©ëŽªëŽ«ëŽ­"
  ],
  [
    "8981",
    "ëŽ®",
    21,
    "ë†ë‡ë‰ëŠëëë‘ë’ë“ë–ë˜ëšëœëžëŸë¡ë¢ë£ë¥ë¦ë§ë©",
    18,
    "ë½",
    18,
    "ë‘",
    6,
    "ë™ëšë›ëëžëŸë¡",
    6,
    "ëªë¬",
    7,
    "ëµ",
    15
  ],
  [
    "8a41",
    "ë‘…",
    10,
    "ë‘’ë‘“ë‘•ë‘–ë‘—ë‘™",
    6,
    "ë‘¢ë‘¤ë‘¦"
  ],
  [
    "8a61",
    "ë‘§",
    4,
    "ë‘­",
    18,
    "ë’ë’‚"
  ],
  [
    "8a81",
    "ë’ƒ",
    4,
    "ë’‰",
    19,
    "ë’ž",
    5,
    "ë’¥ë’¦ë’§ë’©ë’ªë’«ë’­",
    7,
    "ë’¶ë’¸ë’º",
    5,
    "ë“ë“‚ë“ƒë“…ë“†ë“‡ë“‰",
    6,
    "ë“‘ë“’ë““ë“”ë“–",
    5,
    "ë“žë“Ÿë“¡ë“¢ë“¥ë“§",
    4,
    "ë“®ë“°ë“²",
    5,
    "ë“¹",
    26,
    "ë”–ë”—ë”™ë”šë”"
  ],
  [
    "8b41",
    "ë”ž",
    5,
    "ë”¦ë”«",
    4,
    "ë”²ë”³ë”µë”¶ë”·ë”¹",
    6,
    "ë•‚ë•†"
  ],
  [
    "8b61",
    "ë•‡ë•ˆë•‰ë•Šë•Žë•ë•‘ë•’ë•“ë••",
    6,
    "ë•žë•¢",
    8
  ],
  [
    "8b81",
    "ë•«",
    52,
    "ë–¢ë–£ë–¥ë–¦ë–§ë–©ë–¬ë–­ë–®ë–¯ë–²ë–¶",
    4,
    "ë–¾ë–¿ë—ë—‚ë—ƒë—…",
    6,
    "ë—Žë—’",
    5,
    "ë—™",
    18,
    "ë—­",
    18
  ],
  [
    "8c41",
    "ë˜€",
    15,
    "ë˜’ë˜“ë˜•ë˜–ë˜—ë˜™",
    4
  ],
  [
    "8c61",
    "ë˜ž",
    6,
    "ë˜¦",
    5,
    "ë˜­",
    6,
    "ë˜µ",
    5
  ],
  [
    "8c81",
    "ë˜»",
    12,
    "ë™‰",
    26,
    "ë™¥ë™¦ë™§ë™©",
    50,
    "ëšžëšŸëš¡ëš¢ëš£ëš¥",
    5,
    "ëš­ëš®ëš¯ëš°ëš²",
    16
  ],
  [
    "8d41",
    "ë›ƒ",
    16,
    "ë›•",
    8
  ],
  [
    "8d61",
    "ë›ž",
    17,
    "ë›±ë›²ë›³ë›µë›¶ë›·ë›¹ë›º"
  ],
  [
    "8d81",
    "ë›»",
    4,
    "ëœ‚ëœƒëœ„ëœ†",
    33,
    "ëœªëœ«ëœ­ëœ®ëœ±",
    6,
    "ëœºëœ¼",
    7,
    "ë…ë†ë‡ë‰ëŠë‹ë",
    6,
    "ë–",
    9,
    "ë¡ë¢ë£ë¥ë¦ë§ë©",
    6,
    "ë²ë´ë¶",
    5,
    "ë¾ë¿ëžëž‚ëžƒëž…",
    6,
    "ëžŽëž“ëž”ëž•ëžšëž›ëžëžž"
  ],
  [
    "8e41",
    "ëžŸëž¡",
    6,
    "ëžªëž®",
    5,
    "ëž¶ëž·ëž¹",
    8
  ],
  [
    "8e61",
    "ëŸ‚",
    4,
    "ëŸˆëŸŠ",
    19
  ],
  [
    "8e81",
    "ëŸž",
    13,
    "ëŸ®ëŸ¯ëŸ±ëŸ²ëŸ³ëŸµ",
    6,
    "ëŸ¾ë ‚",
    4,
    "ë Šë ‹ë ë Žë ë ‘",
    6,
    "ë šë œë ž",
    5,
    "ë ¦ë §ë ©ë ªë «ë ­",
    6,
    "ë ¶ë º",
    5,
    "ë¡ë¡‚ë¡ƒë¡…",
    11,
    "ë¡’ë¡”",
    7,
    "ë¡žë¡Ÿë¡¡ë¡¢ë¡£ë¡¥",
    6,
    "ë¡®ë¡°ë¡²",
    5,
    "ë¡¹ë¡ºë¡»ë¡½",
    7
  ],
  [
    "8f41",
    "ë¢…",
    7,
    "ë¢Ž",
    17
  ],
  [
    "8f61",
    "ë¢ ",
    7,
    "ë¢©",
    6,
    "ë¢±ë¢²ë¢³ë¢µë¢¶ë¢·ë¢¹",
    4
  ],
  [
    "8f81",
    "ë¢¾ë¢¿ë£‚ë£„ë£†",
    5,
    "ë£ë£Žë£ë£‘ë£’ë£“ë£•",
    7,
    "ë£žë£ ë£¢",
    5,
    "ë£ªë£«ë£­ë£®ë£¯ë£±",
    6,
    "ë£ºë£¼ë£¾",
    5,
    "ë¤…",
    18,
    "ë¤™",
    6,
    "ë¤¡",
    26,
    "ë¤¾ë¤¿ë¥ë¥‚ë¥ƒë¥…",
    6,
    "ë¥ë¥Žë¥ë¥’",
    5
  ],
  [
    "9041",
    "ë¥šë¥›ë¥ë¥žë¥Ÿë¥¡",
    6,
    "ë¥ªë¥¬ë¥®",
    5,
    "ë¥¶ë¥·ë¥¹ë¥ºë¥»ë¥½"
  ],
  [
    "9061",
    "ë¥¾",
    5,
    "ë¦†ë¦ˆë¦‹ë¦Œë¦",
    15
  ],
  [
    "9081",
    "ë¦Ÿ",
    12,
    "ë¦®ë¦¯ë¦±ë¦²ë¦³ë¦µ",
    6,
    "ë¦¾ë§€ë§‚",
    5,
    "ë§Šë§‹ë§ë§“",
    4,
    "ë§šë§œë§Ÿë§ ë§¢ë§¦ë§§ë§©ë§ªë§«ë§­",
    6,
    "ë§¶ë§»",
    4,
    "ë¨‚",
    5,
    "ë¨‰",
    11,
    "ë¨–",
    33,
    "ë¨ºë¨»ë¨½ë¨¾ë¨¿ë©ë©ƒë©„ë©…ë©†"
  ],
  [
    "9141",
    "ë©‡ë©Šë©Œë©ë©ë©‘ë©’ë©–ë©—ë©™ë©šë©›ë©",
    6,
    "ë©¦ë©ª",
    5
  ],
  [
    "9161",
    "ë©²ë©³ë©µë©¶ë©·ë©¹",
    9,
    "ëª†ëªˆëª‰ëªŠëª‹ëª",
    5
  ],
  [
    "9181",
    "ëª“",
    20,
    "ëªªëª­ëª®ëª¯ëª±ëª³",
    4,
    "ëªºëª¼ëª¾",
    5,
    "ë«…ë«†ë«‡ë«‰",
    14,
    "ë«š",
    33,
    "ë«½ë«¾ë«¿ë¬ë¬‚ë¬ƒë¬…",
    7,
    "ë¬Žë¬ë¬’",
    5,
    "ë¬™ë¬šë¬›ë¬ë¬žë¬Ÿë¬¡",
    6
  ],
  [
    "9241",
    "ë¬¨ë¬ªë¬¬",
    7,
    "ë¬·ë¬¹ë¬ºë¬¿",
    4,
    "ë­†ë­ˆë­Šë­‹ë­Œë­Žë­‘ë­’"
  ],
  [
    "9261",
    "ë­“ë­•ë­–ë­—ë­™",
    7,
    "ë­¢ë­¤",
    7,
    "ë­­",
    4
  ],
  [
    "9281",
    "ë­²",
    21,
    "ë®‰ë®Šë®‹ë®ë®Žë®ë®‘",
    18,
    "ë®¥ë®¦ë®§ë®©ë®ªë®«ë®­",
    6,
    "ë®µë®¶ë®¸",
    7,
    "ë¯ë¯‚ë¯ƒë¯…ë¯†ë¯‡ë¯‰",
    6,
    "ë¯‘ë¯’ë¯”",
    35,
    "ë¯ºë¯»ë¯½ë¯¾ë°"
  ],
  [
    "9341",
    "ë°ƒ",
    4,
    "ë°Šë°Žë°ë°’ë°“ë°™ë°šë° ë°¡ë°¢ë°£ë°¦ë°¨ë°ªë°«ë°¬ë°®ë°¯ë°²ë°³ë°µ"
  ],
  [
    "9361",
    "ë°¶ë°·ë°¹",
    6,
    "ë±‚ë±†ë±‡ë±ˆë±Šë±‹ë±Žë±ë±‘",
    8
  ],
  [
    "9381",
    "ë±šë±›ë±œë±ž",
    37,
    "ë²†ë²‡ë²‰ë²Šë²ë²",
    4,
    "ë²–ë²˜ë²›",
    4,
    "ë²¢ë²£ë²¥ë²¦ë²©",
    6,
    "ë²²ë²¶",
    5,
    "ë²¾ë²¿ë³ë³‚ë³ƒë³…",
    7,
    "ë³Žë³’ë³“ë³”ë³–ë³—ë³™ë³šë³›ë³",
    22,
    "ë³·ë³¹ë³ºë³»ë³½"
  ],
  [
    "9441",
    "ë³¾",
    5,
    "ë´†ë´ˆë´Š",
    5,
    "ë´‘ë´’ë´“ë´•",
    8
  ],
  [
    "9461",
    "ë´ž",
    5,
    "ë´¥",
    6,
    "ë´­",
    12
  ],
  [
    "9481",
    "ë´º",
    5,
    "ëµ",
    6,
    "ëµŠëµ‹ëµëµŽëµëµ‘",
    6,
    "ëµš",
    9,
    "ëµ¥ëµ¦ëµ§ëµ©",
    22,
    "ë¶‚ë¶ƒë¶…ë¶†ë¶‹",
    4,
    "ë¶’ë¶”ë¶–ë¶—ë¶˜ë¶›ë¶",
    6,
    "ë¶¥",
    10,
    "ë¶±",
    6,
    "ë¶¹",
    24
  ],
  [
    "9541",
    "ë·’ë·“ë·–ë·—ë·™ë·šë·›ë·",
    11,
    "ë·ª",
    5,
    "ë·±"
  ],
  [
    "9561",
    "ë·²ë·³ë·µë·¶ë··ë·¹",
    6,
    "ë¸ë¸‚ë¸„ë¸†",
    5,
    "ë¸Žë¸ë¸‘ë¸’ë¸“"
  ],
  [
    "9581",
    "ë¸•",
    6,
    "ë¸žë¸ ",
    35,
    "ë¹†ë¹‡ë¹‰ë¹Šë¹‹ë¹ë¹",
    4,
    "ë¹–ë¹˜ë¹œë¹ë¹žë¹Ÿë¹¢ë¹£ë¹¥ë¹¦ë¹§ë¹©ë¹«",
    4,
    "ë¹²ë¹¶",
    4,
    "ë¹¾ë¹¿ëºëº‚ëºƒëº…",
    6,
    "ëºŽëº’",
    5,
    "ëºš",
    13,
    "ëº©",
    14
  ],
  [
    "9641",
    "ëº¸",
    23,
    "ë»’ë»“"
  ],
  [
    "9661",
    "ë»•ë»–ë»™",
    6,
    "ë»¡ë»¢ë»¦",
    5,
    "ë»­",
    8
  ],
  [
    "9681",
    "ë»¶",
    10,
    "ë¼‚",
    5,
    "ë¼Š",
    13,
    "ë¼šë¼ž",
    33,
    "ë½‚ë½ƒë½…ë½†ë½‡ë½‰",
    6,
    "ë½’ë½“ë½”ë½–",
    44
  ],
  [
    "9741",
    "ë¾ƒ",
    16,
    "ë¾•",
    8
  ],
  [
    "9761",
    "ë¾ž",
    17,
    "ë¾±",
    7
  ],
  [
    "9781",
    "ë¾¹",
    11,
    "ë¿†",
    5,
    "ë¿Žë¿ë¿‘ë¿’ë¿“ë¿•",
    6,
    "ë¿ë¿žë¿ ë¿¢",
    89,
    "ì€½ì€¾ì€¿"
  ],
  [
    "9841",
    "ì€",
    16,
    "ì’",
    5,
    "ì™ìšì›"
  ],
  [
    "9861",
    "ììžìŸì¡",
    6,
    "ìª",
    15
  ],
  [
    "9881",
    "ìº",
    21,
    "ì‚’ì‚“ì‚•ì‚–ì‚—ì‚™",
    6,
    "ì‚¢ì‚¤ì‚¦",
    5,
    "ì‚®ì‚±ì‚²ì‚·",
    4,
    "ì‚¾ìƒ‚ìƒƒìƒ„ìƒ†ìƒ‡ìƒŠìƒ‹ìƒìƒŽìƒìƒ‘",
    6,
    "ìƒšìƒž",
    5,
    "ìƒ¦ìƒ§ìƒ©ìƒªìƒ«ìƒ­",
    6,
    "ìƒ¶ìƒ¸ìƒº",
    5,
    "ì„ì„‚ì„ƒì„…ì„†ì„‡ì„‰",
    6,
    "ì„‘ì„’ì„“ì„”ì„–",
    5,
    "ì„¡ì„¢ì„¥ì„¨ì„©ì„ªì„«ì„®"
  ],
  [
    "9941",
    "ì„²ì„³ì„´ì„µì„·ì„ºì„»ì„½ì„¾ì„¿ì…",
    6,
    "ì…Šì…Ž",
    5,
    "ì…–ì…—"
  ],
  [
    "9961",
    "ì…™ì…šì…›ì…",
    6,
    "ì…¦ì…ª",
    5,
    "ì…±ì…²ì…³ì…µì…¶ì…·ì…¹ì…ºì…»"
  ],
  [
    "9981",
    "ì…¼",
    8,
    "ì††",
    5,
    "ì†ì†‘ì†’ì†“ì†•ì†—",
    4,
    "ì†žì† ì†¢ì†£ì†¤ì†¦ì†§ì†ªì†«ì†­ì†®ì†¯ì†±",
    11,
    "ì†¾",
    5,
    "ì‡…ì‡†ì‡‡ì‡‰ì‡Šì‡‹ì‡",
    6,
    "ì‡•ì‡–ì‡™",
    6,
    "ì‡¡ì‡¢ì‡£ì‡¥ì‡¦ì‡§ì‡©",
    6,
    "ì‡²ì‡´",
    7,
    "ì‡¾ì‡¿ìˆìˆ‚ìˆƒìˆ…",
    6,
    "ìˆŽìˆìˆ’",
    5,
    "ìˆšìˆ›ìˆìˆžìˆ¡ìˆ¢ìˆ£"
  ],
  [
    "9a41",
    "ìˆ¤ìˆ¥ìˆ¦ìˆ§ìˆªìˆ¬ìˆ®ìˆ°ìˆ³ìˆµ",
    16
  ],
  [
    "9a61",
    "ì‰†ì‰‡ì‰‰",
    6,
    "ì‰’ì‰“ì‰•ì‰–ì‰—ì‰™",
    6,
    "ì‰¡ì‰¢ì‰£ì‰¤ì‰¦"
  ],
  [
    "9a81",
    "ì‰§",
    4,
    "ì‰®ì‰¯ì‰±ì‰²ì‰³ì‰µ",
    6,
    "ì‰¾ìŠ€ìŠ‚",
    5,
    "ìŠŠ",
    5,
    "ìŠ‘",
    6,
    "ìŠ™ìŠšìŠœìŠž",
    5,
    "ìŠ¦ìŠ§ìŠ©ìŠªìŠ«ìŠ®",
    5,
    "ìŠ¶ìŠ¸ìŠº",
    33,
    "ì‹žì‹Ÿì‹¡ì‹¢ì‹¥",
    5,
    "ì‹®ì‹°ì‹²ì‹³ì‹´ì‹µì‹·ì‹ºì‹½ì‹¾ì‹¿ìŒ",
    6,
    "ìŒŠìŒ‹ìŒŽìŒ"
  ],
  [
    "9b41",
    "ìŒìŒ‘ìŒ’ìŒ–ìŒ—ìŒ™ìŒšìŒ›ìŒ",
    6,
    "ìŒ¦ìŒ§ìŒª",
    8
  ],
  [
    "9b61",
    "ìŒ³",
    17,
    "ì†",
    7
  ],
  [
    "9b81",
    "ìŽ",
    25,
    "ìªì«ì­ì®ì¯ì±ì³",
    4,
    "ìºì»ì¾",
    5,
    "ìŽ…ìŽ†ìŽ‡ìŽ‰ìŽŠìŽ‹ìŽ",
    50,
    "ì",
    22,
    "ìš"
  ],
  [
    "9c41",
    "ì›ììžì¡ì£",
    4,
    "ìªì«ì¬ì®",
    5,
    "ì¶ì·ì¹",
    5
  ],
  [
    "9c61",
    "ì¿",
    8,
    "ì‰",
    6,
    "ì‘",
    9
  ],
  [
    "9c81",
    "ì›",
    8,
    "ì¥",
    6,
    "ì­ì®ì¯ì±ì²ì³ìµ",
    6,
    "ì¾",
    9,
    "ì‘‰",
    26,
    "ì‘¦ì‘§ì‘©ì‘ªì‘«ì‘­",
    6,
    "ì‘¶ì‘·ì‘¸ì‘º",
    5,
    "ì’",
    18,
    "ì’•",
    6,
    "ì’",
    12
  ],
  [
    "9d41",
    "ì’ª",
    13,
    "ì’¹ì’ºì’»ì’½",
    8
  ],
  [
    "9d61",
    "ì“†",
    25
  ],
  [
    "9d81",
    "ì“ ",
    8,
    "ì“ª",
    5,
    "ì“²ì“³ì“µì“¶ì“·ì“¹ì“»ì“¼ì“½ì“¾ì”‚",
    9,
    "ì”ì”Žì”ì”‘ì”’ì”“ì”•",
    6,
    "ì”",
    10,
    "ì”ªì”«ì”­ì”®ì”¯ì”±",
    6,
    "ì”ºì”¼ì”¾",
    5,
    "ì•†ì•‡ì•‹ì•ì•ì•‘ì•’ì•–ì•šì•›ì•œì•Ÿì•¢ì•£ì•¥ì•¦ì•§ì•©",
    6,
    "ì•²ì•¶",
    5,
    "ì•¾ì•¿ì–ì–‚ì–ƒì–…ì–†ì–ˆì–‰ì–Šì–‹ì–Žì–ì–’ì–“ì–”"
  ],
  [
    "9e41",
    "ì––ì–™ì–šì–›ì–ì–žì–Ÿì–¡",
    7,
    "ì–ª",
    9,
    "ì–¶"
  ],
  [
    "9e61",
    "ì–·ì–ºì–¿",
    4,
    "ì—‹ì—ì—ì—’ì—“ì—•ì—–ì——ì—™",
    6,
    "ì—¢ì—¤ì—¦ì—§"
  ],
  [
    "9e81",
    "ì—¨ì—©ì—ªì—«ì—¯ì—±ì—²ì—³ì—µì—¸ì—¹ì—ºì—»ì˜‚ì˜ƒì˜„ì˜‰ì˜Šì˜‹ì˜ì˜Žì˜ì˜‘",
    6,
    "ì˜šì˜",
    6,
    "ì˜¦ì˜§ì˜©ì˜ªì˜«ì˜¯ì˜±ì˜²ì˜¶ì˜¸ì˜ºì˜¼ì˜½ì˜¾ì˜¿ì™‚ì™ƒì™…ì™†ì™‡ì™‰",
    6,
    "ì™’ì™–",
    5,
    "ì™žì™Ÿì™¡",
    10,
    "ì™­ì™®ì™°ì™²",
    5,
    "ì™ºì™»ì™½ì™¾ì™¿ìš",
    6,
    "ìšŠìšŒìšŽ",
    5,
    "ìš–ìš—ìš™ìššìš›ìš",
    6,
    "ìš¦"
  ],
  [
    "9f41",
    "ìš¨ìšª",
    5,
    "ìš²ìš³ìšµìš¶ìš·ìš»",
    4,
    "ì›‚ì›„ì›†",
    5,
    "ì›Ž"
  ],
  [
    "9f61",
    "ì›ì›‘ì›’ì›“ì›•",
    6,
    "ì›žì›Ÿì›¢",
    5,
    "ì›ªì›«ì›­ì›®ì›¯ì›±ì›²"
  ],
  [
    "9f81",
    "ì›³",
    4,
    "ì›ºì›»ì›¼ì›¾",
    5,
    "ìœ†ìœ‡ìœ‰ìœŠìœ‹ìœ",
    6,
    "ìœ–ìœ˜ìœš",
    5,
    "ìœ¢ìœ£ìœ¥ìœ¦ìœ§ìœ©",
    6,
    "ìœ²ìœ´ìœ¶ìœ¸ìœ¹ìœºìœ»ìœ¾ìœ¿ìì‚ìƒì…",
    4,
    "ì‹ìŽìì™ìšì›ììžìŸì¡",
    6,
    "ì©ìªì¬",
    7,
    "ì¶ì·ì¹ìºì»ì¿ìž€ìžìž‚ìž†ìž‹ìžŒìžìžìž’ìž“ìž•ìž™ìž›",
    4,
    "ìž¢ìž§",
    4,
    "ìž®ìž¯ìž±ìž²ìž³ìžµìž¶ìž·"
  ],
  [
    "a041",
    "ìž¸ìž¹ìžºìž»ìž¾ìŸ‚",
    5,
    "ìŸŠìŸ‹ìŸìŸìŸ‘",
    6,
    "ìŸ™ìŸšìŸ›ìŸœ"
  ],
  [
    "a061",
    "ìŸž",
    5,
    "ìŸ¥ìŸ¦ìŸ§ìŸ©ìŸªìŸ«ìŸ­",
    13
  ],
  [
    "a081",
    "ìŸ»",
    4,
    "ì ‚ì ƒì …ì †ì ‡ì ‰ì ‹",
    4,
    "ì ’ì ”ì —",
    4,
    "ì žì Ÿì ¡ì ¢ì £ì ¥",
    6,
    "ì ®ì °ì ²",
    5,
    "ì ¹ì ºì »ì ½ì ¾ì ¿ì¡",
    6,
    "ì¡Šì¡‹ì¡Ž",
    5,
    "ì¡•",
    26,
    "ì¡²ì¡³ì¡µì¡¶ì¡·ì¡¹ì¡»",
    4,
    "ì¢‚ì¢„ì¢ˆì¢‰ì¢Šì¢Ž",
    5,
    "ì¢•",
    7,
    "ì¢žì¢ ì¢¢ì¢£ì¢¤"
  ],
  [
    "a141",
    "ì¢¥ì¢¦ì¢§ì¢©",
    18,
    "ì¢¾ì¢¿ì£€ì£"
  ],
  [
    "a161",
    "ì£‚ì£ƒì£…ì£†ì£‡ì£‰ì£Šì£‹ì£",
    6,
    "ì£–ì£˜ì£š",
    5,
    "ì£¢ì££ì£¥"
  ],
  [
    "a181",
    "ì£¦",
    14,
    "ì£¶",
    5,
    "ì£¾ì£¿ì¤ì¤‚ì¤ƒì¤‡",
    4,
    "ì¤Žã€€ã€ã€‚Â·â€¥â€¦Â¨ã€ƒÂ­â€•âˆ¥ï¼¼âˆ¼â€˜â€™â€œâ€ã€”ã€•ã€ˆ",
    9,
    "Â±Ã—Ã·â‰ â‰¤â‰¥âˆžâˆ´Â°â€²â€³â„ƒâ„«ï¿ ï¿¡ï¿¥â™‚â™€âˆ âŠ¥âŒ’âˆ‚âˆ‡â‰¡â‰’Â§â€»â˜†â˜…â—‹â—â—Žâ—‡â—†â–¡â– â–³â–²â–½â–¼â†’â†â†‘â†“â†”ã€“â‰ªâ‰«âˆšâˆ½âˆâˆµâˆ«âˆ¬âˆˆâˆ‹âŠ†âŠ‡âŠ‚âŠƒâˆªâˆ©âˆ§âˆ¨ï¿¢"
  ],
  [
    "a241",
    "ì¤ì¤’",
    5,
    "ì¤™",
    18
  ],
  [
    "a261",
    "ì¤­",
    6,
    "ì¤µ",
    18
  ],
  [
    "a281",
    "ì¥ˆ",
    7,
    "ì¥’ì¥“ì¥•ì¥–ì¥—ì¥™",
    6,
    "ì¥¢ì¥¤",
    7,
    "ì¥­ì¥®ì¥¯â‡’â‡”âˆ€âˆƒÂ´ï½žË‡Ë˜ËËšË™Â¸Ë›Â¡Â¿Ëâˆ®âˆ‘âˆÂ¤â„‰â€°â—â—€â–·â–¶â™¤â™ â™¡â™¥â™§â™£âŠ™â—ˆâ–£â—â—‘â–’â–¤â–¥â–¨â–§â–¦â–©â™¨â˜â˜Žâ˜œâ˜žÂ¶â€ â€¡â†•â†—â†™â†–â†˜â™­â™©â™ªâ™¬ã‰¿ãˆœâ„–ã‡â„¢ã‚ã˜â„¡â‚¬Â®"
  ],
  [
    "a341",
    "ì¥±ì¥²ì¥³ì¥µ",
    6,
    "ì¥½",
    10,
    "ì¦Šì¦‹ì¦ì¦Žì¦"
  ],
  [
    "a361",
    "ì¦‘",
    6,
    "ì¦šì¦œì¦ž",
    16
  ],
  [
    "a381",
    "ì¦¯",
    16,
    "ì§‚ì§ƒì§…ì§†ì§‰ì§‹",
    4,
    "ì§’ì§”ì§—ì§˜ì§›ï¼",
    58,
    "ï¿¦ï¼½",
    32,
    "ï¿£"
  ],
  [
    "a441",
    "ì§žì§Ÿì§¡ì§£ì§¥ì§¦ì§¨ì§©ì§ªì§«ì§®ì§²",
    5,
    "ì§ºì§»ì§½ì§¾ì§¿ì¨ì¨‚ì¨ƒì¨„"
  ],
  [
    "a461",
    "ì¨…ì¨†ì¨‡ì¨Šì¨Ž",
    5,
    "ì¨•ì¨–ì¨—ì¨™",
    12
  ],
  [
    "a481",
    "ì¨¦ì¨§ì¨¨ì¨ª",
    28,
    "ã„±",
    93
  ],
  [
    "a541",
    "ì©‡",
    4,
    "ì©Žì©ì©‘ì©’ì©“ì©•",
    6,
    "ì©žì©¢",
    5,
    "ì©©ì©ª"
  ],
  [
    "a561",
    "ì©«",
    17,
    "ì©¾",
    5,
    "ìª…ìª†"
  ],
  [
    "a581",
    "ìª‡",
    16,
    "ìª™",
    14,
    "â…°",
    9
  ],
  [
    "a5b0",
    "â… ",
    9
  ],
  [
    "a5c1",
    "Î‘",
    16,
    "Î£",
    6
  ],
  [
    "a5e1",
    "Î±",
    16,
    "Ïƒ",
    6
  ],
  [
    "a641",
    "ìª¨",
    19,
    "ìª¾ìª¿ì«ì«‚ì«ƒì«…"
  ],
  [
    "a661",
    "ì«†",
    5,
    "ì«Žì«ì«’ì«”ì«•ì«–ì«—ì«š",
    5,
    "ì«¡",
    6
  ],
  [
    "a681",
    "ì«¨ì«©ì«ªì««ì«­",
    6,
    "ì«µ",
    18,
    "ì¬‰ì¬Šâ”€â”‚â”Œâ”â”˜â””â”œâ”¬â”¤â”´â”¼â”â”ƒâ”â”“â”›â”—â”£â”³â”«â”»â•‹â” â”¯â”¨â”·â”¿â”â”°â”¥â”¸â•‚â”’â”‘â”šâ”™â”–â”•â”Žâ”â”žâ”Ÿâ”¡â”¢â”¦â”§â”©â”ªâ”­â”®â”±â”²â”µâ”¶â”¹â”ºâ”½â”¾â•€â•â•ƒ",
    7
  ],
  [
    "a741",
    "ì¬‹",
    4,
    "ì¬‘ì¬’ì¬“ì¬•ì¬–ì¬—ì¬™",
    6,
    "ì¬¢",
    7
  ],
  [
    "a761",
    "ì¬ª",
    22,
    "ì­‚ì­ƒì­„"
  ],
  [
    "a781",
    "ì­…ì­†ì­‡ì­Šì­‹ì­ì­Žì­ì­‘",
    6,
    "ì­šì­›ì­œì­ž",
    5,
    "ì­¥",
    7,
    "ãŽ•ãŽ–ãŽ—â„“ãŽ˜ã„ãŽ£ãŽ¤ãŽ¥ãŽ¦ãŽ™",
    9,
    "ãŠãŽãŽŽãŽããŽˆãŽ‰ãˆãŽ§ãŽ¨ãŽ°",
    9,
    "ãŽ€",
    4,
    "ãŽº",
    5,
    "ãŽ",
    4,
    "â„¦ã€ããŽŠãŽ‹ãŽŒã–ã…ãŽ­ãŽ®ãŽ¯ã›ãŽ©ãŽªãŽ«ãŽ¬ããã“ãƒã‰ãœã†"
  ],
  [
    "a841",
    "ì­­",
    10,
    "ì­º",
    14
  ],
  [
    "a861",
    "ì®‰",
    18,
    "ì®",
    6
  ],
  [
    "a881",
    "ì®¤",
    19,
    "ì®¹",
    11,
    "Ã†ÃÂªÄ¦"
  ],
  [
    "a8a6",
    "Ä²"
  ],
  [
    "a8a8",
    "Ä¿ÅÃ˜Å’ÂºÃžÅ¦ÅŠ"
  ],
  [
    "a8b1",
    "ã‰ ",
    27,
    "â“",
    25,
    "â‘ ",
    14,
    "Â½â…“â…”Â¼Â¾â…›â…œâ…â…ž"
  ],
  [
    "a941",
    "ì¯…",
    14,
    "ì¯•",
    10
  ],
  [
    "a961",
    "ì¯ ì¯¡ì¯¢ì¯£ì¯¥ì¯¦ì¯¨ì¯ª",
    18
  ],
  [
    "a981",
    "ì¯½",
    14,
    "ì°Žì°ì°‘ì°’ì°“ì°•",
    6,
    "ì°žì°Ÿì° ì°£ì°¤Ã¦Ä‘Ã°Ä§Ä±Ä³Ä¸Å€Å‚Ã¸Å“ÃŸÃ¾Å§Å‹Å‰ãˆ€",
    27,
    "â’œ",
    25,
    "â‘´",
    14,
    "Â¹Â²Â³â´â¿â‚â‚‚â‚ƒâ‚„"
  ],
  [
    "aa41",
    "ì°¥ì°¦ì°ªì°«ì°­ì°¯ì°±",
    6,
    "ì°ºì°¿",
    4,
    "ì±†ì±‡ì±‰ì±Šì±‹ì±ì±Ž"
  ],
  [
    "aa61",
    "ì±",
    4,
    "ì±–ì±š",
    5,
    "ì±¡ì±¢ì±£ì±¥ì±§ì±©",
    6,
    "ì±±ì±²"
  ],
  [
    "aa81",
    "ì±³ì±´ì±¶",
    29,
    "ã",
    82
  ],
  [
    "ab41",
    "ì²”ì²•ì²–ì²—ì²šì²›ì²ì²žì²Ÿì²¡",
    6,
    "ì²ªì²®",
    5,
    "ì²¶ì²·ì²¹"
  ],
  [
    "ab61",
    "ì²ºì²»ì²½",
    6,
    "ì³†ì³ˆì³Š",
    5,
    "ì³‘ì³’ì³“ì³•",
    5
  ],
  [
    "ab81",
    "ì³›",
    8,
    "ì³¥",
    6,
    "ì³­ì³®ì³¯ì³±",
    12,
    "ã‚¡",
    85
  ],
  [
    "ac41",
    "ì³¾ì³¿ì´€ì´‚",
    5,
    "ì´Šì´‹ì´ì´Žì´ì´‘",
    6,
    "ì´šì´œì´žì´Ÿì´ "
  ],
  [
    "ac61",
    "ì´¡ì´¢ì´£ì´¥ì´¦ì´§ì´©ì´ªì´«ì´­",
    11,
    "ì´º",
    4
  ],
  [
    "ac81",
    "ì´¿",
    28,
    "ìµìµžìµŸÐ",
    5,
    "ÐÐ–",
    25
  ],
  [
    "acd1",
    "Ð°",
    5,
    "Ñ‘Ð¶",
    25
  ],
  [
    "ad41",
    "ìµ¡ìµ¢ìµ£ìµ¥",
    6,
    "ìµ®ìµ°ìµ²",
    5,
    "ìµ¹",
    7
  ],
  [
    "ad61",
    "ì¶",
    6,
    "ì¶‰",
    10,
    "ì¶–ì¶—ì¶™ì¶šì¶›ì¶ì¶žì¶Ÿ"
  ],
  [
    "ad81",
    "ì¶ ì¶¡ì¶¢ì¶£ì¶¦ì¶¨ì¶ª",
    5,
    "ì¶±",
    18,
    "ì·…"
  ],
  [
    "ae41",
    "ì·†",
    5,
    "ì·ì·Žì·ì·‘",
    16
  ],
  [
    "ae61",
    "ì·¢",
    5,
    "ì·©ì·ªì·«ì·­ì·®ì·¯ì·±",
    6,
    "ì·ºì·¼ì·¾",
    4
  ],
  [
    "ae81",
    "ì¸ƒì¸…ì¸†ì¸‡ì¸‰ì¸Šì¸‹ì¸",
    6,
    "ì¸•ì¸–ì¸—ì¸˜ì¸š",
    5,
    "ì¸¢ì¸£ì¸¥ì¸¦ì¸§ì¸©ì¸ªì¸«"
  ],
  [
    "af41",
    "ì¸¬ì¸­ì¸®ì¸¯ì¸²ì¸´ì¸¶",
    19
  ],
  [
    "af61",
    "ì¹Š",
    13,
    "ì¹šì¹›ì¹ì¹žì¹¢",
    5,
    "ì¹ªì¹¬"
  ],
  [
    "af81",
    "ì¹®",
    5,
    "ì¹¶ì¹·ì¹¹ì¹ºì¹»ì¹½",
    6,
    "ìº†ìºˆìºŠ",
    5,
    "ìº’ìº“ìº•ìº–ìº—ìº™"
  ],
  [
    "b041",
    "ìºš",
    5,
    "ìº¢ìº¦",
    5,
    "ìº®",
    12
  ],
  [
    "b061",
    "ìº»",
    5,
    "ì»‚",
    19
  ],
  [
    "b081",
    "ì»–",
    13,
    "ì»¦ì»§ì»©ì»ªì»­",
    6,
    "ì»¶ì»º",
    5,
    "ê°€ê°ê°„ê°‡ê°ˆê°‰ê°Šê°",
    7,
    "ê°™",
    4,
    "ê° ê°¤ê°¬ê°­ê°¯ê°°ê°±ê°¸ê°¹ê°¼ê±€ê±‹ê±ê±”ê±˜ê±œê±°ê±±ê±´ê±·ê±¸ê±ºê²€ê²ê²ƒê²„ê²…ê²†ê²‰ê²Šê²‹ê²Œê²ê²”ê²œê²ê²Ÿê² ê²¡ê²¨ê²©ê²ªê²¬ê²¯ê²°ê²¸ê²¹ê²»ê²¼ê²½ê³ê³„ê³ˆê³Œê³•ê³—ê³ ê³¡ê³¤ê³§ê³¨ê³ªê³¬ê³¯ê³°ê³±ê³³ê³µê³¶ê³¼ê³½ê´€ê´„ê´†"
  ],
  [
    "b141",
    "ì¼‚ì¼ƒì¼…ì¼†ì¼‡ì¼‰",
    6,
    "ì¼’ì¼”ì¼–",
    5,
    "ì¼ì¼žì¼Ÿì¼¡ì¼¢ì¼£"
  ],
  [
    "b161",
    "ì¼¥",
    6,
    "ì¼®ì¼²",
    5,
    "ì¼¹",
    11
  ],
  [
    "b181",
    "ì½…",
    14,
    "ì½–ì½—ì½™ì½šì½›ì½",
    6,
    "ì½¦ì½¨ì½ªì½«ì½¬ê´Œê´ê´ê´‘ê´˜ê´œê´ ê´©ê´¬ê´­ê´´ê´µê´¸ê´¼êµ„êµ…êµ‡êµ‰êµêµ”êµ˜êµ¡êµ£êµ¬êµ­êµ°êµ³êµ´êµµêµ¶êµ»êµ¼êµ½êµ¿ê¶ê¶‚ê¶ˆê¶‰ê¶Œê¶ê¶œê¶ê¶¤ê¶·ê·€ê·ê·„ê·ˆê·ê·‘ê·“ê·œê· ê·¤ê·¸ê·¹ê·¼ê·¿ê¸€ê¸ê¸ˆê¸‰ê¸‹ê¸ê¸”ê¸°ê¸±ê¸´ê¸·ê¸¸ê¸ºê¹€ê¹ê¹ƒê¹…ê¹†ê¹Šê¹Œê¹ê¹Žê¹ê¹”ê¹–ê¹œê¹ê¹Ÿê¹ ê¹¡ê¹¥ê¹¨ê¹©ê¹¬ê¹°ê¹¸"
  ],
  [
    "b241",
    "ì½­ì½®ì½¯ì½²ì½³ì½µì½¶ì½·ì½¹",
    6,
    "ì¾ì¾‚ì¾ƒì¾„ì¾†",
    5,
    "ì¾"
  ],
  [
    "b261",
    "ì¾Ž",
    18,
    "ì¾¢",
    5,
    "ì¾©"
  ],
  [
    "b281",
    "ì¾ª",
    5,
    "ì¾±",
    18,
    "ì¿…",
    6,
    "ê¹¹ê¹»ê¹¼ê¹½êº„êº…êºŒêº¼êº½êº¾ê»€ê»„ê»Œê»ê»ê»ê»‘ê»˜ê»™ê»œê»¨ê»«ê»­ê»´ê»¸ê»¼ê¼‡ê¼ˆê¼ê¼ê¼¬ê¼­ê¼°ê¼²ê¼´ê¼¼ê¼½ê¼¿ê½ê½‚ê½ƒê½ˆê½‰ê½ê½œê½ê½¤ê½¥ê½¹ê¾€ê¾„ê¾ˆê¾ê¾‘ê¾•ê¾œê¾¸ê¾¹ê¾¼ê¿€ê¿‡ê¿ˆê¿‰ê¿‹ê¿ê¿Žê¿”ê¿œê¿¨ê¿©ê¿°ê¿±ê¿´ê¿¸ë€€ë€ë€„ë€Œë€ë€”ë€œë€ë€¨ë„ë…ëˆëŠëŒëŽë“ë”ë•ë—ë™"
  ],
  [
    "b341",
    "ì¿Œ",
    19,
    "ì¿¢ì¿£ì¿¥ì¿¦ì¿§ì¿©"
  ],
  [
    "b361",
    "ì¿ª",
    5,
    "ì¿²ì¿´ì¿¶",
    5,
    "ì¿½ì¿¾ì¿¿í€í€‚í€ƒí€…",
    5
  ],
  [
    "b381",
    "í€‹",
    5,
    "í€’",
    5,
    "í€™",
    19,
    "ëë¼ë½ë‚€ë‚„ë‚Œë‚ë‚ë‚‘ë‚˜ë‚™ë‚šë‚œë‚Ÿë‚ ë‚¡ë‚¢ë‚¨ë‚©ë‚«",
    4,
    "ë‚±ë‚³ë‚´ë‚µë‚¸ë‚¼ëƒ„ëƒ…ëƒ‡ëƒˆëƒ‰ëƒëƒ‘ëƒ”ëƒ˜ëƒ ëƒ¥ë„ˆë„‰ë„‹ë„Œë„ë„’ë„“ë„˜ë„™ë„›ë„œë„ë„£ë„¤ë„¥ë„¨ë„¬ë„´ë„µë„·ë„¸ë„¹ë…€ë…ë…„ë…ˆë…ë…‘ë…”ë…•ë…˜ë…œë… ë…¸ë…¹ë…¼ë†€ë†‚ë†ˆë†‰ë†‹ë†ë†’ë†“ë†”ë†˜ë†œë†¨ë‡Œë‡ë‡”ë‡œë‡"
  ],
  [
    "b441",
    "í€®",
    5,
    "í€¶í€·í€¹í€ºí€»í€½",
    6,
    "í†íˆíŠ",
    5
  ],
  [
    "b461",
    "í‘í’í“í•í–í—í™",
    6,
    "í¡",
    10,
    "í®í¯"
  ],
  [
    "b481",
    "í±í²í³íµ",
    6,
    "í¾í¿í‚€í‚‚",
    18,
    "ë‡Ÿë‡¨ë‡©ë‡¬ë‡°ë‡¹ë‡»ë‡½ëˆ„ëˆ…ëˆˆëˆ‹ëˆŒëˆ”ëˆ•ëˆ—ëˆ™ëˆ ëˆ´ëˆ¼ë‰˜ë‰œë‰ ë‰¨ë‰©ë‰´ë‰µë‰¼ëŠ„ëŠ…ëŠ‰ëŠëŠ‘ëŠ”ëŠ˜ëŠ™ëŠšëŠ ëŠ¡ëŠ£ëŠ¥ëŠ¦ëŠªëŠ¬ëŠ°ëŠ´ë‹ˆë‹‰ë‹Œë‹ë‹’ë‹˜ë‹™ë‹›ë‹ë‹¢ë‹¤ë‹¥ë‹¦ë‹¨ë‹«",
    4,
    "ë‹³ë‹´ë‹µë‹·",
    4,
    "ë‹¿ëŒ€ëŒëŒ„ëŒˆëŒëŒ‘ëŒ“ëŒ”ëŒ•ëŒœë”ë•ë–ë˜ë›ëœëžëŸë¤ë¥"
  ],
  [
    "b541",
    "í‚•",
    14,
    "í‚¦í‚§í‚©í‚ªí‚«í‚­",
    5
  ],
  [
    "b561",
    "í‚³í‚¶í‚¸í‚º",
    5,
    "íƒ‚íƒƒíƒ…íƒ†íƒ‡íƒŠ",
    5,
    "íƒ’íƒ–",
    4
  ],
  [
    "b581",
    "íƒ›íƒžíƒŸíƒ¡íƒ¢íƒ£íƒ¥",
    6,
    "íƒ®íƒ²",
    5,
    "íƒ¹",
    11,
    "ë§ë©ë«ë®ë°ë±ë´ë¸ëŽ€ëŽëŽƒëŽ„ëŽ…ëŽŒëŽëŽ”ëŽ ëŽ¡ëŽ¨ëŽ¬ë„ë…ëˆë‹ëŒëŽëë”ë•ë—ë™ë›ëë ë¤ë¨ë¼ëë˜ëœë ë¨ë©ë«ë´ë‘ë‘‘ë‘”ë‘˜ë‘ ë‘¡ë‘£ë‘¥ë‘¬ë’€ë’ˆë’ë’¤ë’¨ë’¬ë’µë’·ë’¹ë“€ë“„ë“ˆë“ë“•ë“œë“ë“ ë“£ë“¤ë“¦ë“¬ë“­ë“¯ë“±ë“¸ë””ë”•ë”˜ë”›ë”œë”¤ë”¥ë”§ë”¨ë”©ë”ªë”°ë”±ë”´ë”¸"
  ],
  [
    "b641",
    "í„…",
    7,
    "í„Ž",
    17
  ],
  [
    "b661",
    "í„ ",
    15,
    "í„²í„³í„µí„¶í„·í„¹í„»í„¼í„½í„¾"
  ],
  [
    "b681",
    "í„¿í…‚í…†",
    5,
    "í…Ží…í…‘í…’í…“í…•",
    6,
    "í…ží… í…¢",
    5,
    "í…©í…ªí…«í…­ë•€ë•ë•ƒë•„ë•…ë•‹ë•Œë•ë•ë•”ë•œë•ë•Ÿë• ë•¡ë– ë–¡ë–¤ë–¨ë–ªë–«ë–°ë–±ë–³ë–´ë–µë–»ë–¼ë–½ë—€ë—„ë—Œë—ë—ë—ë—‘ë—˜ë—¬ë˜ë˜‘ë˜”ë˜˜ë˜¥ë˜¬ë˜´ë™ˆë™¤ë™¨ëšœëšëš ëš¤ëš«ëš¬ëš±ë›”ë›°ë›´ë›¸ëœ€ëœëœ…ëœ¨ëœ©ëœ¬ëœ¯ëœ°ëœ¸ëœ¹ëœ»ë„ëˆëŒë”ë•ë ë¤ë¨ë°ë±ë³ëµë¼ë½ëž€ëž„ëžŒëžëžëžëž‘ëž’ëž–ëž—"
  ],
  [
    "b741",
    "í…®",
    13,
    "í…½",
    6,
    "í†…í††í†‡í†‰í†Š"
  ],
  [
    "b761",
    "í†‹",
    20,
    "í†¢í†£í†¥í†¦í†§"
  ],
  [
    "b781",
    "í†©",
    6,
    "í†²í†´í†¶í†·í†¸í†¹í†»í†½í†¾í†¿í‡",
    14,
    "ëž˜ëž™ëžœëž ëž¨ëž©ëž«ëž¬ëž­ëž´ëžµëž¸ëŸ‡ëŸ‰ëŸ¬ëŸ­ëŸ°ëŸ´ëŸ¼ëŸ½ëŸ¿ë €ë ë ‡ë ˆë ‰ë Œë ë ˜ë ™ë ›ë ë ¤ë ¥ë ¨ë ¬ë ´ë µë ·ë ¸ë ¹ë¡€ë¡„ë¡‘ë¡“ë¡œë¡ë¡ ë¡¤ë¡¬ë¡­ë¡¯ë¡±ë¡¸ë¡¼ë¢ë¢¨ë¢°ë¢´ë¢¸ë£€ë£ë£ƒë£…ë£Œë£ë£”ë£ë£Ÿë£¡ë£¨ë£©ë£¬ë£°ë£¸ë£¹ë£»ë£½ë¤„ë¤˜ë¤ ë¤¼ë¤½ë¥€ë¥„ë¥Œë¥ë¥‘ë¥˜ë¥™ë¥œë¥ ë¥¨ë¥©"
  ],
  [
    "b841",
    "í‡",
    7,
    "í‡™",
    17
  ],
  [
    "b861",
    "í‡«",
    8,
    "í‡µí‡¶í‡·í‡¹",
    13
  ],
  [
    "b881",
    "íˆˆíˆŠ",
    5,
    "íˆ‘",
    24,
    "ë¥«ë¥­ë¥´ë¥µë¥¸ë¥¼ë¦„ë¦…ë¦‡ë¦‰ë¦Šë¦ë¦Žë¦¬ë¦­ë¦°ë¦´ë¦¼ë¦½ë¦¿ë§ë§ˆë§‰ë§Œë§Ž",
    4,
    "ë§˜ë§™ë§›ë§ë§žë§¡ë§£ë§¤ë§¥ë§¨ë§¬ë§´ë§µë§·ë§¸ë§¹ë§ºë¨€ë¨ë¨ˆë¨•ë¨¸ë¨¹ë¨¼ë©€ë©‚ë©ˆë©‰ë©‹ë©ë©Žë©“ë©”ë©•ë©˜ë©œë©¤ë©¥ë©§ë©¨ë©©ë©°ë©±ë©´ë©¸ëªƒëª„ëª…ëª‡ëªŒëª¨ëª©ëª«ëª¬ëª°ëª²ëª¸ëª¹ëª»ëª½ë«„ë«ˆë«˜ë«™ë«¼"
  ],
  [
    "b941",
    "íˆªíˆ«íˆ®íˆ¯íˆ±íˆ²íˆ³íˆµ",
    6,
    "íˆ¾í‰€í‰‚",
    5,
    "í‰‰í‰Ší‰‹í‰Œ"
  ],
  [
    "b961",
    "í‰",
    14,
    "í‰",
    6,
    "í‰¥í‰¦í‰§í‰¨"
  ],
  [
    "b981",
    "í‰©",
    22,
    "íŠ‚íŠƒíŠ…íŠ†íŠ‡íŠ‰íŠŠíŠ‹íŠŒë¬€ë¬„ë¬ë¬ë¬‘ë¬˜ë¬œë¬ ë¬©ë¬«ë¬´ë¬µë¬¶ë¬¸ë¬»ë¬¼ë¬½ë¬¾ë­„ë­…ë­‡ë­‰ë­ë­ë­ë­”ë­˜ë­¡ë­£ë­¬ë®ˆë®Œë®ë®¤ë®¨ë®¬ë®´ë®·ë¯€ë¯„ë¯ˆë¯ë¯“ë¯¸ë¯¹ë¯¼ë¯¿ë°€ë°‚ë°ˆë°‰ë°‹ë°Œë°ë°ë°‘ë°”",
    4,
    "ë°›",
    4,
    "ë°¤ë°¥ë°§ë°©ë°­ë°°ë°±ë°´ë°¸ë±€ë±ë±ƒë±„ë±…ë±‰ë±Œë±ë±ë±ë²„ë²…ë²ˆë²‹ë²Œë²Žë²”ë²•ë²—"
  ],
  [
    "ba41",
    "íŠíŠŽíŠíŠ’íŠ“íŠ”íŠ–",
    5,
    "íŠíŠžíŠŸíŠ¡íŠ¢íŠ£íŠ¥",
    6,
    "íŠ­"
  ],
  [
    "ba61",
    "íŠ®íŠ¯íŠ°íŠ²",
    5,
    "íŠºíŠ»íŠ½íŠ¾í‹í‹ƒ",
    4,
    "í‹Ší‹Œ",
    5
  ],
  [
    "ba81",
    "í‹’í‹“í‹•í‹–í‹—í‹™í‹ší‹›í‹",
    6,
    "í‹¦",
    9,
    "í‹²í‹³í‹µí‹¶í‹·í‹¹í‹ºë²™ë²šë² ë²¡ë²¤ë²§ë²¨ë²°ë²±ë²³ë²´ë²µë²¼ë²½ë³€ë³„ë³ë³ë³ë³‘ë³•ë³˜ë³œë³´ë³µë³¶ë³¸ë³¼ë´„ë´…ë´‡ë´‰ë´ë´”ë´¤ë´¬ëµ€ëµˆëµ‰ëµŒëµëµ˜ëµ™ëµ¤ëµ¨ë¶€ë¶ë¶„ë¶‡ë¶ˆë¶‰ë¶Šë¶ë¶‘ë¶“ë¶•ë¶™ë¶šë¶œë¶¤ë¶°ë¶¸ë·”ë·•ë·˜ë·œë·©ë·°ë·´ë·¸ë¸€ë¸ƒë¸…ë¸Œë¸ë¸ë¸”ë¸œë¸ë¸Ÿë¹„ë¹…ë¹ˆë¹Œë¹Žë¹”ë¹•ë¹—ë¹™ë¹šë¹›ë¹ ë¹¡ë¹¤"
  ],
  [
    "bb41",
    "í‹»",
    4,
    "íŒ‚íŒ„íŒ†",
    5,
    "íŒíŒ‘íŒ’íŒ“íŒ•íŒ—",
    4,
    "íŒžíŒ¢íŒ£"
  ],
  [
    "bb61",
    "íŒ¤íŒ¦íŒ§íŒªíŒ«íŒ­íŒ®íŒ¯íŒ±",
    6,
    "íŒºíŒ¾",
    5,
    "í†í‡íˆí‰"
  ],
  [
    "bb81",
    "íŠ",
    31,
    "ë¹¨ë¹ªë¹°ë¹±ë¹³ë¹´ë¹µë¹»ë¹¼ë¹½ëº€ëº„ëºŒëºëºëºëº‘ëº˜ëº™ëº¨ë»ë»‘ë»”ë»—ë»˜ë» ë»£ë»¤ë»¥ë»¬ë¼ë¼ˆë¼‰ë¼˜ë¼™ë¼›ë¼œë¼ë½€ë½ë½„ë½ˆë½ë½‘ë½•ë¾”ë¾°ë¿…ë¿Œë¿ë¿ë¿”ë¿œë¿Ÿë¿¡ì€¼ì‘ì˜ìœì ì¨ì©ì‚ì‚‘ì‚”ì‚˜ì‚ ì‚¡ì‚£ì‚¥ì‚¬ì‚­ì‚¯ì‚°ì‚³ì‚´ì‚µì‚¶ì‚¼ì‚½ì‚¿ìƒ€ìƒìƒ…ìƒˆìƒ‰ìƒŒìƒìƒ˜ìƒ™ìƒ›ìƒœìƒìƒ¤"
  ],
  [
    "bc41",
    "íª",
    17,
    "í¾í¿íŽíŽ‚íŽƒíŽ…íŽ†íŽ‡"
  ],
  [
    "bc61",
    "íŽˆíŽ‰íŽŠíŽ‹íŽŽíŽ’",
    5,
    "íŽšíŽ›íŽíŽžíŽŸíŽ¡",
    6,
    "íŽªíŽ¬íŽ®"
  ],
  [
    "bc81",
    "íŽ¯",
    4,
    "íŽµíŽ¶íŽ·íŽ¹íŽºíŽ»íŽ½",
    6,
    "í†í‡íŠ",
    5,
    "í‘",
    5,
    "ìƒ¥ìƒ¨ìƒ¬ìƒ´ìƒµìƒ·ìƒ¹ì„€ì„„ì„ˆì„ì„•ì„œ",
    4,
    "ì„£ì„¤ì„¦ì„§ì„¬ì„­ì„¯ì„°ì„±ì„¶ì„¸ì„¹ì„¼ì…€ì…ˆì…‰ì…‹ì…Œì…ì…”ì…•ì…˜ì…œì…¤ì…¥ì…§ì…¨ì…©ì…°ì…´ì…¸ì†…ì†Œì†ì†Žì†ì†”ì†–ì†œì†ì†Ÿì†¡ì†¥ì†¨ì†©ì†¬ì†°ì†½ì‡„ì‡ˆì‡Œì‡”ì‡—ì‡˜ì‡ ì‡¤ì‡¨ì‡°ì‡±ì‡³ì‡¼ì‡½ìˆ€ìˆ„ìˆŒìˆìˆìˆ‘ìˆ˜ìˆ™ìˆœìˆŸìˆ ìˆ¨ìˆ©ìˆ«ìˆ­"
  ],
  [
    "bd41",
    "í—í™",
    7,
    "í¢í¤",
    7,
    "í®í¯í±í²í³íµí¶í·"
  ],
  [
    "bd61",
    "í¸í¹íºí»í¾í€í‚",
    5,
    "í‰",
    13
  ],
  [
    "bd81",
    "í—",
    5,
    "íž",
    25,
    "ìˆ¯ìˆ±ìˆ²ìˆ´ì‰ˆì‰ì‰‘ì‰”ì‰˜ì‰ ì‰¥ì‰¬ì‰­ì‰°ì‰´ì‰¼ì‰½ì‰¿ìŠìŠˆìŠ‰ìŠìŠ˜ìŠ›ìŠìŠ¤ìŠ¥ìŠ¨ìŠ¬ìŠ­ìŠ´ìŠµìŠ·ìŠ¹ì‹œì‹ì‹ ì‹£ì‹¤ì‹«ì‹¬ì‹­ì‹¯ì‹±ì‹¶ì‹¸ì‹¹ì‹»ì‹¼ìŒ€ìŒˆìŒ‰ìŒŒìŒìŒ“ìŒ”ìŒ•ìŒ˜ìŒœìŒ¤ìŒ¥ìŒ¨ìŒ©ì…ì¨ì©ì¬ì°ì²ì¸ì¹ì¼ì½ìŽ„ìŽˆìŽŒì€ì˜ì™ìœìŸì ì¢ì¨ì©ì­ì´ìµì¸ìˆìì¤ì¬ì°"
  ],
  [
    "be41",
    "í¸",
    7,
    "í‘í‘‚í‘ƒí‘…",
    14
  ],
  [
    "be61",
    "í‘”",
    7,
    "í‘í‘ží‘Ÿí‘¡í‘¢í‘£í‘¥",
    7,
    "í‘®í‘°í‘±í‘²"
  ],
  [
    "be81",
    "í‘³",
    4,
    "í‘ºí‘»í‘½í‘¾í’í’ƒ",
    4,
    "í’Ší’Œí’Ž",
    5,
    "í’•",
    8,
    "ì´ì¼ì½ì‘ˆì‘¤ì‘¥ì‘¨ì‘¬ì‘´ì‘µì‘¹ì’€ì’”ì’œì’¸ì’¼ì“©ì“°ì“±ì“´ì“¸ì“ºì“¿ì”€ì”ì”Œì”ì””ì”œì”¨ì”©ì”¬ì”°ì”¸ì”¹ì”»ì”½ì•„ì•…ì•ˆì•‰ì•Šì•Œì•ì•Žì•“ì•”ì••ì•—ì•˜ì•™ì•ì•žì• ì•¡ì•¤ì•¨ì•°ì•±ì•³ì•´ì•µì•¼ì•½ì–€ì–„ì–‡ì–Œì–ì–ì–‘ì–•ì–—ì–˜ì–œì– ì–©ì–´ì–µì–¸ì–¹ì–»ì–¼ì–½ì–¾ì—„",
    6,
    "ì—Œì—Ž"
  ],
  [
    "bf41",
    "í’ž",
    10,
    "í’ª",
    14
  ],
  [
    "bf61",
    "í’¹",
    18,
    "í“í“Ží“í“‘í“’í““í“•"
  ],
  [
    "bf81",
    "í“–",
    5,
    "í“í“ží“ ",
    7,
    "í“©í“ªí“«í“­í“®í“¯í“±",
    6,
    "í“¹í“ºí“¼ì—ì—‘ì—”ì—˜ì— ì—¡ì—£ì—¥ì—¬ì—­ì—®ì—°ì—´ì—¶ì—·ì—¼",
    5,
    "ì˜…ì˜†ì˜‡ì˜ˆì˜Œì˜ì˜˜ì˜™ì˜›ì˜œì˜¤ì˜¥ì˜¨ì˜¬ì˜­ì˜®ì˜°ì˜³ì˜´ì˜µì˜·ì˜¹ì˜»ì™€ì™ì™„ì™ˆì™ì™‘ì™“ì™”ì™•ì™œì™ì™ ì™¬ì™¯ì™±ì™¸ì™¹ì™¼ìš€ìšˆìš‰ìš‹ìšìš”ìš•ìš˜ìšœìš¤ìš¥ìš§ìš©ìš°ìš±ìš´ìš¸ìš¹ìšºì›€ì›ì›ƒì›…ì›Œì›ì›ì›”ì›œì›ì› ì›¡ì›¨"
  ],
  [
    "c041",
    "í“¾",
    5,
    "í”…í”†í”‡í”‰í”Ší”‹í”",
    6,
    "í”–í”˜",
    5
  ],
  [
    "c061",
    "í”ž",
    25
  ],
  [
    "c081",
    "í”¸í”¹í”ºí”»í”¾í”¿í•í•‚í•ƒí•…",
    6,
    "í•Ží•í•’",
    5,
    "í•ší•›í•í•ží•Ÿí•¡í•¢í•£ì›©ì›¬ì›°ì›¸ì›¹ì›½ìœ„ìœ…ìœˆìœŒìœ”ìœ•ìœ—ìœ™ìœ ìœ¡ìœ¤ìœ¨ìœ°ìœ±ìœ³ìœµìœ·ìœ¼ìœ½ì€ì„ìŠìŒììì‘",
    7,
    "ìœì ì¨ì«ì´ìµì¸ì¼ì½ì¾ìžƒìž„ìž…ìž‡ìžˆìž‰ìžŠìžŽìžìž‘ìž”ìž–ìž—ìž˜ìžšìž ìž¡ìž£ìž¤ìž¥ìž¦ìž¬ìž­ìž°ìž´ìž¼ìž½ìž¿ìŸ€ìŸìŸˆìŸ‰ìŸŒìŸŽìŸìŸ˜ìŸìŸ¤ìŸ¨ìŸ¬ì €ì ì „ì ˆì Š"
  ],
  [
    "c141",
    "í•¤í•¦í•§í•ªí•¬í•®",
    5,
    "í•¶í•·í•¹í•ºí•»í•½",
    6,
    "í–†í–Ší–‹"
  ],
  [
    "c161",
    "í–Œí–í–Ží–í–‘",
    19,
    "í–¦í–§"
  ],
  [
    "c181",
    "í–¨",
    31,
    "ì ì ‘ì “ì •ì –ì œì ì  ì ¤ì ¬ì ­ì ¯ì ±ì ¸ì ¼ì¡€ì¡ˆì¡‰ì¡Œì¡ì¡”ì¡°ì¡±ì¡´ì¡¸ì¡ºì¢€ì¢ì¢ƒì¢…ì¢†ì¢‡ì¢‹ì¢Œì¢ì¢”ì¢ì¢Ÿì¢¡ì¢¨ì¢¼ì¢½ì£„ì£ˆì£Œì£”ì£•ì£—ì£™ì£ ì£¡ì£¤ì£µì£¼ì£½ì¤€ì¤„ì¤…ì¤†ì¤Œì¤ì¤ì¤‘ì¤˜ì¤¬ì¤´ì¥ì¥‘ì¥”ì¥˜ì¥ ì¥¡ì¥£ì¥¬ì¥°ì¥´ì¥¼ì¦ˆì¦‰ì¦Œì¦ì¦˜ì¦™ì¦›ì¦ì§€ì§ì§„ì§‡ì§ˆì§Šì§ì§‘ì§“"
  ],
  [
    "c241",
    "í—Ší—‹í—í—Ží—í—‘í—“",
    4,
    "í—ší—œí—ž",
    5,
    "í—¦í—§í—©í—ªí—«í—­í—®"
  ],
  [
    "c261",
    "í—¯",
    4,
    "í—¶í—¸í—º",
    5,
    "í˜‚í˜ƒí˜…í˜†í˜‡í˜‰",
    6,
    "í˜’"
  ],
  [
    "c281",
    "í˜–",
    5,
    "í˜í˜ží˜Ÿí˜¡í˜¢í˜£í˜¥",
    7,
    "í˜®",
    9,
    "í˜ºí˜»ì§•ì§–ì§™ì§šì§œì§ì§ ì§¢ì§¤ì§§ì§¬ì§­ì§¯ì§°ì§±ì§¸ì§¹ì§¼ì¨€ì¨ˆì¨‰ì¨‹ì¨Œì¨ì¨”ì¨˜ì¨©ì©Œì©ì©ì©”ì©œì©ì©Ÿì© ì©¡ì©¨ì©½ìª„ìª˜ìª¼ìª½ì«€ì«„ì«Œì«ì«ì«‘ì«“ì«˜ì«™ì« ì«¬ì«´ì¬ˆì¬ì¬”ì¬˜ì¬ ì¬¡ì­ì­ˆì­‰ì­Œì­ì­˜ì­™ì­ì­¤ì­¸ì­¹ì®œì®¸ì¯”ì¯¤ì¯§ì¯©ì°Œì°ì°ì°”ì°œì°ì°¡ì°¢ì°§ì°¨ì°©ì°¬ì°®ì°°ì°¸ì°¹ì°»"
  ],
  [
    "c341",
    "í˜½í˜¾í˜¿í™í™‚í™ƒí™„í™†í™‡í™Ší™Œí™Ží™í™í™’í™“í™–í™—í™™í™ší™›í™",
    4
  ],
  [
    "c361",
    "í™¢",
    4,
    "í™¨í™ª",
    5,
    "í™²í™³í™µ",
    11
  ],
  [
    "c381",
    "íšíš‚íš„íš†",
    5,
    "íšŽíšíš‘íš’íš“íš•",
    7,
    "íšžíš íš¢",
    5,
    "íš©íšªì°¼ì°½ì°¾ì±„ì±…ì±ˆì±Œì±”ì±•ì±—ì±˜ì±™ì± ì±¤ì±¦ì±¨ì±°ì±µì²˜ì²™ì²œì² ì²¨ì²©ì²«ì²¬ì²­ì²´ì²µì²¸ì²¼ì³„ì³…ì³‡ì³‰ì³ì³”ì³¤ì³¬ì³°ì´ì´ˆì´‰ì´Œì´ì´˜ì´™ì´›ì´ì´¤ì´¨ì´¬ì´¹ìµœìµ ìµ¤ìµ¬ìµ­ìµ¯ìµ±ìµ¸ì¶ˆì¶”ì¶•ì¶˜ì¶œì¶¤ì¶¥ì¶§ì¶©ì¶°ì·„ì·Œì·ì·¨ì·¬ì·°ì·¸ì·¹ì·»ì·½ì¸„ì¸ˆì¸Œì¸”ì¸™ì¸ ì¸¡ì¸¤ì¸¨ì¸°ì¸±ì¸³ì¸µ"
  ],
  [
    "c441",
    "íš«íš­íš®íš¯íš±",
    7,
    "íšºíš¼",
    7,
    "í›†í›‡í›‰í›Ší›‹"
  ],
  [
    "c461",
    "í›í›Ží›í›í›’í›“í›•í›–í›˜í›š",
    5,
    "í›¡í›¢í›£í›¥í›¦í›§í›©",
    4
  ],
  [
    "c481",
    "í›®í›¯í›±í›²í›³í›´í›¶",
    5,
    "í›¾í›¿íœíœ‚íœƒíœ…",
    11,
    "íœ’íœ“íœ”ì¹˜ì¹™ì¹œì¹Ÿì¹ ì¹¡ì¹¨ì¹©ì¹«ì¹­ì¹´ì¹µì¹¸ì¹¼ìº„ìº…ìº‡ìº‰ìºìº‘ìº”ìº˜ìº ìº¡ìº£ìº¤ìº¥ìº¬ìº­ì»ì»¤ì»¥ì»¨ì»«ì»¬ì»´ì»µì»·ì»¸ì»¹ì¼€ì¼ì¼„ì¼ˆì¼ì¼‘ì¼“ì¼•ì¼œì¼ ì¼¤ì¼¬ì¼­ì¼¯ì¼°ì¼±ì¼¸ì½”ì½•ì½˜ì½œì½¤ì½¥ì½§ì½©ì½°ì½±ì½´ì½¸ì¾€ì¾…ì¾Œì¾¡ì¾¨ì¾°ì¿„ì¿ ì¿¡ì¿¤ì¿¨ì¿°ì¿±ì¿³ì¿µì¿¼í€€í€„í€‘í€˜í€­í€´í€µí€¸í€¼"
  ],
  [
    "c541",
    "íœ•íœ–íœ—íœšíœ›íœíœžíœŸíœ¡",
    6,
    "íœªíœ¬íœ®",
    5,
    "íœ¶íœ·íœ¹"
  ],
  [
    "c561",
    "íœºíœ»íœ½",
    6,
    "í…í†íˆíŠ",
    5,
    "í’í“í•íš",
    4
  ],
  [
    "c581",
    "íŸí¢í¤í¦í§í¨íªí«í­í®í¯í±í²í³íµ",
    6,
    "í¾í¿íž€íž‚",
    5,
    "ížŠíž‹í„í…í‡í‰íí”í˜í í¬í­í°í´í¼í½í‚í‚¤í‚¥í‚¨í‚¬í‚´í‚µí‚·í‚¹íƒ€íƒíƒ„íƒˆíƒ‰íƒíƒ‘íƒ“íƒ”íƒ•íƒœíƒíƒ íƒ¤íƒ¬íƒ­íƒ¯íƒ°íƒ±íƒ¸í„í„°í„±í„´í„¸í„ºí…€í…í…ƒí…„í……í…Œí…í…í…”í…œí…í…Ÿí…¡í…¨í…¬í…¼í†„í†ˆí† í†¡í†¤í†¨í†°í†±í†³í†µí†ºí†¼í‡€í‡˜í‡´í‡¸íˆ‡íˆ‰íˆíˆ¬íˆ­íˆ°íˆ´íˆ¼íˆ½íˆ¿í‰í‰ˆí‰œ"
  ],
  [
    "c641",
    "ížížŽížíž‘",
    6,
    "ížšížœížž",
    5
  ],
  [
    "c6a1",
    "í‰¤íŠ€íŠíŠ„íŠˆíŠíŠ‘íŠ•íŠœíŠ íŠ¤íŠ¬íŠ±íŠ¸íŠ¹íŠ¼íŠ¿í‹€í‹‚í‹ˆí‹‰í‹‹í‹”í‹˜í‹œí‹¤í‹¥í‹°í‹±í‹´í‹¸íŒ€íŒíŒƒíŒ…íŒŒíŒíŒŽíŒíŒ”íŒ–íŒœíŒíŒŸíŒ íŒ¡íŒ¥íŒ¨íŒ©íŒ¬íŒ°íŒ¸íŒ¹íŒ»íŒ¼íŒ½í„í…í¼í½íŽ€íŽ„íŽŒíŽíŽíŽíŽ‘íŽ˜íŽ™íŽœíŽ íŽ¨íŽ©íŽ«íŽ­íŽ´íŽ¸íŽ¼í„í…íˆí‰íí˜í¡í£í¬í­í°í´í¼í½í¿í"
  ],
  [
    "c7a1",
    "íˆíí‘€í‘„í‘œí‘ í‘¤í‘­í‘¯í‘¸í‘¹í‘¼í‘¿í’€í’‚í’ˆí’‰í’‹í’í’”í’©í“Œí“í“”í“œí“Ÿí“¨í“¬í“°í“¸í“»í“½í”„í”ˆí”Œí””í”•í”—í”¼í”½í•€í•„í•Œí•í•í•‘í•˜í•™í•œí• í•¥í•¨í•©í•«í•­í•´í•µí•¸í•¼í–„í–…í–‡í–ˆí–‰í–í–¥í—ˆí—‰í—Œí—í—’í—˜í—™í—›í—í—¤í—¥í—¨í—¬í—´í—µí—·í—¹í˜€í˜í˜„í˜ˆí˜í˜‘í˜“í˜”í˜•í˜œí˜ "
  ],
  [
    "c8a1",
    "í˜¤í˜­í˜¸í˜¹í˜¼í™€í™…í™ˆí™‰í™‹í™í™‘í™”í™•í™˜í™œí™§í™©í™°í™±í™´íšƒíš…íšŒíšíšíš”íšíšŸíš¡íš¨íš¬íš°íš¹íš»í›„í›…í›ˆí›Œí›‘í›”í›—í›™í› í›¤í›¨í›°í›µí›¼í›½íœ€íœ„íœ‘íœ˜íœ™íœœíœ íœ¨íœ©íœ«íœ­íœ´íœµíœ¸íœ¼í„í‡í‰íí‘í”í–í—í˜í™í í¡í£í¥í©í¬í°í´í¼í½ížížˆíž‰ížŒížíž˜íž™íž›íž"
  ],
  [
    "caa1",
    "ä¼½ä½³å‡åƒ¹åŠ å¯å‘µå“¥å˜‰å«å®¶æš‡æž¶æž·æŸ¯æ­Œç‚ç—‚ç¨¼è‹›èŒ„è¡—è¢ˆè¨¶è³ˆè·è»»è¿¦é§•åˆ»å´å„æªæ…¤æ®¼çè„šè¦ºè§’é–£ä¾ƒåˆŠå¢¾å¥¸å§¦å¹²å¹¹æ‡‡æ€æ†æŸ¬æ¡¿æ¾—ç™Žçœ‹ç£µç¨ˆç«¿ç°¡è‚è‰®è‰±è««é–“ä¹«å–æ›·æ¸´ç¢£ç«­è‘›è¤èŽéž¨å‹˜åŽå ªåµŒæ„Ÿæ†¾æˆ¡æ•¢æŸ‘æ©„æ¸›ç”˜ç–³ç›£çž°ç´ºé‚¯é‘‘é‘’é¾•"
  ],
  [
    "cba1",
    "åŒ£å²¬ç”²èƒ›é‰€é–˜å‰›å ˆå§œå²¡å´—åº·å¼ºå½Šæ…·æ±Ÿç•ºç–†ç³ çµ³ç¶±ç¾Œè…”èˆ¡è–‘è¥è¬›é‹¼é™é±‡ä»‹ä»·å€‹å‡±å¡æ„·æ„¾æ…¨æ”¹æ§ªæ¼‘ç–¥çš†ç›–ç®‡èŠ¥è“‹ï¤€éŽ§é–‹å–€å®¢å‘ï¤ç²³ç¾¹é†µå€¨åŽ»å±…å·¨æ‹’æ®æ“šæ“§æ¸ ç‚¬ç¥›è·è¸žï¤‚é½é‰…é‹¸ä¹¾ä»¶å¥å·¾å»ºæ„†æ¥—è…±è™”è¹‡éµé¨«ä¹žå‚‘æ°æ¡€å„‰åŠåŠ’æª¢"
  ],
  [
    "cca1",
    "çž¼éˆé»”åŠ«æ€¯è¿²åˆæ†©æ­æ“Šæ ¼æª„æ¿€è†ˆè¦¡éš”å …ç‰½çŠ¬ç”„çµ¹ç¹­è‚©è¦‹è­´é£éµ‘æŠ‰æ±ºæ½”çµç¼ºè¨£å…¼æ…Šç®è¬™é‰—éŽŒäº¬ä¿“å€žå‚¾å„†å‹å‹å¿å°å¢ƒåºšå¾‘æ…¶æ†¬æ“Žæ•¬æ™¯æš»æ›´æ¢—æ¶‡ç‚…çƒ±ç’Ÿç’¥ç“Šç—™ç¡¬ç£¬ç«Ÿç«¶çµ…ç¶“è€•è€¿è„›èŽ–è­¦è¼•é€•é¡é ƒé ¸é©šé¯¨ä¿‚å•“å ºå¥‘å­£å±†æ‚¸æˆ’æ¡‚æ¢°"
  ],
  [
    "cda1",
    "æ£¨æºªç•Œç™¸ç£Žç¨½ç³»ç¹«ç¹¼è¨ˆèª¡è°¿éšŽé·„å¤å©å‘Šå‘±å›ºå§‘å­¤å°»åº«æ‹·æ”·æ•…æ•²æš æž¯æ§æ²½ç—¼çšç¾ç¨¿ç¾”è€ƒè‚¡è†è‹¦è‹½è°è—è ±è¢´èª¥ï¤ƒè¾œéŒ®é›‡é¡§é«˜é¼“å“­æ–›æ›²æ¢ç©€è°·éµ å›°å¤å´‘æ˜†æ¢±æ£æ»¾ç¨è¢žé¯¤æ±¨ï¤„éª¨ä¾›å…¬å…±åŠŸå­”å·¥ææ­æ‹±æŽ§æ”»ç™ç©ºèš£è²¢éžä¸²å¯¡æˆˆæžœç“œ"
  ],
  [
    "cea1",
    "ç§‘è“èª‡èª²è·¨éŽé‹é¡†å»“æ§¨è—¿éƒ­ï¤…å† å®˜å¯¬æ…£æ£ºæ¬¾çŒç¯ç“˜ç®¡ç½è…è§€è²«é—œé¤¨åˆ®ææ‹¬é€‚ä¾Šå…‰åŒ¡å£™å»£æ› æ´¸ç‚šç‹‚ç–ç­èƒ±é‘›å¦æŽ›ç½«ä¹–å‚€å¡Šå£žæ€ªæ„§æ‹æ§é­å®ç´˜è‚±è½Ÿäº¤åƒ‘å’¬å–¬å¬Œå¶ å·§æ”ªæ•Žæ ¡æ©‹ç‹¡çšŽçŸ¯çµžç¿¹è† è•Žè›Ÿè¼ƒè½ŽéƒŠé¤ƒé©•é®«ä¸˜ä¹…ä¹ä»‡ä¿±å…·å‹¾"
  ],
  [
    "cfa1",
    "å€å£å¥å’Žå˜”åµåž¢å¯‡å¶‡å»æ‡¼æ‹˜æ•‘æž¸æŸ©æ§‹æ­æ¯†æ¯¬æ±‚æºç¸ç‹—çŽ–çƒçž¿çŸ©ç©¶çµ¿è€‰è‡¼èˆ…èˆŠè‹Ÿè¡¢è¬³è³¼è»€é€‘é‚±é‰¤éŠ¶é§’é©…é³©é·—é¾œåœ‹å±€èŠéž éž«éº´å›çª˜ç¾¤è£™è»éƒ¡å €å±ˆæŽ˜çªŸå®®å¼“ç©¹çª®èŠŽèº¬å€¦åˆ¸å‹¸å·åœˆæ‹³æ²æ¬Šæ·ƒçœ·åŽ¥ç—è•¨è¹¶é—•æœºæ«ƒæ½°è©­è»Œé¥‹ï¤†æ™·æ­¸è²´"
  ],
  [
    "d0a1",
    "é¬¼ï¤‡å«åœ­å¥Žæ†æ§»çªç¡…çªºç«…ç³¾è‘µè¦èµ³é€µé–¨å‹»å‡ç•‡ç­ èŒéˆžï¤ˆæ©˜å…‹å‰‹åŠ‡æˆŸæ£˜æ¥µéš™åƒ…åŠ¤å‹¤æ‡ƒæ–¤æ ¹æ§¿ç‘¾ç­‹èŠ¹è«è¦²è¬¹è¿‘é¥‰ï¤‰ä»Šå¦—æ“’æ˜‘æªŽç´ç¦ç¦½èŠ©è¡¾è¡¿è¥Ÿï¤ŠéŒ¦ä¼‹åŠæ€¥æ‰±æ±²ç´šçµ¦äº˜å…¢çŸœè‚¯ä¼ä¼Žå…¶å†€å—œå™¨åœ»åŸºåŸ¼å¤”å¥‡å¦“å¯„å²å´Žå·±å¹¾å¿ŒæŠ€æ——æ—£"
  ],
  [
    "d1a1",
    "æœžæœŸæžæ£‹æ£„æ©Ÿæ¬ºæ°£æ±½æ²‚æ·‡çŽ˜ç¦çªç’‚ç’£ç•¸ç•¿ç¢ç£¯ç¥ç¥‡ç¥ˆç¥ºç®•ç´€ç¶ºç¾ˆè€†è€­è‚Œè¨˜è­è±ˆèµ·éŒ¡éŒ¤é£¢é¥‘é¨Žé¨é©¥éº’ç·Šä½¶å‰æ‹®æ¡”é‡‘å–«å„ºï¤‹ï¤Œå¨œæ‡¦ï¤æ‹æ‹¿ï¤Ž",
    5,
    "é‚£ï¤”",
    4,
    "è«¾ï¤™ï¤šï¤›ï¤œæš–ï¤ç…–ï¤žï¤Ÿé›£ï¤ ææºå—ï¤¡æžæ¥ æ¹³ï¤¢ç”·ï¤£ï¤¤ï¤¥"
  ],
  [
    "d2a1",
    "ç´ï¤¦ï¤§è¡²å›Šå¨˜ï¤¨",
    4,
    "ä¹ƒï¤­å…§å¥ˆæŸ°è€ï¤®å¥³å¹´æ’šç§Šå¿µæ¬æ‹ˆæ»å¯§å¯—åŠªï¤¯å¥´å¼©æ€’ï¤°ï¤±ï¤²ç‘™ï¤³",
    5,
    "é§‘ï¤¹",
    10,
    "æ¿ƒï¥„ï¥…è†¿è¾²æƒ±ï¥†ï¥‡è…¦ï¥ˆï¥‰å°¿ï¥Š",
    7,
    "å«©è¨¥æ»ç´ï¥’",
    5,
    "èƒ½ï¥˜ï¥™å°¼æ³¥åŒ¿æººå¤šèŒ¶"
  ],
  [
    "d3a1",
    "ä¸¹äº¶ä½†å–®åœ˜å£‡å½–æ–·æ—¦æª€æ®µæ¹çŸ­ç«¯ç°žç·žè›‹è¢’é„²é›æ’»æ¾¾çºç–¸é”å•–åæ†ºæ“”æ›‡æ·¡æ¹›æ½­æ¾¹ç—°èƒè†½è•è¦ƒè«‡è­šéŒŸæ²“ç•“ç­”è¸éå”å ‚å¡˜å¹¢æˆ‡æ’žæ£ ç•¶ç³–èž³é»¨ä»£åžˆå®å¤§å°å²±å¸¶å¾…æˆ´æ“¡çŽ³è‡ºè¢‹è²¸éšŠé»›å®…å¾·æ‚³å€’åˆ€åˆ°åœ–å µå¡—å°Žå± å³¶å¶‹åº¦å¾’æ‚¼æŒ‘æŽ‰æ—æ¡ƒ"
  ],
  [
    "d4a1",
    "æ£¹æ«‚æ·˜æ¸¡æ»”æ¿¤ç‡¾ç›œç¹ç¦±ç¨»è„è¦©è³­è·³è¹ˆé€ƒé€”é“éƒ½éé™¶éŸœæ¯’ç€†ç‰˜çŠ¢ç¨ç£ç¦¿ç¯¤çº›è®€å¢©æƒ‡æ•¦æ—½æš¾æ²Œç„žç‡‰è±šé “ä¹­çªä»å†¬å‡å‹•åŒæ†§æ±æ¡æ£Ÿæ´žæ½¼ç–¼çž³ç«¥èƒ´è‘£éŠ…å…œæ–—æœæž“ç—˜ç«‡è³ï¥šè±†é€—é ­å±¯è‡€èŠšéé¯éˆå¾—å¶æ©™ç‡ˆç™»ç­‰è—¤è¬„é„§é¨°å–‡æ‡¶ï¥›ç™©ç¾…"
  ],
  [
    "d5a1",
    "è˜¿èžºè£¸é‚ï¥œæ´›çƒ™çžçµ¡è½ï¥é…ªé§±ï¥žäº‚åµæ¬„æ¬’ç€¾çˆ›è˜­é¸žå‰Œè¾£åµæ“¥æ”¬æ¬–æ¿«ç±ƒçºœè—è¥¤è¦½æ‹‰è‡˜è Ÿå»Šæœ—æµªç‹¼ç…ç‘¯èž‚éƒžä¾†å´å¾ èŠå†·æŽ ç•¥äº®å€†å…©å‡‰æ¢æ¨‘ç²®ç²±ç³§è‰¯è«’è¼›é‡ä¾¶å„·å‹µå‘‚å»¬æ…®æˆ¾æ—…æ«šæ¿¾ç¤ªè—œè £é–­é©¢é©ªéº—é»ŽåŠ›æ›†æ­·ç€ç¤«è½¢é‚æ†æˆ€æ”£æ¼£"
  ],
  [
    "d6a1",
    "ç…‰ç’‰ç·´è¯è“®è¼¦é€£éŠå†½åˆ—åŠ£æ´Œçƒˆè£‚å»‰æ–‚æ®®æ¿‚ç°¾çµä»¤ä¼¶å›¹ï¥Ÿå²ºå¶ºæ€œçŽ²ç¬­ç¾šç¿Žè†é€žéˆ´é›¶éˆé ˜é½¡ä¾‹æ¾§ç¦®é†´éš·å‹žï¥ æ’ˆæ“„æ«“æ½žç€˜çˆç›§è€è˜†è™œè·¯è¼…éœ²é­¯é·ºé¹µç¢Œç¥¿ç¶ è‰éŒ„é¹¿éº“è«–å£Ÿå¼„æœ§ç€§ç“ç± è¾å„¡ç€¨ç‰¢ç£Šè³‚è³šè³´é›·äº†åƒšå¯®å»–æ–™ç‡Žç™‚çž­èŠè“¼"
  ],
  [
    "d7a1",
    "é¼é¬§é¾å£˜å©å±¢æ¨“æ·šæ¼ç˜»ç´¯ç¸·è”žè¤¸é¤é™‹åŠ‰æ—’æŸ³æ¦´æµæºœç€ç‰ç‘ ç•™ç˜¤ç¡«è¬¬é¡žå…­æˆ®é™¸ä¾–å€«å´™æ·ªç¶¸è¼ªå¾‹æ…„æ —ï¥¡éš†å‹’è‚‹å‡œå‡Œæ¥žç¨œç¶¾è±é™µä¿šåˆ©åŽ˜åå”Žå±¥æ‚§æŽæ¢¨æµ¬çŠç‹¸ç†ç’ƒï¥¢ç—¢ç±¬ç½¹ç¾¸èŽ‰è£è£¡é‡Œé‡é›¢é¯‰åæ½¾ç‡ç’˜è—ºèºªéš£é±—éºŸæž—æ·‹ç³è‡¨éœ–ç ¬"
  ],
  [
    "d8a1",
    "ç«‹ç¬ ç²’æ‘©ç‘ªç—²ç¢¼ç£¨é¦¬é­”éº»å¯žå¹•æ¼ è†œèŽ«é‚ˆä¸‡åå¨©å·’å½Žæ…¢æŒ½æ™©æ›¼æ»¿æ¼«ç£çžžè¬è”“è »è¼“é¥…é°»å”œæŠ¹æœ«æ²«èŒ‰è¥ªéºäº¡å¦„å¿˜å¿™æœ›ç¶²ç½”èŠ’èŒ«èŽ½è¼žé‚™åŸ‹å¦¹åª’å¯æ˜§æžšæ¢…æ¯ç…¤ç½µè²·è³£é‚é­…è„ˆè²Šé™Œé©€éº¥å­Ÿæ°“çŒ›ç›²ç›ŸèŒå†ªè¦“å…å†•å‹‰æ£‰æ²”çœ„çœ ç¶¿ç·¬é¢éºµæ»…"
  ],
  [
    "d9a1",
    "è”‘å†¥åå‘½æ˜Žæšæ¤§æºŸçš¿çž‘èŒ—è“‚èžŸé…©éŠ˜é³´è¢‚ä¾®å†’å‹Ÿå§†å¸½æ…•æ‘¸æ‘¹æš®æŸæ¨¡æ¯æ¯›ç‰Ÿç‰¡ç‘çœ¸çŸ›è€—èŠ¼èŒ…è¬€è¬¨è²Œæœ¨æ²ç‰§ç›®ç¦ç©†é¶©æ­¿æ²’å¤¢æœ¦è’™å¯å¢“å¦™å»Ÿææ˜´æ³æ¸ºçŒ«ç«—è‹—éŒ¨å‹™å·«æ†®æ‡‹æˆŠæ‹‡æ’«æ— æ¥™æ­¦æ¯‹ç„¡ç·ç•ç¹†èˆžèŒ‚è•ªèª£è²¿éœ§éµ¡å¢¨é»˜å€‘åˆŽå»å•æ–‡"
  ],
  [
    "daa1",
    "æ±¶ç´Šç´‹èžèšŠé–€é›¯å‹¿æ²•ç‰©å‘³åªšå°¾åµ‹å½Œå¾®æœªæ¢¶æ¥£æ¸¼æ¹„çœ‰ç±³ç¾Žè–‡è¬Žè¿·é¡é»´å²·æ‚¶æ„æ†«æ•æ—»æ—¼æ°‘æ³¯çŽŸç‰ç·¡é–”å¯†èœœè¬å‰åšæ‹ææ’²æœ´æ¨¸æ³Šç€ç’žç®”ç²•ç¸›è†Šèˆ¶è–„è¿«é›¹é§ä¼´åŠåå›æ‹Œæ¬æ”€æ–‘æ§ƒæ³®æ½˜ç­ç•”ç˜¢ç›¤ç›¼ç£ç£»ç¤¬çµ†èˆ¬èŸ è¿”é ’é£¯å‹ƒæ‹”æ’¥æ¸¤æ½‘"
  ],
  [
    "dba1",
    "ç™¼è·‹é†±é‰¢é«®é­ƒå€£å‚åŠå¦¨å°¨å¹‡å½·æˆ¿æ”¾æ–¹æ—æ˜‰æž‹æ¦œæ»‚ç£…ç´¡è‚ªè†€èˆ«èŠ³è’¡èšŒè¨ªè¬—é‚¦é˜²é¾å€ä¿³ï¥£åŸ¹å¾˜æ‹œæŽ’æ¯æ¹ƒç„™ç›ƒèƒŒèƒšè£´è£µè¤™è³ è¼©é…é™ªä¼¯ä½°å¸›æŸæ ¢ç™½ç™¾é­„å¹¡æ¨Šç…©ç‡”ç•ªï¥¤ç¹è•ƒè—©é£œä¼ç­ç½°é–¥å‡¡å¸†æ¢µæ°¾æ±Žæ³›çŠ¯ç¯„èŒƒæ³•çºåƒ»åŠˆå£æ“˜æª—ç’§ç™–"
  ],
  [
    "dca1",
    "ç¢§è˜—é—¢éœ¹ï¥¥åžå¼è®Šè¾¨è¾¯é‚Šåˆ¥çž¥é±‰é¼ˆä¸™å€‚å…µå±›å¹·æ˜žæ˜ºæŸ„æ£…ç‚³ç”ç—…ç§‰ç«è¼§é¤ é¨ˆä¿å ¡å ±å¯¶æ™®æ­¥æ´‘æ¹ºæ½½ç¤ç”«è©è£œè¤“è­œè¼”ä¼åƒ•åŒåœå®“å¾©æœç¦è…¹èŒ¯è””è¤‡è¦†è¼¹è¼»é¦¥é°’æœ¬ä¹¶ä¿¸å¥‰å°å³¯å³°æ§æ£’çƒ½ç†¢ç«ç¸«è“¬èœ‚é€¢é‹’é³³ä¸ä»˜ä¿¯å‚…å‰–å‰¯å¦å’åŸ å¤«å©¦"
  ],
  [
    "dda1",
    "å­šå­µå¯Œåºœï¥¦æ‰¶æ•·æ–§æµ®æº¥çˆ¶ç¬¦ç°¿ç¼¶è…è…‘è†šè‰€èŠ™èŽ©è¨ƒè² è³¦è³»èµ´è¶ºéƒ¨é‡œé˜œé™„é§™é³§åŒ—åˆ†å©å™´å¢³å¥”å¥®å¿¿æ†¤æ‰®æ˜æ±¾ç„šç›†ç²‰ç³žç´›èŠ¬è³é›°ï¥§ä½›å¼—å½¿æ‹‚å´©æœ‹æ£šç¡¼ç¹ƒéµ¬ä¸•å‚™åŒ•åŒªå‘å¦ƒå©¢åº‡æ‚²æ†Šæ‰‰æ‰¹æ–æž‡æ¦§æ¯”æ¯–æ¯—æ¯˜æ²¸ï¥¨çµç—ºç ’ç¢‘ç§•ç§˜ç²ƒç·‹ç¿¡è‚¥"
  ],
  [
    "dea1",
    "è„¾è‡‚è²èœšè£¨èª¹è­¬è²»é„™éžé£›é¼»åš¬å¬ªå½¬æ–Œæª³æ®¯æµœæ¿±ç€•ç‰çŽ­è²§è³“é »æ†‘æ°·è˜é¨ä¹äº‹äº›ä»•ä¼ºä¼¼ä½¿ä¿Ÿåƒ¿å²å¸å”†å—£å››å£«å¥¢å¨‘å¯«å¯ºå°„å·³å¸«å¾™æ€æ¨æ–œæ–¯æŸ¶æŸ»æ¢­æ­»æ²™æ³—æ¸£ç€‰ç…ç ‚ç¤¾ç¥€ç¥ ç§ç¯©ç´—çµ²è‚†èˆèŽŽè“‘è›‡è£Ÿè©è©žè¬è³œèµ¦è¾­é‚ªé£¼é§Ÿéºå‰Šï¥©æœ”ï¥ª"
  ],
  [
    "dfa1",
    "å‚˜åˆªå±±æ•£æ±•çŠç”£ç–ç®—è’œé…¸éœ°ä¹·æ’’æ®ºç…žè–©ä¸‰ï¥«æ‰æ£®æ¸—èŠŸè”˜è¡«æ·æ¾éˆ’é¢¯ä¸Šå‚·åƒå„Ÿå•†å–ªå˜—å­€å°™å³ å¸¸åºŠåº å»‚æƒ³æ¡‘æ©¡æ¹˜çˆ½ç‰€ç‹€ç›¸ç¥¥ç®±ç¿”è£³è§´è©³è±¡è³žéœœå¡žç’½è³½å—‡ï¥¬ç©¡ç´¢è‰²ç‰²ç”Ÿç”¥ï¥­ç¬™å¢…å£»å¶¼åºåº¶å¾æ•æŠ’æ¿æ•æš‘æ›™æ›¸æ –æ£²çŠ€ç‘žç­®çµ®ç·–ç½²"
  ],
  [
    "e0a1",
    "èƒ¥èˆ’è–¯è¥¿èª“é€é‹¤é»é¼ å¤•å¥­å¸­æƒœæ˜”æ™³æžæ±æ·…æ½ŸçŸ³ç¢©è“†é‡‹éŒ«ä»™åƒŠå…ˆå–„å¬‹å®£æ‰‡æ•¾æ—‹æ¸²ç…½çç‘„ç’‡ç’¿ç™¬ç¦ªç·šç¹•ç¾¨è…ºè†³èˆ¹è˜šèŸ¬è©µè·£é¸éŠ‘é¥é¥é®®å¨å±‘æ¥”æ³„æ´©æ¸«èˆŒè–›è¤»è¨­èªªé›ªé½§å‰¡æš¹æ®²çº–èŸ¾è´é–ƒé™æ”æ¶‰ç‡®ï¥®åŸŽå§“å®¬æ€§æƒºæˆæ˜Ÿæ™ŸçŒ©ç¹ç››çœç­¬"
  ],
  [
    "e1a1",
    "è–è²è…¥èª é†’ä¸–å‹¢æ­²æ´—ç¨…ç¬¹ç´°ï¥¯è²°å¬å˜¯å¡‘å®µå°å°‘å·¢æ‰€æŽƒæ”æ˜­æ¢³æ²¼æ¶ˆæº¯ç€Ÿç‚¤ç‡’ç”¦ç–ç–Žç˜™ç¬‘ç¯ ç°«ç´ ç´¹è”¬è•­è˜‡è¨´é€é¡é‚µéŠ·éŸ¶é¨·ä¿—å±¬æŸæ¶‘ç²ŸçºŒè¬–è´–é€Ÿå­«å·½æè“€éœé£¡çŽ‡å®‹æ‚šæ¾æ·žè¨Ÿèª¦é€é Œåˆ·ï¥°ç‘ç¢ŽéŽ–è¡°é‡—ä¿®å—å—½å›šåž‚å£½å«‚å®ˆå²«å³€å¸¥æ„"
  ],
  [
    "e2a1",
    "æˆæ‰‹æŽˆæœæ”¶æ•¸æ¨¹æ®Šæ°´æ´™æ¼±ç‡§ç‹©ç¸ç‡ç’²ç˜¦ç¡ç§€ç©—ç«ªç²¹ç¶ç¶¬ç¹¡ç¾žè„©èŒ±è’è“šè—ªè¢–èª°è®è¼¸é‚é‚ƒé…¬éŠ–éŠ¹éš‹éš§éš¨é›–éœ€é ˆé¦–é«“é¬šå”å¡¾å¤™å­°å®¿æ·‘æ½šç†Ÿç¡ç’¹è‚…è½å·¡å¾‡å¾ªæ‚æ—¬æ ’æ¥¯æ©“æ®‰æ´µæ·³ç£ç›¾çž¬ç­ç´”è„£èˆœè€è“´è•£è©¢è«„é†‡éŒžé †é¦´æˆŒè¡“è¿°é‰¥å´‡å´§"
  ],
  [
    "e3a1",
    "åµ©ç‘Ÿè†è¨æ¿•æ‹¾ç¿’è¤¶è¥²ä¸žä¹˜åƒ§å‹å‡æ‰¿æ˜‡ç¹©è …é™žä¾åŒ™å˜¶å§‹åª¤å°¸å±Žå±å¸‚å¼‘æƒæ–½æ˜¯æ™‚æž¾æŸ´çŒœçŸ¢ç¤ºç¿…è’”è“è¦–è©¦è©©è«¡è±•è±ºåŸ´å¯”å¼æ¯æ‹­æ¤æ®–æ¹œç†„ç¯’è•è­˜è»¾é£Ÿé£¾ä¼¸ä¾ä¿¡å‘»å¨ å®¸æ„¼æ–°æ™¨ç‡¼ç”³ç¥žç´³è…Žè‡£èŽ˜è–ªè—Žèœƒè¨Šèº«è¾›ï¥±è¿…å¤±å®¤å¯¦æ‚‰å¯©å°‹å¿ƒæ²"
  ],
  [
    "e4a1",
    "ï¥²æ·±ç€‹ç”šèŠ¯è«¶ä»€åï¥³é›™æ°äºžä¿„å…’å•žå¨¥å³¨æˆ‘ç‰™èŠ½èŽªè›¾è¡™è¨é˜¿é›…é¤“é´‰éµå Šå²³å¶½å¹„æƒ¡æ„•æ¡æ¨‚æ¸¥é„‚é”é¡Žé°é½·å®‰å²¸æŒ‰æ™æ¡ˆçœ¼é›éžé¡”é®Ÿæ–¡è¬è»‹é–¼å”µå²©å·–åºµæš—ç™Œè´é—‡å£“æŠ¼ç‹Žé´¨ä»°å¤®æ€æ˜»æ®ƒç§§é´¦åŽ“å“€åŸƒå´–æ„›æ›–æ¶¯ç¢è‰¾éš˜é„åŽ„æ‰¼æŽ–æ¶²ç¸Šè…‹é¡"
  ],
  [
    "e5a1",
    "æ«»ç½Œé¶¯é¸šä¹Ÿå€»å†¶å¤œæƒ¹æ¶æ¤°çˆºè€¶ï¥´é‡Žå¼±ï¥µï¥¶ç´„è‹¥è‘¯è’»è—¥èºï¥·ä½¯ï¥¸ï¥¹å£¤å­ƒæ™æšæ”˜æ•­æš˜ï¥ºæ¥Šæ¨£æ´‹ç€ç…¬ç—’ç˜ç¦³ç©°ï¥»ç¾Šï¥¼è¥„ï¥½è®“é‡€é™½ï¥¾é¤Šåœ„å¾¡æ–¼æ¼ç˜€ç¦¦èªžé¦­é­šé½¬å„„æ†¶æŠ‘æªè‡†åƒå °å½¦ç„‰è¨€è«ºå­¼è˜–ä¿ºå„¼åš´å¥„æŽ©æ·¹å¶ªæ¥­å††äºˆä½™ï¥¿ï¦€ï¦å¦‚ï¦‚"
  ],
  [
    "e6a1",
    "ï¦ƒæ­Ÿæ±ï¦„ç’µç¤–ï¦…èˆ‡è‰…èŒ¹è¼¿è½ï¦†é¤˜ï¦‡ï¦ˆï¦‰äº¦ï¦ŠåŸŸå½¹æ˜“ï¦‹ï¦Œç–«ç¹¹è­¯ï¦é€†é©›åš¥å §å§¸å¨Ÿå®´ï¦Žå»¶ï¦ï¦ææŒ»ï¦‘æ¤½æ²‡æ²¿æ¶Žæ¶“æ·µæ¼”ï¦’çƒŸç„¶ç…™ï¦“ç‡ƒç‡•ï¦”ç¡ç¡¯ï¦•ç­µç·£ï¦–ç¸¯ï¦—è¡è»Ÿï¦˜ï¦™ï¦šé‰›ï¦›é³¶ï¦œï¦ï¦žæ‚…æ¶…ï¦Ÿç†±ï¦ ï¦¡é–±åŽ­ï¦¢ï¦£ï¦¤æŸ“ï¦¥ç‚Žç„°ç°è‰¶è‹’"
  ],
  [
    "e7a1",
    "ï¦¦é–»é«¥é¹½æ›„ï¦§ç‡è‘‰ï¦¨ï¦©å¡‹ï¦ªï¦«å¶¸å½±ï¦¬æ˜ æšŽæ¥¹æ¦®æ°¸æ³³æ¸¶æ½æ¿šç€›ç€¯ç…ç‡Ÿç°ï¦­ç‘›ï¦®ç“”ç›ˆç©Žçº“ï¦¯ï¦°è‹±è© è¿Žï¦±éˆï¦²éœ™ï¦³ï¦´ä¹‚å€ªï¦µåˆˆå¡æ›³æ±­æ¿ŠçŒŠç¿ç©¢èŠ®è—è˜‚ï¦¶è£”è©£è­½è±«ï¦·éŠ³ï¦¸éœ“é äº”ä¼ä¿‰å‚²åˆå¾å³å—šå¡¢å¢ºå¥§å¨›å¯¤æ‚Ÿï¦¹æ‡Šæ•–æ—¿æ™¤æ¢§æ±šæ¾³"
  ],
  [
    "e8a1",
    "çƒç†¬ç’ç­½èœˆèª¤é°²é¼‡å±‹æ²ƒç„çŽ‰éˆºæº«ç‘¥ç˜Ÿç©©ç¸•è˜Šå…€å£…æ“ç“®ç”•ç™°ç¿é‚•é›é¥”æ¸¦ç“¦çª©çªªè‡¥è›™è¸è¨›å©‰å®Œå®›æ¢¡æ¤€æµ£çŽ©ç“ç¬ç¢—ç·©ç¿«è„˜è…•èŽžè±Œé˜®é ‘æ›°å¾€æ—ºæž‰æ±ªçŽ‹å€­å¨ƒæ­ªçŸ®å¤–åµ¬å·çŒ¥ç•ï¦ºï¦»åƒ¥å‡¹å ¯å¤­å¦–å§šå¯¥ï¦¼ï¦½å¶¢æ‹—æ–æ’“æ“¾ï¦¾æ›œï¦¿æ©ˆï§€ç‡¿ç‘¤ï§"
  ],
  [
    "e9a1",
    "çªˆçª¯ç¹‡ç¹žè€€è…°ï§‚èŸ¯è¦è¬ é™ï§ƒé‚€é¥’æ…¾æ¬²æµ´ç¸Ÿè¤¥è¾±ä¿‘å‚­å†—å‹‡åŸ‡å¢‰å®¹åº¸æ…‚æ¦•æ¶Œæ¹§æº¶ç†”ç‘¢ç”¨ç”¬è³èŒ¸è“‰è¸ŠéŽ”éžï§„äºŽä½‘å¶å„ªåˆå‹å³å®‡å¯“å°¤æ„šæ†‚æ—´ç‰›çŽ—ç‘€ç›‚ç¥ç¦‘ç¦¹ç´†ç¾½èŠ‹è—•è™žè¿‚é‡éƒµé‡ªéš…é›¨é›©å‹–å½§æ—­æ˜±æ ¯ç…œç¨¶éƒé Šäº‘ï§…æ©’æ®žæ¾ç†‰è€˜èŠ¸è•“"
  ],
  [
    "eaa1",
    "é‹éš•é›²éŸ»è”šé¬±äºç†Šé›„å…ƒåŽŸå“¡åœ“åœ’åž£åª›å«„å¯ƒæ€¨æ„¿æ´æ²…æ´¹æ¹²æºçˆ°çŒ¿ç‘—è‹‘è¢è½…é ï§†é™¢é¡˜é´›æœˆè¶Šé‰žä½å‰åƒžå±åœå§”å¨å°‰æ…°æšæ¸­çˆ²ç‘‹ç·¯èƒƒèŽè‘¦è”¿èŸè¡›è¤˜è¬‚é•éŸ‹é­ä¹³ä¾‘å„’å…ªï§‡å”¯å–©å­ºå®¥å¹¼å¹½åº¾æ‚ æƒŸæ„ˆæ„‰æ„æ”¸æœ‰ï§ˆæŸ”æŸšï§‰æ¥¡æ¥¢æ²¹æ´§ï§Šæ¸¸ï§‹"
  ],
  [
    "eba1",
    "æ¿¡çŒ¶çŒ·ï§Œç‘œç”±ï§ç™’ï§Žï§ç¶­è‡¾è¸è£•èª˜è«›è«­è¸°è¹‚éŠé€¾éºé…‰é‡‰é®ï§ï§‘å ‰ï§’æ¯“è‚‰è‚²ï§“ï§”å…å¥«å°¹ï§•ï§–æ½¤çŽ§èƒ¤è´‡ï§—éˆ—é–ï§˜ï§™ï§šï§›è¿æˆŽç€œçµ¨èžï§œåž æ©æ…‡æ®·èª¾éŠ€éš±ä¹™åŸæ·«è”­é™°éŸ³é£®æ–æ³£é‚‘å‡æ‡‰è†ºé·¹ä¾å€šå„€å®œæ„æ‡¿æ“¬æ¤…æ¯…ç–‘çŸ£ç¾©è‰¤è–èŸ»è¡£èª¼"
  ],
  [
    "eca1",
    "è­°é†«äºŒä»¥ä¼Šï§ï§žå¤·å§¨ï§Ÿå·²å¼›å½›æ€¡ï§ ï§¡ï§¢ï§£çˆ¾ç¥ï§¤ç•°ç—ï§¥ç§»ï§¦è€Œè€³è‚„è‹¡è‘ï§§ï§¨è²½è²³é‚‡ï§©ï§ªé£´é¤Œï§«ï§¬ç€·ç›Šç¿Šç¿Œç¿¼è¬šäººä»åˆƒå°ï§­å’½å› å§»å¯…å¼•å¿æ¹®ï§®ï§¯çµªèŒµï§°èš“èªï§±é­é·ï§²ï§³ä¸€ä½šä½¾å£¹æ—¥æº¢é€¸éŽ°é¦¹ä»»å£¬å¦Šå§™æï§´ï§µç¨”ï§¶èè³ƒå…¥å„"
  ],
  [
    "eda1",
    "ï§·ï§¸ï§¹ä»å‰©å­•èŠ¿ä»”åˆºå’¨å§‰å§¿å­å­—å­œæ£æ…ˆæ»‹ç‚™ç…®çŽ†ç“·ç–µç£ç´«è€…è‡ªèŒ¨è”—è—‰è«®è³‡é›Œä½œå‹ºåš¼æ–«æ˜¨ç¼ç‚¸çˆµç¶½èŠé…Œé›€éµ²å­±æ£§æ®˜æ½ºç›žå²‘æš«æ½›ç®´ç°ªè ¶é›œä¸ˆä»—åŒ å ´å¢»å£¯å¥¬å°‡å¸³åº„å¼µæŽŒæš²æ–æ¨Ÿæª£æ¬Œæ¼¿ç‰†ï§ºçç’‹ç« ç²§è…¸è‡Ÿè‡§èŽŠè‘¬è”£è–”è—è£è´“é†¬é•·"
  ],
  [
    "eea1",
    "éšœå†å“‰åœ¨å®°æ‰ææ ½æ¢“æ¸½æ»“ç½ç¸¡è£è²¡è¼‰é½‹é½Žçˆ­ç®è«éŒšä½‡ä½Žå„²å’€å§åº•æŠµæµæ¥®æ¨—æ²®æ¸šç‹™çŒªç–½ç®¸ç´µè‹§è¹è‘—è—·è©›è²¯èº‡é€™é‚¸é›Žé½Ÿå‹£åŠå«¡å¯‚æ‘˜æ•µæ»´ç‹„ï§»çš„ç©ç¬›ç±ç¸¾ç¿Ÿè»è¬«è³Šèµ¤è·¡è¹Ÿè¿ªè¿¹é©é‘ä½ƒä½ºå‚³å…¨å…¸å‰å‰ªå¡¡å¡¼å¥ å°ˆå±•å»›æ‚›æˆ°æ “æ®¿æ°ˆæ¾±"
  ],
  [
    "efa1",
    "ç…Žç ç”°ç”¸ç•‘ç™²ç­Œç®‹ç®­ç¯†çºè©®è¼¾è½‰éˆ¿éŠ“éŒ¢é«é›»é¡šé¡«é¤žåˆ‡æˆªæŠ˜æµ™ç™¤ç«Šç¯€çµ¶å å²¾åº—æ¼¸ç‚¹ç²˜éœ‘é®Žé»žæŽ¥æ‘ºè¶ä¸äº•äº­åœåµå‘ˆå§ƒå®šå¹€åº­å»·å¾æƒ…æŒºæ”¿æ•´æ—Œæ™¶æ™¸æŸ¾æ¥¨æª‰æ­£æ±€æ·€æ·¨æ¸Ÿæ¹žç€žç‚¡çŽŽç½ç”ºç›ç¢‡ç¦Žç¨‹ç©½ç²¾ç¶Žè‰‡è¨‚è«ªè²žé„­é…Šé‡˜é‰¦é‹ŒéŒ éœ†é–"
  ],
  [
    "f0a1",
    "éœé ‚é¼Žåˆ¶åŠ‘å•¼å ¤å¸å¼Ÿæ‚Œææ¢¯æ¿Ÿç¥­ç¬¬è‡è–ºè£½è«¸è¹„é†é™¤éš›éœ½é¡Œé½Šä¿Žå…†å‡‹åŠ©å˜²å¼”å½«æŽªæ“æ—©æ™æ›ºæ›¹æœæ¢æ£—æ§½æ¼•æ½®ç…§ç‡¥çˆªç’ªçœºç¥–ç¥šç§Ÿç¨ çª•ç²—ç³Ÿçµ„ç¹°è‚‡è—»èš¤è©”èª¿è¶™èºé€ é­é‡£é˜»é›•é³¥æ—ç°‡è¶³éƒå­˜å°Šå’æ‹™çŒå€§å®—å¾žæ‚°æ…«æ£•æ·™ç®ç¨®çµ‚ç¶œç¸±è…«"
  ],
  [
    "f1a1",
    "è¸ªè¸µé¾é˜ä½åå·¦åº§æŒ«ç½ªä¸»ä½ä¾åšå§èƒ„å‘ªå‘¨å—¾å¥å®™å·žå»šæ™æœ±æŸ±æ ªæ³¨æ´²æ¹Šæ¾ç‚·ç ç–‡ç±Œç´‚ç´¬ç¶¢èˆŸè››è¨»èª…èµ°èºŠè¼³é€±é…Žé…’é‘„é§ç«¹ç²¥ä¿Šå„å‡†åŸˆå¯¯å³»æ™™æ¨½æµšæº–æ¿¬ç„Œç•¯ç«£è ¢é€¡éµé›‹é§¿èŒä¸­ä»²è¡†é‡å½æ«›æ¥«æ±è‘ºå¢žæ†Žæ›¾æ‹¯çƒç”‘ç—‡ç¹’è’¸è­‰è´ˆä¹‹åª"
  ],
  [
    "f2a1",
    "å’«åœ°å€å¿—æŒæŒ‡æ‘¯æ”¯æ—¨æ™ºæžæž³æ­¢æ± æ²šæ¼¬çŸ¥ç ¥ç¥‰ç¥—ç´™è‚¢è„‚è‡³èŠèŠ·èœ˜èªŒï§¼è´„è¶¾é²ç›´ç¨™ç¨·ç¹”è·å”‡å—”å¡µæŒ¯æ¢æ™‰æ™‹æ¡­æ¦›æ®„æ´¥æº±çç‘¨ç’¡ç•›ç–¹ç›¡çœžçž‹ç§¦ç¸‰ç¸è‡»è”¯è¢—è¨ºè³‘è»«è¾°é€²éŽ­é™£é™³éœ‡ä¾„å±å§ªå«‰å¸™æ¡Žç“†ç–¾ç§©çª’è†£è›­è³ªè·Œè¿­æ–Ÿæœ•ï§½åŸ·æ½—ç·è¼¯"
  ],
  [
    "f3a1",
    "é¶é›†å¾µæ‡²æ¾„ä¸”ä¾˜å€Ÿå‰å—Ÿåµ¯å·®æ¬¡æ­¤ç£‹ç®šï§¾è¹‰è»Šé®æ‰æ¾ç€çª„éŒ¯é‘¿é½ªæ’°æ¾¯ç‡¦ç’¨ç“šç«„ç°’çº‚ç²²çº˜è®šè´Šé‘½é¤é¥Œåˆ¹å¯Ÿæ“¦æœ­ç´®åƒ­åƒå¡¹æ…˜æ…™æ‡ºæ–¬ç«™è®’è®–å€‰å€¡å‰µå”±å¨¼å» å½°æ„´æ•žæ˜Œæ˜¶æš¢æ§æ»„æ¼²çŒ–ç˜¡çª“è„¹è‰™è–è’¼å‚µåŸ°å¯€å¯¨å½©æŽ¡ç ¦ç¶µèœè”¡é‡‡é‡µå†ŠæŸµç­–"
  ],
  [
    "f4a1",
    "è²¬å‡„å¦»æ‚½è™•å€œï§¿å‰”å°ºæ…½æˆšæ‹“æ“²æ–¥æ»Œç˜ è„Šè¹ é™Ÿéš»ä»Ÿåƒå–˜å¤©å·æ“…æ³‰æ·ºçŽ”ç©¿èˆ›è–¦è³¤è¸é·é‡§é—¡é˜¡éŸ†å‡¸å“²å–†å¾¹æ’¤æ¾ˆç¶´è¼Ÿè½éµåƒ‰å°–æ²¾æ·»ç”›çž»ç°½ç±¤è©¹è«‚å žå¦¾å¸–æ·ç‰’ç–Šç«è«œè²¼è¼’å»³æ™´æ·¸è½èè«‹é‘é¯–ï¨€å‰ƒæ›¿æ¶•æ»¯ç· è«¦é€®éžé«”åˆå‰¿å“¨æ†”æŠ„æ‹›æ¢¢"
  ],
  [
    "f5a1",
    "æ¤’æ¥šæ¨µç‚’ç„¦ç¡ç¤ç¤Žç§’ç¨è‚–è‰¸è‹•è‰è•‰è²‚è¶…é…¢é†‹é†®ä¿ƒå›‘ç‡­çŸ—èœ€è§¸å¯¸å¿–æ‘é‚¨å¢å¡šå¯µæ‚¤æ†æ‘ ç¸½è°è”¥éŠƒæ’®å‚¬å´”æœ€å¢œæŠ½æŽ¨æ¤Žæ¥¸æ¨žæ¹«çšºç§‹èŠ»è©è«è¶¨è¿½é„’é…‹é†œéŒéŒ˜éŽšé››é¨¶é°ä¸‘ç•œç¥ç«ºç­‘ç¯‰ç¸®è“„è¹™è¹´è»¸é€æ˜¥æ¤¿ç‘ƒå‡ºæœ®é»œå……å¿ æ²–èŸ²è¡è¡·æ‚´è†µèƒ"
  ],
  [
    "f6a1",
    "è´…å–å¹å˜´å¨¶å°±ç‚Šç¿ èšè„†è‡­è¶£é†‰é©Ÿé·²å´ä»„åŽ æƒ»æ¸¬å±¤ä¾ˆå€¤å—¤å³™å¹Ÿæ¥æ¢”æ²»æ·„ç†¾ç—”ç—´ç™¡ç¨šç©‰ç·‡ç·»ç½®è‡´èš©è¼œé›‰é¦³é½’å‰‡å‹…é£­è¦ªä¸ƒæŸ’æ¼†ä¾µå¯¢æž•æ²ˆæµ¸ç›ç §é‡é¼èŸ„ç§¤ç¨±å¿«ä»–å’¤å”¾å¢®å¦¥æƒ°æ‰“æ‹–æœ¶æ¥•èˆµé™€é¦±é§å€¬å“å•„å¼ï¨æ‰˜ï¨‚æ“¢æ™«æŸæ¿æ¿¯ç¢ç¸è¨—"
  ],
  [
    "f7a1",
    "é¸å‘‘å˜†å¦å½ˆæ†šæ­Žç˜ç‚­ç¶»èª•å¥ªè„«æŽ¢çœˆè€½è²ªå¡”æ­æ¦»å®•å¸‘æ¹¯ï¨ƒè•©å…Œå°å¤ªæ€ æ…‹æ®†æ±°æ³°ç¬žèƒŽè‹”è·†é‚°é¢±ï¨„æ“‡æ¾¤æ’‘æ”„å…ŽååœŸè¨Žæ…Ÿæ¡¶ï¨…ç—›ç­’çµ±é€šå †æ§Œè…¿è¤ªé€€é ¹å¸å¥—å¦¬æŠ•é€é¬ªæ…ç‰¹é—–å¡å©†å·´æŠŠæ’­æ“ºæ·æ³¢æ´¾çˆ¬ç¶ç ´ç½·èŠ­è·›é —åˆ¤å‚æ¿ç‰ˆç“£è²©è¾¦éˆ‘"
  ],
  [
    "f8a1",
    "é˜ªå…«å­æŒä½©å”„æ‚–æ•—æ²›æµ¿ç‰Œç‹½ç¨—è¦‡è²å½­æ¾Žçƒ¹è†¨æ„Žä¾¿åæ‰ç‰‡ç¯‡ç·¨ç¿©ééž­é¨™è²¶åªå¹³æž°èè©•å å¬–å¹£å»¢å¼Šæ–ƒè‚ºè”½é–‰é™›ä½ˆåŒ…åŒåŒå’†å“ºåœƒå¸ƒæ€–æŠ›æŠ±æ•ï¨†æ³¡æµ¦ç–±ç ²èƒžè„¯è‹žè‘¡è’²è¢è¤’é€‹é‹ªé£½é®‘å¹…æš´æ›ç€‘çˆ†ï¨‡ä¿µå‰½å½ªæ…“æ“æ¨™æ¼‚ç“¢ç¥¨è¡¨è±¹é£‡é£„é©ƒ"
  ],
  [
    "f9a1",
    "å“ç¨Ÿæ¥“è«·è±Šé¢¨é¦®å½¼æŠ«ç–²çš®è¢«é¿é™‚åŒ¹å¼¼å¿…æ³ŒçŒç•¢ç–‹ç­†è‹¾é¦ä¹é€¼ä¸‹ä½•åŽ¦å¤å»ˆæ˜°æ²³ç‘•è·è¦è³€ééœžé°•å£‘å­¸è™è¬”é¶´å¯’æ¨æ‚æ—±æ±—æ¼¢æ¾£ç€šç½•ç¿°é–‘é–’é™éŸ“å‰²è½„å‡½å«å’¸å•£å–Šæª»æ¶µç·˜è‰¦éŠœé™·é¹¹åˆå“ˆç›’è›¤é–¤é—”é™œäº¢ä¼‰å§®å«¦å··æ’æŠ—æ­æ¡æ²†æ¸¯ç¼¸è‚›èˆª"
  ],
  [
    "faa1",
    "ï¨ˆï¨‰é …äº¥å•å’³åž“å¥šå­©å®³æ‡ˆæ¥·æµ·ç€£èŸ¹è§£è©²è«§é‚‚é§­éª¸åŠ¾æ ¸å€–å¹¸æè‡è¡Œäº«å‘åš®ç¦é„•éŸ¿é¤‰é¥—é¦™å™“å¢Ÿè™›è¨±æ†²æ«¶ç»è»’æ­‡éšªé©—å¥•çˆ€èµ«é©ä¿”å³´å¼¦æ‡¸æ™›æ³«ç‚«çŽ„çŽ¹ç¾çœ©ççµƒçµ¢ç¸£èˆ·è¡’ï¨Šè³¢é‰‰é¡¯å­‘ç©´è¡€é å«Œä¿ å”å¤¾å³½æŒ¾æµ¹ç‹¹è„…è„‡èŽ¢é‹é °äº¨å…„åˆ‘åž‹"
  ],
  [
    "fba1",
    "å½¢æ³‚æ»Žç€…çç‚¯ç†’ç©ç‘©èŠèž¢è¡¡é€ˆé‚¢éŽ£é¦¨å…®å½—æƒ æ…§æš³è•™è¹Šé†¯éž‹ä¹Žäº’å‘¼å£•å£ºå¥½å²µå¼§æˆ¶æ‰ˆæ˜Šæ™§æ¯«æµ©æ·æ¹–æ»¸æ¾”æ¿ æ¿©çç‹ç¥ç‘šç“ çš“ç¥œç³Šç¸žèƒ¡èŠ¦è‘«è’¿è™Žè™Ÿè´è­·è±ªéŽ¬é €é¡¥æƒ‘æˆ–é…·å©šæ˜æ··æ¸¾ç¿é­‚å¿½æƒšç¬å“„å¼˜æ±žæ³“æ´ªçƒ˜ç´…è™¹è¨Œé´»åŒ–å’Œå¬…æ¨ºç«ç•µ"
  ],
  [
    "fca1",
    "ç¦ç¦¾èŠ±è¯è©±è­è²¨é´ï¨‹æ“´æ”«ç¢ºç¢»ç©«ä¸¸å–šå¥å®¦å¹»æ‚£æ›æ­¡æ™¥æ¡“æ¸™ç…¥ç’°ç´ˆé‚„é©©é°¥æ´»æ»‘çŒ¾è±é—Šå‡°å¹Œå¾¨ææƒ¶æ„°æ…Œæ™ƒæ™„æ¦¥æ³æ¹Ÿæ»‰æ½¢ç…Œç’œçš‡ç¯ç°§è’è—é‘éšé»ƒåŒ¯å›žå»»å¾Šæ¢æ‚”æ‡·æ™¦æœƒæªœæ·®æ¾®ç°çªç¹ªè†¾èŒ´è›”èª¨è³„åŠƒç²å®–æ©«é„å“®åš†å­æ•ˆæ–…æ›‰æ¢Ÿæ¶æ·†"
  ],
  [
    "fda1",
    "çˆ»è‚´é…µé©ä¾¯å€™åŽšåŽå¼å–‰å—…å¸¿å¾Œæœ½ç…¦çé€…å‹›å‹³å¡¤å£Žç„„ç†ç‡»è–°è¨“æšˆè–¨å–§æš„ç…Šè±å‰å–™æ¯å½™å¾½æ®æš‰ç…‡è«±è¼éº¾ä¼‘æºçƒ‹ç•¦è™§æ¤è­Žé·¸å…‡å‡¶åŒˆæ´¶èƒ¸é»‘æ˜•æ¬£ç‚˜ç—•åƒå±¹ç´‡è¨–æ¬ æ¬½æ­†å¸æ°æ´½ç¿•èˆˆåƒ–å‡žå–œå™«å›å§¬å¬‰å¸Œæ†™æ†˜æˆ±æ™žæ›¦ç†™ç†¹ç†ºçŠ§ç¦§ç¨€ç¾²è©°"
  ]
];
const require$$6 = [
  [
    "0",
    "\0",
    127
  ],
  [
    "a140",
    "ã€€ï¼Œã€ã€‚ï¼Žâ€§ï¼›ï¼šï¼Ÿï¼ï¸°â€¦â€¥ï¹ï¹‘ï¹’Â·ï¹”ï¹•ï¹–ï¹—ï½œâ€“ï¸±â€”ï¸³â•´ï¸´ï¹ï¼ˆï¼‰ï¸µï¸¶ï½›ï½ï¸·ï¸¸ã€”ã€•ï¸¹ï¸ºã€ã€‘ï¸»ï¸¼ã€Šã€‹ï¸½ï¸¾ã€ˆã€‰ï¸¿ï¹€ã€Œã€ï¹ï¹‚ã€Žã€ï¹ƒï¹„ï¹™ï¹š"
  ],
  [
    "a1a1",
    "ï¹›ï¹œï¹ï¹žâ€˜â€™â€œâ€ã€ã€žâ€µâ€²ï¼ƒï¼†ï¼Šâ€»Â§ã€ƒâ—‹â—â–³â–²â—Žâ˜†â˜…â—‡â—†â–¡â– â–½â–¼ãŠ£â„…Â¯ï¿£ï¼¿Ëï¹‰ï¹Šï¹ï¹Žï¹‹ï¹Œï¹Ÿï¹ ï¹¡ï¼‹ï¼Ã—Ã·Â±âˆšï¼œï¼žï¼â‰¦â‰§â‰ âˆžâ‰’â‰¡ï¹¢",
    4,
    "ï½žâˆ©âˆªâŠ¥âˆ âˆŸâŠ¿ã’ã‘âˆ«âˆ®âˆµâˆ´â™€â™‚âŠ•âŠ™â†‘â†“â†â†’â†–â†—â†™â†˜âˆ¥âˆ£ï¼"
  ],
  [
    "a240",
    "ï¼¼âˆ•ï¹¨ï¼„ï¿¥ã€’ï¿ ï¿¡ï¼…ï¼ â„ƒâ„‰ï¹©ï¹ªï¹«ã•ãŽœãŽãŽžãŽãŽ¡ãŽŽãŽã„Â°å…™å…›å…žå…å…¡å…£å—§ç“©ç³Žâ–",
    7,
    "â–â–Žâ–â–Œâ–‹â–Šâ–‰â”¼â”´â”¬â”¤â”œâ–”â”€â”‚â–•â”Œâ”â””â”˜â•­"
  ],
  [
    "a2a1",
    "â•®â•°â•¯â•â•žâ•ªâ•¡â—¢â—£â—¥â—¤â•±â•²â•³ï¼",
    9,
    "â… ",
    9,
    "ã€¡",
    8,
    "åå„å…ï¼¡",
    25,
    "ï½",
    21
  ],
  [
    "a340",
    "ï½—ï½˜ï½™ï½šÎ‘",
    16,
    "Î£",
    6,
    "Î±",
    16,
    "Ïƒ",
    6,
    "ã„…",
    10
  ],
  [
    "a3a1",
    "ã„",
    25,
    "Ë™Ë‰ËŠË‡Ë‹"
  ],
  [
    "a3e1",
    "â‚¬"
  ],
  [
    "a440",
    "ä¸€ä¹™ä¸ä¸ƒä¹ƒä¹äº†äºŒäººå„¿å…¥å…«å‡ åˆ€åˆåŠ›åŒ•ååœåˆä¸‰ä¸‹ä¸ˆä¸Šä¸«ä¸¸å‡¡ä¹…ä¹ˆä¹Ÿä¹žäºŽäº¡å…€åˆƒå‹ºåƒå‰å£åœŸå£«å¤•å¤§å¥³å­å­‘å­“å¯¸å°å°¢å°¸å±±å·å·¥å·±å·²å·³å·¾å¹²å»¾å¼‹å¼“æ‰"
  ],
  [
    "a4a1",
    "ä¸‘ä¸ä¸ä¸­ä¸°ä¸¹ä¹‹å°¹äºˆäº‘äº•äº’äº”äº¢ä»ä»€ä»ƒä»†ä»‡ä»ä»Šä»‹ä»„å…ƒå…å…§å…­å…®å…¬å†—å‡¶åˆ†åˆ‡åˆˆå‹»å‹¾å‹¿åŒ–åŒ¹åˆå‡å…åžåŽ„å‹åŠåå£¬å¤©å¤«å¤ªå¤­å­”å°‘å°¤å°ºå±¯å·´å¹»å»¿å¼”å¼•å¿ƒæˆˆæˆ¶æ‰‹æ‰Žæ”¯æ–‡æ–—æ–¤æ–¹æ—¥æ›°æœˆæœ¨æ¬ æ­¢æ­¹æ¯‹æ¯”æ¯›æ°æ°´ç«çˆªçˆ¶çˆ»ç‰‡ç‰™ç‰›çŠ¬çŽ‹ä¸™"
  ],
  [
    "a540",
    "ä¸–ä¸•ä¸”ä¸˜ä¸»ä¹ä¹ä¹Žä»¥ä»˜ä»”ä»•ä»–ä»—ä»£ä»¤ä»™ä»žå……å…„å†‰å†Šå†¬å‡¹å‡ºå‡¸åˆŠåŠ åŠŸåŒ…åŒ†åŒ—åŒä»ŸåŠå‰å¡å å¯å®åŽ»å¯å¤å³å¬å®å©å¨å¼å¸åµå«å¦åªå²å±å°å¥å­å»å››å›šå¤–"
  ],
  [
    "a5a1",
    "å¤®å¤±å¥´å¥¶å­•å®ƒå°¼å·¨å·§å·¦å¸‚å¸ƒå¹³å¹¼å¼å¼˜å¼—å¿…æˆŠæ‰“æ‰”æ‰’æ‰‘æ–¥æ—¦æœ®æœ¬æœªæœ«æœ­æ­£æ¯æ°‘æ°æ°¸æ±æ±€æ°¾çŠ¯çŽ„çŽ‰ç“œç“¦ç”˜ç”Ÿç”¨ç”©ç”°ç”±ç”²ç”³ç–‹ç™½çš®çš¿ç›®çŸ›çŸ¢çŸ³ç¤ºç¦¾ç©´ç«‹ä¸žä¸Ÿä¹’ä¹“ä¹©äº™äº¤äº¦äº¥ä»¿ä¼‰ä¼™ä¼Šä¼•ä¼ä¼ä¼‘ä¼ä»²ä»¶ä»»ä»°ä»³ä»½ä¼ä¼‹å…‰å…‡å…†å…ˆå…¨"
  ],
  [
    "a640",
    "å…±å†å†°åˆ—åˆ‘åˆ’åˆŽåˆ–åŠ£åŒˆåŒ¡åŒ å°å±å‰ååŒåŠååå‹å„å‘ååˆåƒåŽå†å’å› å›žå›åœ³åœ°åœ¨åœ­åœ¬åœ¯åœ©å¤™å¤šå¤·å¤¸å¦„å¥¸å¦ƒå¥½å¥¹å¦‚å¦å­—å­˜å®‡å®ˆå®…å®‰å¯ºå°–å±¹å·žå¸†å¹¶å¹´"
  ],
  [
    "a6a1",
    "å¼å¼›å¿™å¿–æˆŽæˆŒæˆæˆæ‰£æ‰›æ‰˜æ”¶æ—©æ—¨æ—¬æ—­æ›²æ›³æœ‰æœ½æœ´æœ±æœµæ¬¡æ­¤æ­»æ°–æ±æ±—æ±™æ±Ÿæ± æ±æ±•æ±¡æ±›æ±æ±Žç°ç‰Ÿç‰ç™¾ç«¹ç±³ç³¸ç¼¶ç¾Šç¾½è€è€ƒè€Œè€’è€³è¿è‚‰è‚‹è‚Œè‡£è‡ªè‡³è‡¼èˆŒèˆ›èˆŸè‰®è‰²è‰¾è™«è¡€è¡Œè¡£è¥¿é˜¡ä¸²äº¨ä½ä½ä½‡ä½—ä½žä¼´ä½›ä½•ä¼°ä½ä½‘ä¼½ä¼ºä¼¸ä½ƒä½”ä¼¼ä½†ä½£"
  ],
  [
    "a740",
    "ä½œä½ ä¼¯ä½Žä¼¶ä½™ä½ä½ˆä½šå…Œå…‹å…å…µå†¶å†·åˆ¥åˆ¤åˆ©åˆªåˆ¨åŠ«åŠ©åŠªåŠ¬åŒ£å³åµåå­åžå¾å¦å‘Žå§å‘†å‘ƒå³å‘ˆå‘‚å›å©å‘Šå¹å»å¸å®åµå¶å å¼å‘€å±å«åŸå¬å›ªå›°å›¤å›«åŠå‘å€å"
  ],
  [
    "a7a1",
    "å‡åŽåœ¾åååœ»å£¯å¤¾å¦å¦’å¦¨å¦žå¦£å¦™å¦–å¦å¦¤å¦“å¦Šå¦¥å­å­œå­šå­›å®Œå®‹å®å°¬å±€å±å°¿å°¾å²å²‘å²”å²Œå·«å¸Œåºåº‡åºŠå»·å¼„å¼Ÿå½¤å½¢å½·å½¹å¿˜å¿Œå¿—å¿å¿±å¿«å¿¸å¿ªæˆ’æˆ‘æŠ„æŠ—æŠ–æŠ€æ‰¶æŠ‰æ‰­æŠŠæ‰¼æ‰¾æ‰¹æ‰³æŠ’æ‰¯æŠ˜æ‰®æŠ•æŠ“æŠ‘æŠ†æ”¹æ”»æ”¸æ—±æ›´æŸæŽæææ‘æœæ–æžæ‰æ†æ "
  ],
  [
    "a840",
    "æ“æ—æ­¥æ¯æ±‚æ±žæ²™æ²æ²ˆæ²‰æ²…æ²›æ±ªæ±ºæ²æ±°æ²Œæ±¨æ²–æ²’æ±½æ²ƒæ±²æ±¾æ±´æ²†æ±¶æ²æ²”æ²˜æ²‚ç¶ç¼ç½ç¸ç‰¢ç‰¡ç‰ ç‹„ç‹‚çŽ–ç”¬ç”«ç”·ç”¸çš‚ç›¯çŸ£ç§ç§€ç¦¿ç©¶ç³»ç½•è‚–è‚“è‚è‚˜è‚›è‚šè‚²è‰¯èŠ’"
  ],
  [
    "a8a1",
    "èŠ‹èŠè¦‹è§’è¨€è°·è±†è±•è²èµ¤èµ°è¶³èº«è»Šè¾›è¾°è¿‚è¿†è¿…è¿„å·¡é‚‘é‚¢é‚ªé‚¦é‚£é…‰é‡†é‡Œé˜²é˜®é˜±é˜ªé˜¬ä¸¦ä¹–ä¹³äº‹äº›äºžäº«äº¬ä½¯ä¾ä¾ä½³ä½¿ä½¬ä¾›ä¾‹ä¾†ä¾ƒä½°ä½µä¾ˆä½©ä½»ä¾–ä½¾ä¾ä¾‘ä½ºå…”å…’å…•å…©å…·å…¶å…¸å†½å‡½åˆ»åˆ¸åˆ·åˆºåˆ°åˆ®åˆ¶å‰åŠ¾åŠ»å’å”å“å‘å¦å·å¸å¹å–å”å—å‘³å‘µ"
  ],
  [
    "a940",
    "å’–å‘¸å’•å’€å‘»å‘·å’„å’’å’†å‘¼å’å‘±å‘¶å’Œå’šå‘¢å‘¨å’‹å‘½å’Žå›ºåžƒå·åªå©å¡å¦å¤å¼å¤œå¥‰å¥‡å¥ˆå¥„å¥”å¦¾å¦»å§”å¦¹å¦®å§‘å§†å§å§å§‹å§“å§Šå¦¯å¦³å§’å§…å­Ÿå­¤å­£å®—å®šå®˜å®œå®™å®›å°šå±ˆå±…"
  ],
  [
    "a9a1",
    "å±†å²·å²¡å²¸å²©å²«å²±å²³å¸˜å¸šå¸–å¸•å¸›å¸‘å¹¸åºšåº—åºœåº•åº–å»¶å¼¦å¼§å¼©å¾€å¾å½¿å½¼å¿å¿ å¿½å¿µå¿¿æ€æ€”æ€¯æ€µæ€–æ€ªæ€•æ€¡æ€§æ€©æ€«æ€›æˆ–æˆ•æˆ¿æˆ¾æ‰€æ‰¿æ‹‰æ‹Œæ‹„æŠ¿æ‹‚æŠ¹æ‹’æ‹›æŠ«æ‹“æ‹”æ‹‹æ‹ˆæŠ¨æŠ½æŠ¼æ‹æ‹™æ‹‡æ‹æŠµæ‹šæŠ±æ‹˜æ‹–æ‹—æ‹†æŠ¬æ‹Žæ”¾æ–§æ–¼æ—ºæ˜”æ˜“æ˜Œæ˜†æ˜‚æ˜Žæ˜€æ˜æ˜•æ˜Š"
  ],
  [
    "aa40",
    "æ˜‡æœæœ‹æ­æž‹æž•æ±æžœæ³æ·æž‡æžæž—æ¯æ°æ¿æž‰æ¾æžæµæžšæž“æ¼æªæ²æ¬£æ­¦æ­§æ­¿æ°“æ°›æ³£æ³¨æ³³æ²±æ³Œæ³¥æ²³æ²½æ²¾æ²¼æ³¢æ²«æ³•æ³“æ²¸æ³„æ²¹æ³æ²®æ³—æ³…æ³±æ²¿æ²»æ³¡æ³›æ³Šæ²¬æ³¯æ³œæ³–æ³ "
  ],
  [
    "aaa1",
    "ç‚•ç‚Žç‚’ç‚Šç‚™çˆ¬çˆ­çˆ¸ç‰ˆç‰§ç‰©ç‹€ç‹Žç‹™ç‹—ç‹çŽ©çŽ¨çŽŸçŽ«çŽ¥ç”½ç–ç–™ç–šçš„ç›‚ç›²ç›´çŸ¥çŸ½ç¤¾ç¥€ç¥ç§‰ç§ˆç©ºç©¹ç«ºç³¾ç½”ç¾Œç¾‹è€…è‚ºè‚¥è‚¢è‚±è‚¡è‚«è‚©è‚´è‚ªè‚¯è‡¥è‡¾èˆèŠ³èŠèŠ™èŠ­èŠ½èŠŸèŠ¹èŠ±èŠ¬èŠ¥èŠ¯èŠ¸èŠ£èŠ°èŠ¾èŠ·è™Žè™±åˆè¡¨è»‹è¿Žè¿”è¿‘é‚µé‚¸é‚±é‚¶é‡‡é‡‘é•·é–€é˜œé™€é˜¿é˜»é™„"
  ],
  [
    "ab40",
    "é™‚éš¹é›¨é’éžäºŸäº­äº®ä¿¡ä¾µä¾¯ä¾¿ä¿ ä¿‘ä¿ä¿ä¿ƒä¾¶ä¿˜ä¿Ÿä¿Šä¿—ä¾®ä¿ä¿„ä¿‚ä¿šä¿Žä¿žä¾·å…—å†’å†‘å† å‰Žå‰ƒå‰Šå‰å‰Œå‰‹å‰‡å‹‡å‹‰å‹ƒå‹åŒå—å»åŽšå›å’¬å“€å’¨å“Žå“‰å’¸å’¦å’³å“‡å“‚å’½å’ªå“"
  ],
  [
    "aba1",
    "å“„å“ˆå’¯å’«å’±å’»å’©å’§å’¿å›¿åž‚åž‹åž åž£åž¢åŸŽåž®åž“å¥•å¥‘å¥å¥Žå¥å§œå§˜å§¿å§£å§¨å¨ƒå§¥å§ªå§šå§¦å¨å§»å­©å®£å®¦å®¤å®¢å®¥å°å±Žå±å±å±‹å³™å³’å··å¸å¸¥å¸Ÿå¹½åº åº¦å»ºå¼ˆå¼­å½¥å¾ˆå¾…å¾Šå¾‹å¾‡å¾Œå¾‰æ€’æ€æ€ æ€¥æ€Žæ€¨ææ°æ¨æ¢æ†æƒæ¬æ«æªæ¤æ‰æ‹œæŒ–æŒ‰æ‹¼æ‹­æŒæ‹®æ‹½æŒ‡æ‹±æ‹·"
  ],
  [
    "ac40",
    "æ‹¯æ‹¬æ‹¾æ‹´æŒ‘æŒ‚æ”¿æ•…æ–«æ–½æ—¢æ˜¥æ˜­æ˜ æ˜§æ˜¯æ˜Ÿæ˜¨æ˜±æ˜¤æ›·æŸ¿æŸ“æŸ±æŸ”æŸæŸ¬æž¶æž¯æŸµæŸ©æŸ¯æŸ„æŸ‘æž´æŸšæŸ¥æž¸æŸæŸžæŸ³æž°æŸ™æŸ¢æŸæŸ’æ­ªæ®ƒæ®†æ®µæ¯’æ¯—æ°Ÿæ³‰æ´‹æ´²æ´ªæµæ´¥æ´Œæ´±æ´žæ´—"
  ],
  [
    "aca1",
    "æ´»æ´½æ´¾æ´¶æ´›æ³µæ´¹æ´§æ´¸æ´©æ´®æ´µæ´Žæ´«ç‚«ç‚ºç‚³ç‚¬ç‚¯ç‚­ç‚¸ç‚®ç‚¤çˆ°ç‰²ç‰¯ç‰´ç‹©ç‹ ç‹¡çŽ·çŠçŽ»çŽ²çç€çŽ³ç”šç”­ç•ç•Œç•Žç•‹ç–«ç–¤ç–¥ç–¢ç–£ç™¸çš†çš‡çšˆç›ˆç›†ç›ƒç›…çœç›¹ç›¸çœ‰çœ‹ç›¾ç›¼çœ‡çŸœç ‚ç ”ç Œç ç¥†ç¥‰ç¥ˆç¥‡ç¦¹ç¦ºç§‘ç§’ç§‹ç©¿çªç«¿ç«½ç±½ç´‚ç´…ç´€ç´‰ç´‡ç´„ç´†ç¼¸ç¾Žç¾¿è€„"
  ],
  [
    "ad40",
    "è€è€è€‘è€¶èƒ–èƒ¥èƒšèƒƒèƒ„èƒŒèƒ¡èƒ›èƒŽèƒžèƒ¤èƒè‡´èˆ¢è‹§èŒƒèŒ…è‹£è‹›è‹¦èŒ„è‹¥èŒ‚èŒ‰è‹’è‹—è‹±èŒè‹œè‹”è‹‘è‹žè‹“è‹Ÿè‹¯èŒ†è™è™¹è™»è™ºè¡è¡«è¦è§”è¨ˆè¨‚è¨ƒè²žè² èµ´èµ³è¶´è»è»Œè¿°è¿¦è¿¢è¿ªè¿¥"
  ],
  [
    "ada1",
    "è¿­è¿«è¿¤è¿¨éƒŠéƒŽéƒéƒƒé…‹é…Šé‡é–‚é™é™‹é™Œé™é¢é©éŸ‹éŸ­éŸ³é é¢¨é£›é£Ÿé¦–é¦™ä¹˜äº³å€Œå€å€£ä¿¯å€¦å€¥ä¿¸å€©å€–å€†å€¼å€Ÿå€šå€’å€‘ä¿ºå€€å€”å€¨ä¿±å€¡å€‹å€™å€˜ä¿³ä¿®å€­å€ªä¿¾å€«å€‰å…¼å†¤å†¥å†¢å‡å‡Œå‡†å‡‹å‰–å‰œå‰”å‰›å‰åŒªå¿åŽŸåŽåŸå“¨å”å”å”·å“¼å“¥å“²å”†å“ºå””å“©å“­å“¡å”‰å“®å“ª"
  ],
  [
    "ae40",
    "å“¦å”§å”‡å“½å”åœƒåœ„åŸ‚åŸ”åŸ‹åŸƒå ‰å¤å¥—å¥˜å¥šå¨‘å¨˜å¨œå¨Ÿå¨›å¨“å§¬å¨ å¨£å¨©å¨¥å¨Œå¨‰å­«å±˜å®°å®³å®¶å®´å®®å®µå®¹å®¸å°„å±‘å±•å±å³­å³½å³»å³ªå³¨å³°å³¶å´å³´å·®å¸­å¸«åº«åº­åº§å¼±å¾’å¾‘å¾æ™"
  ],
  [
    "aea1",
    "æ£æ¥ææ•æ­æ©æ¯æ‚„æ‚Ÿæ‚šæ‚æ‚”æ‚Œæ‚…æ‚–æ‰‡æ‹³æŒˆæ‹¿æŽæŒ¾æŒ¯æ•æ‚æ†ææ‰æŒºææŒ½æŒªæŒ«æŒ¨ææŒæ•ˆæ•‰æ–™æ—æ—…æ™‚æ™‰æ™æ™ƒæ™’æ™Œæ™…æ™æ›¸æœ”æœ•æœ—æ ¡æ ¸æ¡ˆæ¡†æ¡“æ ¹æ¡‚æ¡”æ ©æ¢³æ —æ¡Œæ¡‘æ ½æŸ´æ¡æ¡€æ ¼æ¡ƒæ ªæ¡…æ “æ ˜æ¡æ®Šæ®‰æ®·æ°£æ°§æ°¨æ°¦æ°¤æ³°æµªæ¶•æ¶ˆæ¶‡æµ¦æµ¸æµ·æµ™æ¶“"
  ],
  [
    "af40",
    "æµ¬æ¶‰æµ®æµšæµ´æµ©æ¶Œæ¶Šæµ¹æ¶…æµ¥æ¶”çƒŠçƒ˜çƒ¤çƒ™çƒˆçƒçˆ¹ç‰¹ç‹¼ç‹¹ç‹½ç‹¸ç‹·çŽ†ç­ç‰ç®ç çªçžç•”ç•ç•œç•šç•™ç–¾ç—…ç—‡ç–²ç–³ç–½ç–¼ç–¹ç—‚ç–¸çš‹çš°ç›Šç›ç›Žçœ©çœŸçœ çœ¨çŸ©ç °ç §ç ¸ç ç ´ç ·"
  ],
  [
    "afa1",
    "ç ¥ç ­ç  ç Ÿç ²ç¥•ç¥ç¥ ç¥Ÿç¥–ç¥žç¥ç¥—ç¥šç§¤ç§£ç§§ç§Ÿç§¦ç§©ç§˜çª„çªˆç«™ç¬†ç¬‘ç²‰ç´¡ç´—ç´‹ç´Šç´ ç´¢ç´”ç´ç´•ç´šç´œç´ç´™ç´›ç¼ºç½Ÿç¾”ç¿…ç¿è€†è€˜è€•è€™è€—è€½è€¿èƒ±è„‚èƒ°è„…èƒ­èƒ´è„†èƒ¸èƒ³è„ˆèƒ½è„Šèƒ¼èƒ¯è‡­è‡¬èˆ€èˆèˆªèˆ«èˆ¨èˆ¬èŠ»èŒ«è’è”èŠèŒ¸èè‰èŒµèŒ´èèŒ²èŒ¹èŒ¶èŒ—è€èŒ±èŒ¨èƒ"
  ],
  [
    "b040",
    "è™”èšŠèšªèš“èš¤èš©èšŒèš£èšœè¡°è¡·è¢è¢‚è¡½è¡¹è¨˜è¨è¨Žè¨Œè¨•è¨Šè¨—è¨“è¨–è¨è¨‘è±ˆè±ºè±¹è²¡è²¢èµ·èº¬è»’è»”è»è¾±é€é€†è¿·é€€è¿ºè¿´é€ƒè¿½é€…è¿¸é‚•éƒ¡éƒéƒ¢é…’é…é…Œé‡˜é‡é‡—é‡œé‡™é–ƒé™¢é™£é™¡"
  ],
  [
    "b0a1",
    "é™›é™é™¤é™˜é™žéš»é£¢é¦¬éª¨é«˜é¬¥é¬²é¬¼ä¹¾åºå½åœå‡åƒåŒåšå‰å¥å¶åŽå•åµå´å·åå€å¯å­å…œå†•å‡°å‰ªå‰¯å‹’å‹™å‹˜å‹•åŒåŒåŒ™åŒ¿å€åŒ¾åƒæ›¼å•†å•ªå•¦å•„å•žå•¡å•ƒå•Šå”±å•–å•å••å”¯å•¤å”¸å”®å•œå”¬å•£å”³å•å•—åœˆåœ‹åœ‰åŸŸå …å Šå †åŸ åŸ¤åŸºå ‚å µåŸ·åŸ¹å¤ å¥¢å¨¶å©å©‰å©¦å©ªå©€"
  ],
  [
    "b140",
    "å¨¼å©¢å©šå©†å©Šå­°å¯‡å¯…å¯„å¯‚å®¿å¯†å°‰å°ˆå°‡å± å±œå±å´‡å´†å´Žå´›å´–å´¢å´‘å´©å´”å´™å´¤å´§å´—å·¢å¸¸å¸¶å¸³å¸·åº·åº¸åº¶åºµåº¾å¼µå¼·å½—å½¬å½©å½«å¾—å¾™å¾žå¾˜å¾¡å¾ å¾œæ¿æ‚£æ‚‰æ‚ æ‚¨æƒ‹æ‚´æƒ¦æ‚½"
  ],
  [
    "b1a1",
    "æƒ…æ‚»æ‚µæƒœæ‚¼æƒ˜æƒ•æƒ†æƒŸæ‚¸æƒšæƒ‡æˆšæˆ›æ‰ˆæŽ æŽ§æ²æŽ–æŽ¢æŽ¥æ·æ§æŽ˜æŽªæ±æŽ©æŽ‰æŽƒæŽ›æ«æŽ¨æŽ„æŽˆæŽ™æŽ¡æŽ¬æŽ’æŽæŽ€æ»æ©æ¨æºæ•æ•–æ•‘æ•™æ•—å•Ÿæ•æ•˜æ••æ•”æ–œæ–›æ–¬æ—æ—‹æ—Œæ—Žæ™æ™šæ™¤æ™¨æ™¦æ™žæ›¹å‹—æœ›æ¢æ¢¯æ¢¢æ¢“æ¢µæ¡¿æ¡¶æ¢±æ¢§æ¢—æ¢°æ¢ƒæ£„æ¢­æ¢†æ¢…æ¢”æ¢æ¢¨æ¢Ÿæ¢¡æ¢‚æ¬²æ®º"
  ],
  [
    "b240",
    "æ¯«æ¯¬æ°«æ¶Žæ¶¼æ·³æ·™æ¶²æ·¡æ·Œæ·¤æ·»æ·ºæ¸…æ·‡æ·‹æ¶¯æ·‘æ¶®æ·žæ·¹æ¶¸æ··æ·µæ·…æ·’æ¸šæ¶µæ·šæ·«æ·˜æ·ªæ·±æ·®æ·¨æ·†æ·„æ¶ªæ·¬æ¶¿æ·¦çƒ¹ç„‰ç„Šçƒ½çƒ¯çˆ½ç‰½çŠçŒœçŒ›çŒ–çŒ“çŒ™çŽ‡ç…çŠçƒç†ç¾çç“ ç“¶"
  ],
  [
    "b2a1",
    "ç“·ç”œç”¢ç•¥ç•¦ç•¢ç•°ç–ç—”ç—•ç–µç—Šç—çšŽç›”ç›’ç››çœ·çœ¾çœ¼çœ¶çœ¸çœºç¡«ç¡ƒç¡Žç¥¥ç¥¨ç¥­ç§»çª’çª•ç¬ ç¬¨ç¬›ç¬¬ç¬¦ç¬™ç¬žç¬®ç²’ç²—ç²•çµ†çµƒçµ±ç´®ç´¹ç´¼çµ€ç´°ç´³çµ„ç´¯çµ‚ç´²ç´±ç¼½ç¾žç¾šç¿Œç¿Žç¿’è€œèŠè†è„¯è„–è„£è„«è„©è„°è„¤èˆ‚èˆµèˆ·èˆ¶èˆ¹èŽŽèŽžèŽ˜è¸èŽ¢èŽ–èŽ½èŽ«èŽ’èŽŠèŽ“èŽ‰èŽ è·è»è¼"
  ],
  [
    "b340",
    "èŽ†èŽ§è™•å½ªè›‡è›€èš¶è›„èšµè›†è›‹èš±èš¯è›‰è¡“è¢žè¢ˆè¢«è¢’è¢–è¢è¢‹è¦“è¦è¨ªè¨è¨£è¨¥è¨±è¨­è¨Ÿè¨›è¨¢è±‰è±šè²©è²¬è²«è²¨è²ªè²§èµ§èµ¦è¶¾è¶ºè»›è»Ÿé€™é€é€šé€—é€£é€Ÿé€é€é€•é€žé€ é€é€¢é€–é€›é€”"
  ],
  [
    "b3a1",
    "éƒ¨éƒ­éƒ½é…—é‡Žé‡µé‡¦é‡£é‡§é‡­é‡©é–‰é™ªé™µé™³é™¸é™°é™´é™¶é™·é™¬é›€é›ªé›©ç« ç«Ÿé ‚é ƒé­šé³¥é¹µé¹¿éº¥éº»å‚¢å‚å‚…å‚™å‚‘å‚€å‚–å‚˜å‚šæœ€å‡±å‰²å‰´å‰µå‰©å‹žå‹å‹›åšåŽ¥å•»å–€å–§å•¼å–Šå–å–˜å–‚å–œå–ªå–”å–‡å–‹å–ƒå–³å–®å–Ÿå”¾å–²å–šå–»å–¬å–±å•¾å–‰å–«å–™åœå ¯å ªå ´å ¤å °å ±å ¡å å  å£¹å£ºå¥ "
  ],
  [
    "b440",
    "å©·åªšå©¿åª’åª›åª§å­³å­±å¯’å¯Œå¯“å¯å°Šå°‹å°±åµŒåµå´´åµ‡å·½å¹…å¸½å¹€å¹ƒå¹¾å»Šå»å»‚å»„å¼¼å½­å¾©å¾ªå¾¨æƒ‘æƒ¡æ‚²æ‚¶æƒ æ„œæ„£æƒºæ„•æƒ°æƒ»æƒ´æ…¨æƒ±æ„Žæƒ¶æ„‰æ„€æ„’æˆŸæ‰‰æŽ£æŽŒææ€æ©æ‰æ†æ"
  ],
  [
    "b4a1",
    "æ’æ£ææ¡æ–æ­æ®æ¶æ´æªæ›æ‘’æšæ¹æ•žæ•¦æ•¢æ•£æ–‘æ–æ–¯æ™®æ™°æ™´æ™¶æ™¯æš‘æ™ºæ™¾æ™·æ›¾æ›¿æœŸæœæ£ºæ£•æ£ æ£˜æ£—æ¤…æ£Ÿæ£µæ£®æ£§æ£¹æ£’æ£²æ££æ£‹æ£æ¤æ¤’æ¤Žæ£‰æ£šæ¥®æ£»æ¬¾æ¬ºæ¬½æ®˜æ®–æ®¼æ¯¯æ°®æ°¯æ°¬æ¸¯æ¸¸æ¹”æ¸¡æ¸²æ¹§æ¹Šæ¸ æ¸¥æ¸£æ¸›æ¹›æ¹˜æ¸¤æ¹–æ¹®æ¸­æ¸¦æ¹¯æ¸´æ¹æ¸ºæ¸¬æ¹ƒæ¸æ¸¾æ»‹"
  ],
  [
    "b540",
    "æº‰æ¸™æ¹Žæ¹£æ¹„æ¹²æ¹©æ¹Ÿç„™ç„šç„¦ç„°ç„¡ç„¶ç…®ç„œç‰ŒçŠ„çŠ€çŒ¶çŒ¥çŒ´çŒ©çºçªç³ç¢ç¥çµç¶ç´ç¯ç›ç¦ç¨ç”¥ç”¦ç•«ç•ªç—¢ç—›ç—£ç—™ç—˜ç—žç— ç™»ç™¼çš–çš“çš´ç›œççŸ­ç¡ç¡¬ç¡¯ç¨ç¨ˆç¨‹ç¨…ç¨€çª˜"
  ],
  [
    "b5a1",
    "çª—çª–ç«¥ç«£ç­‰ç­–ç­†ç­ç­’ç­”ç­ç­‹ç­ç­‘ç²Ÿç²¥çµžçµçµ¨çµ•ç´«çµ®çµ²çµ¡çµ¦çµ¢çµ°çµ³å–„ç¿”ç¿•è€‹è’è‚…è…•è…”è…‹è…‘è…Žè„¹è…†è„¾è…Œè…“è…´èˆ’èˆœè©èƒè¸èè è…è‹èè¯è±è´è‘—èŠè°èŒèŒè½è²èŠè¸èŽè„èœè‡è”èŸè™›è›Ÿè›™è›­è›”è››è›¤è›è›žè¡—è£è£‚è¢±è¦ƒè¦–è¨»è© è©•è©žè¨¼è©"
  ],
  [
    "b640",
    "è©”è©›è©è©†è¨´è¨ºè¨¶è©–è±¡è²‚è²¯è²¼è²³è²½è³è²»è³€è²´è²·è²¶è²¿è²¸è¶Šè¶…è¶è·Žè·è·‹è·šè·‘è·Œè·›è·†è»»è»¸è»¼è¾œé€®é€µé€±é€¸é€²é€¶é„‚éƒµé„‰éƒ¾é…£é…¥é‡éˆ”éˆ•éˆ£éˆ‰éˆžéˆéˆéˆ‡éˆ‘é–”é–é–‹é–‘"
  ],
  [
    "b6a1",
    "é–“é–’é–ŽéšŠéšŽéš‹é™½éš…éš†éšé™²éš„é›é›…é›„é›†é›‡é›¯é›²éŸŒé …é †é ˆé£§é£ªé£¯é£©é£²é£­é¦®é¦­é»ƒé»é»‘äº‚å‚­å‚µå‚²å‚³åƒ…å‚¾å‚¬å‚·å‚»å‚¯åƒ‡å‰¿å‰·å‰½å‹Ÿå‹¦å‹¤å‹¢å‹£åŒ¯å—Ÿå—¨å—“å—¦å—Žå—œå—‡å—‘å—£å—¤å—¯å—šå—¡å—…å—†å—¥å—‰åœ’åœ“å¡žå¡‘å¡˜å¡—å¡šå¡”å¡«å¡Œå¡­å¡Šå¡¢å¡’å¡‹å¥§å«å«‰å«Œåª¾åª½åª¼"
  ],
  [
    "b740",
    "åª³å«‚åª²åµ©åµ¯å¹Œå¹¹å»‰å»ˆå¼’å½™å¾¬å¾®æ„šæ„æ…ˆæ„Ÿæƒ³æ„›æƒ¹æ„æ„ˆæ…Žæ…Œæ…„æ…æ„¾æ„´æ„§æ„æ„†æ„·æˆ¡æˆ¢æ“æ¾æžæªæ­æ½æ¬ææœæ”ææ¶æ–æ—æ†æ•¬æ–Ÿæ–°æš—æš‰æš‡æšˆæš–æš„æš˜æšæœƒæ¦”æ¥­"
  ],
  [
    "b7a1",
    "æ¥šæ¥·æ¥ æ¥”æ¥µæ¤°æ¦‚æ¥Šæ¥¨æ¥«æ¥žæ¥“æ¥¹æ¦†æ¥æ¥£æ¥›æ­‡æ­²æ¯€æ®¿æ¯“æ¯½æº¢æº¯æ»“æº¶æ»‚æºæºæ»‡æ»…æº¥æº˜æº¼æººæº«æ»‘æº–æºœæ»„æ»”æºªæº§æº´ç…Žç…™ç…©ç…¤ç…‰ç…§ç…œç…¬ç…¦ç…Œç…¥ç…žç…†ç…¨ç…–çˆºç‰’çŒ·ç…çŒ¿çŒ¾ç‘¯ç‘šç‘•ç‘Ÿç‘žç‘ç¿ç‘™ç‘›ç‘œç•¶ç•¸ç˜€ç—°ç˜ç—²ç—±ç—ºç—¿ç—´ç—³ç›žç›Ÿç›ç«ç¦çžç£"
  ],
  [
    "b840",
    "ç¹çªç¬çœç¥ç¨ç¢çŸ®ç¢Žç¢°ç¢—ç¢˜ç¢Œç¢‰ç¡¼ç¢‘ç¢“ç¡¿ç¥ºç¥¿ç¦è¬ç¦½ç¨œç¨šç¨ ç¨”ç¨Ÿç¨žçªŸçª ç­·ç¯€ç­ ç­®ç­§ç²±ç²³ç²µç¶“çµ¹ç¶‘ç¶ç¶çµ›ç½®ç½©ç½ªç½²ç¾©ç¾¨ç¾¤è–è˜è‚†è‚„è…±è…°è…¸è…¥è…®è…³è…«"
  ],
  [
    "b8a1",
    "è…¹è…ºè…¦èˆ…è‰‡è’‚è‘·è½è±è‘µè‘¦è‘«è‘‰è‘¬è‘›è¼èµè‘¡è‘£è‘©è‘­è‘†è™žè™œè™Ÿè›¹èœ“èœˆèœ‡èœ€è›¾è›»èœ‚èœƒèœ†èœŠè¡™è£Ÿè£”è£™è£œè£˜è£è£¡è£Šè£•è£’è¦œè§£è©«è©²è©³è©¦è©©è©°èª‡è©¼è©£èª è©±èª…è©­è©¢è©®è©¬è©¹è©»è¨¾è©¨è±¢è²Šè²‰è³Šè³‡è³ˆè³„è²²è³ƒè³‚è³…è·¡è·Ÿè·¨è·¯è·³è·ºè·ªè·¤è·¦èº²è¼ƒè¼‰è»¾è¼Š"
  ],
  [
    "b940",
    "è¾Ÿè¾²é‹éŠé“é‚é”é€¼é•éé‡ééŽéé‘é€¾éé„’é„—é…¬é…ªé…©é‡‰éˆ·é‰—éˆ¸éˆ½é‰€éˆ¾é‰›é‰‹é‰¤é‰‘éˆ´é‰‰é‰é‰…éˆ¹éˆ¿é‰šé–˜éš˜éš”éš•é›é›‹é›‰é›Šé›·é›»é›¹é›¶é–é´é¶é é ‘é “é Šé ’é Œé£¼é£´"
  ],
  [
    "b9a1",
    "é£½é£¾é¦³é¦±é¦´é«¡é³©éº‚é¼Žé¼“é¼ åƒ§åƒ®åƒ¥åƒ–åƒ­åƒšåƒ•åƒåƒ‘åƒ±åƒŽåƒ©å…¢å‡³åŠƒåŠ‚åŒ±åŽ­å—¾å˜€å˜›å˜—å—½å˜”å˜†å˜‰å˜å˜Žå—·å˜–å˜Ÿå˜ˆå˜å—¶åœ˜åœ–å¡µå¡¾å¢ƒå¢“å¢Šå¡¹å¢…å¡½å£½å¤¥å¤¢å¤¤å¥ªå¥©å«¡å«¦å«©å«—å«–å«˜å«£å­µå¯žå¯§å¯¡å¯¥å¯¦å¯¨å¯¢å¯¤å¯Ÿå°å±¢å¶„å¶‡å¹›å¹£å¹•å¹—å¹”å»“å»–å¼Šå½†å½°å¾¹æ…‡"
  ],
  [
    "ba40",
    "æ„¿æ…‹æ…·æ…¢æ…£æ…Ÿæ…šæ…˜æ…µæˆªæ’‡æ‘˜æ‘”æ’¤æ‘¸æ‘Ÿæ‘ºæ‘‘æ‘§æ´æ‘­æ‘»æ•²æ–¡æ——æ—–æš¢æš¨æšæ¦œæ¦¨æ¦•æ§æ¦®æ§“æ§‹æ¦›æ¦·æ¦»æ¦«æ¦´æ§æ§æ¦­æ§Œæ¦¦æ§ƒæ¦£æ­‰æ­Œæ°³æ¼³æ¼”æ»¾æ¼“æ»´æ¼©æ¼¾æ¼ æ¼¬æ¼æ¼‚æ¼¢"
  ],
  [
    "baa1",
    "æ»¿æ»¯æ¼†æ¼±æ¼¸æ¼²æ¼£æ¼•æ¼«æ¼¯æ¾ˆæ¼ªæ»¬æ¼æ»²æ»Œæ»·ç†”ç†™ç…½ç†Šç†„ç†’çˆ¾çŠ’çŠ–ç„çç‘¤ç‘£ç‘ªç‘°ç‘­ç”„ç–‘ç˜§ç˜ç˜‹ç˜‰ç˜“ç›¡ç›£çž„ç½ç¿ç¡ç£ç¢Ÿç¢§ç¢³ç¢©ç¢£ç¦Žç¦ç¦ç¨®ç¨±çªªçª©ç«­ç«¯ç®¡ç®•ç®‹ç­µç®—ç®ç®”ç®ç®¸ç®‡ç®„ç²¹ç²½ç²¾ç¶»ç¶°ç¶œç¶½ç¶¾ç¶ ç·Šç¶´ç¶²ç¶±ç¶ºç¶¢ç¶¿ç¶µç¶¸ç¶­ç·’ç·‡ç¶¬"
  ],
  [
    "bb40",
    "ç½°ç¿ ç¿¡ç¿Ÿèžèšè‚‡è…è†€è†è†ˆè†Šè…¿è†‚è‡§è‡ºèˆ‡èˆ”èˆžè‰‹è“‰è’¿è“†è“„è’™è’žè’²è’œè“‹è’¸è“€è““è’è’¼è“‘è“Šèœ¿èœœèœ»èœ¢èœ¥èœ´èœ˜è•èœ·èœ©è£³è¤‚è£´è£¹è£¸è£½è£¨è¤šè£¯èª¦èªŒèªžèª£èªèª¡èª“èª¤"
  ],
  [
    "bba1",
    "èªªèª¥èª¨èª˜èª‘èªšèª§è±ªè²è²Œè³“è³‘è³’èµ«è¶™è¶•è·¼è¼”è¼’è¼•è¼“è¾£é é˜éœé£é™éžé¢éé›é„™é„˜é„žé…µé…¸é…·é…´é‰¸éŠ€éŠ…éŠ˜éŠ–é‰»éŠ“éŠœéŠ¨é‰¼éŠ‘é–¡é–¨é–©é–£é–¥é–¤éš™éšœéš›é›Œé›’éœ€é¼éž…éŸ¶é —é ˜é¢¯é¢±é¤ƒé¤…é¤Œé¤‰é§éª¯éª°é«¦é­é­‚é³´é³¶é³³éº¼é¼»é½Šå„„å„€åƒ»åƒµåƒ¹å„‚å„ˆå„‰å„…å‡œ"
  ],
  [
    "bc40",
    "åŠ‡åŠˆåŠ‰åŠåŠŠå‹°åŽ²å˜®å˜»å˜¹å˜²å˜¿å˜´å˜©å™“å™Žå™—å™´å˜¶å˜¯å˜°å¢€å¢Ÿå¢žå¢³å¢œå¢®å¢©å¢¦å¥­å¬‰å«»å¬‹å«µå¬Œå¬ˆå¯®å¯¬å¯©å¯«å±¤å±¥å¶å¶”å¹¢å¹Ÿå¹¡å»¢å»šå»Ÿå»å»£å» å½ˆå½±å¾·å¾µæ…¶æ…§æ…®æ…æ…•æ†‚"
  ],
  [
    "bca1",
    "æ…¼æ…°æ…«æ…¾æ†§æ†æ†«æ†Žæ†¬æ†šæ†¤æ†”æ†®æˆ®æ‘©æ‘¯æ‘¹æ’žæ’²æ’ˆæ’æ’°æ’¥æ’“æ’•æ’©æ’’æ’®æ’­æ’«æ’šæ’¬æ’™æ’¢æ’³æ•µæ•·æ•¸æš®æš«æš´æš±æ¨£æ¨Ÿæ§¨æ¨æ¨žæ¨™æ§½æ¨¡æ¨“æ¨Šæ§³æ¨‚æ¨…æ§­æ¨‘æ­æ­Žæ®¤æ¯…æ¯†æ¼¿æ½¼æ¾„æ½‘æ½¦æ½”æ¾†æ½­æ½›æ½¸æ½®æ¾Žæ½ºæ½°æ½¤æ¾—æ½˜æ»•æ½¯æ½ æ½Ÿç†Ÿç†¬ç†±ç†¨ç‰–çŠ›çŽç—ç‘©ç’‹ç’ƒ"
  ],
  [
    "bd40",
    "ç‘¾ç’€ç•¿ç˜ ç˜©ç˜Ÿç˜¤ç˜¦ç˜¡ç˜¢çššçšºç›¤çžŽçž‡çžŒçž‘çž‹ç£‹ç£…ç¢ºç£Šç¢¾ç£•ç¢¼ç£ç¨¿ç¨¼ç©€ç¨½ç¨·ç¨»çª¯çª®ç®­ç®±ç¯„ç®´ç¯†ç¯‡ç¯ç® ç¯Œç³Šç· ç·´ç·¯ç·»ç·˜ç·¬ç·ç·¨ç·£ç·šç·žç·©ç¶žç·™ç·²ç·¹ç½µç½·ç¾¯"
  ],
  [
    "bda1",
    "ç¿©è€¦è†›è†œè†è† è†šè†˜è”—è”½è”šè“®è”¬è”­è”“è”‘è”£è”¡è””è“¬è”¥è“¿è”†èž‚è´è¶è è¦è¸è¨è™è—èŒè“è¡›è¡è¤è¤‡è¤’è¤“è¤•è¤Šèª¼è«’è«‡è«„èª•è«‹è«¸èª²è«‰è«‚èª¿èª°è«–è«èª¶èª¹è«›è±Œè±Žè±¬è³ è³žè³¦è³¤è³¬è³­è³¢è³£è³œè³ªè³¡èµ­è¶Ÿè¶£è¸«è¸è¸è¸¢è¸è¸©è¸Ÿè¸¡è¸žèººè¼è¼›è¼Ÿè¼©è¼¦è¼ªè¼œè¼ž"
  ],
  [
    "be40",
    "è¼¥é©é®é¨é­é·é„°é„­é„§é„±é†‡é†‰é†‹é†ƒé‹…éŠ»éŠ·é‹ªéŠ¬é‹¤é‹éŠ³éŠ¼é‹’é‹‡é‹°éŠ²é–­é–±éœ„éœ†éœ‡éœ‰é éžéž‹éžé ¡é «é œé¢³é¤Šé¤“é¤’é¤˜é§é§é§Ÿé§›é§‘é§•é§’é§™éª·é«®é«¯é¬§é­…é­„é­·é­¯é´†é´‰"
  ],
  [
    "bea1",
    "é´ƒéº©éº¾é»Žå¢¨é½’å„’å„˜å„”å„å„•å†€å†ªå‡åŠ‘åŠ“å‹³å™™å™«å™¹å™©å™¤å™¸å™ªå™¨å™¥å™±å™¯å™¬å™¢å™¶å£å¢¾å£‡å£…å¥®å¬å¬´å­¸å¯°å°Žå½Šæ†²æ†‘æ†©æ†Šæ‡æ†¶æ†¾æ‡Šæ‡ˆæˆ°æ“…æ“æ“‹æ’»æ’¼æ“šæ“„æ“‡æ“‚æ“æ’¿æ“’æ“”æ’¾æ•´æ›†æ›‰æš¹æ›„æ›‡æš¸æ¨½æ¨¸æ¨ºæ©™æ©«æ©˜æ¨¹æ©„æ©¢æ©¡æ©‹æ©‡æ¨µæ©Ÿæ©ˆæ­™æ­·æ°…æ¿‚æ¾±æ¾¡"
  ],
  [
    "bf40",
    "æ¿ƒæ¾¤æ¿æ¾§æ¾³æ¿€æ¾¹æ¾¶æ¾¦æ¾ æ¾´ç†¾ç‡‰ç‡ç‡’ç‡ˆç‡•ç†¹ç‡Žç‡™ç‡œç‡ƒç‡„ç¨ç’œç’£ç’˜ç’Ÿç’žç“¢ç”Œç”ç˜´ç˜¸ç˜ºç›§ç›¥çž çžžçžŸçž¥ç£¨ç£šç£¬ç£§ç¦¦ç©ç©Žç©†ç©Œç©‹çªºç¯™ç°‘ç¯‰ç¯¤ç¯›ç¯¡ç¯©ç¯¦ç³•ç³–ç¸Š"
  ],
  [
    "bfa1",
    "ç¸‘ç¸ˆç¸›ç¸£ç¸žç¸ç¸‰ç¸ç½¹ç¾²ç¿°ç¿±ç¿®è€¨è†³è†©è†¨è‡»èˆˆè‰˜è‰™è•Šè•™è•ˆè•¨è•©è•ƒè•‰è•­è•ªè•žèžƒèžŸèžžèž¢èžè¡¡è¤ªè¤²è¤¥è¤«è¤¡è¦ªè¦¦è«¦è«ºè««è«±è¬€è«œè«§è«®è«¾è¬è¬‚è«·è«­è«³è«¶è«¼è±«è±­è²“è³´è¹„è¸±è¸´è¹‚è¸¹è¸µè¼»è¼¯è¼¸è¼³è¾¨è¾¦éµé´é¸é²é¼éºé„´é†’éŒ éŒ¶é‹¸éŒ³éŒ¯éŒ¢é‹¼éŒ«éŒ„éŒš"
  ],
  [
    "c040",
    "éŒéŒ¦éŒ¡éŒ•éŒ®éŒ™é–»éš§éš¨éšªé›•éœŽéœ‘éœ–éœéœ“éœé›éœé¦éž˜é °é ¸é »é ·é ­é ¹é ¤é¤é¤¨é¤žé¤›é¤¡é¤šé§­é§¢é§±éª¸éª¼é«»é«­é¬¨é®‘é´•é´£é´¦é´¨é´’é´›é»˜é»”é¾é¾œå„ªå„Ÿå„¡å„²å‹µåšŽåš€åšåš…åš‡"
  ],
  [
    "c0a1",
    "åšå£•å£“å£‘å£Žå¬°å¬ªå¬¤å­ºå°·å±¨å¶¼å¶ºå¶½å¶¸å¹«å½Œå¾½æ‡‰æ‡‚æ‡‡æ‡¦æ‡‹æˆ²æˆ´æ“Žæ“Šæ“˜æ“ æ“°æ“¦æ“¬æ“±æ“¢æ“­æ–‚æ–ƒæ›™æ›–æª€æª”æª„æª¢æªœæ«›æª£æ©¾æª—æªæª æ­œæ®®æ¯šæ°ˆæ¿˜æ¿±æ¿Ÿæ¿ æ¿›æ¿¤æ¿«æ¿¯æ¾€æ¿¬æ¿¡æ¿©æ¿•æ¿®æ¿°ç‡§ç‡Ÿç‡®ç‡¦ç‡¥ç‡­ç‡¬ç‡´ç‡ çˆµç‰†ç°ç²ç’©ç’°ç’¦ç’¨ç™†ç™‚ç™Œç›ªçž³çžªçž°çž¬"
  ],
  [
    "c140",
    "çž§çž­çŸ¯ç£·ç£ºç£´ç£¯ç¤ç¦§ç¦ªç©—çª¿ç°‡ç°ç¯¾ç¯·ç°Œç¯ ç³ ç³œç³žç³¢ç³Ÿç³™ç³ç¸®ç¸¾ç¹†ç¸·ç¸²ç¹ƒç¸«ç¸½ç¸±ç¹…ç¹ç¸´ç¸¹ç¹ˆç¸µç¸¿ç¸¯ç½„ç¿³ç¿¼è±è²è°è¯è³è‡†è‡ƒè†ºè‡‚è‡€è†¿è†½è‡‰è†¾è‡¨èˆ‰è‰±è–ª"
  ],
  [
    "c1a1",
    "è–„è•¾è–œè–‘è–”è–¯è–›è–‡è–¨è–Šè™§èŸ€èŸ‘èž³èŸ’èŸ†èž«èž»èžºèŸˆèŸ‹è¤»è¤¶è¥„è¤¸è¤½è¦¬è¬Žè¬—è¬™è¬›è¬Šè¬ è¬è¬„è¬è±è°¿è±³è³ºè³½è³¼è³¸è³»è¶¨è¹‰è¹‹è¹ˆè¹Šè½„è¼¾è½‚è½…è¼¿é¿é½é‚„é‚é‚‚é‚€é„¹é†£é†žé†œééŽ‚éŒ¨éµéŠé¥é‹éŒ˜é¾é¬é›é°éšé”é—Šé—‹é—Œé—ˆé—†éš±éš¸é›–éœœéœžéž éŸ“é¡†é¢¶é¤µé¨"
  ],
  [
    "c240",
    "é§¿é®®é®«é®ªé®­é´»é´¿éº‹é»é»žé»œé»é»›é¼¾é½‹å¢åš•åš®å£™å£˜å¬¸å½æ‡£æˆ³æ“´æ“²æ“¾æ”†æ“ºæ“»æ“·æ–·æ›œæœ¦æª³æª¬æ«ƒæª»æª¸æ«‚æª®æª¯æ­Ÿæ­¸æ®¯ç€‰ç€‹æ¿¾ç€†æ¿ºç€‘ç€ç‡»ç‡¼ç‡¾ç‡¸ç·çµç’§ç’¿ç”•ç™–ç™˜"
  ],
  [
    "c2a1",
    "ç™’çž½çž¿çž»çž¼ç¤Žç¦®ç©¡ç©¢ç© ç«„ç«…ç°«ç°§ç°ªç°žç°£ç°¡ç³§ç¹”ç¹•ç¹žç¹šç¹¡ç¹’ç¹™ç½ˆç¿¹ç¿»è·è¶è‡è‡èˆŠè—è–©è—è—è—‰è–°è–ºè–¹è–¦èŸ¯èŸ¬èŸ²èŸ è¦†è¦²è§´è¬¨è¬¹è¬¬è¬«è±è´…è¹™è¹£è¹¦è¹¤è¹Ÿè¹•è»€è½‰è½é‚‡é‚ƒé‚ˆé†«é†¬é‡éŽ”éŽŠéŽ–éŽ¢éŽ³éŽ®éŽ¬éŽ°éŽ˜éŽšéŽ—é—”é—–é—é—•é›¢é›œé›™é››é›žéœ¤éž£éž¦"
  ],
  [
    "c340",
    "éž­éŸ¹é¡é¡é¡Œé¡Žé¡“é¢ºé¤¾é¤¿é¤½é¤®é¦¥é¨Žé«é¬ƒé¬†é­é­Žé­é¯Šé¯‰é¯½é¯ˆé¯€éµ‘éµéµ é» é¼•é¼¬å„³åš¥å£žå£Ÿå£¢å¯µé¾å»¬æ‡²æ‡·æ‡¶æ‡µæ”€æ”æ› æ›æ«¥æ«æ«šæ«“ç€›ç€Ÿç€¨ç€šç€ç€•ç€˜çˆ†çˆç‰˜çŠ¢ç¸"
  ],
  [
    "c3a1",
    "çºç’½ç“Šç“£ç–‡ç–†ç™Ÿç™¡çŸ‡ç¤™ç¦±ç©«ç©©ç°¾ç°¿ç°¸ç°½ç°·ç±€ç¹«ç¹­ç¹¹ç¹©ç¹ªç¾…ç¹³ç¾¶ç¾¹ç¾¸è‡˜è—©è—è—ªè—•è—¤è—¥è—·èŸ»è …è èŸ¹èŸ¾è¥ è¥Ÿè¥–è¥žè­è­œè­˜è­‰è­šè­Žè­è­†è­™è´ˆè´Šè¹¼è¹²èº‡è¹¶è¹¬è¹ºè¹´è½”è½Žè¾­é‚Šé‚‹é†±é†®é¡é‘éŸéƒéˆéœéé–é¢éé˜é¤é—é¨é—œéš´é›£éœªéœ§é¡éŸœéŸ»é¡ž"
  ],
  [
    "c440",
    "é¡˜é¡›é¢¼é¥…é¥‰é¨–é¨™é¬é¯¨é¯§é¯–é¯›é¶‰éµ¡éµ²éµªéµ¬éº’éº—éº“éº´å‹¸åš¨åš·åš¶åš´åš¼å£¤å­€å­ƒå­½å¯¶å·‰æ‡¸æ‡ºæ”˜æ””æ”™æ›¦æœ§æ«¬ç€¾ç€°ç€²çˆç»ç“ç™¢ç™¥ç¤¦ç¤ªç¤¬ç¤«ç«‡ç«¶ç±Œç±ƒç±ç³¯ç³°è¾®ç¹½ç¹¼"
  ],
  [
    "c4a1",
    "çº‚ç½Œè€€è‡šè‰¦è—»è—¹è˜‘è—ºè˜†è˜‹è˜‡è˜Šè ”è •è¥¤è¦ºè§¸è­°è­¬è­¦è­¯è­Ÿè­«è´è´èº‰èºèº…èº‚é†´é‡‹é˜éƒé½é—¡éœ°é£„é¥’é¥‘é¦¨é¨«é¨°é¨·é¨µé°“é°é¹¹éºµé»¨é¼¯é½Ÿé½£é½¡å„·å„¸å›å›€å›‚å¤”å±¬å·æ‡¼æ‡¾æ”æ”œæ–•æ›©æ«»æ¬„æ«ºæ®²çŒçˆ›çŠ§ç“–ç“”ç™©çŸ“ç±çºçºŒç¾¼è˜—è˜­è˜šè £è ¢è ¡è Ÿè¥ªè¥¬è¦½è­´"
  ],
  [
    "c540",
    "è­·è­½è´“èºŠèºèº‹è½Ÿè¾¯é†ºé®é³éµéºé¸é²é«é—¢éœ¸éœ¹éœ²éŸ¿é¡§é¡¥é¥—é©…é©ƒé©€é¨¾é«é­”é­‘é°­é°¥é¶¯é¶´é·‚é¶¸éºé»¯é¼™é½œé½¦é½§å„¼å„»å›ˆå›Šå›‰å­¿å·”å·’å½Žæ‡¿æ”¤æ¬Šæ­¡ç‘ç˜çŽ€ç“¤ç–Šç™®ç™¬"
  ],
  [
    "c5a1",
    "ç¦³ç± ç±Ÿè¾è½è‡Ÿè¥²è¥¯è§¼è®€è´–è´—èº‘èº“è½¡é…ˆé‘„é‘‘é‘’éœ½éœ¾éŸƒéŸé¡«é¥•é©•é©é«’é¬šé±‰é°±é°¾é°»é·“é·—é¼´é½¬é½ªé¾”å›Œå·–æˆ€æ”£æ”«æ”ªæ›¬æ¬ç“šç«Šç±¤ç±£ç±¥çº“çº–çº”è‡¢è˜¸è˜¿è ±è®Šé‚é‚é‘£é‘ é‘¤é¨é¡¯é¥œé©šé©›é©—é«“é«”é«‘é±”é±—é±–é·¥éºŸé»´å›‘å£©æ”¬çžç™±ç™²çŸ—ç½ç¾ˆè ¶è ¹è¡¢è®“è®’"
  ],
  [
    "c640",
    "è®–è‰·è´›é‡€é‘ªé‚éˆé„éŸ†é¡°é©Ÿé¬¢é­˜é±Ÿé·¹é·ºé¹¼é¹½é¼‡é½·é½²å»³æ¬–ç£ç±¬ç±®è »è§€èº¡é‡é‘²é‘°é¡±é¥žé«–é¬£é»Œç¤çŸšè®šé‘·éŸ‰é©¢é©¥çºœè®œèºªé‡…é‘½é‘¾é‘¼é±·é±¸é»·è±”é‘¿é¸šçˆ¨é©ªé¬±é¸›é¸žç±²"
  ],
  [
    "c940",
    "ä¹‚ä¹œå‡µåŒšåŽ‚ä¸‡ä¸Œä¹‡äºå›—ï¨Œå±®å½³ä¸å†‡ä¸Žä¸®äº“ä»‚ä»‰ä»ˆå†˜å‹¼å¬åŽ¹åœ å¤ƒå¤¬å°å·¿æ—¡æ®³æ¯Œæ°”çˆ¿ä¸±ä¸¼ä»¨ä»œä»©ä»¡ä»ä»šåˆŒåŒœåŒåœ¢åœ£å¤—å¤¯å®å®„å°’å°»å±´å±³å¸„åº€åº‚å¿‰æˆ‰æ‰æ°•"
  ],
  [
    "c9a1",
    "æ°¶æ±ƒæ°¿æ°»çŠ®çŠ°çŽŠç¦¸è‚Šé˜žä¼Žä¼˜ä¼¬ä»µä¼”ä»±ä¼€ä»·ä¼ˆä¼ä¼‚ä¼…ä¼¢ä¼“ä¼„ä»´ä¼’å†±åˆ“åˆ‰åˆåŠ¦åŒ¢åŒŸååŽŠå‡å›¡å›Ÿåœ®åœªåœ´å¤¼å¦€å¥¼å¦…å¥»å¥¾å¥·å¥¿å­–å°•å°¥å±¼å±ºå±»å±¾å·Ÿå¹µåº„å¼‚å¼šå½´å¿•å¿”å¿æ‰œæ‰žæ‰¤æ‰¡æ‰¦æ‰¢æ‰™æ‰ æ‰šæ‰¥æ—¯æ—®æœ¾æœ¹æœ¸æœ»æœºæœ¿æœ¼æœ³æ°˜æ±†æ±’æ±œæ±æ±Šæ±”æ±‹"
  ],
  [
    "ca40",
    "æ±Œç±ç‰žçŠ´çŠµçŽŽç”ªç™¿ç©µç½‘è‰¸è‰¼èŠ€è‰½è‰¿è™è¥¾é‚™é‚—é‚˜é‚›é‚”é˜¢é˜¤é˜ é˜£ä½–ä¼»ä½¢ä½‰ä½“ä½¤ä¼¾ä½§ä½’ä½Ÿä½ä½˜ä¼­ä¼³ä¼¿ä½¡å†å†¹åˆœåˆžåˆ¡åŠ­åŠ®åŒ‰å£å²åŽŽåŽå°å·åªå‘”å‘…å™åœå¥å˜"
  ],
  [
    "caa1",
    "å½å‘å‘å¨å¤å‘‡å›®å›§å›¥åå…åŒå‰å‹å’å¤†å¥€å¦¦å¦˜å¦ å¦—å¦Žå¦¢å¦å¦å¦§å¦¡å®Žå®’å°¨å°ªå²å²å²ˆå²‹å²‰å²’å²Šå²†å²“å²•å· å¸Šå¸Žåº‹åº‰åºŒåºˆåºå¼…å¼å½¸å½¶å¿’å¿‘å¿å¿­å¿¨å¿®å¿³å¿¡å¿¤å¿£å¿ºå¿¯å¿·å¿»æ€€å¿´æˆºæŠƒæŠŒæŠŽæŠæŠ”æŠ‡æ‰±æ‰»æ‰ºæ‰°æŠæŠˆæ‰·æ‰½æ‰²æ‰´æ”·æ—°æ—´æ—³æ—²æ—µæ…æ‡"
  ],
  [
    "cb40",
    "æ™æ•æŒæˆæææšæ‹æ¯æ°™æ°šæ±¸æ±§æ±«æ²„æ²‹æ²æ±±æ±¯æ±©æ²šæ±­æ²‡æ²•æ²œæ±¦æ±³æ±¥æ±»æ²Žç´çºç‰£çŠ¿çŠ½ç‹ƒç‹†ç‹çŠºç‹…çŽ•çŽ—çŽ“çŽ”çŽ’ç”ºç”¹ç–”ç–•çšç¤½è€´è‚•è‚™è‚è‚’è‚œèŠèŠèŠ…èŠŽèŠ‘èŠ“"
  ],
  [
    "cba1",
    "èŠŠèŠƒèŠ„è±¸è¿‰è¾¿é‚Ÿé‚¡é‚¥é‚žé‚§é‚ é˜°é˜¨é˜¯é˜­ä¸³ä¾˜ä½¼ä¾…ä½½ä¾€ä¾‡ä½¶ä½´ä¾‰ä¾„ä½·ä½Œä¾—ä½ªä¾šä½¹ä¾ä½¸ä¾ä¾œä¾”ä¾žä¾’ä¾‚ä¾•ä½«ä½®å†žå†¼å†¾åˆµåˆ²åˆ³å‰†åˆ±åŠ¼åŒŠåŒ‹åŒ¼åŽ’åŽ”å’‡å‘¿å’å’‘å’‚å’ˆå‘«å‘ºå‘¾å‘¥å‘¬å‘´å‘¦å’å‘¯å‘¡å‘ å’˜å‘£å‘§å‘¤å›·å›¹å¯å²å­å«å±å°å¶åž€åµå»å³å´å¢"
  ],
  [
    "cc40",
    "å¨å½å¤Œå¥…å¦µå¦ºå§å§Žå¦²å§Œå§å¦¶å¦¼å§ƒå§–å¦±å¦½å§€å§ˆå¦´å§‡å­¢å­¥å®“å®•å±„å±‡å²®å²¤å² å²µå²¯å²¨å²¬å²Ÿå²£å²­å²¢å²ªå²§å²å²¥å²¶å²°å²¦å¸—å¸”å¸™å¼¨å¼¢å¼£å¼¤å½”å¾‚å½¾å½½å¿žå¿¥æ€­æ€¦æ€™æ€²æ€‹"
  ],
  [
    "cca1",
    "æ€´æ€Šæ€—æ€³æ€šæ€žæ€¬æ€¢æ€æ€æ€®æ€“æ€‘æ€Œæ€‰æ€œæˆ”æˆ½æŠ­æŠ´æ‹‘æŠ¾æŠªæŠ¶æ‹ŠæŠ®æŠ³æŠ¯æŠ»æŠ©æŠ°æŠ¸æ”½æ–¨æ–»æ˜‰æ—¼æ˜„æ˜’æ˜ˆæ—»æ˜ƒæ˜‹æ˜æ˜…æ—½æ˜‘æ˜æ›¶æœŠæž…æ¬æžŽæž’æ¶æ»æž˜æž†æž„æ´æžæžŒæºæžŸæž‘æž™æžƒæ½æžæ¸æ¹æž”æ¬¥æ®€æ­¾æ¯žæ°æ²“æ³¬æ³«æ³®æ³™æ²¶æ³”æ²­æ³§æ²·æ³æ³‚æ²ºæ³ƒæ³†æ³­æ³²"
  ],
  [
    "cd40",
    "æ³’æ³æ²´æ²Šæ²æ²€æ³žæ³€æ´°æ³æ³‡æ²°æ³¹æ³æ³©æ³‘ç‚”ç‚˜ç‚…ç‚“ç‚†ç‚„ç‚‘ç‚–ç‚‚ç‚šç‚ƒç‰ªç‹–ç‹‹ç‹˜ç‹‰ç‹œç‹’ç‹”ç‹šç‹Œç‹‘çŽ¤çŽ¡çŽ­çŽ¦çŽ¢çŽ çŽ¬çŽç“ç“¨ç”¿ç•€ç”¾ç–Œç–˜çš¯ç›³ç›±ç›°ç›µçŸ¸çŸ¼çŸ¹çŸ»çŸº"
  ],
  [
    "cda1",
    "çŸ·ç¥‚ç¤¿ç§…ç©¸ç©»ç«»ç±µç³½è€µè‚è‚®è‚£è‚¸è‚µè‚­èˆ èŠ è‹€èŠ«èŠšèŠ˜èŠ›èŠµèŠ§èŠ®èŠ¼èŠžèŠºèŠ´èŠ¨èŠ¡èŠ©è‹‚èŠ¤è‹ƒèŠ¶èŠ¢è™°è™¯è™­è™®è±–è¿’è¿‹è¿“è¿è¿–è¿•è¿—é‚²é‚´é‚¯é‚³é‚°é˜¹é˜½é˜¼é˜ºé™ƒä¿ä¿…ä¿“ä¾²ä¿‰ä¿‹ä¿ä¿”ä¿œä¿™ä¾»ä¾³ä¿›ä¿‡ä¿–ä¾ºä¿€ä¾¹ä¿¬å‰„å‰‰å‹€å‹‚åŒ½å¼åŽ—åŽ–åŽ™åŽ˜å’ºå’¡å’­å’¥å“"
  ],
  [
    "ce40",
    "å“ƒèŒå’·å’®å“–å’¶å“…å“†å’ å‘°å’¼å’¢å’¾å‘²å“žå’°åžµåžžåžŸåž¤åžŒåž—åžåž›åž”åž˜åžåž™åž¥åžšåž•å£´å¤å¥“å§¡å§žå§®å¨€å§±å§å§ºå§½å§¼å§¶å§¤å§²å§·å§›å§©å§³å§µå§ å§¾å§´å§­å®¨å±Œå³å³˜å³Œå³—å³‹å³›"
  ],
  [
    "cea1",
    "å³žå³šå³‰å³‡å³Šå³–å³“å³”å³å³ˆå³†å³Žå³Ÿå³¸å·¹å¸¡å¸¢å¸£å¸ å¸¤åº°åº¤åº¢åº›åº£åº¥å¼‡å¼®å½–å¾†æ€·æ€¹æ”æ²æžæ…æ“æ‡æ‰æ›æŒæ€æ‚æŸæ€¤æ„æ˜æ¦æ®æ‰‚æ‰ƒæ‹æŒæŒ‹æ‹µæŒŽæŒƒæ‹«æ‹¹æŒæŒŒæ‹¸æ‹¶æŒ€æŒ“æŒ”æ‹ºæŒ•æ‹»æ‹°æ•æ•ƒæ–ªæ–¿æ˜¶æ˜¡æ˜²æ˜µæ˜œæ˜¦æ˜¢æ˜³æ˜«æ˜ºæ˜æ˜´æ˜¹æ˜®æœæœæŸæŸ²æŸˆæžº"
  ],
  [
    "cf40",
    "æŸœæž»æŸ¸æŸ˜æŸ€æž·æŸ…æŸ«æŸ¤æŸŸæžµæŸæž³æŸ·æŸ¶æŸ®æŸ£æŸ‚æž¹æŸŽæŸ§æŸ°æž²æŸ¼æŸ†æŸ­æŸŒæž®æŸ¦æŸ›æŸºæŸ‰æŸŠæŸƒæŸªæŸ‹æ¬¨æ®‚æ®„æ®¶æ¯–æ¯˜æ¯ æ° æ°¡æ´¨æ´´æ´­æ´Ÿæ´¼æ´¿æ´’æ´Šæ³šæ´³æ´„æ´™æ´ºæ´šæ´‘æ´€æ´æµ‚"
  ],
  [
    "cfa1",
    "æ´æ´˜æ´·æ´ƒæ´æµ€æ´‡æ´ æ´¬æ´ˆæ´¢æ´‰æ´ç‚·ç‚Ÿç‚¾ç‚±ç‚°ç‚¡ç‚´ç‚µç‚©ç‰ç‰‰ç‰Šç‰¬ç‰°ç‰³ç‰®ç‹Šç‹¤ç‹¨ç‹«ç‹Ÿç‹ªç‹¦ç‹£çŽ…çŒç‚çˆç…çŽ¹çŽ¶çŽµçŽ´ç«çŽ¿ç‡çŽ¾çƒç†çŽ¸ç‹ç“¬ç“®ç”®ç•‡ç•ˆç–§ç–ªç™¹ç›„çœˆçœƒçœ„çœ…çœŠç›·ç›»ç›ºçŸ§çŸ¨ç †ç ‘ç ’ç …ç ç ç Žç ‰ç ƒç “ç¥Šç¥Œç¥‹ç¥…ç¥„ç§•ç§ç§ç§–ç§Žçª€"
  ],
  [
    "d040",
    "ç©¾ç«‘ç¬€ç¬ç±ºç±¸ç±¹ç±¿ç²€ç²ç´ƒç´ˆç´ç½˜ç¾‘ç¾ç¾¾è€‡è€Žè€è€”è€·èƒ˜èƒ‡èƒ èƒ‘èƒˆèƒ‚èƒèƒ…èƒ£èƒ™èƒœèƒŠèƒ•èƒ‰èƒèƒ—èƒ¦èƒè‡¿èˆ¡èŠ”è‹™è‹¾è‹¹èŒ‡è‹¨èŒ€è‹•èŒºè‹«è‹–è‹´è‹¬è‹¡è‹²è‹µèŒŒè‹»è‹¶è‹°è‹ª"
  ],
  [
    "d0a1",
    "è‹¤è‹ è‹ºè‹³è‹­è™·è™´è™¼è™³è¡è¡Žè¡§è¡ªè¡©è§“è¨„è¨‡èµ²è¿£è¿¡è¿®è¿ éƒ±é‚½é‚¿éƒ•éƒ…é‚¾éƒ‡éƒ‹éƒˆé‡”é‡“é™”é™é™‘é™“é™Šé™Žå€žå€…å€‡å€“å€¢å€°å€›ä¿µä¿´å€³å€·å€¬ä¿¶ä¿·å€—å€œå€ å€§å€µå€¯å€±å€Žå…šå†”å†“å‡Šå‡„å‡…å‡ˆå‡Žå‰¡å‰šå‰’å‰žå‰Ÿå‰•å‰¢å‹åŒŽåŽžå”¦å“¢å”—å”’å“§å“³å“¤å”šå“¿å”„å”ˆå“«å”‘å”…å“±"
  ],
  [
    "d140",
    "å”Šå“»å“·å“¸å“ å”Žå”ƒå”‹åœåœ‚åŸŒå ²åŸ•åŸ’åžºåŸ†åž½åž¼åž¸åž¶åž¿åŸ‡åŸåž¹åŸå¤Žå¥Šå¨™å¨–å¨­å¨®å¨•å¨å¨—å¨Šå¨žå¨³å­¬å®§å®­å®¬å°ƒå±–å±”å³¬å³¿å³®å³±å³·å´€å³¹å¸©å¸¨åº¨åº®åºªåº¬å¼³å¼°å½§ææšæ§"
  ],
  [
    "d1a1",
    "ææ‚¢æ‚ˆæ‚€æ‚’æ‚æ‚æ‚ƒæ‚•æ‚›æ‚—æ‚‡æ‚œæ‚Žæˆ™æ‰†æ‹²æŒæ–æŒ¬æ„æ…æŒ¶æƒæ¤æŒ¹æ‹æŠæŒ¼æŒ©ææŒ´æ˜æ”æ™æŒ­æ‡æŒ³æšæ‘æŒ¸æ—æ€æˆæ•Šæ•†æ—†æ—ƒæ—„æ—‚æ™Šæ™Ÿæ™‡æ™‘æœ’æœ“æ Ÿæ šæ¡‰æ ²æ ³æ »æ¡‹æ¡æ –æ ±æ œæ µæ «æ ­æ ¯æ¡Žæ¡„æ ´æ æ ’æ ”æ ¦æ ¨æ ®æ¡æ ºæ ¥æ  æ¬¬æ¬¯æ¬­æ¬±æ¬´æ­­è‚‚æ®ˆæ¯¦æ¯¤"
  ],
  [
    "d240",
    "æ¯¨æ¯£æ¯¢æ¯§æ°¥æµºæµ£æµ¤æµ¶æ´æµ¡æ¶’æµ˜æµ¢æµ­æµ¯æ¶‘æ¶æ·¯æµ¿æ¶†æµžæµ§æµ æ¶—æµ°æµ¼æµŸæ¶‚æ¶˜æ´¯æµ¨æ¶‹æµ¾æ¶€æ¶„æ´–æ¶ƒæµ»æµ½æµµæ¶çƒœçƒ“çƒ‘çƒçƒ‹ç¼¹çƒ¢çƒ—çƒ’çƒžçƒ çƒ”çƒçƒ…çƒ†çƒ‡çƒšçƒŽçƒ¡ç‰‚ç‰¸"
  ],
  [
    "d2a1",
    "ç‰·ç‰¶çŒ€ç‹ºç‹´ç‹¾ç‹¶ç‹³ç‹»çŒç“ç™ç¥ç–çŽ¼ç§ç£ç©çœç’ç›ç”ççšç—ç˜ç¨ç“žç“Ÿç“´ç“µç”¡ç•›ç•Ÿç–°ç—ç–»ç—„ç—€ç–¿ç–¶ç–ºçšŠç›‰çœçœ›çœçœ“çœ’çœ£çœ‘çœ•çœ™çœšçœ¢çœ§ç £ç ¬ç ¢ç µç ¯ç ¨ç ®ç «ç ¡ç ©ç ³ç ªç ±ç¥”ç¥›ç¥ç¥œç¥“ç¥’ç¥‘ç§«ç§¬ç§ ç§®ç§­ç§ªç§œç§žç§çª†çª‰çª…çª‹çªŒçªŠçª‡ç«˜ç¬"
  ],
  [
    "d340",
    "ç¬„ç¬“ç¬…ç¬ç¬ˆç¬Šç¬Žç¬‰ç¬’ç²„ç²‘ç²Šç²Œç²ˆç²ç²…ç´žç´ç´‘ç´Žç´˜ç´–ç´“ç´Ÿç´’ç´ç´Œç½œç½¡ç½žç½ ç½ç½›ç¾–ç¾’ç¿ƒç¿‚ç¿€è€–è€¾è€¹èƒºèƒ²èƒ¹èƒµè„èƒ»è„€èˆèˆ¯èˆ¥èŒ³èŒ­è„èŒ™è‘èŒ¥è–èŒ¿èèŒ¦èŒœèŒ¢"
  ],
  [
    "d3a1",
    "è‚èŽèŒ›èŒªèŒˆèŒ¼èèŒ–èŒ¤èŒ èŒ·èŒ¯èŒ©è‡è…èŒè“èŒžèŒ¬è‹èŒ§èˆè™“è™’èš¢èš¨èš–èšèš‘èšžèš‡èš—èš†èš‹èššèš…èš¥èš™èš¡èš§èš•èš˜èšŽèšèšèš”è¡ƒè¡„è¡­è¡µè¡¶è¡²è¢€è¡±è¡¿è¡¯è¢ƒè¡¾è¡´è¡¼è¨’è±‡è±—è±»è²¤è²£èµ¶èµ¸è¶µè¶·è¶¶è»‘è»“è¿¾è¿µé€‚è¿¿è¿»é€„è¿¼è¿¶éƒ–éƒ éƒ™éƒšéƒ£éƒŸéƒ¥éƒ˜éƒ›éƒ—éƒœéƒ¤é…"
  ],
  [
    "d440",
    "é…Žé…é‡•é‡¢é‡šé™œé™Ÿéš¼é££é«Ÿé¬¯ä¹¿å°åªå¡åžå å“å‹åå²åˆååå›åŠå¢å€•å…åŸå©å«å£å¤å†å€å®å³å—å‘å‡å‰«å‰­å‰¬å‰®å‹–å‹“åŒ­åŽœå•µå•¶å”¼å•å•å”´å”ªå•‘å•¢å”¶å”µå”°å•’å•…"
  ],
  [
    "d4a1",
    "å”Œå”²å•¥å•Žå”¹å•ˆå”­å”»å•€å•‹åœŠåœ‡åŸ»å ”åŸ¢åŸ¶åŸœåŸ´å €åŸ­åŸ½å ˆåŸ¸å ‹åŸ³åŸå ‡åŸ®åŸ£åŸ²åŸ¥åŸ¬åŸ¡å ŽåŸ¼å åŸ§å å ŒåŸ±åŸ©åŸ°å å „å¥œå© å©˜å©•å©§å©žå¨¸å¨µå©­å©å©Ÿå©¥å©¬å©“å©¤å©—å©ƒå©å©’å©„å©›å©ˆåªŽå¨¾å©å¨¹å©Œå©°å©©å©‡å©‘å©–å©‚å©œå­²å­®å¯å¯€å±™å´žå´‹å´å´šå´ å´Œå´¨å´å´¦å´¥å´"
  ],
  [
    "d540",
    "å´°å´’å´£å´Ÿå´®å¸¾å¸´åº±åº´åº¹åº²åº³å¼¶å¼¸å¾›å¾–å¾Ÿæ‚Šæ‚æ‚†æ‚¾æ‚°æ‚ºæƒ“æƒ”æƒæƒ¤æƒ™æƒæƒˆæ‚±æƒ›æ‚·æƒŠæ‚¿æƒƒæƒæƒ€æŒ²æ¥æŽŠæŽ‚æ½æŽ½æŽžæŽ­æŽæŽ—æŽ«æŽŽæ¯æŽ‡æŽæ®æŽ¯æµæŽœæ­æŽ®æ¼æŽ¤æŒ»æŽŸ"
  ],
  [
    "d5a1",
    "æ¸æŽ…æŽæŽ‘æŽæ°æ•“æ—æ™¥æ™¡æ™›æ™™æ™œæ™¢æœ˜æ¡¹æ¢‡æ¢æ¢œæ¡­æ¡®æ¢®æ¢«æ¥–æ¡¯æ¢£æ¢¬æ¢©æ¡µæ¡´æ¢²æ¢æ¡·æ¢’æ¡¼æ¡«æ¡²æ¢ªæ¢€æ¡±æ¡¾æ¢›æ¢–æ¢‹æ¢ æ¢‰æ¢¤æ¡¸æ¡»æ¢‘æ¢Œæ¢Šæ¡½æ¬¶æ¬³æ¬·æ¬¸æ®‘æ®æ®æ®Žæ®Œæ°ªæ·€æ¶«æ¶´æ¶³æ¹´æ¶¬æ·©æ·¢æ¶·æ·¶æ·”æ¸€æ·ˆæ· æ·Ÿæ·–æ¶¾æ·¥æ·œæ·æ·›æ·´æ·Šæ¶½æ·­æ·°æ¶ºæ·•æ·‚æ·æ·‰"
  ],
  [
    "d640",
    "æ·æ·²æ·“æ·½æ·—æ·æ·£æ¶»çƒºç„çƒ·ç„—çƒ´ç„Œçƒ°ç„„çƒ³ç„çƒ¼çƒ¿ç„†ç„“ç„€çƒ¸çƒ¶ç„‹ç„‚ç„Žç‰¾ç‰»ç‰¼ç‰¿çŒçŒ—çŒ‡çŒ‘çŒ˜çŒŠçŒˆç‹¿çŒçŒžçŽˆç¶ç¸çµç„çç½ç‡ç€çºç¼ç¿çŒç‹ç´çˆç•¤ç•£ç—Žç—’ç—"
  ],
  [
    "d6a1",
    "ç—‹ç—Œç—‘ç—çšçš‰ç›“çœ¹çœ¯çœ­çœ±çœ²çœ´çœ³çœ½çœ¥çœ»çœµç¡ˆç¡’ç¡‰ç¡ç¡Šç¡Œç ¦ç¡…ç¡ç¥¤ç¥§ç¥©ç¥ªç¥£ç¥«ç¥¡ç¦»ç§ºç§¸ç§¶ç§·çªçª”çªç¬µç­‡ç¬´ç¬¥ç¬°ç¬¢ç¬¤ç¬³ç¬˜ç¬ªç¬ç¬±ç¬«ç¬­ç¬¯ç¬²ç¬¸ç¬šç¬£ç²”ç²˜ç²–ç²£ç´µç´½ç´¸ç´¶ç´ºçµ…ç´¬ç´©çµçµ‡ç´¾ç´¿çµŠç´»ç´¨ç½£ç¾•ç¾œç¾ç¾›ç¿Šç¿‹ç¿ç¿ç¿‘ç¿‡ç¿ç¿‰è€Ÿ"
  ],
  [
    "d740",
    "è€žè€›è‡èƒèˆè„˜è„¥è„™è„›è„­è„Ÿè„¬è„žè„¡è„•è„§è„è„¢èˆ‘èˆ¸èˆ³èˆºèˆ´èˆ²è‰´èŽèŽ£èŽ¨èŽèºè³èŽ¤è´èŽèŽèŽ•èŽ™èµèŽ”èŽ©è½èŽƒèŽŒèŽèŽ›èŽªèŽ‹è¾èŽ¥èŽ¯èŽˆèŽ—èŽ°è¿èŽ¦èŽ‡èŽ®è¶èŽšè™™è™–èš¿èš·"
  ],
  [
    "d7a1",
    "è›‚è›è›…èšºèš°è›ˆèš¹èš³èš¸è›Œèš´èš»èš¼è›ƒèš½èš¾è¡’è¢‰è¢•è¢¨è¢¢è¢ªè¢šè¢‘è¢¡è¢Ÿè¢˜è¢§è¢™è¢›è¢—è¢¤è¢¬è¢Œè¢“è¢Žè¦‚è§–è§™è§•è¨°è¨§è¨¬è¨žè°¹è°»è±œè±è±½è²¥èµ½èµ»èµ¹è¶¼è·‚è¶¹è¶¿è·è»˜è»žè»è»œè»—è» è»¡é€¤é€‹é€‘é€œé€Œé€¡éƒ¯éƒªéƒ°éƒ´éƒ²éƒ³éƒ”éƒ«éƒ¬éƒ©é…–é…˜é…šé…“é…•é‡¬é‡´é‡±é‡³é‡¸é‡¤é‡¹é‡ª"
  ],
  [
    "d840",
    "é‡«é‡·é‡¨é‡®é•ºé–†é–ˆé™¼é™­é™«é™±é™¯éš¿éªé „é£¥é¦—å‚›å‚•å‚”å‚žå‚‹å‚£å‚ƒå‚Œå‚Žå‚å¨å‚œå‚’å‚‚å‚‡å…Ÿå‡”åŒ’åŒ‘åŽ¤åŽ§å–‘å–¨å–¥å–­å•·å™…å–¢å–“å–ˆå–å–µå–å–£å–’å–¤å•½å–Œå–¦å•¿å–•å–¡å–ŽåœŒå ©å ·"
  ],
  [
    "d8a1",
    "å ™å žå §å £å ¨åŸµå¡ˆå ¥å œå ›å ³å ¿å ¶å ®å ¹å ¸å ­å ¬å »å¥¡åª¯åª”åªŸå©ºåª¢åªžå©¸åª¦å©¼åª¥åª¬åª•åª®å¨·åª„åªŠåª—åªƒåª‹åª©å©»å©½åªŒåªœåªåª“åªå¯ªå¯å¯‹å¯”å¯‘å¯Šå¯Žå°Œå°°å´·åµƒåµ«åµåµ‹å´¿å´µåµ‘åµŽåµ•å´³å´ºåµ’å´½å´±åµ™åµ‚å´¹åµ‰å´¸å´¼å´²å´¶åµ€åµ…å¹„å¹å½˜å¾¦å¾¥å¾«æƒ‰æ‚¹æƒŒæƒ¢æƒŽæƒ„æ„”"
  ],
  [
    "d940",
    "æƒ²æ„Šæ„–æ„…æƒµæ„“æƒ¸æƒ¼æƒ¾æƒæ„ƒæ„˜æ„æ„æƒ¿æ„„æ„‹æ‰ŠæŽ”æŽ±æŽ°æŽæ¥æ¨æ¯æƒæ’æ³æŠæ æ¶æ•æ²æµæ‘¡æŸæŽ¾ææœæ„æ˜æ“æ‚æ‡æŒæ‹æˆæ°æ—æ™æ”²æ•§æ•ªæ•¤æ•œæ•¨æ•¥æ–Œæ–æ–žæ–®æ—æ—’"
  ],
  [
    "d9a1",
    "æ™¼æ™¬æ™»æš€æ™±æ™¹æ™ªæ™²æœæ¤Œæ£“æ¤„æ£œæ¤ªæ£¬æ£ªæ£±æ¤æ£–æ£·æ£«æ£¤æ£¶æ¤“æ¤æ£³æ£¡æ¤‡æ£Œæ¤ˆæ¥°æ¢´æ¤‘æ£¯æ£†æ¤”æ£¸æ£æ£½æ£¼æ£¨æ¤‹æ¤Šæ¤—æ£Žæ£ˆæ£æ£žæ£¦æ£´æ£‘æ¤†æ£”æ£©æ¤•æ¤¥æ£‡æ¬¹æ¬»æ¬¿æ¬¼æ®”æ®—æ®™æ®•æ®½æ¯°æ¯²æ¯³æ°°æ·¼æ¹†æ¹‡æ¸Ÿæ¹‰æºˆæ¸¼æ¸½æ¹…æ¹¢æ¸«æ¸¿æ¹æ¹æ¹³æ¸œæ¸³æ¹‹æ¹€æ¹‘æ¸»æ¸ƒæ¸®æ¹ž"
  ],
  [
    "da40",
    "æ¹¨æ¹œæ¹¡æ¸±æ¸¨æ¹ æ¹±æ¹«æ¸¹æ¸¢æ¸°æ¹“æ¹¥æ¸§æ¹¸æ¹¤æ¹·æ¹•æ¹¹æ¹’æ¹¦æ¸µæ¸¶æ¹šç„ ç„žç„¯çƒ»ç„®ç„±ç„£ç„¥ç„¢ç„²ç„Ÿç„¨ç„ºç„›ç‰‹ç‰šçŠˆçŠ‰çŠ†çŠ…çŠ‹çŒ’çŒ‹çŒ°çŒ¢çŒ±çŒ³çŒ§çŒ²çŒ­çŒ¦çŒ£çŒµçŒŒç®ç¬ç°ç«ç–"
  ],
  [
    "daa1",
    "çšç¡ç­ç±ç¤ç£çç©ç ç²ç“»ç”¯ç•¯ç•¬ç—§ç—šç—¡ç—¦ç—ç—Ÿç—¤ç——çš•çš’ç›šç†ç‡ç„çç…çŠçŽç‹çŒçŸžçŸ¬ç¡ ç¡¤ç¡¥ç¡œç¡­ç¡±ç¡ªç¡®ç¡°ç¡©ç¡¨ç¡žç¡¢ç¥´ç¥³ç¥²ç¥°ç¨‚ç¨Šç¨ƒç¨Œç¨„çª™ç«¦ç«¤ç­Šç¬»ç­„ç­ˆç­Œç­Žç­€ç­˜ç­…ç²¢ç²žç²¨ç²¡çµ˜çµ¯çµ£çµ“çµ–çµ§çµªçµçµ­çµœçµ«çµ’çµ”çµ©çµ‘çµŸçµŽç¼¾ç¼¿ç½¥"
  ],
  [
    "db40",
    "ç½¦ç¾¢ç¾ ç¾¡ç¿—è‘èèèƒ¾èƒ”è…ƒè…Šè…’è…è…‡è„½è…è„ºè‡¦è‡®è‡·è‡¸è‡¹èˆ„èˆ¼èˆ½èˆ¿è‰µèŒ»èè¹è£è€è¨è’è§è¤è¼è¶èè†èˆè«è£èŽ¿èèè¥è˜è¿è¡è‹èŽè–èµè‰è‰èèžè‘è†è‚è³"
  ],
  [
    "dba1",
    "è•èºè‡è‘èªè“èƒè¬è®è„è»è—è¢è›è›è¾è›˜è›¢è›¦è›“è›£è›šè›ªè›è›«è›œè›¬è›©è›—è›¨è›‘è¡ˆè¡–è¡•è¢ºè£—è¢¹è¢¸è£€è¢¾è¢¶è¢¼è¢·è¢½è¢²è¤è£‰è¦•è¦˜è¦—è§è§šè§›è©Žè©è¨¹è©™è©€è©—è©˜è©„è©…è©’è©ˆè©‘è©Šè©Œè©è±Ÿè²è²€è²ºè²¾è²°è²¹è²µè¶„è¶€è¶‰è·˜è·“è·è·‡è·–è·œè·è·•è·™è·ˆè·—è·…è»¯è»·è»º"
  ],
  [
    "dc40",
    "è»¹è»¦è»®è»¥è»µè»§è»¨è»¶è»«è»±è»¬è»´è»©é€­é€´é€¯é„†é„¬é„„éƒ¿éƒ¼é„ˆéƒ¹éƒ»é„é„€é„‡é„…é„ƒé…¡é…¤é…Ÿé…¢é… éˆéˆŠéˆ¥éˆƒéˆšéˆ¦éˆéˆŒéˆ€éˆ’é‡¿é‡½éˆ†éˆ„éˆ§éˆ‚éˆœéˆ¤éˆ™éˆ—éˆ…éˆ–é•»é–é–Œé–éš‡é™¾éšˆ"
  ],
  [
    "dca1",
    "éš‰éšƒéš€é›‚é›ˆé›ƒé›±é›°é¬é°é®é ‡é¢©é£«é³¦é»¹äºƒäº„äº¶å‚½å‚¿åƒ†å‚®åƒ„åƒŠå‚´åƒˆåƒ‚å‚°åƒå‚ºå‚±åƒ‹åƒ‰å‚¶å‚¸å‡—å‰ºå‰¸å‰»å‰¼å—ƒå—›å—Œå—å—‹å—Šå—å—€å—”å—„å—©å–¿å—’å–å—å—•å—¢å—–å—ˆå—²å—å—™å—‚åœ”å¡“å¡¨å¡¤å¡å¡å¡‰å¡¯å¡•å¡Žå¡å¡™å¡¥å¡›å ½å¡£å¡±å£¼å«‡å«„å«‹åªºåª¸åª±åªµåª°åª¿å«ˆåª»å«†"
  ],
  [
    "dd40",
    "åª·å«€å«Šåª´åª¶å«åª¹åªå¯–å¯˜å¯™å°Ÿå°³åµ±åµ£åµŠåµ¥åµ²åµ¬åµžåµ¨åµ§åµ¢å·°å¹å¹Žå¹Šå¹å¹‹å»…å»Œå»†å»‹å»‡å½€å¾¯å¾­æƒ·æ…‰æ…Šæ„«æ……æ„¶æ„²æ„®æ…†æ„¯æ…æ„©æ…€æˆ é…¨æˆ£æˆ¥æˆ¤æ…æ±æ«ææ’æ‰æ æ¤"
  ],
  [
    "dda1",
    "æ³æ‘ƒæŸæ•æ˜æ¹æ·æ¢æ£æŒæ¦æ°æ¨æ‘æµæ¯æŠæšæ‘€æ¥æ§æ‹æ§æ›æ®æ¡æŽæ•¯æ–’æ—“æš†æšŒæš•æšæš‹æšŠæš™æš”æ™¸æœ æ¥¦æ¥Ÿæ¤¸æ¥Žæ¥¢æ¥±æ¤¿æ¥…æ¥ªæ¤¹æ¥‚æ¥—æ¥™æ¥ºæ¥ˆæ¥‰æ¤µæ¥¬æ¤³æ¤½æ¥¥æ£°æ¥¸æ¤´æ¥©æ¥€æ¥¯æ¥„æ¥¶æ¥˜æ¥æ¥´æ¥Œæ¤»æ¥‹æ¤·æ¥œæ¥æ¥‘æ¤²æ¥’æ¤¯æ¥»æ¤¼æ­†æ­…æ­ƒæ­‚æ­ˆæ­æ®›ï¨æ¯»æ¯¼"
  ],
  [
    "de40",
    "æ¯¹æ¯·æ¯¸æº›æ»–æ»ˆæºæ»€æºŸæº“æº”æº æº±æº¹æ»†æ»’æº½æ»æºžæ»‰æº·æº°æ»æº¦æ»æº²æº¾æ»ƒæ»œæ»˜æº™æº’æºŽæºæº¤æº¡æº¿æº³æ»æ»Šæº—æº®æº£ç…‡ç…”ç…’ç…£ç… ç…ç…ç…¢ç…²ç…¸ç…ªç…¡ç…‚ç…˜ç…ƒç…‹ç…°ç…Ÿç…ç…“"
  ],
  [
    "dea1",
    "ç…„ç…ç…šç‰çŠçŠŒçŠ‘çŠçŠŽçŒ¼ç‚çŒ»çŒºç€çŠç‰ç‘„ç‘Šç‘‹ç‘’ç‘‘ç‘—ç‘€ç‘ç‘ç‘Žç‘‚ç‘†ç‘ç‘”ç“¡ç“¿ç“¾ç“½ç”ç•¹ç•·æ¦ƒç—¯ç˜ç˜ƒç—·ç—¾ç—¼ç—¹ç—¸ç˜ç—»ç—¶ç—­ç—µç—½çš™çšµç›ç•çŸç ç’ç–çšç©ç§ç”ç™ç­çŸ ç¢‡ç¢šç¢”ç¢ç¢„ç¢•ç¢…ç¢†ç¢¡ç¢ƒç¡¹ç¢™ç¢€ç¢–ç¡»ç¥¼ç¦‚ç¥½ç¥¹ç¨‘ç¨˜ç¨™ç¨’ç¨—ç¨•ç¨¢ç¨“"
  ],
  [
    "df40",
    "ç¨›ç¨çª£çª¢çªžç««ç­¦ç­¤ç­­ç­´ç­©ç­²ç­¥ç­³ç­±ç­°ç­¡ç­¸ç­¶ç­£ç²²ç²´ç²¯ç¶ˆç¶†ç¶€ç¶çµ¿ç¶…çµºç¶Žçµ»ç¶ƒçµ¼ç¶Œç¶”ç¶„çµ½ç¶’ç½­ç½«ç½§ç½¨ç½¬ç¾¦ç¾¥ç¾§ç¿›ç¿œè€¡è…¤è… è…·è…œè…©è…›è…¢è…²æœ¡è…žè…¶è…§è…¯"
  ],
  [
    "dfa1",
    "è…„è…¡èˆè‰‰è‰„è‰€è‰‚è‰…è“±è¿è‘–è‘¶è‘¹è’è’è‘¥è‘‘è‘€è’†è‘§è°è‘è‘½è‘šè‘™è‘´è‘³è‘è”‡è‘žè·èºè´è‘ºè‘ƒè‘¸è²è‘…è©è™è‘‹è¯è‘‚è­è‘Ÿè‘°è¹è‘Žè‘Œè‘’è‘¯è“…è’Žè»è‘‡è¶è³è‘¨è‘¾è‘„è«è‘ è‘”è‘®è‘èœ‹èœ„è›·èœŒè›ºè›–è›µèè›¸èœŽèœ‰èœè›¶èœèœ…è£–è£‹è£è£Žè£žè£›è£šè£Œè£è¦…è¦›è§Ÿè§¥è§¤"
  ],
  [
    "e040",
    "è§¡è§ è§¢è§œè§¦è©¶èª†è©¿è©¡è¨¿è©·èª‚èª„è©µèªƒèªè©´è©ºè°¼è±‹è±Šè±¥è±¤è±¦è²†è²„è²…è³Œèµ¨èµ©è¶‘è¶Œè¶Žè¶è¶è¶“è¶”è¶è¶’è·°è· è·¬è·±è·®è·è·©è·£è·¢è·§è·²è·«è·´è¼†è»¿è¼è¼€è¼…è¼‡è¼ˆè¼‚è¼‹é’é€¿"
  ],
  [
    "e0a1",
    "é„é‰é€½é„é„é„é„‘é„–é„”é„‹é„Žé…®é…¯é‰ˆé‰’éˆ°éˆºé‰¦éˆ³é‰¥é‰žéŠƒéˆ®é‰Šé‰†é‰­é‰¬é‰é‰ é‰§é‰¯éˆ¶é‰¡é‰°éˆ±é‰”é‰£é‰é‰²é‰Žé‰“é‰Œé‰–éˆ²é–Ÿé–œé–žé–›éš’éš“éš‘éš—é›Žé›ºé›½é›¸é›µé³é·é¸é²é é é Žé¢¬é£¶é£¹é¦¯é¦²é¦°é¦µéª­éª«é­›é³ªé³­é³§éº€é»½åƒ¦åƒ”åƒ—åƒ¨åƒ³åƒ›åƒªåƒåƒ¤åƒ“åƒ¬åƒ°åƒ¯åƒ£åƒ "
  ],
  [
    "e140",
    "å‡˜åŠ€åŠå‹©å‹«åŒ°åŽ¬å˜§å˜•å˜Œå˜’å—¼å˜å˜œå˜å˜“å˜‚å—ºå˜å˜„å—¿å—¹å¢‰å¡¼å¢å¢˜å¢†å¢å¡¿å¡´å¢‹å¡ºå¢‡å¢‘å¢Žå¡¶å¢‚å¢ˆå¡»å¢”å¢å£¾å¥«å«œå«®å«¥å«•å«ªå«šå«­å««å«³å«¢å« å«›å«¬å«žå«å«™å«¨å«Ÿå­·å¯ "
  ],
  [
    "e1a1",
    "å¯£å±£å¶‚å¶€åµ½å¶†åµºå¶åµ·å¶Šå¶‰å¶ˆåµ¾åµ¼å¶åµ¹åµ¿å¹˜å¹™å¹“å»˜å»‘å»—å»Žå»œå»•å»™å»’å»”å½„å½ƒå½¯å¾¶æ„¬æ„¨æ…æ…žæ…±æ…³æ…’æ…“æ…²æ…¬æ†€æ…´æ…”æ…ºæ…›æ…¥æ„»æ…ªæ…¡æ…–æˆ©æˆ§æˆ«æ«æ‘æ‘›æ‘æ‘´æ‘¶æ‘²æ‘³æ‘½æ‘µæ‘¦æ’¦æ‘Žæ’‚æ‘žæ‘œæ‘‹æ‘“æ‘ æ‘æ‘¿æ¿æ‘¬æ‘«æ‘™æ‘¥æ‘·æ•³æ– æš¡æš æšŸæœ…æœ„æœ¢æ¦±æ¦¶æ§‰"
  ],
  [
    "e240",
    "æ¦ æ§Žæ¦–æ¦°æ¦¬æ¦¼æ¦‘æ¦™æ¦Žæ¦§æ¦æ¦©æ¦¾æ¦¯æ¦¿æ§„æ¦½æ¦¤æ§”æ¦¹æ§Šæ¦šæ§æ¦³æ¦“æ¦ªæ¦¡æ¦žæ§™æ¦—æ¦æ§‚æ¦µæ¦¥æ§†æ­Šæ­æ­‹æ®žæ®Ÿæ® æ¯ƒæ¯„æ¯¾æ»Žæ»µæ»±æ¼ƒæ¼¥æ»¸æ¼·æ»»æ¼®æ¼‰æ½Žæ¼™æ¼šæ¼§æ¼˜æ¼»æ¼’æ»­æ¼Š"
  ],
  [
    "e2a1",
    "æ¼¶æ½³æ»¹æ»®æ¼­æ½€æ¼°æ¼¼æ¼µæ»«æ¼‡æ¼Žæ½ƒæ¼…æ»½æ»¶æ¼¹æ¼œæ»¼æ¼ºæ¼Ÿæ¼æ¼žæ¼ˆæ¼¡ç†‡ç†ç†‰ç†€ç†…ç†‚ç†ç…»ç††ç†ç†—ç‰„ç‰“çŠ—çŠ•çŠ“çƒçç‘çŒç‘¢ç‘³ç‘±ç‘µç‘²ç‘§ç‘®ç”€ç”‚ç”ƒç•½ç–ç˜–ç˜ˆç˜Œç˜•ç˜‘ç˜Šç˜”çš¸çžç¼çž…çž‚ç®çž€ç¯ç¾çžƒç¢²ç¢ªç¢´ç¢­ç¢¨ç¡¾ç¢«ç¢žç¢¥ç¢ ç¢¬ç¢¢ç¢¤ç¦˜ç¦Šç¦‹ç¦–ç¦•ç¦”ç¦“"
  ],
  [
    "e340",
    "ç¦—ç¦ˆç¦’ç¦ç¨«ç©Šç¨°ç¨¯ç¨¨ç¨¦çª¨çª«çª¬ç«®ç®ˆç®œç®Šç®‘ç®ç®–ç®ç®Œç®›ç®Žç®…ç®˜åŠ„ç®™ç®¤ç®‚ç²»ç²¿ç²¼ç²ºç¶§ç¶·ç·‚ç¶£ç¶ªç·ç·€ç·…ç¶ç·Žç·„ç·†ç·‹ç·Œç¶¯ç¶¹ç¶–ç¶¼ç¶Ÿç¶¦ç¶®ç¶©ç¶¡ç·‰ç½³ç¿¢ç¿£ç¿¥ç¿ž"
  ],
  [
    "e3a1",
    "è€¤èèœè†‰è††è†ƒè†‡è†è†Œè†‹èˆ•è’—è’¤è’¡è’Ÿè’ºè“Žè“‚è’¬è’®è’«è’¹è’´è“è“è’ªè’šè’±è“è’è’§è’»è’¢è’”è“‡è“Œè’›è’©è’¯è’¨è“–è’˜è’¶è“è’ è“—è“”è“’è“›è’°è’‘è™¡èœ³èœ£èœ¨è«è€èœ®èœžèœ¡èœ™èœ›èƒèœ¬èèœ¾è†èœ èœ²èœªèœ­èœ¼èœ’èœºèœ±èœµè‚èœ¦èœ§èœ¸èœ¤èœšèœ°èœ‘è£·è£§è£±è£²è£ºè£¾è£®è£¼è£¶è£»"
  ],
  [
    "e440",
    "è£°è£¬è£«è¦è¦¡è¦Ÿè¦žè§©è§«è§¨èª«èª™èª‹èª’èªèª–è°½è±¨è±©è³•è³è³—è¶–è¸‰è¸‚è·¿è¸è·½è¸Šè¸ƒè¸‡è¸†è¸…è·¾è¸€è¸„è¼è¼‘è¼Žè¼é„£é„œé„ é„¢é„Ÿé„é„šé„¤é„¡é„›é…ºé…²é…¹é…³éŠ¥éŠ¤é‰¶éŠ›é‰ºéŠ éŠ”éŠªéŠ"
  ],
  [
    "e4a1",
    "éŠ¦éŠšéŠ«é‰¹éŠ—é‰¿éŠ£é‹®éŠŽéŠ‚éŠ•éŠ¢é‰½éŠˆéŠ¡éŠŠéŠ†éŠŒéŠ™éŠ§é‰¾éŠ‡éŠ©éŠéŠ‹éˆ­éšžéš¡é›¿é˜é½éºé¾éžƒéž€éž‚é»éž„éžé¿éŸŽéŸé –é¢­é¢®é¤‚é¤€é¤‡é¦é¦œé§ƒé¦¹é¦»é¦ºé§‚é¦½é§‡éª±é«£é«§é¬¾é¬¿é­ é­¡é­Ÿé³±é³²é³µéº§åƒ¿å„ƒå„°åƒ¸å„†å„‡åƒ¶åƒ¾å„‹å„Œåƒ½å„ŠåŠ‹åŠŒå‹±å‹¯å™ˆå™‚å™Œå˜µå™å™Šå™‰å™†å™˜"
  ],
  [
    "e540",
    "å™šå™€å˜³å˜½å˜¬å˜¾å˜¸å˜ªå˜ºåœšå¢«å¢å¢±å¢ å¢£å¢¯å¢¬å¢¥å¢¡å£¿å«¿å«´å«½å«·å«¶å¬ƒå«¸å¬‚å«¹å¬å¬‡å¬…å¬å±§å¶™å¶—å¶Ÿå¶’å¶¢å¶“å¶•å¶ å¶œå¶¡å¶šå¶žå¹©å¹å¹ å¹œç·³å»›å»žå»¡å½‰å¾²æ†‹æ†ƒæ…¹æ†±æ†°æ†¢æ†‰"
  ],
  [
    "e5a1",
    "æ†›æ†“æ†¯æ†­æ†Ÿæ†’æ†ªæ†¡æ†æ…¦æ†³æˆ­æ‘®æ‘°æ’–æ’ æ’…æ’—æ’œæ’æ’‹æ’Šæ’Œæ’£æ’Ÿæ‘¨æ’±æ’˜æ•¶æ•ºæ•¹æ•»æ–²æ–³æšµæš°æš©æš²æš·æšªæš¯æ¨€æ¨†æ¨—æ§¥æ§¸æ¨•æ§±æ§¤æ¨ æ§¿æ§¬æ§¢æ¨›æ¨æ§¾æ¨§æ§²æ§®æ¨”æ§·æ§§æ©€æ¨ˆæ§¦æ§»æ¨æ§¼æ§«æ¨‰æ¨„æ¨˜æ¨¥æ¨æ§¶æ¨¦æ¨‡æ§´æ¨–æ­‘æ®¥æ®£æ®¢æ®¦æ°æ°€æ¯¿æ°‚æ½æ¼¦æ½¾æ¾‡æ¿†æ¾’"
  ],
  [
    "e640",
    "æ¾æ¾‰æ¾Œæ½¢æ½æ¾…æ½šæ¾–æ½¶æ½¬æ¾‚æ½•æ½²æ½’æ½æ½—æ¾”æ¾“æ½æ¼€æ½¡æ½«æ½½æ½§æ¾æ½“æ¾‹æ½©æ½¿æ¾•æ½£æ½·æ½ªæ½»ç†²ç†¯ç†›ç†°ç† ç†šç†©ç†µç†ç†¥ç†žç†¤ç†¡ç†ªç†œç†§ç†³çŠ˜çŠšç˜ç’çžçŸç çç›ç¡çšç™"
  ],
  [
    "e6a1",
    "ç¢ç’‡ç’‰ç’Šç’†ç’ç‘½ç’…ç’ˆç‘¼ç‘¹ç”ˆç”‡ç•¾ç˜¥ç˜žç˜™ç˜ç˜œç˜£ç˜šç˜¨ç˜›çšœçšçšžçš›çžçžçž‰çžˆç£ç¢»ç£ç£Œç£‘ç£Žç£”ç£ˆç£ƒç£„ç£‰ç¦šç¦¡ç¦ ç¦œç¦¢ç¦›æ­¶ç¨¹çª²çª´çª³ç®·ç¯‹ç®¾ç®¬ç¯Žç®¯ç®¹ç¯Šç®µç³…ç³ˆç³Œç³‹ç··ç·›ç·ªç·§ç·—ç·¡ç¸ƒç·ºç·¦ç·¶ç·±ç·°ç·®ç·Ÿç½¶ç¾¬ç¾°ç¾­ç¿­ç¿«ç¿ªç¿¬ç¿¦ç¿¨è¤è§è†£è†Ÿ"
  ],
  [
    "e740",
    "è†žè†•è†¢è†™è†—èˆ–è‰è‰“è‰’è‰è‰Žè‰‘è”¤è”»è”è”€è”©è”Žè”‰è”è”Ÿè”Šè”§è”œè“»è”«è“ºè”ˆè”Œè“´è”ªè“²è”•è“·è“«è“³è“¼è”’è“ªè“©è”–è“¾è”¨è”è”®è”‚è“½è”žè“¶è”±è”¦è“§è“¨è“°è“¯è“¹è”˜è” è”°è”‹è”™è”¯è™¢"
  ],
  [
    "e7a1",
    "è–è£è¤è·èŸ¡è³è˜è”è›è’è¡èšè‘èžè­èªèèŽèŸèè¯è¬èºè®èœè¥èè»èµè¢è§è©è¡šè¤…è¤Œè¤”è¤‹è¤—è¤˜è¤™è¤†è¤–è¤‘è¤Žè¤‰è¦¢è¦¤è¦£è§­è§°è§¬è«è«†èª¸è«“è«‘è«”è«•èª»è«—èª¾è«€è«…è«˜è«ƒèªºèª½è«™è°¾è±è²è³¥è³Ÿè³™è³¨è³šè³è³§è¶ è¶œè¶¡è¶›è¸ è¸£è¸¥è¸¤è¸®è¸•è¸›è¸–è¸‘è¸™è¸¦è¸§"
  ],
  [
    "e840",
    "è¸”è¸’è¸˜è¸“è¸œè¸—è¸šè¼¬è¼¤è¼˜è¼šè¼ è¼£è¼–è¼—é³é°é¯é§é«é„¯é„«é„©é„ªé„²é„¦é„®é†…é††é†Šé†é†‚é†„é†€é‹é‹ƒé‹„é‹€é‹™éŠ¶é‹é‹±é‹Ÿé‹˜é‹©é‹—é‹é‹Œé‹¯é‹‚é‹¨é‹Šé‹ˆé‹Žé‹¦é‹é‹•é‹‰é‹ é‹žé‹§é‹‘é‹“"
  ],
  [
    "e8a1",
    "éŠµé‹¡é‹†éŠ´é•¼é–¬é–«é–®é–°éš¤éš¢é›“éœ…éœˆéœ‚éšéžŠéžŽéžˆéŸéŸé žé é ¦é ©é ¨é  é ›é §é¢²é¤ˆé£ºé¤‘é¤”é¤–é¤—é¤•é§œé§é§é§“é§”é§Žé§‰é§–é§˜é§‹é§—é§Œéª³é«¬é««é«³é«²é«±é­†é­ƒé­§é­´é­±é­¦é­¶é­µé­°é­¨é­¤é­¬é³¼é³ºé³½é³¿é³·é´‡é´€é³¹é³»é´ˆé´…é´„éºƒé»“é¼é¼å„œå„“å„—å„šå„‘å‡žåŒ´å¡å™°å™ å™®"
  ],
  [
    "e940",
    "å™³å™¦å™£å™­å™²å™žå™·åœœåœ›å£ˆå¢½å£‰å¢¿å¢ºå£‚å¢¼å£†å¬—å¬™å¬›å¬¡å¬”å¬“å¬å¬–å¬¨å¬šå¬ å¬žå¯¯å¶¬å¶±å¶©å¶§å¶µå¶°å¶®å¶ªå¶¨å¶²å¶­å¶¯å¶´å¹§å¹¨å¹¦å¹¯å»©å»§å»¦å»¨å»¥å½‹å¾¼æ†æ†¨æ†–æ‡…æ†´æ‡†æ‡æ‡Œæ†º"
  ],
  [
    "e9a1",
    "æ†¿æ†¸æ†Œæ“—æ“–æ“æ“æ“‰æ’½æ’‰æ“ƒæ“›æ“³æ“™æ”³æ•¿æ•¼æ–¢æ›ˆæš¾æ›€æ›Šæ›‹æ›æš½æš»æšºæ›Œæœ£æ¨´æ©¦æ©‰æ©§æ¨²æ©¨æ¨¾æ©æ©­æ©¶æ©›æ©‘æ¨¨æ©šæ¨»æ¨¿æ©æ©ªæ©¤æ©æ©æ©”æ©¯æ©©æ© æ¨¼æ©žæ©–æ©•æ©æ©Žæ©†æ­•æ­”æ­–æ®§æ®ªæ®«æ¯ˆæ¯‡æ°„æ°ƒæ°†æ¾­æ¿‹æ¾£æ¿‡æ¾¼æ¿Žæ¿ˆæ½žæ¿„æ¾½æ¾žæ¿Šæ¾¨ç€„æ¾¥æ¾®æ¾ºæ¾¬æ¾ªæ¿æ¾¿æ¾¸"
  ],
  [
    "ea40",
    "æ¾¢æ¿‰æ¾«æ¿æ¾¯æ¾²æ¾°ç‡…ç‡‚ç†¿ç†¸ç‡–ç‡€ç‡ç‡‹ç‡”ç‡Šç‡‡ç‡ç†½ç‡˜ç†¼ç‡†ç‡šç‡›çŠçŠžç©ç¦ç§ç¬ç¥ç«çªç‘¿ç’šç’ ç’”ç’’ç’•ç’¡ç”‹ç–€ç˜¯ç˜­ç˜±ç˜½ç˜³ç˜¼ç˜µç˜²ç˜°çš»ç›¦çžšçžçž¡çžœçž›çž¢çž£çž•çž™"
  ],
  [
    "eaa1",
    "çž—ç£ç£©ç£¥ç£ªç£žç££ç£›ç£¡ç£¢ç£­ç£Ÿç£ ç¦¤ç©„ç©ˆç©‡çª¶çª¸çªµçª±çª·ç¯žç¯£ç¯§ç¯ç¯•ç¯¥ç¯šç¯¨ç¯¹ç¯”ç¯ªç¯¢ç¯œç¯«ç¯˜ç¯Ÿç³’ç³”ç³—ç³ç³‘ç¸’ç¸¡ç¸—ç¸Œç¸Ÿç¸ ç¸“ç¸Žç¸œç¸•ç¸šç¸¢ç¸‹ç¸ç¸–ç¸ç¸”ç¸¥ç¸¤ç½ƒç½»ç½¼ç½ºç¾±ç¿¯è€ªè€©è¬è†±è†¦è†®è†¹è†µè†«è†°è†¬è†´è†²è†·è†§è‡²è‰•è‰–è‰—è•–è•…è•«è•è•“è•¡è•˜"
  ],
  [
    "eb40",
    "è•€è•†è•¤è•è•¢è•„è•‘è•‡è•£è”¾è•›è•±è•Žè•®è•µè••è•§è• è–Œè•¦è•è•”è•¥è•¬è™£è™¥è™¤èž›èžèž—èž“èž’èžˆèžèž–èž˜è¹èž‡èž£èž…èžèž‘èžèž„èž”èžœèžšèž‰è¤žè¤¦è¤°è¤­è¤®è¤§è¤±è¤¢è¤©è¤£è¤¯è¤¬è¤Ÿè§±è« "
  ],
  [
    "eba1",
    "è«¢è«²è«´è«µè«è¬”è«¤è«Ÿè«°è«ˆè«žè«¡è«¨è«¿è«¯è«»è²‘è²’è²è³µè³®è³±è³°è³³èµ¬èµ®è¶¥è¶§è¸³è¸¾è¸¸è¹€è¹…è¸¶è¸¼è¸½è¹è¸°è¸¿èº½è¼¶è¼®è¼µè¼²è¼¹è¼·è¼´é¶é¹é»é‚†éƒºé„³é„µé„¶é†“é†é†‘é†é†éŒ§éŒžéŒˆéŒŸéŒ†éŒéºéŒ¸éŒ¼éŒ›éŒ£éŒ’éŒé†éŒ­éŒŽéŒé‹‹éŒé‹ºéŒ¥éŒ“é‹¹é‹·éŒ´éŒ‚éŒ¤é‹¿éŒ©éŒ¹éŒµéŒªéŒ”éŒŒ"
  ],
  [
    "ec40",
    "éŒ‹é‹¾éŒ‰éŒ€é‹»éŒ–é–¼é—é–¾é–¹é–ºé–¶é–¿é–µé–½éš©é›”éœ‹éœ’éœéž™éž—éž”éŸ°éŸ¸é µé ¯é ²é¤¤é¤Ÿé¤§é¤©é¦žé§®é§¬é§¥é§¤é§°é§£é§ªé§©é§§éª¹éª¿éª´éª»é«¶é«ºé«¹é«·é¬³é®€é®…é®‡é­¼é­¾é­»é®‚é®“é®’é®é­ºé®•"
  ],
  [
    "eca1",
    "é­½é®ˆé´¥é´—é´ é´žé´”é´©é´é´˜é´¢é´é´™é´Ÿéºˆéº†éº‡éº®éº­é»•é»–é»ºé¼’é¼½å„¦å„¥å„¢å„¤å„ å„©å‹´åš“åšŒåšåš†åš„åšƒå™¾åš‚å™¿åšå£–å£”å£å£’å¬­å¬¥å¬²å¬£å¬¬å¬§å¬¦å¬¯å¬®å­»å¯±å¯²å¶·å¹¬å¹ªå¾¾å¾»æ‡ƒæ†µæ†¼æ‡§æ‡ æ‡¥æ‡¤æ‡¨æ‡žæ“¯æ“©æ“£æ“«æ“¤æ“¨æ–æ–€æ–¶æ—šæ›’æªæª–æªæª¥æª‰æªŸæª›æª¡æªžæª‡æª“æªŽ"
  ],
  [
    "ed40",
    "æª•æªƒæª¨æª¤æª‘æ©¿æª¦æªšæª…æªŒæª’æ­›æ®­æ°‰æ¿Œæ¾©æ¿´æ¿”æ¿£æ¿œæ¿­æ¿§æ¿¦æ¿žæ¿²æ¿æ¿¢æ¿¨ç‡¡ç‡±ç‡¨ç‡²ç‡¤ç‡°ç‡¢ç³ç®ç¯ç’—ç’²ç’«ç’ç’ªç’­ç’±ç’¥ç’¯ç”ç”‘ç”’ç”ç–„ç™ƒç™ˆç™‰ç™‡çš¤ç›©çžµçž«çž²çž·çž¶"
  ],
  [
    "eda1",
    "çž´çž±çž¨çŸ°ç£³ç£½ç¤‚ç£»ç£¼ç£²ç¤…ç£¹ç£¾ç¤„ç¦«ç¦¨ç©œç©›ç©–ç©˜ç©”ç©šçª¾ç«€ç«ç°…ç°ç¯²ç°€ç¯¿ç¯»ç°Žç¯´ç°‹ç¯³ç°‚ç°‰ç°ƒç°ç¯¸ç¯½ç°†ç¯°ç¯±ç°ç°Šç³¨ç¸­ç¸¼ç¹‚ç¸³é¡ˆç¸¸ç¸ªç¹‰ç¹€ç¹‡ç¸©ç¹Œç¸°ç¸»ç¸¶ç¹„ç¸ºç½…ç½¿ç½¾ç½½ç¿´ç¿²è€¬è†»è‡„è‡Œè‡Šè‡…è‡‡è†¼è‡©è‰›è‰šè‰œè–ƒè–€è–è–§è–•è– è–‹è–£è•»è–¤è–šè–ž"
  ],
  [
    "ee40",
    "è•·è•¼è–‰è–¡è•ºè•¸è•—è–Žè––è–†è–è–™è–è–è–¢è–‚è–ˆè–…è•¹è•¶è–˜è–è–Ÿè™¨èž¾èžªèž­èŸ…èž°èž¬èž¹èžµèž¼èž®èŸ‰èŸƒèŸ‚èŸŒèž·èž¯èŸ„èŸŠèž´èž¶èž¿èž¸èž½èŸžèž²è¤µè¤³è¤¼è¤¾è¥è¥’è¤·è¥‚è¦­è¦¯è¦®è§²è§³è¬ž"
  ],
  [
    "eea1",
    "è¬˜è¬–è¬‘è¬…è¬‹è¬¢è¬è¬’è¬•è¬‡è¬è¬ˆè¬†è¬œè¬“è¬šè±è±°è±²è±±è±¯è²•è²”è³¹èµ¯è¹Žè¹è¹“è¹è¹Œè¹‡è½ƒè½€é‚…é¾é„¸é†šé†¢é†›é†™é†Ÿé†¡é†é† éŽ¡éŽƒéŽ¯é¤é–é‡é¼é˜éœé¶é‰éé‘é é­éŽéŒéªé¹é—é•é’éé±é·é»é¡éžé£é§éŽ€éŽé™é—‡é—€é—‰é—ƒé—…é–·éš®éš°éš¬éœ éœŸéœ˜éœéœ™éžšéž¡éžœ"
  ],
  [
    "ef40",
    "éžžéžéŸ•éŸ”éŸ±é¡é¡„é¡Šé¡‰é¡…é¡ƒé¤¥é¤«é¤¬é¤ªé¤³é¤²é¤¯é¤­é¤±é¤°é¦˜é¦£é¦¡é¨‚é§ºé§´é§·é§¹é§¸é§¶é§»é§½é§¾é§¼é¨ƒéª¾é«¾é«½é¬é«¼é­ˆé®šé®¨é®žé®›é®¦é®¡é®¥é®¤é®†é®¢é® é®¯é´³éµéµ§é´¶é´®é´¯é´±é´¸é´°"
  ],
  [
    "efa1",
    "éµ…éµ‚éµƒé´¾é´·éµ€é´½ç¿µé´­éºŠéº‰éºéº°é»ˆé»šé»»é»¿é¼¤é¼£é¼¢é½”é¾ å„±å„­å„®åš˜åšœåš—åššåšåš™å¥°å¬¼å±©å±ªå·€å¹­å¹®æ‡˜æ‡Ÿæ‡­æ‡®æ‡±æ‡ªæ‡°æ‡«æ‡–æ‡©æ“¿æ”„æ“½æ“¸æ”æ”ƒæ“¼æ–”æ—›æ›šæ››æ›˜æ«…æª¹æª½æ«¡æ«†æªºæª¶æª·æ«‡æª´æª­æ­žæ¯‰æ°‹ç€‡ç€Œç€ç€ç€…ç€”ç€Žæ¿¿ç€€æ¿»ç€¦æ¿¼æ¿·ç€Šçˆç‡¿ç‡¹çˆƒç‡½ç¶"
  ],
  [
    "f040",
    "ç’¸ç“€ç’µç“ç’¾ç’¶ç’»ç“‚ç””ç”“ç™œç™¤ç™™ç™ç™“ç™—ç™šçš¦çš½ç›¬çŸ‚çžºç£¿ç¤Œç¤“ç¤”ç¤‰ç¤ç¤’ç¤‘ç¦­ç¦¬ç©Ÿç°œç°©ç°™ç° ç°Ÿç°­ç°ç°¦ç°¨ç°¢ç°¥ç°°ç¹œç¹ç¹–ç¹£ç¹˜ç¹¢ç¹Ÿç¹‘ç¹ ç¹—ç¹“ç¾µç¾³ç¿·ç¿¸èµè‡‘è‡’"
  ],
  [
    "f0a1",
    "è‡è‰Ÿè‰žè–´è—†è—€è—ƒè—‚è–³è–µè–½è—‡è—„è–¿è—‹è—Žè—ˆè—…è–±è–¶è—’è˜¤è–¸è–·è–¾è™©èŸ§èŸ¦èŸ¢èŸ›èŸ«èŸªèŸ¥èŸŸèŸ³èŸ¤èŸ”èŸœèŸ“èŸ­èŸ˜èŸ£èž¤èŸ—èŸ™è èŸ´èŸ¨èŸè¥“è¥‹è¥è¥Œè¥†è¥è¥‘è¥‰è¬ªè¬§è¬£è¬³è¬°è¬µè­‡è¬¯è¬¼è¬¾è¬±è¬¥è¬·è¬¦è¬¶è¬®è¬¤è¬»è¬½è¬ºè±‚è±µè²™è²˜è²—è³¾è´„è´‚è´€è¹œè¹¢è¹ è¹—è¹–è¹žè¹¥è¹§"
  ],
  [
    "f140",
    "è¹›è¹šè¹¡è¹è¹©è¹”è½†è½‡è½ˆè½‹é„¨é„ºé„»é„¾é†¨é†¥é†§é†¯é†ªéŽµéŽŒéŽ’éŽ·éŽ›éŽéŽ‰éŽ§éŽŽéŽªéŽžéŽ¦éŽ•éŽˆéŽ™éŽŸéŽéŽ±éŽ‘éŽ²éŽ¤éŽ¨éŽ´éŽ£éŽ¥é—’é—“é—‘éš³é›—é›šå·‚é›Ÿé›˜é›éœ£éœ¢éœ¥éž¬éž®éž¨éž«éž¤éžª"
  ],
  [
    "f1a1",
    "éž¢éž¥éŸ—éŸ™éŸ–éŸ˜éŸºé¡é¡‘é¡’é¢¸é¥é¤¼é¤ºé¨é¨‹é¨‰é¨é¨„é¨‘é¨Šé¨…é¨‡é¨†é«€é«œé¬ˆé¬„é¬…é¬©é¬µé­Šé­Œé­‹é¯‡é¯†é¯ƒé®¿é¯é®µé®¸é¯“é®¶é¯„é®¹é®½éµœéµ“éµéµŠéµ›éµ‹éµ™éµ–éµŒéµ—éµ’éµ”éµŸéµ˜éµšéºŽéºŒé»Ÿé¼é¼€é¼–é¼¥é¼«é¼ªé¼©é¼¨é½Œé½•å„´å„µåŠ–å‹·åŽ´åš«åš­åš¦åš§åšªåš¬å£šå£å£›å¤’å¬½å¬¾å¬¿å·ƒå¹°"
  ],
  [
    "f240",
    "å¾¿æ‡»æ”‡æ”æ”æ”‰æ”Œæ”Žæ–„æ—žæ—æ›žæ«§æ« æ«Œæ«‘æ«™æ«‹æ«Ÿæ«œæ«æ««æ«æ«æ«žæ­ æ®°æ°Œç€™ç€§ç€ ç€–ç€«ç€¡ç€¢ç€£ç€©ç€—ç€¤ç€œç€ªçˆŒçˆŠçˆ‡çˆ‚çˆ…çŠ¥çŠ¦çŠ¤çŠ£çŠ¡ç“‹ç“…ç’·ç“ƒç”–ç™ çŸ‰çŸŠçŸ„çŸ±ç¤ç¤›"
  ],
  [
    "f2a1",
    "ç¤¡ç¤œç¤—ç¤žç¦°ç©§ç©¨ç°³ç°¼ç°¹ç°¬ç°»ç³¬ç³ªç¹¶ç¹µç¹¸ç¹°ç¹·ç¹¯ç¹ºç¹²ç¹´ç¹¨ç½‹ç½Šç¾ƒç¾†ç¾·ç¿½ç¿¾è¸è‡—è‡•è‰¤è‰¡è‰£è—«è—±è—­è—™è—¡è—¨è—šè——è—¬è—²è—¸è—˜è—Ÿè—£è—œè—‘è—°è—¦è—¯è—žè—¢è €èŸºè ƒèŸ¶èŸ·è ‰è Œè ‹è †èŸ¼è ˆèŸ¿è Šè ‚è¥¢è¥šè¥›è¥—è¥¡è¥œè¥˜è¥è¥™è¦ˆè¦·è¦¶è§¶è­è­ˆè­Šè­€è­“è­–è­”è­‹è­•"
  ],
  [
    "f340",
    "è­‘è­‚è­’è­—è±ƒè±·è±¶è²šè´†è´‡è´‰è¶¬è¶ªè¶­è¶«è¹­è¹¸è¹³è¹ªè¹¯è¹»è»‚è½’è½‘è½è½è½“è¾´é…€é„¿é†°é†­éžé‡éé‚éšéé¹é¬éŒé™éŽ©é¦éŠé”é®é£é•é„éŽé€é’é§é•½é—šé—›é›¡éœ©éœ«éœ¬éœ¨éœ¦"
  ],
  [
    "f3a1",
    "éž³éž·éž¶éŸéŸžéŸŸé¡œé¡™é¡é¡—é¢¿é¢½é¢»é¢¾é¥ˆé¥‡é¥ƒé¦¦é¦§é¨šé¨•é¨¥é¨é¨¤é¨›é¨¢é¨ é¨§é¨£é¨žé¨œé¨”é«‚é¬‹é¬Šé¬Žé¬Œé¬·é¯ªé¯«é¯ é¯žé¯¤é¯¦é¯¢é¯°é¯”é¯—é¯¬é¯œé¯™é¯¥é¯•é¯¡é¯šéµ·é¶é¶Šé¶„é¶ˆéµ±é¶€éµ¸é¶†é¶‹é¶Œéµ½éµ«éµ´éµµéµ°éµ©é¶…éµ³éµ»é¶‚éµ¯éµ¹éµ¿é¶‡éµ¨éº”éº‘é»€é»¼é¼­é½€é½é½é½–é½—é½˜åŒ·åš²"
  ],
  [
    "f440",
    "åšµåš³å££å­…å·†å·‡å»®å»¯å¿€å¿æ‡¹æ”—æ”–æ”•æ”“æ—Ÿæ›¨æ›£æ›¤æ«³æ«°æ«ªæ«¨æ«¹æ«±æ«®æ«¯ç€¼ç€µç€¯ç€·ç€´ç€±ç‚ç€¸ç€¿ç€ºç€¹ç€ç€»ç€³ççˆ“çˆ”çŠ¨ç½ç¼ç’ºçš«çšªçš¾ç›­çŸŒçŸŽçŸçŸçŸ²ç¤¥ç¤£ç¤§ç¤¨ç¤¤ç¤©"
  ],
  [
    "f4a1",
    "ç¦²ç©®ç©¬ç©­ç«·ç±‰ç±ˆç±Šç±‡ç±…ç³®ç¹»ç¹¾çºçº€ç¾ºç¿¿è¹è‡›è‡™èˆ‹è‰¨è‰©è˜¢è—¿è˜è—¾è˜›è˜€è—¶è˜„è˜‰è˜…è˜Œè—½è ™è è ‘è —è “è –è¥£è¥¦è¦¹è§·è­ è­ªè­è­¨è­£è­¥è­§è­­è¶®èº†èºˆèº„è½™è½–è½—è½•è½˜è½šé‚é…ƒé…é†·é†µé†²é†³é‹é“é»é éé”é¾é•éé¨é™ééµé€é·é‡éŽé–é’éºé‰é¸éŠé¿"
  ],
  [
    "f540",
    "é¼éŒé¶é‘é†é—žé— é—Ÿéœ®éœ¯éž¹éž»éŸ½éŸ¾é¡ é¡¢é¡£é¡Ÿé£é£‚é¥é¥Žé¥™é¥Œé¥‹é¥“é¨²é¨´é¨±é¨¬é¨ªé¨¶é¨©é¨®é¨¸é¨­é«‡é«Šé«†é¬é¬’é¬‘é°‹é°ˆé¯·é°…é°’é¯¸é±€é°‡é°Žé°†é°—é°”é°‰é¶Ÿé¶™é¶¤é¶é¶’é¶˜é¶é¶›"
  ],
  [
    "f5a1",
    "é¶ é¶”é¶œé¶ªé¶—é¶¡é¶šé¶¢é¶¨é¶žé¶£é¶¿é¶©é¶–é¶¦é¶§éº™éº›éºšé»¥é»¤é»§é»¦é¼°é¼®é½›é½ é½žé½é½™é¾‘å„ºå„¹åŠ˜åŠ—å›ƒåš½åš¾å­ˆå­‡å·‹å·å»±æ‡½æ”›æ¬‚æ«¼æ¬ƒæ«¸æ¬€çƒç„çŠçˆç‰ç…ç†çˆçˆšçˆ™ç¾ç”—ç™ªçŸç¤­ç¤±ç¤¯ç±”ç±“ç³²çºŠçº‡çºˆçº‹çº†çºç½ç¾»è€°è‡è˜˜è˜ªè˜¦è˜Ÿè˜£è˜œè˜™è˜§è˜®è˜¡è˜ è˜©è˜žè˜¥"
  ],
  [
    "f640",
    "è ©è è ›è  è ¤è œè «è¡Šè¥­è¥©è¥®è¥«è§ºè­¹è­¸è­…è­ºè­»è´è´”è¶¯èºŽèºŒè½žè½›è½é…†é…„é……é†¹é¿é»é¶é©é½é¼é°é¹éªé·é¬é‘€é±é—¥é—¤é—£éœµéœºéž¿éŸ¡é¡¤é£‰é£†é£€é¥˜é¥–é¨¹é¨½é©†é©„é©‚é©é¨º"
  ],
  [
    "f6a1",
    "é¨¿é«é¬•é¬—é¬˜é¬–é¬ºé­’é°«é°é°œé°¬é°£é°¨é°©é°¤é°¡é¶·é¶¶é¶¼é·é·‡é·Šé·é¶¾é·…é·ƒé¶»é¶µé·Žé¶¹é¶ºé¶¬é·ˆé¶±é¶­é·Œé¶³é·é¶²é¹ºéºœé»«é»®é»­é¼›é¼˜é¼šé¼±é½Žé½¥é½¤é¾’äº¹å›†å›…å›‹å¥±å­‹å­Œå·•å·‘å»²æ”¡æ” æ”¦æ”¢æ¬‹æ¬ˆæ¬‰æ°ç•ç–ç—ç’çˆžçˆŸçŠ©ç¿ç“˜ç“•ç“™ç“—ç™­çš­ç¤µç¦´ç©°ç©±ç±—ç±œç±™ç±›ç±š"
  ],
  [
    "f740",
    "ç³´ç³±çº‘ç½ç¾‡è‡žè‰«è˜´è˜µè˜³è˜¬è˜²è˜¶è ¬è ¨è ¦è ªè ¥è¥±è¦¿è¦¾è§»è­¾è®„è®‚è®†è®…è­¿è´•èº•èº”èºšèº’èºèº–èº—è½ è½¢é…‡é‘Œé‘é‘Šé‘‹é‘é‘‡é‘…é‘ˆé‘‰é‘†éœ¿éŸ£é¡ªé¡©é£‹é¥”é¥›é©Žé©“é©”é©Œé©é©ˆé©Š"
  ],
  [
    "f7a1",
    "é©‰é©’é©é«é¬™é¬«é¬»é­–é­•é±†é±ˆé°¿é±„é°¹é°³é±é°¼é°·é°´é°²é°½é°¶é·›é·’é·žé·šé·‹é·é·œé·‘é·Ÿé·©é·™é·˜é·–é·µé·•é·éº¶é»°é¼µé¼³é¼²é½‚é½«é¾•é¾¢å„½åŠ™å£¨å£§å¥²å­å·˜è ¯å½æˆæˆƒæˆ„æ”©æ”¥æ––æ›«æ¬‘æ¬’æ¬æ¯Šç›çšçˆ¢çŽ‚çŽçŽƒç™°çŸ”ç±§ç±¦çº•è‰¬è˜ºè™€è˜¹è˜¼è˜±è˜»è˜¾è °è ²è ®è ³è¥¶è¥´è¥³è§¾"
  ],
  [
    "f840",
    "è®Œè®Žè®‹è®ˆè±…è´™èº˜è½¤è½£é†¼é‘¢é‘•é‘é‘—é‘žéŸ„éŸ…é €é©–é©™é¬žé¬Ÿé¬ é±’é±˜é±é±Šé±é±‹é±•é±™é±Œé±Žé·»é··é·¯é·£é·«é·¸é·¤é·¶é·¡é·®é·¦é·²é·°é·¢é·¬é·´é·³é·¨é·­é»‚é»é»²é»³é¼†é¼œé¼¸é¼·é¼¶é½ƒé½"
  ],
  [
    "f8a1",
    "é½±é½°é½®é½¯å›“å›å­Žå±­æ”­æ›­æ›®æ¬“çŸç¡çç çˆ£ç“›ç“¥çŸ•ç¤¸ç¦·ç¦¶ç±ªçº—ç¾‰è‰­è™ƒè ¸è ·è µè¡‹è®”è®•èºžèºŸèº èºé†¾é†½é‡‚é‘«é‘¨é‘©é›¥é†éƒé‡éŸ‡éŸ¥é©žé«•é­™é±£é±§é±¦é±¢é±žé± é¸‚é·¾é¸‡é¸ƒé¸†é¸…é¸€é¸é¸‰é·¿é·½é¸„éº é¼žé½†é½´é½µé½¶å›”æ”®æ–¸æ¬˜æ¬™æ¬—æ¬šç¢çˆ¦çŠªçŸ˜çŸ™ç¤¹ç±©ç±«ç³¶çºš"
  ],
  [
    "f940",
    "çº˜çº›çº™è‡ è‡¡è™†è™‡è™ˆè¥¹è¥ºè¥¼è¥»è§¿è®˜è®™èº¥èº¤èº£é‘®é‘­é‘¯é‘±é‘³é‰é¡²é¥Ÿé±¨é±®é±­é¸‹é¸é¸é¸é¸’é¸‘éº¡é»µé¼‰é½‡é½¸é½»é½ºé½¹åœžç¦ç±¯è ¼è¶²èº¦é‡ƒé‘´é‘¸é‘¶é‘µé© é±´é±³é±±é±µé¸”é¸“é»¶é¼Š"
  ],
  [
    "f9a1",
    "é¾¤ç¨ç¥ç³·è™ªè ¾è ½è ¿è®žè²œèº©è»‰é‹é¡³é¡´é£Œé¥¡é¦«é©¤é©¦é©§é¬¤é¸•é¸—é½ˆæˆ‡æ¬žçˆ§è™Œèº¨é’‚é’€é’é©©é©¨é¬®é¸™çˆ©è™‹è®Ÿé’ƒé±¹éº·ç™µé©«é±ºé¸ç©çªéº¤é½¾é½‰é¾˜ç¢éŠ¹è£å¢»æ’ç²§å«ºâ•”â•¦â•—â• â•¬â•£â•šâ•©â•â•’â•¤â••â•žâ•ªâ•¡â•˜â•§â•›â•“â•¥â•–â•Ÿâ•«â•¢â•™â•¨â•œâ•‘â•â•­â•®â•°â•¯â–“"
  ]
];
const require$$7 = [
  [
    "8740",
    "ä°ä°²ä˜ƒä–¦ä•¸ð§‰§äµ·ä–³ð§²±ä³¢ð§³…ã®•äœ¶ä„ä±‡ä±€ð¤Š¿ð£˜—ð§’ð¦º‹ð§ƒ’ä±—ðª‘ää—šä²…ð§±¬ä´‡äª¤äš¡ð¦¬£çˆ¥ð¥©”ð¡©£ð£¸†ð£½¡æ™å›»"
  ],
  [
    "8767",
    "ç¶•å¤ð¨®¹ã·´éœ´ð§¯¯å¯›ð¡µžåª¤ã˜¥ð©º°å«‘å®·å³¼æ®è–“ð©¥…ç‘¡ç’ã¡µð¡µ“ð£šžð¦€¡ã»¬"
  ],
  [
    "87a1",
    "ð¥£žã«µç«¼é¾—ð¤…¡ð¨¤ð£‡ªð ªŠð£‰žäŒŠè’„é¾–é¯ä¤°è˜“å¢–éŠéˆ˜ç§ç¨²æ™ æ¨©è¢ç‘Œç¯…æž‚ç¨¬å‰é†ã“¦ç„ð¥¶¹ç“†é¿‡åž³ä¤¯å‘Œä„±ð£šŽå ˜ç©²ð§­¥è®äš®ð¦ºˆä†ð¥¶™ç®®ð¢’¼é¿ˆð¢“ð¢“‰ð¢“Œé¿‰è”„ð£–»ä‚´é¿Šä“¡ðª·¿æ‹ç®é¿‹"
  ],
  [
    "8840",
    "ã‡€",
    4,
    "ð „Œã‡…ð ƒ‘ð ƒã‡†ã‡‡ð ƒ‹ð¡¿¨ã‡ˆð ƒŠã‡‰ã‡Šã‡‹ã‡Œð „Žã‡ã‡ŽÄ€ÃÇÃ€Ä’Ã‰ÄšÃˆÅŒÃ“Ç‘Ã’à¿¿ÃŠÌ„áº¾à¿¿ÃŠÌŒá»€ÃŠÄÃ¡ÇŽÃ É‘Ä“Ã©Ä›Ã¨Ä«Ã­ÇÃ¬ÅÃ³Ç’Ã²Å«ÃºÇ”Ã¹Ç–Ç˜Çš"
  ],
  [
    "88a1",
    "ÇœÃ¼à¿¿ÃªÌ„áº¿à¿¿ÃªÌŒá»ÃªÉ¡âšâ›"
  ],
  [
    "8940",
    "ðªŽ©ð¡……"
  ],
  [
    "8943",
    "æ”Š"
  ],
  [
    "8946",
    "ä¸½æ»éµŽé‡Ÿ"
  ],
  [
    "894c",
    "ð§œµæ’‘ä¼šä¼¨ä¾¨å…–å…´å†œå‡¤åŠ¡åŠ¨åŒ»åŽå‘å˜å›¢å£°å¤„å¤‡å¤²å¤´å­¦å®žå®Ÿå²šåº†æ€»æ–‰æŸ¾æ „æ¡¥æµŽç‚¼ç”µçº¤çº¬çººç»‡ç»ç»Ÿç¼†ç¼·è‰ºè‹è¯è§†è®¾è¯¢è½¦è½§è½®"
  ],
  [
    "89a1",
    "ç‘ç³¼ç·æ¥†ç«‰åˆ§"
  ],
  [
    "89ab",
    "é†Œç¢¸é…žè‚¼"
  ],
  [
    "89b0",
    "è´‹èƒ¶ð §§"
  ],
  [
    "89b5",
    "è‚Ÿé»‡ä³é·‰é¸Œä°¾ð©·¶ð§€Žé¸Šðª„³ã—"
  ],
  [
    "89c1",
    "æºšèˆ¾ç”™"
  ],
  [
    "89c5",
    "ä¤‘é©¬éªé¾™ç¦‡ð¨‘¬ð¡·Šð —ð¢«¦ä¸¤äºäº€äº‡äº¿ä»«ä¼·ã‘Œä¾½ã¹ˆå€ƒå‚ˆã‘½ã’“ã’¥å††å¤…å‡›å‡¼åˆ…äº‰å‰¹åŠåŒ§ã—‡åŽ©ã•‘åŽ°ã•“å‚å£ã•­ã•²ãšå’“å’£å’´å’¹å“å“¯å”˜å”£å”¨ã–˜å”¿ã–¥ã–¿å——ã—…"
  ],
  [
    "8a40",
    "ð§¶„å”¥"
  ],
  [
    "8a43",
    "ð ±‚ð ´•ð¥„«å–ð¢³†ã§¬ð è¹†ð¤¶¸ð©“¥ä“ð¨‚¾çºð¢°¸ã¨´äŸ•ð¨…ð¦§²ð¤·ªæ“ð µ¼ð ¾´ð ³•ð¡ƒ´æ’è¹¾ð º–ð °‹ð ½¤ð¢²©ð¨‰–ð¤““"
  ],
  [
    "8a64",
    "ð µ†ð©©ð¨ƒ©äŸ´ð¤º§ð¢³‚éª²ã©§ð©—´ã¿­ã”†ð¥‹‡ð©Ÿ”ð§£ˆð¢µ„éµ®é •"
  ],
  [
    "8a76",
    "ä™ð¦‚¥æ’´å“£ð¢µŒð¢¯Šð¡·ã§»ð¡¯"
  ],
  [
    "8aa1",
    "ð¦›šð¦œ–ð§¦ æ“ªð¥’ð ±ƒè¹¨ð¢†¡ð¨­Œð œ±"
  ],
  [
    "8aac",
    "ä ‹ð †©ã¿ºå¡³ð¢¶"
  ],
  [
    "8ab2",
    "ð¤—ˆð “¼ð¦‚—ð ½Œð ¶–å•¹ä‚»äŽº"
  ],
  [
    "8abb",
    "äª´ð¢©¦ð¡‚è†ªé£µð ¶œæ¹ã§¾ð¢µè·€åš¡æ‘¼ã¹ƒ"
  ],
  [
    "8ac9",
    "ðª˜ð ¸‰ð¢«ð¢³‰"
  ],
  [
    "8ace",
    "ð¡ƒˆð£§‚ã¦’ã¨†ð¨Š›ã•¸ð¥¹‰ð¢ƒ‡å™’ð ¼±ð¢²²ð©œ ã’¼æ°½ð¤¸»"
  ],
  [
    "8adf",
    "ð§•´ð¢º‹ð¢ˆˆðª™›ð¨³ð ¹ºð °´ð¦ œç¾“ð¡ƒð¢ ƒð¢¤¹ã—»ð¥‡£ð ºŒð ¾ð ºªã¾“ð ¼°ð µ‡ð¡…ð ¹Œ"
  ],
  [
    "8af6",
    "ð º«ð ®©ð µˆð¡ƒ€ð¡„½ã¿¹ð¢š–æ²ð ¾­"
  ],
  [
    "8b40",
    "ð£´ð§˜¹ð¢¯Žð µ¾ð µ¿ð¢±‘ð¢±•ã¨˜ð º˜ð¡ƒ‡ð ¼®ðª˜²ð¦­ð¨³’ð¨¶™ð¨³Šé–ªå“Œè‹„å–¹"
  ],
  [
    "8b55",
    "ð©»ƒé°¦éª¶ð§žð¢·®ç…€è…­èƒ¬å°œð¦•²è„´ãž—åŸð¨‚½é†¶ð »ºð ¸ð ¹·ð »»ã—ð¤·«ã˜‰ð ³–åš¯ð¢žµð¡ƒ‰ð ¸ð ¹¸ð¡¸ð¡…ˆð¨ˆ‡ð¡‘•ð ¹¹ð¤¹ð¢¶¤å©”ð¡€ð¡€žð¡ƒµð¡ƒ¶åžœð ¸‘"
  ],
  [
    "8ba1",
    "ð§š”ð¨‹ð ¾µð ¹»ð¥…¾ãœƒð ¾¶ð¡†€ð¥‹˜ðªŠ½ð¤§šð¡ ºð¤…·ð¨‰¼å¢™å‰¨ã˜šð¥œ½ç®²å­¨ä €ä¬¬é¼§ä§§é°Ÿé®ð¥­´ð£„½å—»ã—²åš‰ä¸¨å¤‚ð¡¯ð¯¡¸é‘ð ‚†ä¹›äº»ã”¾å°£å½‘å¿„ã£ºæ‰Œæ”µæ­ºæ°µæ°ºç¬çˆ«ä¸¬çŠ­ð¤£©ç½’ç¤»ç³¹ç½“ð¦‰ªã“"
  ],
  [
    "8bde",
    "ð¦‹è€‚è‚€ð¦˜’ð¦¥‘åè¡¤è§ð§¢²è® è´é’…é•¸é•¿é—¨ð¨¸éŸ¦é¡µé£Žé£žé¥£ð© é±¼é¸Ÿé»„æ­¯ï¤‡ä¸·ð ‚‡é˜æˆ·é’¢"
  ],
  [
    "8c40",
    "å€»æ·¾ð©±³é¾¦ã·‰è¢ð¤…Žç·å³µä¬ ð¥‡ã•™ð¥´°æ„¢ð¨¨²è¾§é‡¶ç†‘æœ™çŽºð£Šðª„‡ã²‹ð¡¦€ä¬ç£¤ç‚å†®ð¨œä€‰æ©£ðªŠºäˆ£è˜ð ©¯ç¨ªð©¥‡ð¨«ªé•çåŒ¤ð¢¾é´ç›™ð¨§£é¾§çŸäº£ä¿°å‚¼ä¸¯ä¼—é¾¨å´ç¶‹å¢’å£ð¡¶¶åº’åº™å¿‚ð¢œ’æ–‹"
  ],
  [
    "8ca1",
    "ð£¹æ¤™æ©ƒð£±£æ³¿"
  ],
  [
    "8ca7",
    "çˆ€ð¤”…çŽŒã»›ð¤¨“å¬•ç’¹è®ƒð¥²¤ð¥š•çª“ç¯¬ç³ƒç¹¬è‹¸è–—é¾©è¢é¾ªèº¹é¾«è¿è•Ÿé§ éˆ¡é¾¬ð¨¶¹ð¡¿ä±äŠ¢å¨š"
  ],
  [
    "8cc9",
    "é¡¨æ«ä‰¶åœ½"
  ],
  [
    "8cce",
    "è—–ð¤¥»èŠ¿ð§„ä²ð¦µ´åµ»ð¦¬•ð¦¾¾é¾­é¾®å®–é¾¯æ›§ç¹›æ¹—ç§Šã¶ˆä“ƒð£‰–ð¢ž–äŽšä”¶"
  ],
  [
    "8ce6",
    "å³•ð£¬šè«¹å±¸ã´’ð£•‘åµ¸é¾²ç…—ä•˜ð¤ƒ¬ð¡¸£ä±·ã¥¸ã‘Šð †¤ð¦±è«Œä¾´ð ˆ¹å¦¿è…¬é¡–ð©£ºå¼»"
  ],
  [
    "8d40",
    "ð ®Ÿ"
  ],
  [
    "8d42",
    "ð¢‡ð¨¥­ä„‚äš»ð©¹ã¼‡é¾³ðª†µäƒ¸ãŸ–ä›·ð¦±†ä…¼ð¨š²ð§¿ä•­ã£”ð¥’šä•¡ä”›ä¶‰ä±»äµ¶ä—ªã¿ˆð¤¬ã™¡ä“žä’½ä‡­å´¾åµˆåµ–ã·¼ã å¶¤å¶¹ã  ã ¸å¹‚åº½å¼¥å¾ƒã¤ˆã¤”ã¤¿ã¥æƒ—æ„½å³¥ã¦‰æ†·æ†¹æ‡ã¦¸æˆ¬æŠæ‹¥æŒ˜ã§¸åš±"
  ],
  [
    "8da1",
    "ã¨ƒæ¢æ»æ‡æ‘šã©‹æ“€å´•å˜¡é¾Ÿãª—æ–†ãª½æ—¿æ™“ã«²æš’ã¬¢æœ–ã­‚æž¤æ €ã­˜æ¡Šæ¢„ã­²ã­±ã­»æ¤‰æ¥ƒç‰œæ¥¤æ¦Ÿæ¦…ã®¼æ§–ã¯æ©¥æ©´æ©±æª‚ã¯¬æª™ã¯²æª«æªµæ«”æ«¶æ®æ¯æ¯ªæ±µæ²ªã³‹æ´‚æ´†æ´¦æ¶ã³¯æ¶¤æ¶±æ¸•æ¸˜æ¸©æº†ð¨§€æº»æ»¢æ»šé½¿æ»¨æ»©æ¼¤æ¼´ãµ†ð£½æ¾æ¾¾ãµªãµµç†·å²™ã¶Šç€¬ã¶‘çç”ç¯ç¿ç‚‰ð Œ¥äã—±ð »˜"
  ],
  [
    "8e40",
    "ð£»—åž¾ð¦»“ç„¾ð¥Ÿ ã™Žæ¦¢ð¨¯©å­´ç©‰ð¥£¡ð©“™ç©¥ç©½ð¥¦¬çª»çª°ç«‚ç«ƒç‡‘ð¦’ä‡Šç«šç«ç«ªä‡¯å’²ð¥°ç¬‹ç­•ç¬©ð¥ŒŽð¥³¾ç®¢ç­¯èŽœð¥®´ð¦±¿ç¯è¡ç®’ç®¸ð¥´ ã¶­ð¥±¥è’’ç¯ºç°†ç°µð¥³ç±„ç²ƒð¤¢‚ç²¦æ™½ð¤•¸ç³‰ç³‡ç³¦ç±´ç³³ç³µç³Ž"
  ],
  [
    "8ea1",
    "ç¹§ä”ð¦¹„çµð¦»–ç’ç¶‰ç¶«ç„µç¶³ç·’ð¤—ð¦€©ç·¤ã´“ç·µð¡Ÿ¹ç·¥ð¨­ç¸ð¦„¡ð¦…šç¹®çº’äŒ«é‘¬ç¸§ç½€ç½ç½‡ç¤¶ð¦‹é§¡ç¾—ð¦‘ç¾£ð¡™¡ð ¨ä•œð£¦ä”ƒð¨Œºç¿ºð¦’‰è€…è€ˆè€è€¨è€¯ðª‚‡ð¦³ƒè€»è€¼è¡ð¢œ”ä¦‰ð¦˜¦ð£·£ð¦›¨æœ¥è‚§ð¨©ˆè„‡è„šå¢°ð¢›¶æ±¿ð¦’˜ð¤¾¸æ“§ð¡’Šèˆ˜ð¡¡žæ©“ð¤©¥ð¤ª•ä‘ºèˆ©ð ¬ð¦©’ð£µ¾ä¿¹ð¡“½è“¢è¢ð¦¬Šð¤¦§ð£”°ð¡³ð£·¸èŠªæ¤›ð¯¦”ä‡›"
  ],
  [
    "8f40",
    "è•‹è‹èŒšð ¸–ð¡ž´ã›ð£…½ð£•šè‰»è‹¢èŒ˜ð£º‹ð¦¶£ð¦¬…ð¦®—ð£—Žã¶¿èŒå—¬èŽ…ä”‹ð¦¶¥èŽ¬èè“ã‘¾ð¦»”æ©—è•šã’–ð¦¹‚ð¢»¯è‘˜ð¥¯¤è‘±ã·“ä“¤æª§è‘Šð£²µç¥˜è’¨ð¦®–ð¦¹·ð¦¹ƒè“žèèŽ‘ä’ è’“è“¤ð¥²‘ä‰€ð¥³€ä•ƒè”´å«²ð¦º™ä”§è•³ä”–æž¿è˜–"
  ],
  [
    "8fa1",
    "ð¨˜¥ð¨˜»è—ð§‚ˆè˜‚ð¡–‚ð§ƒð¯¦²ä•ªè˜¨ã™ˆð¡¢¢å·ð§Žšè™¾è±ðªƒ¸èŸ®ð¢°§èž±èŸšè å™¡è™¬æ¡–ä˜è¡…è¡†ð§— ð£¶¹ð§—¤è¡žè¢œä™›è¢´è¢µæè£…ç·ð§œè¦‡è¦Šè¦¦è¦©è¦§è¦¼ð¨¨¥è§§ð§¤¤ð§ª½èªœçž“é‡¾èªð§©™ç«©ð§¬ºð£¾äœ“ð§¬¸ç…¼è¬Œè¬Ÿð¥°ð¥•¥è¬¿è­Œè­èª©ð¤©ºè®è®›èª¯ð¡›Ÿä˜•è¡è²›ð§µ”ð§¶ð¯§”ãœ¥ð§µ“è³–ð§¶˜ð§¶½è´’è´ƒð¡¤è³›çœè´‘ð¤³‰ã»èµ·"
  ],
  [
    "9040",
    "è¶©ð¨€‚ð¡€”ð¤¦Šã­¼ð¨†¼ð§„Œç«§èº­èº¶è»ƒé‹”è¼™è¼­ð¨¥ð¨’è¾¥éŒƒðªŠŸð ©è¾³ä¤ªð¨§žð¨”½ð£¶»å»¸ð£‰¢è¿¹ðª€”ð¨š¼ð¨”ð¢Œ¥ã¦€ð¦»—é€·ð¨”¼ð§ª¾é¡ð¨•¬ð¨˜‹é‚¨ð¨œ“éƒ„ð¨›¦é‚®éƒ½é…§ã«°é†©é‡„ç²¬ð¨¤³ð¡º‰éˆŽæ²Ÿé‰é‰¢ð¥–¹éŠ¹ð¨«†ð£²›ð¨¬Œð¥—›"
  ],
  [
    "90a1",
    "ð ´±éŒ¬é«ð¨«¡ð¨¯«ç‚å«ƒð¨«¢ð¨«¥ä¥¥é‰„ð¨¯¬ð¨°¹ð¨¯¿é³é‘›èº¼é–…é–¦é¦é– æ¿¶äŠ¹ð¢™ºð¨›˜ð¡‰¼ð£¸®ä§Ÿæ°œé™»éš–ä…¬éš£ð¦»•æ‡šéš¶ç£µð¨« éš½åŒä¦¡ð¦²¸ð ‰´ð¦ð©‚¯ð©ƒ¥ð¤«‘ð¡¤•ð£ŒŠéœ±è™‚éœ¶ä¨ä”½ä–…ð¤«©çµå­éœ›éœð©‡•é—å­Šð©‡«éŸé¥åƒð£‚·ð£‚¼éž‰éžŸéž±éž¾éŸ€éŸ’éŸ ð¥‘¬éŸ®çœð©³éŸ¿éŸµð©ð§¥ºä«‘é ´é ³é¡‹é¡¦ã¬Žð§…µãµ‘ð ˜°ð¤…œ"
  ],
  [
    "9140",
    "ð¥œ†é£Šé¢·é£ˆé£‡ä«¿ð¦´§ð¡›“å–°é£¡é£¦é£¬é¸é¤¹ð¤¨©ä­²ð©¡—ð©¤…é§µé¨Œé¨»é¨é©˜ð¥œ¥ã›„ð©‚±ð©¯•é« é«¢ð©¬…é«´ä°Žé¬”é¬­ð¨˜€å€´é¬´ð¦¦¨ã£ƒð£½é­é­€ð©´¾å©…ð¡¡£é®Žð¤‰‹é°‚é¯¿é°Œð©¹¨é·”ð©¾·ðª†’ðª†«ðªƒ¡ðª„£ðª‡Ÿéµ¾é¶ƒðª„´é¸Žæ¢ˆ"
  ],
  [
    "91a1",
    "é·„ð¢…›ðª†“ðªˆ ð¡¤»ðªˆ³é´¹ðª‚¹ðªŠ´éºéº•éºžéº¢ä´´éºªéº¯ð¤¤é»ã­ ã§¥ã´ä¼²ãž¾ð¨°«é¼‚é¼ˆä®–é¤ð¦¶¢é¼—é¼–é¼¹åšŸåšŠé½…é¦¸ð©‚‹éŸ²è‘¿é½¢é½©ç«œé¾Žçˆ–ä®¾ð¤¥µð¤¦»ç…·ð¤§¸ð¤ˆð¤©‘çŽžð¨¯šð¡£ºç¦Ÿð¨¥¾ð¨¸¶é©é³ð¨©„é‹¬éŽé‹ð¨¥¬ð¤’¹çˆ—ã»«ç²ç©ƒçƒð¤‘³ð¤¸ç…¾ð¡Ÿ¯ç‚£ð¡¢¾ð£–™ã»‡ð¡¢…ð¥¯ð¡Ÿ¸ãœ¢ð¡›»ð¡ ¹ã›¡ð¡´ð¡£‘ð¥½‹ãœ£ð¡›€å›ð¤¨¥ð¡¾ð¡Š¨"
  ],
  [
    "9240",
    "ð¡†ð¡’¶è”ƒð£š¦è”ƒè‘•ð¤¦”ð§…¥ð£¸±ð¥•œð£»»ð§’ä“´ð£›®ð©¦ð¦¼¦æŸ¹ãœ³ã°•ã·§å¡¬ð¡¤¢æ ä—ð£œ¿ð¤ƒ¡ð¤‚‹ð¤„ð¦°¡å“‹åšžð¦š±åš’ð ¿Ÿð ®¨ð ¸é†ð¨¬“éŽœä»¸å„«ã ™ð¤¶äº¼ð ‘¥ð ¿ä½‹ä¾Šð¥™‘å©¨ð †«ð ‹ã¦™ð ŒŠð ”ãµä¼©ð ‹€ð¨º³ð ‰µè«šð ˆŒäº˜"
  ],
  [
    "92a1",
    "åƒå„ä¾¢ä¼ƒð¤¨Žð£ºŠä½‚å€®å¬å‚ä¿Œä¿¥å˜åƒ¼å…™å…›å…å…žæ¹¶ð£–•ð£¸¹ð£º¿æµ²ð¡¢„ð£º‰å†¨å‡ƒð — ä“ð ’£ð ’’ð ’‘èµºð¨ªœð œŽå‰™åŠ¤ð ¡³å‹¡é®ä™ºç†Œð¤ŽŒð ° ð¤¦¬ð¡ƒ¤æ§‘ð ¸ç‘¹ã»žç’™ç”ç‘–çŽ˜ä®Žð¤ª¼ð¤‚åã–„çˆð¤ƒ‰å–´ð …å“ð ¯†åœé‰é›´é¦åŸåžå¿ã˜¾å£‹åª™ð¨©†ð¡›ºð¡¯ð¡œå¨¬å¦¸éŠå©¾å«å¨’ð¥¥†ð¡§³ð¡¡¡ð¤Š•ã›µæ´…ç‘ƒå¨¡ð¥ºƒ"
  ],
  [
    "9340",
    "åªð¨¯—ð “é ç’Œð¡Œƒç„…ä¥²éˆð¨§»éŽ½ãž å°žå²žå¹žå¹ˆð¡¦–ð¡¥¼ð£«®å»å­ð¡¤ƒð¡¤„ãœð¡¢ ã›ð¡›¾ã›“è„ªð¨©‡ð¡¶ºð£‘²ð¨¦¨å¼Œå¼Žð¡¤§ð¡ž«å©«ð¡œ»å­„è˜”ð§—½è¡ æ¾ð¢¡ ð¢˜«å¿›ãº¸ð¢–¯ð¢–¾ð©‚ˆð¦½³æ‡€ð €¾ð †ð¢˜›æ†™æ†˜æµð¢²›ð¢´‡ð¤›”ð©…"
  ],
  [
    "93a1",
    "æ‘±ð¤™¥ð¢­ªã¨©ð¢¬¢ð£‘ð©£ªð¢¹¸æŒ·ðª‘›æ’¶æŒ±æ‘ð¤§£ð¢µ§æŠ¤ð¢²¡æ»æ•«æ¥²ã¯´ð£‚Žð£Š­ð¤¦‰ð£Š«å”ð£‹ ð¡£™ð©¿æ›Žð£Š‰ð£†³ã« ä†ð¥–„ð¨¬¢ð¥–ð¡›¼ð¥•›ð¥¥ç£®ð£„ƒð¡ ªð£ˆ´ã‘¤ð£ˆð£†‚ð¤‹‰æšŽð¦´¤æ™«ä®“æ˜°ð§¡°ð¡·«æ™£ð£‹’ð£‹¡æ˜žð¥¡²ã£‘ð£ ºð£ž¼ã®™ð£ž¢ð£¾ç“ã®–æžð¤˜ªæ¢¶æ žã¯„æª¾ã¡£ð£Ÿ•ð¤’‡æ¨³æ©’æ«‰æ¬…ð¡¤’æ”‘æ¢˜æ©Œã¯—æ©ºæ­—ð£¿€ð£²šéŽ é‹²ð¨¯ªð¨«‹"
  ],
  [
    "9440",
    "éŠ‰ð¨€žð¨§œé‘§æ¶¥æ¼‹ð¤§¬æµ§ð£½¿ã¶æ¸„ð¤€¼å¨½æ¸Šå¡‡æ´¤ç¡‚ç„»ð¤Œšð¤‰¶çƒ±ç‰çŠ‡çŠ”ð¤žð¤œ¥å…¹ð¤ª¤ð —«ç‘ºð£»¸ð£™Ÿð¤©Šð¤¤—ð¥¿¡ã¼†ãº±ð¤«Ÿð¨°£ð£¼µæ‚§ã»³ç“Œç¼éŽ‡ç·ä’Ÿð¦·ªä•‘ç–ƒã½£ð¤³™ð¤´†ã½˜ç••ç™³ðª—†ã¬™ç‘¨ð¨«Œð¤¦«ð¤¦Žã«»"
  ],
  [
    "94a1",
    "ã·ð¤©Žã»¿ð¤§…ð¤£³é‡ºåœ²é‚ð¨«£ð¡¡¤åƒŸð¥ˆ¡ð¥‡§ç¸ð£ˆ²çœŽçœç»ð¤š—ð£žã©žð¤£°ç¸ç’›ãº¿ð¤ªºð¤«‡äƒˆð¤ª–ð¦†®éŒ‡ð¥–ç žç¢ç¢ˆç£’çç¥™ð§ð¥›£ä„Žç¦›è’–ç¦¥æ¨­ð£»ºç¨ºç§´ä…®ð¡›¦ä„²éˆµç§±ð µŒð¤¦Œð Š™ð£¶ºð¡®ã–—å•«ã•°ãšªð ‡”ð °ç«¢å©™ð¢›µð¥ª¯ð¥ªœå¨ð ‰›ç£°å¨ªð¥¯†ç«¾ä‡¹ç±ç±­äˆ‘ð¥®³ð¥º¼ð¥º¦ç³ð¤§¹ð¡ž°ç²Žç±¼ç²®æª²ç·œç¸‡ç·“ç½Žð¦‰¡"
  ],
  [
    "9540",
    "ð¦…œð§­ˆç¶—ð¥º‚ä‰ªð¦­µð ¤–æŸ–ð Žð£—åŸ„ð¦’ð¦¸ð¤¥¢ç¿ç¬§ð  ¬ð¥«©ð¥µƒç¬Œð¥¸Žé§¦è™…é©£æ¨œð£¿ã§¢ð¤§·ð¦–­é¨Ÿð¦– è’€ð§„§ð¦³‘ä“ªè„·ä‚èƒ†è„‰è…‚ð¦ž´é£ƒð¦©‚è‰¢è‰¥ð¦©‘è‘“ð¦¶§è˜ð§ˆ›åª†ä…¿ð¡¡€å¬«ð¡¢¡å«¤ð¡£˜èš ð¯¦¼ð£¶è ­ð§¢å¨‚"
  ],
  [
    "95a1",
    "è¡®ä½…è¢‡è¢¿è£¦è¥¥è¥ð¥šƒè¥”ð§ž…ð§ž„ð¨¯µð¨¯™ð¨®œð¨§¹ãº­è’£ä›µä›ãŸ²è¨½è¨œð©‘ˆå½éˆ«ð¤Š„æ—”ç„©çƒ„ð¡¡…éµ­è²Ÿè³©ð§·œå¦šçŸƒå§°ä®ã›”è¸ªèº§ð¤°‰è¼°è½Šä‹´æ±˜æ¾»ð¢Œ¡ä¢›æ½¹æº‹ð¡Ÿšé¯©ãšµð¤¤¯é‚»é‚—å•±ä¤†é†»é„ð¨©‹ä¢ð¨«¼é§ð¨°ð¨°»è“¥è¨«é–™é–§é–—é––ð¨´´ç‘…ã»‚ð¤£¿ð¤©‚ð¤ªã»§ð£ˆ¥éšð¨»§ð¨¹¦ð¨¹¥ã»Œð¤§­ð¤©¸ð£¿®ç’ç‘«ã»¼éð©‚°"
  ],
  [
    "9640",
    "æ¡‡ä¨ð©‚“ð¥ŸŸéé¨ð¨¦‰ð¨°¦ð¨¬¯ð¦Ž¾éŠºå¬‘è­©ä¤¼ç¹ð¤ˆ›éž›é±é¤¸ð ¼¦å·ð¨¯…ð¤ª²é Ÿð©“šé‹¶ð©——é‡¥ä“€ð¨­ð¤©§ð¨­¤é£œð¨©…ã¼€éˆªä¤¥è”é¤»é¥ð§¬†ã·½é¦›ä­¯é¦ªé©œð¨­¥ð¥£ˆæªé¨¡å«¾é¨¯ð©£±ä®ð©¥ˆé¦¼ä®½ä®—é½å¡²ð¡Œ‚å ¢ð¤¦¸"
  ],
  [
    "96a1",
    "ð¡“¨ç¡„ð¢œŸð£¶¸æ£…ãµ½é‘˜ã¤§æ…ð¢žð¢¥«æ„‡é±é±“é±»é°µé°é­¿é¯ð©¸­é®Ÿðª‡µðªƒ¾é´¡ä²®ð¤„„é¸˜ä²°é´Œðª†´ðªƒ­ðªƒ³ð©¤¯é¶¥è’½ð¦¸’ð¦¿Ÿð¦®‚è—¼ä”³ð¦¶¤ð¦º„ð¦·°è è—®ð¦¸€ð£Ÿ—ð¦¤ç§¢ð£–œð£™€ä¤­ð¤§žãµ¢é›éŠ¾éˆð Š¿ç¢¹é‰·é‘ä¿¤ã‘€é¤ð¥•ç ½ç¡”ç¢¶ç¡‹ð¡—ð£‡‰ð¤¥ãššä½²æ¿šæ¿™ç€žç€žå”ð¤†µåž»å£³åžŠé´–åŸ—ç„´ã’¯ð¤†¬ç‡«ð¦±€ð¤¾—å¬¨ð¡žµð¨©‰"
  ],
  [
    "9740",
    "æ„Œå«Žå¨‹äŠ¼ð¤’ˆãœ¬ä­»ð¨§¼éŽ»éŽ¸ð¡£–ð ¼è‘²ð¦³€ð¡“ð¤‹ºð¢°¦ð¤å¦”ð£¶·ð¦ç¶¨ð¦…›ð¦‚¤ð¤¦¹ð¤¦‹ð¨§ºé‹¥ç¢ã»©ç’´ð¨­£ð¡¢Ÿã»¡ð¤ª³æ«˜ç³ç»ã»–ð¤¨¾ð¤ª”ð¡Ÿ™ð¤©¦ð Ž§ð¡¤ð¤§¥ç‘ˆð¤¤–ç‚¥ð¤¥¶éŠ„ç¦éŸð “¾éŒ±ð¨«Žð¨¨–éŽ†ð¨¯§ð¥—•ä¤µð¨ª‚ç…«"
  ],
  [
    "97a1",
    "ð¤¥ƒð ³¿åš¤ð ˜šð ¯«ð ²¸å”‚ç§„ð¡Ÿºç·¾ð¡›‚ð¤©ð¡¡’ä”®éãœŠð¨«€ð¤¦­å¦°ð¡¢¿ð¡¢ƒð§’„åª¡ã›¢ð£µ›ãš°é‰Ÿå©¹ð¨ªð¡¡¢é´ã³ð ª´äª–ã¦Šåƒ´ãµ©ãµŒð¡Žœç…µä‹»ð¨ˆ˜æ¸ð©ƒ¤ä“«æµ—ð§¹ç§æ²¯ã³–ð£¿­ð£¸­æ¸‚æ¼Œãµ¯ð µç•‘ãš¼ã“ˆäš€ã»šä¡±å§„é‰®ä¤¾è½ð¨°œð¦¯€å ’åŸˆã›–ð¡‘’çƒ¾ð¤¢ð¤©±ð¢¿£ð¡Š°ð¢Ž½æ¢¹æ¥§ð¡Ž˜ð£“¥ð§¯´ð£›Ÿð¨ªƒð£Ÿ–ð£ºð¤²Ÿæ¨šð£š­ð¦²·è¾ä“Ÿä“Ž"
  ],
  [
    "9840",
    "ð¦´¦ð¦µ‘ð¦²‚ð¦¿žæ¼—ð§„‰èŒ½ð¡œºè­ð¦²€ð§“ð¡Ÿ›å¦‰åª‚ð¡ž³å©¡å©±ð¡¤…ð¤‡¼ãœ­å§¯ð¡œ¼ã›‡ç†ŽéŽæššð¤Š¥å©®å¨«ð¤Š“æ¨«ð£»¹ð§œ¶ð¤‘›ð¤‹Šç„ð¤‰™ð¨§¡ä¾°ð¦´¨å³‚ð¤“Žð§¹ð¤Ž½æ¨Œð¤‰–ð¡Œ„ç‚¦ç„³ð¤©ã¶¥æ³Ÿð¯ ¥ð¤©ç¹¥å§«å´¯ã·³å½œð¤©ð¡ŸŸç¶¤è¦"
  ],
  [
    "98a1",
    "å’…ð£«ºð£Œ€ð ˆ”å¾ð £•ð ˜™ã¿¥ð¡¾žðªŠ¶ç€ƒð©…›åµ°çŽç³“ð¨©™ð© ä¿ˆç¿§ç‹çŒð§«´çŒ¸çŒ¹ð¥›¶ççˆãº©ð§¬˜é¬ç‡µð¤£²ç¡è‡¶ã»ŠçœŒã»‘æ²¢å›½ç™çžçŸã»¢ã»°ã»´ã»ºç““ã¼Žã½“ç•‚ç•­ç•²ç–ã½¼ç—ˆç—œã¿€ç™ã¿—ç™´ã¿œç™ºð¤½œç†ˆå˜£è¦€å¡©ä€çƒä€¹æ¡ä…ã—›çž˜äªä¯å±žçž¾çŸ‹å£²ç ˜ç‚¹ç œä‚¨ç ¹ç¡‡ç¡‘ç¡¦è‘ˆð¥”µç¤³æ ƒç¤²ä„ƒ"
  ],
  [
    "9940",
    "ä„‰ç¦‘ç¦™è¾»ç¨†è¾¼ä…§çª‘ä†²çª¼è‰¹ä‡„ç«ç«›ä‡ä¸¡ç­¢ç­¬ç­»ç°’ç°›ä‰ ä‰ºç±»ç²œäŠŒç²¸äŠ”ç³­è¾“çƒ€ð ³ç·ç·”ç·ç·½ç¾®ç¾´çŠŸäŽ—è€ è€¥ç¬¹è€®è€±è”ã·Œåž´ç‚ è‚·èƒ©ä­è„ŒçŒªè„Žè„’ç• è„”äã¬¹è…–è…™è…š"
  ],
  [
    "99a1",
    "ä“å ºè…¼è†„ä¥è†“ä­è†¥åŸ¯è‡è‡¤è‰”ä’èŠ¦è‰¶è‹Šè‹˜è‹¿ä’°è—é™©æ¦Šè…çƒµè‘¤æƒ£è’ˆä”„è’¾è“¡è“¸è”è”¸è•’ä”»è•¯è•°è— ä•·è™²èš’èš²è›¯é™…èž‹ä˜†ä˜—è¢®è£¿è¤¤è¥‡è¦‘ð§¥§è¨©è¨¸èª”èª´è±‘è³”è³²è´œäž˜å¡Ÿè·ƒäŸ­ä»®è¸ºå—˜å”è¹±å—µèº°ä ·è»Žè»¢è»¤è»­è»²è¾·è¿è¿Šè¿Œé€³é§„ä¢­é£ éˆ“ä¤žéˆ¨é‰˜é‰«éŠ±éŠ®éŠ¿"
  ],
  [
    "9a40",
    "é‹£é‹«é‹³é‹´é‹½éƒéŽ„éŽ­ä¥…ä¥‘éº¿é—åŒéé­é¾ä¥ªé‘”é‘¹é”­é–¢ä¦§é—´é˜³ä§¥æž ä¨¤é€ä¨µéž²éŸ‚å™”ä«¤æƒ¨é¢¹ä¬™é£±å¡„é¤Žé¤™å†´é¤œé¤·é¥‚é¥é¥¢ä­°é§…ä®é¨¼é¬çªƒé­©é®é¯é¯±é¯´ä±­é° ã¯ð¡¯‚éµ‰é°º"
  ],
  [
    "9aa1",
    "é»¾å™é¶“é¶½é·€é·¼é“¶è¾¶é¹»éº¬éº±éº½é»†é“œé»¢é»±é»¸ç«ˆé½„ð ‚”ð Š·ð Ž æ¤šé“ƒå¦¬ð “—å¡€é“ãž¹ð —•ð ˜•ð ™¶ð¡šºå—ç…³ð «‚ð «ð ®¿å‘ªð¯ »ð ¯‹å’žð ¯»ð °»ð ±“ð ±¥ð ±¼æƒ§ð ²å™ºð ²µð ³ð ³­ð µ¯ð ¶²ð ·ˆæ¥•é°¯èž¥ð ¸„ð ¸Žð »—ð ¾ð ¼­ð ¹³å° ð ¾¼å¸‹ð¡œð¡ð¡¶æœžð¡»ð¡‚ˆð¡‚–ã™‡ð¡‚¿ð¡ƒ“ð¡„¯ð¡„»å¤è’­ð¡‹£ð¡µð¡Œ¶è®ð¡•·ð¡˜™ð¡Ÿƒð¡Ÿ‡ä¹¸ç‚»ð¡ ­ð¡¥ª"
  ],
  [
    "9b40",
    "ð¡¨­ð¡©…ð¡°ªð¡±°ð¡²¬ð¡»ˆæ‹ƒð¡»•ð¡¼•ç†˜æ¡•ð¢…æ§©ã›ˆð¢‰¼ð¢—ð¢ºð¢œªð¢¡±ð¢¥è‹½ð¢¥§ð¢¦“ð¢«•è¦¥ð¢«¨è¾ ð¢¬Žéž¸ð¢¬¿é¡‡éª½ð¢±Œ"
  ],
  [
    "9b62",
    "ð¢²ˆð¢²·ð¥¯¨ð¢´ˆð¢´’ð¢¶·ð¢¶•ð¢¹‚ð¢½´ð¢¿Œð£€³ð£¦ð£ŒŸð£žå¾±æ™ˆæš¿ð§©¹ð£•§ð£—³çˆð¤¦ºçŸ—ð£˜šð£œ–çº‡ð †å¢µæœŽ"
  ],
  [
    "9ba1",
    "æ¤˜ð£ª§ð§™—ð¥¿¢ð£¸‘ð£º¹ð§—¾ð¢‚šä£äª¸ð¤„™ð¨ªšð¤‹®ð¤Œð¤€»ð¤Œ´ð¤Ž–ð¤©…ð —Šå‡’ð ˜‘å¦Ÿð¡º¨ã®¾ð£³¿ð¤„ð¤“–åžˆð¤™´ã¦›ð¤œ¯ð¨—¨ð©§‰ã¢ð¢‡ƒè­žð¨­Žé§–ð¤ ’ð¤£»ð¤¨•çˆ‰ð¤«€ð ±¸å¥¥ð¤º¥ð¤¾†ð ¹è»šð¥€¬åŠåœ¿ç…±ð¥Š™ð¥™ð£½Šð¤ª§å–¼ð¥‘†ð¥‘®ð¦­’é‡”ã‘³ð¥”¿ð§˜²ð¥•žäœ˜ð¥•¢ð¥•¦ð¥Ÿ‡ð¤¤¿ð¥¡å¦ã“»ð£Œæƒžð¥¤ƒä¼ð¨¥ˆð¥ª®ð¥®‰ð¥°†ð¡¶åž¡ç…‘æ¾¶ð¦„‚ð§°’é–ð¦†²ð¤¾šè­¢ð¦‚ð¦‘Š"
  ],
  [
    "9c40",
    "åµ›ð¦¯·è¼¶ð¦’„ð¡¤œè«ªð¤§¶ð¦’ˆð£¿¯ð¦”’ä¯€ð¦–¿ð¦šµð¢œ›é‘¥ð¥Ÿ¡æ†•å¨§ð¯£ä¾»åš¹ð¤”¡ð¦›¼ä¹ªð¤¤´é™–æ¶ð¦²½ã˜˜è¥·ð¦ž™ð¦¡®ð¦‘ð¦¡žç‡Ÿð¦£‡ç­‚ð©ƒ€ð ¨‘ð¦¤¦é„„ð¦¤¹ç©…é·°ð¦§ºé¨¦ð¦¨­ã™Ÿð¦‘©ð €¡ç¦ƒð¦¨´ð¦­›å´¬ð£”™èð¦®ä›ð¦²¤ç”»è¡¥ð¦¶®å¢¶"
  ],
  [
    "9ca1",
    "ãœœð¢–ð§‹ð§‡ã±”ð§Š€ð§Š…éŠð¢…ºð§Š‹éŒ°ð§‹¦ð¤§æ°¹é’Ÿð§‘ð »¸è §è£µð¢¤¦ð¨‘³ð¡ž±æº¸ð¤¨ªð¡  ã¦¤ãš¹å°ç§£ä”¿æš¶ð©²­ð©¢¤è¥ƒð§ŸŒð§¡˜å›–äƒŸð¡˜Šã¦¡ð£œ¯ð¨ƒ¨ð¡…ç†­è¦ð§§ð©†¨å©§ä²·ð§‚¯ð¨¦«ð§§½ð§¨Šð§¬‹ð§µ¦ð¤…ºç­ƒç¥¾ð¨€‰æ¾µðª‹Ÿæ¨ƒð¨Œ˜åŽ¢ð¦¸‡éŽ¿æ ¶éð¨…¯ð¨€£ð¦¦µð¡­ð£ˆ¯ð¨ˆå¶…ð¨°°ð¨‚ƒåœ•é £ð¨¥‰å¶«ð¤¦ˆæ–¾æ§•å’ð¤ª¥ð£¾ã°‘æœ¶ð¨‚ð¨ƒ´ð¨„®ð¡¾¡ð¨…"
  ],
  [
    "9d40",
    "ð¨†‰ð¨†¯ð¨ˆšð¨Œ†ð¨Œ¯ð¨ŽŠã—Šð¨‘¨ð¨šªä£ºæ¦ð¨¥–ç ˆé‰•ð¨¦¸ä²ð¨§§äŸð¨§¨ð¨­†ð¨¯”å§¸ð¨°‰è¼‹ð¨¿…ð©ƒ¬ç­‘ð©„ð©„¼ã··ð©…žð¤«Šè¿çŠåš‹ð©“§ð©—©ð©–°ð©–¸ð©œ²ð©£‘ð©¥‰ð©¥ªð©§ƒð©¨¨ð©¬Žð©µšð©¶›çºŸð©»¸ð©¼£ä²¤é•‡ðªŠ“ç†¢ðª‹¿ä¶‘é€’ðª—‹ä¶œð ²œè¾¾å—"
  ],
  [
    "9da1",
    "è¾ºð¢’°è¾¹ð¤ª“ä”‰ç¹¿æ½–æª±ä»ªã“¤ð¨¬¬ð§¢ãœºèº€ð¡Ÿµð¨€¤ð¨­¬ð¨®™ð§¨¾ð¦š¯ã·«ð§™•ð£²·ð¥˜µð¥¥–äºšð¥ºð¦‰˜åš¿ð ¹­è¸Žå­­ð£ºˆð¤²žæžæ‹ð¡Ÿ¶ð¡¡»æ”°å˜­ð¥±Šåšð¥Œ‘ã·†ð©¶˜ä±½å˜¢å˜žç½‰ð¥»˜å¥µð£µ€è°ä¸œð ¿ªð µ‰ð£šºè„—éµžè´˜ç˜»é±…ç™Žçž¹é…å²è…ˆè‹·å˜¥è„²è˜è‚½å—ªç¥¢å™ƒå–ð ºã—Žå˜…å—±æ›±ð¨‹¢ã˜­ç”´å—°å–ºå’—å•²ð ±ð ²–å»ð¥…ˆð ¹¶ð¢±¢"
  ],
  [
    "9e40",
    "ð º¢éº«çµšå—žð¡µæŠé­å’”è³ç‡¶é…¶æ¼æŽ¹æ¾å•©ð¢­ƒé±²ð¢º³å†šã“Ÿð ¶§å†§å‘å”žå”“ç™¦è¸­ð¦¢Šç–±è‚¶è „èž†è£‡è†¶èœð¡ƒä“¬çŒ„ð¤œ†å®èŒ‹ð¦¢“å™»ð¢›´ð§´¯ð¤†£ð§µ³ð¦»ð§Š¶é…°ð¡‡™éˆˆð£³¼ðªš©ð º¬ð »¹ç‰¦ð¡²¢äŽð¤¿‚ð§¿¹ð ¿«äƒº"
  ],
  [
    "9ea1",
    "é±æ”Ÿð¢¶ ä£³ð¤Ÿ ð©µ¼ð ¿¬ð ¸Šæ¢ð§–£ð ¿­"
  ],
  [
    "9ead",
    "ð¦ˆð¡†‡ç†£çºŽéµä¸šä¸„ã•·å¬æ²²å§ãš¬ã§œå½ãš¥ð¤˜˜å¢šð¤­®èˆ­å‘‹åžªð¥ª•ð ¥¹"
  ],
  [
    "9ec5",
    "ã©’ð¢‘¥ç´ð©º¬ä´‰é¯­ð£³¾ð©¼°ä±›ð¤¾©ð©–žð©¿žè‘œð£¶¶ð§Š²ð¦ž³ð£œ æŒ®ç´¥ð£»·ð£¸¬ã¨ªé€ˆå‹Œã¹´ã™ºä—©ð ’Žç™€å«°ð º¶ç¡ºð§¼®å¢§ä‚¿å™¼é®‹åµ´ç™”ðª´éº…ä³¡ç—¹ãŸ»æ„™ð£ƒšð¤²"
  ],
  [
    "9ef5",
    "å™ð¡Š©åž§ð¤¥£ð©¸†åˆ´ð§‚®ã–­æ±Šéµ¼"
  ],
  [
    "9f40",
    "ç±–é¬¹åŸžð¡¬å±“æ““ð©“ð¦Œµð§…¤èš­ð ´¨ð¦´¢ð¤«¢ð µ±"
  ],
  [
    "9f4f",
    "å‡¾ð¡¼å¶Žéœƒð¡·‘éºéŒç¬Ÿé¬‚å³‘ç®£æ‰¨æŒµé«¿ç¯é¬ªç±¾é¬®ç±‚ç²†é°•ç¯¼é¬‰é¼—é°›ð¤¤¾é½šå•³å¯ƒä¿½éº˜ä¿²å‰ ã¸†å‹‘å§å–å¦·å¸’éŸˆé¶«è½œå‘©éž´é¥€éžºåŒ¬æ„°"
  ],
  [
    "9fa1",
    "æ¤¬åšé°Šé´‚ä°»é™æ¦€å‚¦ç•†ð¡­é§šå‰³"
  ],
  [
    "9fae",
    "é…™éšé…œ"
  ],
  [
    "9fb2",
    "é…‘ð¨º—æ¿ð¦´£æ«Šå˜‘é†Žç•ºæŠ…ð ¼çç±°ð¥°¡ð£³½"
  ],
  [
    "9fc1",
    "ð¤¤™ç›–é®ä¸ªð ³”èŽ¾è¡‚"
  ],
  [
    "9fc9",
    "å±Šæ§€åƒ­åºåˆŸå·µä»Žæ°±ð ‡²ä¼¹å’œå“šåŠšè¶‚ã—¾å¼Œã—³"
  ],
  [
    "9fdb",
    "æ­’é…¼é¾¥é®—é ®é¢´éªºéº¨éº„ç…ºç¬”"
  ],
  [
    "9fe7",
    "æ¯ºè ˜ç½¸"
  ],
  [
    "9feb",
    "å˜ ðª™Šè¹·é½“"
  ],
  [
    "9ff0",
    "è·”è¹é¸œè¸æŠ‚ð¨½è¸¨è¹µç«“ð¤©·ç¨¾ç£˜æ³ªè©§ç˜‡"
  ],
  [
    "a040",
    "ð¨©šé¼¦æ³ŽèŸ–ç—ƒðªŠ²ç¡“ð¯¡€è´Œç‹¢ç±è¬­çŒ‚ç“±è³«ð¤ª»è˜¯å¾ºè¢ ä’·"
  ],
  [
    "a055",
    "ð¡ »ð¦¸…"
  ],
  [
    "a058",
    "è©¾ð¢”›"
  ],
  [
    "a05b",
    "æƒ½ç™§é«—éµ„é®é®èŸµ"
  ],
  [
    "a063",
    "è è³·çŒ¬éœ¡é®°ã—–çŠ²ä°‡ç±‘é¥Šð¦…™æ…™ä°„éº–æ…½"
  ],
  [
    "a073",
    "åŸæ…¯æŠ¦æˆ¹æ‹Žã©œæ‡¢åŽªð£µæ¤æ ‚ã—’"
  ],
  [
    "a0a1",
    "åµ—ð¨¯‚è¿šð¨¸¹"
  ],
  [
    "a0a6",
    "åƒ™ð¡µ†ç¤†åŒ²é˜¸ð ¼»ä¥"
  ],
  [
    "a0ae",
    "çŸ¾"
  ],
  [
    "a0b0",
    "ç³‚ð¥¼šç³šç¨­è¦è£çµç”…ç“²è¦”èˆšæœŒè¢ð§’†è›ç“°è„ƒçœ¤è¦‰ð¦ŸŒç•“ð¦»‘èž©èŸŽè‡ˆèžŒè©‰è²­è­ƒçœ«ç“¸è“šã˜µæ¦²è¶¦"
  ],
  [
    "a0d4",
    "è¦©ç‘¨æ¶¹èŸð¤€‘ç“§ã·›ç…¶æ‚¤æ†œã³‘ç…¢æ·"
  ],
  [
    "a0e2",
    "ç½±ð¨¬­ç‰æƒ©ä­¾åˆ ã°˜ð£³‡ð¥»—ð§™–ð¥”±ð¡¥„ð¡‹¾ð©¤ƒð¦·œð§‚­å³ð¦†­ð¨¨ð£™·ð ƒ®ð¦¡†ð¤¼Žä•¢å¬Ÿð¦Œé½éº¦ð¦‰«"
  ],
  [
    "a3c0",
    "â€",
    31,
    "â¡"
  ],
  [
    "c6a1",
    "â‘ ",
    9,
    "â‘´",
    9,
    "â…°",
    9,
    "ä¸¶ä¸¿äº…äº å†‚å†–å†«å‹¹åŒ¸å©åŽ¶å¤Šå®€å·›â¼³å¹¿å»´å½å½¡æ”´æ— ç–’ç™¶è¾µéš¶Â¨Ë†ãƒ½ãƒ¾ã‚ã‚žã€ƒä»ã€…ã€†ã€‡ãƒ¼ï¼»ï¼½âœ½ã",
    23
  ],
  [
    "c740",
    "ã™",
    58,
    "ã‚¡ã‚¢ã‚£ã‚¤"
  ],
  [
    "c7a1",
    "ã‚¥",
    81,
    "Ð",
    5,
    "ÐÐ–",
    4
  ],
  [
    "c840",
    "Ð›",
    26,
    "Ñ‘Ð¶",
    25,
    "â‡§â†¸â†¹ã‡ð ƒŒä¹šð ‚Šåˆ‚ä’‘"
  ],
  [
    "c8a1",
    "é¾°å†ˆé¾±ð§˜‡"
  ],
  [
    "c8cd",
    "ï¿¢ï¿¤ï¼‡ï¼‚ãˆ±â„–â„¡ã‚›ã‚œâº€âº„âº†âº‡âºˆâºŠâºŒâºâº•âºœâºâº¥âº§âºªâº¬âº®âº¶âº¼âº¾â»†â»Šâ»Œâ»â»â»–â»—â»žâ»£"
  ],
  [
    "c8f5",
    "ÊƒÉÉ›É”ÉµÅ“Ã¸Å‹ÊŠÉª"
  ],
  [
    "f9fe",
    "ï¿­"
  ],
  [
    "fa40",
    "ð •‡é‹›ð —Ÿð£¿…è•ŒäŠµç¯å†µã™‰ð¤¥‚ð¨§¤é„ð¡§›è‹®ð£³ˆç ¼æ„æ‹Ÿð¤¤³ð¨¦ªð Š ð¦®³ð¡Œ…ä¾«ð¢“­å€ˆð¦´©ð§ª„ð£˜€ð¤ª±ð¢”“å€©ð ¾å¾¤ð Ž€ð ‡æ»›ð Ÿå½å„ã‘ºå„Žé¡¬ãƒè–ð¤¦¤ð ’‡å… ð£Ž´å…ªð ¯¿ð¢ƒ¼ð ‹¥ð¢”°ð –Žð£ˆ³ð¡¦ƒå®‚è½ð –³ð£²™å†²å†¸"
  ],
  [
    "faa1",
    "é´´å‡‰å‡å‡‘ã³œå‡“ð¤ª¦å†³å‡¢å‚å‡­èæ¤¾ð£œ­å½»åˆ‹åˆ¦åˆ¼åŠµå‰—åŠ”åŠ¹å‹…ç°•è•‚å‹ è˜ð¦¬“åŒ…ð¨«žå•‰æ»™ð£¾€ð ¥”ð£¿¬åŒ³å„ð ¯¢æ³‹ð¡œ¦æ ›ç•æŠãºªã£Œð¡›¨ç‡ä’¢å­å´ð¨š«å¾å¿ð¡––ð¡˜“çŸ¦åŽ“ð¨ª›åŽ åŽ«åŽ®çŽ§ð¥²ã½™çŽœåå…æ±‰ä¹‰åŸ¾å™ãª«ð ®å ð£¿«ð¢¶£å¶ð ±·å“ç¹å”«æ™—æµ›å‘­ð¦­“ð µ´å•å’å’¤äž¦ð¡œð »ã¶´ð µ"
  ],
  [
    "fb40",
    "ð¨¦¼ð¢š˜å•‡ä³­å¯ç—å–†å–©å˜…ð¡£—ð¤€ºä•’ð¤µæš³ð¡‚´å˜·æ›ð£ŠŠæš¤æš­å™å™ç£±å›±éž‡å¾åœ€å›¯å›­ð¨­¦ã˜£ð¡‰å†ð¤†¥æ±®ç‚‹å‚ãš±ð¦±¾åŸ¦ð¡–å ƒð¡‘”ð¤£å ¦ð¤¯µå¡œå¢ªã•¡å£ å£œð¡ˆ¼å£»å¯¿åƒðª…ð¤‰¸é“ã–¡å¤Ÿæ¢¦ã›ƒæ¹™"
  ],
  [
    "fba1",
    "ð¡˜¾å¨¤å•“ð¡š’è”…å§‰ð µŽð¦²ð¦´ªð¡Ÿœå§™ð¡Ÿ»ð¡ž²ð¦¶¦æµ±ð¡ ¨ð¡›•å§¹ð¦¹…åª«å©£ã›¦ð¤¦©å©·ãœˆåª–ç‘¥å«“ð¦¾¡ð¢•”ã¶…ð¡¤‘ãœ²ð¡š¸åºƒå‹å­¶æ–ˆå­¼ð§¨Žä€„ä¡ð ˆ„å¯•æ… ð¡¨´ð¥§Œð –¥å¯³å®ä´å°…ð¡­„å°“çŽå°”ð¡²¥ð¦¬¨å±‰ä£å²…å³©å³¯å¶‹ð¡·¹ð¡¸·å´å´˜åµ†ð¡º¤å²ºå·—è‹¼ã ­ð¤¤ð¢‰ð¢…³èŠ‡ã ¶ã¯‚å¸®æªŠå¹µå¹ºð¤’¼ð ³“åŽ¦äº·å»åŽ¨ð¡±å¸‰å»´ð¨’‚"
  ],
  [
    "fc40",
    "å»¹å»»ã¢ å»¼æ ¾é›å¼ð ‡ð¯¢”ã«žä¢®ð¡Œºå¼ºð¦¢ˆð¢å½˜ð¢‘±å½£éž½ð¦¹®å½²é€ð¨¨¶å¾§å¶¶ãµŸð¥‰ð¡½ªð§ƒ¸ð¢™¨é‡–ð Šžð¨¨©æ€±æš…ð¡¡·ã¥£ã·‡ã˜¹åžð¢ž´ç¥±ã¹€æ‚žæ‚¤æ‚³ð¤¦‚ð¤¦ð§©“ç’¤åƒ¡åª æ…¤è¤æ…‚ð¯¢¦ð¦»’æ†å‡´ð ™–æ†‡å®ªð£¾·"
  ],
  [
    "fca1",
    "ð¢¡Ÿæ‡“ð¨®ð©¥æ‡ã¤²ð¢¦€ð¢£æ€£æ…œæ”žæŽ‹ð „˜æ‹…ð¡°æ‹•ð¢¸æ¬ð¤§Ÿã¨—æ¸æ¸ð¡ŽŽð¡Ÿ¼æ’æ¾Šð¢¸¶é ”ð¤‚Œð¥œæ“¡æ“¥é‘»ã©¦æºã©—æ•æ¼–ð¤¨¨ð¤¨£æ–…æ•­æ•Ÿð£¾æ–µð¤¥€ä¬·æ—‘äƒ˜ð¡ ©æ— æ—£å¿Ÿð£€æ˜˜ð£‡·ð£‡¸æ™„ð£†¤ð£†¥æ™‹ð ¹µæ™§ð¥‡¦æ™³æ™´ð¡¸½ð£ˆ±ð¨—´ð£‡ˆð¥Œ“çŸ…ð¢£·é¦¤æœ‚ð¤Žœð¤¨¡ã¬«æ§ºð£Ÿ‚æžæ§æ¢ð¤‡ð©ƒ­æŸ—ä“©æ ¢æ¹éˆ¼æ ð£¦ð¦¶ æ¡"
  ],
  [
    "fd40",
    "ð£‘¯æ§¡æ¨‹ð¨«Ÿæ¥³æ£ƒð£—æ¤æ¤€ã´²ã¨ð£˜¼ã®€æž¬æ¥¡ð¨©Šä‹¼æ¤¶æ¦˜ã®¡ð ‰è£å‚æ§¹ð£™™ð¢„ªæ©…ð£œƒæªã¯³æž±æ«ˆð©†œã°æ¬ð ¤£æƒžæ¬µæ­´ð¢Ÿæºµð£«›ð Žµð¡¥˜ã€å¡ð£­šæ¯¡ð£»¼æ¯œæ°·ð¢’‹ð¤£±ð¦­‘æ±šèˆ¦æ±¹ð£¶¼ä“…ð£¶½ð¤†¤ð¤¤Œð¤¤€"
  ],
  [
    "fda1",
    "ð£³‰ã›¥ã³«ð ´²é®ƒð£‡¹ð¢’‘ç¾æ ·ð¦´¥ð¦¶¡ð¦·«æ¶–æµœæ¹¼æ¼„ð¤¥¿ð¤‚…ð¦¹²è”³ð¦½´å‡‡æ²œæ¸è®ð¨¬¡æ¸¯ð£¸¯ç‘“ð£¾‚ç§Œæ¹åª‘ð£‹æ¿¸ãœæ¾ð£¸°æ»ºð¡’—ð¤€½ä••é°æ½„æ½œãµŽæ½´ð©…°ã´»æ¾Ÿð¤…„æ¿“ð¤‚‘ð¤…•ð¤€¹ð£¿°ð£¾´ð¤„¿å‡Ÿð¤…–ð¤…—ð¤…€ð¦‡ç‹ç¾ç‚§ç‚çƒŒçƒ•çƒ–çƒŸä„„ã·¨ç†´ç†–ð¤‰·ç„«ç……åªˆç…Šç…®å²œð¤¥ç…é¢ð¤‹ç„¬ð¤‘šð¤¨§ð¤¨¢ç†ºð¨¯¨ç‚½çˆŽ"
  ],
  [
    "fe40",
    "é‘‚çˆ•å¤‘é‘ƒçˆ¤éð¥˜…çˆ®ç‰€ð¤¥´æ¢½ç‰•ç‰—ã¹•ð£„æ æ¼½çŠ‚çŒªçŒ«ð¤ £ð¨ «ä£­ð¨ „çŒ¨çŒ®ççŽªð °ºð¦¨®ç‰ç‘‰ð¤‡¢ð¡›§ð¤¨¤æ˜£ã›…ð¤¦·ð¤¦ð¤§»ç·ç•æ¤ƒð¤¨¦ç¹ð —ƒã»—ç‘œð¢¢­ç‘ ð¨º²ç‘‡ç¤ç‘¶èŽ¹ç‘¬ãœ°ç‘´é±æ¨¬ç’‚ä¥“ð¤ªŒ"
  ],
  [
    "fea1",
    "ð¤…Ÿð¤©¹ð¨®å­†ð¨°ƒð¡¢žç“ˆð¡¦ˆç”Žç“©ç”žð¨»™ð¡©‹å¯—ð¨º¬éŽ…ç•ç•Šç•§ç•®ð¤¾‚ã¼„ð¤´“ç–Žç‘ç–žç–´ç˜‚ç˜¬ç™‘ç™ç™¯ç™¶ð¦µçšè‡¯ãŸ¸ð¦¤‘ð¦¤Žçš¡çš¥çš·ç›Œð¦¾Ÿè‘¢ð¥‚ð¥…½ð¡¸œçœžçœ¦ç€æ’¯ð¥ˆ ç˜ð£Š¬çž¯ð¨¥¤ð¨¥¨ð¡›çŸ´ç ‰ð¡¶ð¤¨’æ£Šç¢¯ç£‡ç£“éš¥ç¤®ð¥— ç£—ç¤´ç¢±ð§˜Œè¾¸è¢„ð¨¬«ð¦‚ƒð¢˜œç¦†è¤€æ¤‚ç¦€ð¥¡—ç¦ð§¬¹ç¤¼ç¦©æ¸ªð§„¦ãº¨ç§†ð©„ç§”"
  ]
];
var dbcsData;
var hasRequiredDbcsData;
function requireDbcsData() {
  if (hasRequiredDbcsData) return dbcsData;
  hasRequiredDbcsData = 1;
  dbcsData = {
    // == Japanese/ShiftJIS ====================================================
    // All japanese encodings are based on JIS X set of standards:
    // JIS X 0201 - Single-byte encoding of ASCII + Â¥ + Kana chars at 0xA1-0xDF.
    // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
    //              Has several variations in 1978, 1983, 1990 and 1997.
    // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
    // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
    //              2 planes, first is superset of 0208, second - revised 0212.
    //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
    // Byte encodings are:
    //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
    //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
    //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
    //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
    //               0x00-0x7F       - lower part of 0201
    //               0x8E, 0xA1-0xDF - upper part of 0201
    //               (0xA1-0xFE)x2   - 0208 plane (94x94).
    //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
    //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
    //               Used as-is in ISO2022 family.
    //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
    //                0201-1976 Roman, 0208-1978, 0208-1983.
    //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
    //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
    //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
    //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
    //
    // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
    //
    // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
    "shiftjis": {
      type: "_dbcs",
      table: function() {
        return require$$0$2;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 },
      encodeSkipVals: [{ from: 60736, to: 63808 }]
    },
    "csshiftjis": "shiftjis",
    "mskanji": "shiftjis",
    "sjis": "shiftjis",
    "windows31j": "shiftjis",
    "ms31j": "shiftjis",
    "xsjis": "shiftjis",
    "windows932": "shiftjis",
    "ms932": "shiftjis",
    "932": "shiftjis",
    "cp932": "shiftjis",
    "eucjp": {
      type: "_dbcs",
      table: function() {
        return require$$1;
      },
      encodeAdd: { "Â¥": 92, "â€¾": 126 }
    },
    // TODO: KDDI extension to Shift_JIS
    // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
    // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
    // == Chinese/GBK ==========================================================
    // http://en.wikipedia.org/wiki/GBK
    // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
    // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
    "gb2312": "cp936",
    "gb231280": "cp936",
    "gb23121980": "cp936",
    "csgb2312": "cp936",
    "csiso58gb231280": "cp936",
    "euccn": "cp936",
    // Microsoft's CP936 is a subset and approximation of GBK.
    "windows936": "cp936",
    "ms936": "cp936",
    "936": "cp936",
    "cp936": {
      type: "_dbcs",
      table: function() {
        return require$$2$1;
      }
    },
    // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
    "gbk": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$1);
      }
    },
    "xgbk": "gbk",
    "isoir58": "gbk",
    // GB18030 is an algorithmic extension of GBK.
    // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
    // http://icu-project.org/docs/papers/gb18030.html
    // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
    // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
    "gb18030": {
      type: "_dbcs",
      table: function() {
        return require$$2$1.concat(require$$3$1);
      },
      gb18030: function() {
        return require$$4$1;
      },
      encodeSkipVals: [128],
      encodeAdd: { "â‚¬": 41699 }
    },
    "chinese": "gb18030",
    // == Korean ===============================================================
    // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
    "windows949": "cp949",
    "ms949": "cp949",
    "949": "cp949",
    "cp949": {
      type: "_dbcs",
      table: function() {
        return require$$5;
      }
    },
    "cseuckr": "cp949",
    "csksc56011987": "cp949",
    "euckr": "cp949",
    "isoir149": "cp949",
    "korean": "cp949",
    "ksc56011987": "cp949",
    "ksc56011989": "cp949",
    "ksc5601": "cp949",
    // == Big5/Taiwan/Hong Kong ================================================
    // There are lots of tables for Big5 and cp950. Please see the following links for history:
    // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
    // Variations, in roughly number of defined chars:
    //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
    //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
    //  * Big5-2003 (Taiwan standard) almost superset of cp950.
    //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
    //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
    //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
    //    Plus, it has 4 combining sequences.
    //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
    //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
    //    Implementations are not consistent within browsers; sometimes labeled as just big5.
    //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
    //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
    //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
    //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
    //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
    // 
    // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
    // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
    "windows950": "cp950",
    "ms950": "cp950",
    "950": "cp950",
    "cp950": {
      type: "_dbcs",
      table: function() {
        return require$$6;
      }
    },
    // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
    "big5": "big5hkscs",
    "big5hkscs": {
      type: "_dbcs",
      table: function() {
        return require$$6.concat(require$$7);
      },
      encodeSkipVals: [41676]
    },
    "cnbig5": "big5hkscs",
    "csbig5": "big5hkscs",
    "xxbig5": "big5hkscs"
  };
  return dbcsData;
}
var hasRequiredEncodings;
function requireEncodings() {
  if (hasRequiredEncodings) return encodings;
  hasRequiredEncodings = 1;
  (function(exports) {
    var modules = [
      requireInternal(),
      requireUtf16(),
      requireUtf7(),
      requireSbcsCodec(),
      requireSbcsData(),
      requireSbcsDataGenerated(),
      requireDbcsCodec(),
      requireDbcsData()
    ];
    for (var i = 0; i < modules.length; i++) {
      var module2 = modules[i];
      for (var enc in module2)
        if (Object.prototype.hasOwnProperty.call(module2, enc))
          exports[enc] = module2[enc];
    }
  })(encodings);
  return encodings;
}
var streams;
var hasRequiredStreams;
function requireStreams() {
  if (hasRequiredStreams) return streams;
  hasRequiredStreams = 1;
  var Buffer2 = require$$0$9.Buffer, Transform = require$$1$4.Transform;
  streams = function(iconv) {
    iconv.encodeStream = function encodeStream(encoding3, options) {
      return new IconvLiteEncoderStream(iconv.getEncoder(encoding3, options), options);
    };
    iconv.decodeStream = function decodeStream(encoding3, options) {
      return new IconvLiteDecoderStream(iconv.getDecoder(encoding3, options), options);
    };
    iconv.supportsStreams = true;
    iconv.IconvLiteEncoderStream = IconvLiteEncoderStream;
    iconv.IconvLiteDecoderStream = IconvLiteDecoderStream;
    iconv._collect = IconvLiteDecoderStream.prototype.collect;
  };
  function IconvLiteEncoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.decodeStrings = false;
    Transform.call(this, options);
  }
  IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteEncoderStream }
  });
  IconvLiteEncoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (typeof chunk != "string")
      return done(new Error("Iconv encoding stream needs strings as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length) this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length) this.push(res2);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteEncoderStream.prototype.collect = function(cb) {
    var chunks = [];
    this.on("error", cb);
    this.on("data", function(chunk) {
      chunks.push(chunk);
    });
    this.on("end", function() {
      cb(null, Buffer2.concat(chunks));
    });
    return this;
  };
  function IconvLiteDecoderStream(conv, options) {
    this.conv = conv;
    options = options || {};
    options.encoding = this.encoding = "utf8";
    Transform.call(this, options);
  }
  IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
    constructor: { value: IconvLiteDecoderStream }
  });
  IconvLiteDecoderStream.prototype._transform = function(chunk, encoding3, done) {
    if (!Buffer2.isBuffer(chunk))
      return done(new Error("Iconv decoding stream needs buffers as its input."));
    try {
      var res2 = this.conv.write(chunk);
      if (res2 && res2.length) this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype._flush = function(done) {
    try {
      var res2 = this.conv.end();
      if (res2 && res2.length) this.push(res2, this.encoding);
      done();
    } catch (e) {
      done(e);
    }
  };
  IconvLiteDecoderStream.prototype.collect = function(cb) {
    var res2 = "";
    this.on("error", cb);
    this.on("data", function(chunk) {
      res2 += chunk;
    });
    this.on("end", function() {
      cb(null, res2);
    });
    return this;
  };
  return streams;
}
var extendNode;
var hasRequiredExtendNode;
function requireExtendNode() {
  if (hasRequiredExtendNode) return extendNode;
  hasRequiredExtendNode = 1;
  var Buffer2 = require$$0$9.Buffer;
  extendNode = function(iconv) {
    var original = void 0;
    iconv.supportsNodeEncodingsExtension = !(Buffer2.from || new Buffer2(0) instanceof Uint8Array);
    iconv.extendNodeEncodings = function extendNodeEncodings() {
      if (original) return;
      original = {};
      if (!iconv.supportsNodeEncodingsExtension) {
        console.error("ACTION NEEDED: require('iconv-lite').extendNodeEncodings() is not supported in your version of Node");
        console.error("See more info at https://github.com/ashtuchkin/iconv-lite/wiki/Node-v4-compatibility");
        return;
      }
      var nodeNativeEncodings = {
        "hex": true,
        "utf8": true,
        "utf-8": true,
        "ascii": true,
        "binary": true,
        "base64": true,
        "ucs2": true,
        "ucs-2": true,
        "utf16le": true,
        "utf-16le": true
      };
      Buffer2.isNativeEncoding = function(enc) {
        return enc && nodeNativeEncodings[enc.toLowerCase()];
      };
      var SlowBuffer = require$$0$9.SlowBuffer;
      original.SlowBufferToString = SlowBuffer.prototype.toString;
      SlowBuffer.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined") start = 0;
        if (typeof end == "undefined") end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.SlowBufferWrite = SlowBuffer.prototype.write;
      SlowBuffer.prototype.write = function(string2, offset, length, encoding3) {
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.SlowBufferWrite.call(this, string2, offset, length, encoding3);
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding3);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      original.BufferIsEncoding = Buffer2.isEncoding;
      Buffer2.isEncoding = function(encoding3) {
        return Buffer2.isNativeEncoding(encoding3) || iconv.encodingExists(encoding3);
      };
      original.BufferByteLength = Buffer2.byteLength;
      Buffer2.byteLength = SlowBuffer.byteLength = function(str2, encoding3) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferByteLength.call(this, str2, encoding3);
        return iconv.encode(str2, encoding3).length;
      };
      original.BufferToString = Buffer2.prototype.toString;
      Buffer2.prototype.toString = function(encoding3, start, end) {
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferToString.call(this, encoding3, start, end);
        if (typeof start == "undefined") start = 0;
        if (typeof end == "undefined") end = this.length;
        return iconv.decode(this.slice(start, end), encoding3);
      };
      original.BufferWrite = Buffer2.prototype.write;
      Buffer2.prototype.write = function(string2, offset, length, encoding3) {
        var _offset = offset, _length = length, _encoding = encoding3;
        if (isFinite(offset)) {
          if (!isFinite(length)) {
            encoding3 = length;
            length = void 0;
          }
        } else {
          var swap = encoding3;
          encoding3 = offset;
          offset = length;
          length = swap;
        }
        encoding3 = String(encoding3 || "utf8").toLowerCase();
        if (Buffer2.isNativeEncoding(encoding3))
          return original.BufferWrite.call(this, string2, _offset, _length, _encoding);
        offset = +offset || 0;
        var remaining = this.length - offset;
        if (!length) {
          length = remaining;
        } else {
          length = +length;
          if (length > remaining) {
            length = remaining;
          }
        }
        if (string2.length > 0 && (length < 0 || offset < 0))
          throw new RangeError("attempt to write beyond buffer bounds");
        var buf = iconv.encode(string2, encoding3);
        if (buf.length < length) length = buf.length;
        buf.copy(this, offset, 0, length);
        return length;
      };
      if (iconv.supportsStreams) {
        var Readable2 = require$$1$4.Readable;
        original.ReadableSetEncoding = Readable2.prototype.setEncoding;
        Readable2.prototype.setEncoding = function setEncoding(enc, options) {
          this._readableState.decoder = iconv.getDecoder(enc, options);
          this._readableState.encoding = enc;
        };
        Readable2.prototype.collect = iconv._collect;
      }
    };
    iconv.undoExtendNodeEncodings = function undoExtendNodeEncodings() {
      if (!iconv.supportsNodeEncodingsExtension)
        return;
      if (!original)
        throw new Error("require('iconv-lite').undoExtendNodeEncodings(): Nothing to undo; extendNodeEncodings() is not called.");
      delete Buffer2.isNativeEncoding;
      var SlowBuffer = require$$0$9.SlowBuffer;
      SlowBuffer.prototype.toString = original.SlowBufferToString;
      SlowBuffer.prototype.write = original.SlowBufferWrite;
      Buffer2.isEncoding = original.BufferIsEncoding;
      Buffer2.byteLength = original.BufferByteLength;
      Buffer2.prototype.toString = original.BufferToString;
      Buffer2.prototype.write = original.BufferWrite;
      if (iconv.supportsStreams) {
        var Readable2 = require$$1$4.Readable;
        Readable2.prototype.setEncoding = original.ReadableSetEncoding;
        delete Readable2.prototype.collect;
      }
      original = void 0;
    };
  };
  return extendNode;
}
var hasRequiredLib$1;
function requireLib$1() {
  if (hasRequiredLib$1) return lib$5.exports;
  hasRequiredLib$1 = 1;
  (function(module2) {
    var Buffer2 = requireSafer().Buffer;
    var bomHandling2 = requireBomHandling(), iconv = module2.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "ï¿½";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode2(str2, encoding3, options) {
      str2 = "" + (str2 || "");
      var encoder = iconv.getEncoder(encoding3, options);
      var res2 = encoder.write(str2);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res2, trail]) : res2;
    };
    iconv.decode = function decode2(buf, encoding3, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding3, options);
      var res2 = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res2 + trail : res2;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding3) {
      if (!iconv.encodings)
        iconv.encodings = requireEncodings();
      var enc = iconv._canonicalizeEncoding(encoding3);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding3 + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding3) {
      return ("" + encoding3).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding3, options) {
      var codec = iconv.getCodec(encoding3), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling2.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder2(encoding3, options) {
      var codec = iconv.getCodec(encoding3), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling2.StripBOM(decoder, options);
      return decoder;
    };
    var nodeVer = typeof process !== "undefined" && process.versions && process.versions.node;
    if (nodeVer) {
      var nodeVerArr = nodeVer.split(".").map(Number);
      if (nodeVerArr[0] > 0 || nodeVerArr[1] >= 10) {
        requireStreams()(iconv);
      }
      requireExtendNode()(iconv);
    }
  })(lib$5);
  return lib$5.exports;
}
var onFinished$4 = { exports: {} };
/*!
 * ee-first
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */
var eeFirst = first$1;
function first$1(stuff, done) {
  if (!Array.isArray(stuff))
    throw new TypeError("arg must be an array of [ee, events...] arrays");
  var cleanups = [];
  for (var i = 0; i < stuff.length; i++) {
    var arr = stuff[i];
    if (!Array.isArray(arr) || arr.length < 2)
      throw new TypeError("each array member must be [ee, events...]");
    var ee2 = arr[0];
    for (var j2 = 1; j2 < arr.length; j2++) {
      var event = arr[j2];
      var fn = listener(event, callback);
      ee2.on(event, fn);
      cleanups.push({
        ee: ee2,
        event,
        fn
      });
    }
  }
  function callback() {
    cleanup();
    done.apply(null, arguments);
  }
  function cleanup() {
    var x;
    for (var i2 = 0; i2 < cleanups.length; i2++) {
      x = cleanups[i2];
      x.ee.removeListener(x.event, x.fn);
    }
  }
  function thunk(fn2) {
    done = fn2;
  }
  thunk.cancel = cleanup;
  return thunk;
}
function listener(event, done) {
  return function onevent(arg1) {
    var args = new Array(arguments.length);
    var ee2 = this;
    var err = event === "error" ? arg1 : null;
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    done(err, ee2, event, args);
  };
}
/*!
 * on-finished
 * Copyright(c) 2013 Jonathan Ong
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
onFinished$4.exports = onFinished$3;
onFinished$4.exports.isFinished = isFinished$1;
var asyncHooks = tryRequireAsyncHooks();
var first = eeFirst;
var defer$3 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
function onFinished$3(msg, listener2) {
  if (isFinished$1(msg) !== false) {
    defer$3(listener2, null, msg);
    return msg;
  }
  attachListener(msg, wrap$2(listener2));
  return msg;
}
function isFinished$1(msg) {
  var socket = msg.socket;
  if (typeof msg.finished === "boolean") {
    return Boolean(msg.finished || socket && !socket.writable);
  }
  if (typeof msg.complete === "boolean") {
    return Boolean(msg.upgrade || !socket || !socket.readable || msg.complete && !msg.readable);
  }
  return void 0;
}
function attachFinishedListener(msg, callback) {
  var eeMsg;
  var eeSocket;
  var finished = false;
  function onFinish(error2) {
    eeMsg.cancel();
    eeSocket.cancel();
    finished = true;
    callback(error2);
  }
  eeMsg = eeSocket = first([[msg, "end", "finish"]], onFinish);
  function onSocket(socket) {
    msg.removeListener("socket", onSocket);
    if (finished) return;
    if (eeMsg !== eeSocket) return;
    eeSocket = first([[socket, "error", "close"]], onFinish);
  }
  if (msg.socket) {
    onSocket(msg.socket);
    return;
  }
  msg.on("socket", onSocket);
  if (msg.socket === void 0) {
    patchAssignSocket(msg, onSocket);
  }
}
function attachListener(msg, listener2) {
  var attached = msg.__onFinished;
  if (!attached || !attached.queue) {
    attached = msg.__onFinished = createListener(msg);
    attachFinishedListener(msg, attached);
  }
  attached.queue.push(listener2);
}
function createListener(msg) {
  function listener2(err) {
    if (msg.__onFinished === listener2) msg.__onFinished = null;
    if (!listener2.queue) return;
    var queue = listener2.queue;
    listener2.queue = null;
    for (var i = 0; i < queue.length; i++) {
      queue[i](err, msg);
    }
  }
  listener2.queue = [];
  return listener2;
}
function patchAssignSocket(res2, callback) {
  var assignSocket = res2.assignSocket;
  if (typeof assignSocket !== "function") return;
  res2.assignSocket = function _assignSocket(socket) {
    assignSocket.call(this, socket);
    callback(socket);
  };
}
function tryRequireAsyncHooks() {
  try {
    return require("async_hooks");
  } catch (e) {
    return {};
  }
}
function wrap$2(fn) {
  var res2;
  if (asyncHooks.AsyncResource) {
    res2 = new asyncHooks.AsyncResource(fn.name || "bound-anonymous-fn");
  }
  if (!res2 || !res2.runInAsyncScope) {
    return fn;
  }
  return res2.runInAsyncScope.bind(res2, fn, null);
}
var onFinishedExports = onFinished$4.exports;
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var read_1;
var hasRequiredRead;
function requireRead() {
  if (hasRequiredRead) return read_1;
  hasRequiredRead = 1;
  var createError2 = httpErrorsExports;
  var destroy2 = destroy_1;
  var getBody = requireRawBody();
  var iconv = requireLib$1();
  var onFinished2 = onFinishedExports;
  var unpipe2 = unpipe_1;
  var zlib2 = require$$3$3;
  read_1 = read;
  function read(req2, res2, next, parse2, debug2, options) {
    var length;
    var opts = options;
    var stream3;
    req2._body = true;
    var encoding3 = opts.encoding !== null ? opts.encoding : null;
    var verify = opts.verify;
    try {
      stream3 = contentstream(req2, debug2, opts.inflate);
      length = stream3.length;
      stream3.length = void 0;
    } catch (err) {
      return next(err);
    }
    opts.length = length;
    opts.encoding = verify ? null : encoding3;
    if (opts.encoding === null && encoding3 !== null && !iconv.encodingExists(encoding3)) {
      return next(createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
        charset: encoding3.toLowerCase(),
        type: "charset.unsupported"
      }));
    }
    debug2("read body");
    getBody(stream3, opts, function(error2, body) {
      if (error2) {
        var _error;
        if (error2.type === "encoding.unsupported") {
          _error = createError2(415, 'unsupported charset "' + encoding3.toUpperCase() + '"', {
            charset: encoding3.toLowerCase(),
            type: "charset.unsupported"
          });
        } else {
          _error = createError2(400, error2);
        }
        if (stream3 !== req2) {
          unpipe2(req2);
          destroy2(stream3, true);
        }
        dump(req2, function onfinished() {
          next(createError2(400, _error));
        });
        return;
      }
      if (verify) {
        try {
          debug2("verify body");
          verify(req2, res2, body, encoding3);
        } catch (err) {
          next(createError2(403, err, {
            body,
            type: err.type || "entity.verify.failed"
          }));
          return;
        }
      }
      var str2 = body;
      try {
        debug2("parse body");
        str2 = typeof body !== "string" && encoding3 !== null ? iconv.decode(body, encoding3) : body;
        req2.body = parse2(str2);
      } catch (err) {
        next(createError2(400, err, {
          body: str2,
          type: err.type || "entity.parse.failed"
        }));
        return;
      }
      next();
    });
  }
  function contentstream(req2, debug2, inflate2) {
    var encoding3 = (req2.headers["content-encoding"] || "identity").toLowerCase();
    var length = req2.headers["content-length"];
    var stream3;
    debug2('content-encoding "%s"', encoding3);
    if (inflate2 === false && encoding3 !== "identity") {
      throw createError2(415, "content encoding unsupported", {
        encoding: encoding3,
        type: "encoding.unsupported"
      });
    }
    switch (encoding3) {
      case "deflate":
        stream3 = zlib2.createInflate();
        debug2("inflate body");
        req2.pipe(stream3);
        break;
      case "gzip":
        stream3 = zlib2.createGunzip();
        debug2("gunzip body");
        req2.pipe(stream3);
        break;
      case "identity":
        stream3 = req2;
        stream3.length = length;
        break;
      default:
        throw createError2(415, 'unsupported content encoding "' + encoding3 + '"', {
          encoding: encoding3,
          type: "encoding.unsupported"
        });
    }
    return stream3;
  }
  function dump(req2, callback) {
    if (onFinished2.isFinished(req2)) {
      callback(null);
    } else {
      onFinished2(req2, callback);
      req2.resume();
    }
  }
  return read_1;
}
var typeIs = { exports: {} };
var mediaTyper = {};
/*!
 * media-typer
 * Copyright(c) 2014 Douglas Christopher Wilson
 * MIT Licensed
 */
var paramRegExp = /; *([!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) *= *("(?:[ !\u0023-\u005b\u005d-\u007e\u0080-\u00ff]|\\[\u0020-\u007e])*"|[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+) */g;
var textRegExp = /^[\u0020-\u007e\u0080-\u00ff]+$/;
var tokenRegExp = /^[!#$%&'\*\+\-\.0-9A-Z\^_`a-z\|~]+$/;
var qescRegExp = /\\([\u0000-\u007f])/g;
var quoteRegExp = /([\\"])/g;
var subtypeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_.-]{0,126}$/;
var typeNameRegExp = /^[A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126}$/;
var typeRegExp = /^ *([A-Za-z0-9][A-Za-z0-9!#$&^_-]{0,126})\/([A-Za-z0-9][A-Za-z0-9!#$&^_.+-]{0,126}) *$/;
mediaTyper.format = format$1;
mediaTyper.parse = parse$8;
function format$1(obj) {
  if (!obj || typeof obj !== "object") {
    throw new TypeError("argument obj is required");
  }
  var parameters = obj.parameters;
  var subtype = obj.subtype;
  var suffix = obj.suffix;
  var type3 = obj.type;
  if (!type3 || !typeNameRegExp.test(type3)) {
    throw new TypeError("invalid type");
  }
  if (!subtype || !subtypeNameRegExp.test(subtype)) {
    throw new TypeError("invalid subtype");
  }
  var string2 = type3 + "/" + subtype;
  if (suffix) {
    if (!typeNameRegExp.test(suffix)) {
      throw new TypeError("invalid suffix");
    }
    string2 += "+" + suffix;
  }
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      if (!tokenRegExp.test(param3)) {
        throw new TypeError("invalid parameter name");
      }
      string2 += "; " + param3 + "=" + qstring$1(parameters[param3]);
    }
  }
  return string2;
}
function parse$8(string2) {
  if (!string2) {
    throw new TypeError("argument string is required");
  }
  if (typeof string2 === "object") {
    string2 = getcontenttype(string2);
  }
  if (typeof string2 !== "string") {
    throw new TypeError("argument string is required to be a string");
  }
  var index2 = string2.indexOf(";");
  var type3 = index2 !== -1 ? string2.substr(0, index2) : string2;
  var key;
  var match2;
  var obj = splitType(type3);
  var params = {};
  var value2;
  paramRegExp.lastIndex = index2;
  while (match2 = paramRegExp.exec(string2)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value2 = match2[2];
    if (value2[0] === '"') {
      value2 = value2.substr(1, value2.length - 2).replace(qescRegExp, "$1");
    }
    params[key] = value2;
  }
  if (index2 !== -1 && index2 !== string2.length) {
    throw new TypeError("invalid parameter format");
  }
  obj.parameters = params;
  return obj;
}
function getcontenttype(obj) {
  if (typeof obj.getHeader === "function") {
    return obj.getHeader("content-type");
  }
  if (typeof obj.headers === "object") {
    return obj.headers && obj.headers["content-type"];
  }
}
function qstring$1(val) {
  var str2 = String(val);
  if (tokenRegExp.test(str2)) {
    return str2;
  }
  if (str2.length > 0 && !textRegExp.test(str2)) {
    throw new TypeError("invalid parameter value");
  }
  return '"' + str2.replace(quoteRegExp, "\\$1") + '"';
}
function splitType(string2) {
  var match2 = typeRegExp.exec(string2.toLowerCase());
  if (!match2) {
    throw new TypeError("invalid media type");
  }
  var type3 = match2[1];
  var subtype = match2[2];
  var suffix;
  var index2 = subtype.lastIndexOf("+");
  if (index2 !== -1) {
    suffix = subtype.substr(index2 + 1);
    subtype = subtype.substr(0, index2);
  }
  var obj = {
    type: type3,
    subtype,
    suffix
  };
  return obj;
}
var mimeTypes = {};
const require$$0$1 = {
  "application/1d-interleaved-parityfec": {
    source: "iana"
  },
  "application/3gpdash-qoe-report+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/3gpp-ims+xml": {
    source: "iana",
    compressible: true
  },
  "application/3gpphal+json": {
    source: "iana",
    compressible: true
  },
  "application/3gpphalforms+json": {
    source: "iana",
    compressible: true
  },
  "application/a2l": {
    source: "iana"
  },
  "application/ace+cbor": {
    source: "iana"
  },
  "application/activemessage": {
    source: "iana"
  },
  "application/activity+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-costmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-directory+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcost+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointcostparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointprop+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-endpointpropparams+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-error+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmap+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-networkmapfilter+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamcontrol+json": {
    source: "iana",
    compressible: true
  },
  "application/alto-updatestreamparams+json": {
    source: "iana",
    compressible: true
  },
  "application/aml": {
    source: "iana"
  },
  "application/andrew-inset": {
    source: "iana",
    extensions: [
      "ez"
    ]
  },
  "application/applefile": {
    source: "iana"
  },
  "application/applixware": {
    source: "apache",
    extensions: [
      "aw"
    ]
  },
  "application/at+jwt": {
    source: "iana"
  },
  "application/atf": {
    source: "iana"
  },
  "application/atfx": {
    source: "iana"
  },
  "application/atom+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atom"
    ]
  },
  "application/atomcat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomcat"
    ]
  },
  "application/atomdeleted+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomdeleted"
    ]
  },
  "application/atomicmail": {
    source: "iana"
  },
  "application/atomsvc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "atomsvc"
    ]
  },
  "application/atsc-dwd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dwd"
    ]
  },
  "application/atsc-dynamic-event-message": {
    source: "iana"
  },
  "application/atsc-held+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "held"
    ]
  },
  "application/atsc-rdt+json": {
    source: "iana",
    compressible: true
  },
  "application/atsc-rsat+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsat"
    ]
  },
  "application/atxml": {
    source: "iana"
  },
  "application/auth-policy+xml": {
    source: "iana",
    compressible: true
  },
  "application/bacnet-xdd+zip": {
    source: "iana",
    compressible: false
  },
  "application/batch-smtp": {
    source: "iana"
  },
  "application/bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/beep+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/calendar+json": {
    source: "iana",
    compressible: true
  },
  "application/calendar+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xcs"
    ]
  },
  "application/call-completion": {
    source: "iana"
  },
  "application/cals-1840": {
    source: "iana"
  },
  "application/captive+json": {
    source: "iana",
    compressible: true
  },
  "application/cbor": {
    source: "iana"
  },
  "application/cbor-seq": {
    source: "iana"
  },
  "application/cccex": {
    source: "iana"
  },
  "application/ccmp+xml": {
    source: "iana",
    compressible: true
  },
  "application/ccxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ccxml"
    ]
  },
  "application/cdfx+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdfx"
    ]
  },
  "application/cdmi-capability": {
    source: "iana",
    extensions: [
      "cdmia"
    ]
  },
  "application/cdmi-container": {
    source: "iana",
    extensions: [
      "cdmic"
    ]
  },
  "application/cdmi-domain": {
    source: "iana",
    extensions: [
      "cdmid"
    ]
  },
  "application/cdmi-object": {
    source: "iana",
    extensions: [
      "cdmio"
    ]
  },
  "application/cdmi-queue": {
    source: "iana",
    extensions: [
      "cdmiq"
    ]
  },
  "application/cdni": {
    source: "iana"
  },
  "application/cea": {
    source: "iana"
  },
  "application/cea-2018+xml": {
    source: "iana",
    compressible: true
  },
  "application/cellml+xml": {
    source: "iana",
    compressible: true
  },
  "application/cfw": {
    source: "iana"
  },
  "application/city+json": {
    source: "iana",
    compressible: true
  },
  "application/clr": {
    source: "iana"
  },
  "application/clue+xml": {
    source: "iana",
    compressible: true
  },
  "application/clue_info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cms": {
    source: "iana"
  },
  "application/cnrp+xml": {
    source: "iana",
    compressible: true
  },
  "application/coap-group+json": {
    source: "iana",
    compressible: true
  },
  "application/coap-payload": {
    source: "iana"
  },
  "application/commonground": {
    source: "iana"
  },
  "application/conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/cose": {
    source: "iana"
  },
  "application/cose-key": {
    source: "iana"
  },
  "application/cose-key-set": {
    source: "iana"
  },
  "application/cpl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cpl"
    ]
  },
  "application/csrattrs": {
    source: "iana"
  },
  "application/csta+xml": {
    source: "iana",
    compressible: true
  },
  "application/cstadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/csvm+json": {
    source: "iana",
    compressible: true
  },
  "application/cu-seeme": {
    source: "apache",
    extensions: [
      "cu"
    ]
  },
  "application/cwt": {
    source: "iana"
  },
  "application/cybercash": {
    source: "iana"
  },
  "application/dart": {
    compressible: true
  },
  "application/dash+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpd"
    ]
  },
  "application/dash-patch+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpp"
    ]
  },
  "application/dashdelta": {
    source: "iana"
  },
  "application/davmount+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "davmount"
    ]
  },
  "application/dca-rft": {
    source: "iana"
  },
  "application/dcd": {
    source: "iana"
  },
  "application/dec-dx": {
    source: "iana"
  },
  "application/dialog-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/dicom": {
    source: "iana"
  },
  "application/dicom+json": {
    source: "iana",
    compressible: true
  },
  "application/dicom+xml": {
    source: "iana",
    compressible: true
  },
  "application/dii": {
    source: "iana"
  },
  "application/dit": {
    source: "iana"
  },
  "application/dns": {
    source: "iana"
  },
  "application/dns+json": {
    source: "iana",
    compressible: true
  },
  "application/dns-message": {
    source: "iana"
  },
  "application/docbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dbk"
    ]
  },
  "application/dots+cbor": {
    source: "iana"
  },
  "application/dskpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/dssc+der": {
    source: "iana",
    extensions: [
      "dssc"
    ]
  },
  "application/dssc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdssc"
    ]
  },
  "application/dvcs": {
    source: "iana"
  },
  "application/ecmascript": {
    source: "iana",
    compressible: true,
    extensions: [
      "es",
      "ecma"
    ]
  },
  "application/edi-consent": {
    source: "iana"
  },
  "application/edi-x12": {
    source: "iana",
    compressible: false
  },
  "application/edifact": {
    source: "iana",
    compressible: false
  },
  "application/efi": {
    source: "iana"
  },
  "application/elm+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/elm+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.cap+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/emergencycalldata.comment+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.control+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.deviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.ecall.msd": {
    source: "iana"
  },
  "application/emergencycalldata.providerinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.serviceinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.subscriberinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/emergencycalldata.veds+xml": {
    source: "iana",
    compressible: true
  },
  "application/emma+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emma"
    ]
  },
  "application/emotionml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "emotionml"
    ]
  },
  "application/encaprtp": {
    source: "iana"
  },
  "application/epp+xml": {
    source: "iana",
    compressible: true
  },
  "application/epub+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "epub"
    ]
  },
  "application/eshop": {
    source: "iana"
  },
  "application/exi": {
    source: "iana",
    extensions: [
      "exi"
    ]
  },
  "application/expect-ct-report+json": {
    source: "iana",
    compressible: true
  },
  "application/express": {
    source: "iana",
    extensions: [
      "exp"
    ]
  },
  "application/fastinfoset": {
    source: "iana"
  },
  "application/fastsoap": {
    source: "iana"
  },
  "application/fdt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fdt"
    ]
  },
  "application/fhir+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fhir+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/fido.trusted-apps+json": {
    compressible: true
  },
  "application/fits": {
    source: "iana"
  },
  "application/flexfec": {
    source: "iana"
  },
  "application/font-sfnt": {
    source: "iana"
  },
  "application/font-tdpfr": {
    source: "iana",
    extensions: [
      "pfr"
    ]
  },
  "application/font-woff": {
    source: "iana",
    compressible: false
  },
  "application/framework-attributes+xml": {
    source: "iana",
    compressible: true
  },
  "application/geo+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "geojson"
    ]
  },
  "application/geo+json-seq": {
    source: "iana"
  },
  "application/geopackage+sqlite3": {
    source: "iana"
  },
  "application/geoxacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/gltf-buffer": {
    source: "iana"
  },
  "application/gml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "gml"
    ]
  },
  "application/gpx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "gpx"
    ]
  },
  "application/gxf": {
    source: "apache",
    extensions: [
      "gxf"
    ]
  },
  "application/gzip": {
    source: "iana",
    compressible: false,
    extensions: [
      "gz"
    ]
  },
  "application/h224": {
    source: "iana"
  },
  "application/held+xml": {
    source: "iana",
    compressible: true
  },
  "application/hjson": {
    extensions: [
      "hjson"
    ]
  },
  "application/http": {
    source: "iana"
  },
  "application/hyperstudio": {
    source: "iana",
    extensions: [
      "stk"
    ]
  },
  "application/ibe-key-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pkg-reply+xml": {
    source: "iana",
    compressible: true
  },
  "application/ibe-pp-data": {
    source: "iana"
  },
  "application/iges": {
    source: "iana"
  },
  "application/im-iscomposing+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/index": {
    source: "iana"
  },
  "application/index.cmd": {
    source: "iana"
  },
  "application/index.obj": {
    source: "iana"
  },
  "application/index.response": {
    source: "iana"
  },
  "application/index.vnd": {
    source: "iana"
  },
  "application/inkml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ink",
      "inkml"
    ]
  },
  "application/iotp": {
    source: "iana"
  },
  "application/ipfix": {
    source: "iana",
    extensions: [
      "ipfix"
    ]
  },
  "application/ipp": {
    source: "iana"
  },
  "application/isup": {
    source: "iana"
  },
  "application/its+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "its"
    ]
  },
  "application/java-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "jar",
      "war",
      "ear"
    ]
  },
  "application/java-serialized-object": {
    source: "apache",
    compressible: false,
    extensions: [
      "ser"
    ]
  },
  "application/java-vm": {
    source: "apache",
    compressible: false,
    extensions: [
      "class"
    ]
  },
  "application/javascript": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "js",
      "mjs"
    ]
  },
  "application/jf2feed+json": {
    source: "iana",
    compressible: true
  },
  "application/jose": {
    source: "iana"
  },
  "application/jose+json": {
    source: "iana",
    compressible: true
  },
  "application/jrd+json": {
    source: "iana",
    compressible: true
  },
  "application/jscalendar+json": {
    source: "iana",
    compressible: true
  },
  "application/json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "json",
      "map"
    ]
  },
  "application/json-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/json-seq": {
    source: "iana"
  },
  "application/json5": {
    extensions: [
      "json5"
    ]
  },
  "application/jsonml+json": {
    source: "apache",
    compressible: true,
    extensions: [
      "jsonml"
    ]
  },
  "application/jwk+json": {
    source: "iana",
    compressible: true
  },
  "application/jwk-set+json": {
    source: "iana",
    compressible: true
  },
  "application/jwt": {
    source: "iana"
  },
  "application/kpml-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/kpml-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/ld+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "jsonld"
    ]
  },
  "application/lgr+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lgr"
    ]
  },
  "application/link-format": {
    source: "iana"
  },
  "application/load-control+xml": {
    source: "iana",
    compressible: true
  },
  "application/lost+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lostxml"
    ]
  },
  "application/lostsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/lpf+zip": {
    source: "iana",
    compressible: false
  },
  "application/lxf": {
    source: "iana"
  },
  "application/mac-binhex40": {
    source: "iana",
    extensions: [
      "hqx"
    ]
  },
  "application/mac-compactpro": {
    source: "apache",
    extensions: [
      "cpt"
    ]
  },
  "application/macwriteii": {
    source: "iana"
  },
  "application/mads+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mads"
    ]
  },
  "application/manifest+json": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "webmanifest"
    ]
  },
  "application/marc": {
    source: "iana",
    extensions: [
      "mrc"
    ]
  },
  "application/marcxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mrcx"
    ]
  },
  "application/mathematica": {
    source: "iana",
    extensions: [
      "ma",
      "nb",
      "mb"
    ]
  },
  "application/mathml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mathml"
    ]
  },
  "application/mathml-content+xml": {
    source: "iana",
    compressible: true
  },
  "application/mathml-presentation+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-associated-procedure-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-deregister+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-envelope+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-msk-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-protection-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-reception-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-register-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-schedule+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbms-user-service-description+xml": {
    source: "iana",
    compressible: true
  },
  "application/mbox": {
    source: "iana",
    extensions: [
      "mbox"
    ]
  },
  "application/media-policy-dataset+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpf"
    ]
  },
  "application/media_control+xml": {
    source: "iana",
    compressible: true
  },
  "application/mediaservercontrol+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mscml"
    ]
  },
  "application/merge-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/metalink+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "metalink"
    ]
  },
  "application/metalink4+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "meta4"
    ]
  },
  "application/mets+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mets"
    ]
  },
  "application/mf4": {
    source: "iana"
  },
  "application/mikey": {
    source: "iana"
  },
  "application/mipc": {
    source: "iana"
  },
  "application/missing-blocks+cbor-seq": {
    source: "iana"
  },
  "application/mmt-aei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "maei"
    ]
  },
  "application/mmt-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musd"
    ]
  },
  "application/mods+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mods"
    ]
  },
  "application/moss-keys": {
    source: "iana"
  },
  "application/moss-signature": {
    source: "iana"
  },
  "application/mosskey-data": {
    source: "iana"
  },
  "application/mosskey-request": {
    source: "iana"
  },
  "application/mp21": {
    source: "iana",
    extensions: [
      "m21",
      "mp21"
    ]
  },
  "application/mp4": {
    source: "iana",
    extensions: [
      "mp4s",
      "m4p"
    ]
  },
  "application/mpeg4-generic": {
    source: "iana"
  },
  "application/mpeg4-iod": {
    source: "iana"
  },
  "application/mpeg4-iod-xmt": {
    source: "iana"
  },
  "application/mrb-consumer+xml": {
    source: "iana",
    compressible: true
  },
  "application/mrb-publish+xml": {
    source: "iana",
    compressible: true
  },
  "application/msc-ivr+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msc-mixer+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/msword": {
    source: "iana",
    compressible: false,
    extensions: [
      "doc",
      "dot"
    ]
  },
  "application/mud+json": {
    source: "iana",
    compressible: true
  },
  "application/multipart-core": {
    source: "iana"
  },
  "application/mxf": {
    source: "iana",
    extensions: [
      "mxf"
    ]
  },
  "application/n-quads": {
    source: "iana",
    extensions: [
      "nq"
    ]
  },
  "application/n-triples": {
    source: "iana",
    extensions: [
      "nt"
    ]
  },
  "application/nasdata": {
    source: "iana"
  },
  "application/news-checkgroups": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-groupinfo": {
    source: "iana",
    charset: "US-ASCII"
  },
  "application/news-transmission": {
    source: "iana"
  },
  "application/nlsml+xml": {
    source: "iana",
    compressible: true
  },
  "application/node": {
    source: "iana",
    extensions: [
      "cjs"
    ]
  },
  "application/nss": {
    source: "iana"
  },
  "application/oauth-authz-req+jwt": {
    source: "iana"
  },
  "application/oblivious-dns-message": {
    source: "iana"
  },
  "application/ocsp-request": {
    source: "iana"
  },
  "application/ocsp-response": {
    source: "iana"
  },
  "application/octet-stream": {
    source: "iana",
    compressible: false,
    extensions: [
      "bin",
      "dms",
      "lrf",
      "mar",
      "so",
      "dist",
      "distz",
      "pkg",
      "bpk",
      "dump",
      "elc",
      "deploy",
      "exe",
      "dll",
      "deb",
      "dmg",
      "iso",
      "img",
      "msi",
      "msp",
      "msm",
      "buffer"
    ]
  },
  "application/oda": {
    source: "iana",
    extensions: [
      "oda"
    ]
  },
  "application/odm+xml": {
    source: "iana",
    compressible: true
  },
  "application/odx": {
    source: "iana"
  },
  "application/oebps-package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "opf"
    ]
  },
  "application/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogx"
    ]
  },
  "application/omdoc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "omdoc"
    ]
  },
  "application/onenote": {
    source: "apache",
    extensions: [
      "onetoc",
      "onetoc2",
      "onetmp",
      "onepkg"
    ]
  },
  "application/opc-nodeset+xml": {
    source: "iana",
    compressible: true
  },
  "application/oscore": {
    source: "iana"
  },
  "application/oxps": {
    source: "iana",
    extensions: [
      "oxps"
    ]
  },
  "application/p21": {
    source: "iana"
  },
  "application/p21+zip": {
    source: "iana",
    compressible: false
  },
  "application/p2p-overlay+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "relo"
    ]
  },
  "application/parityfec": {
    source: "iana"
  },
  "application/passport": {
    source: "iana"
  },
  "application/patch-ops-error+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xer"
    ]
  },
  "application/pdf": {
    source: "iana",
    compressible: false,
    extensions: [
      "pdf"
    ]
  },
  "application/pdx": {
    source: "iana"
  },
  "application/pem-certificate-chain": {
    source: "iana"
  },
  "application/pgp-encrypted": {
    source: "iana",
    compressible: false,
    extensions: [
      "pgp"
    ]
  },
  "application/pgp-keys": {
    source: "iana",
    extensions: [
      "asc"
    ]
  },
  "application/pgp-signature": {
    source: "iana",
    extensions: [
      "asc",
      "sig"
    ]
  },
  "application/pics-rules": {
    source: "apache",
    extensions: [
      "prf"
    ]
  },
  "application/pidf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pidf-diff+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/pkcs10": {
    source: "iana",
    extensions: [
      "p10"
    ]
  },
  "application/pkcs12": {
    source: "iana"
  },
  "application/pkcs7-mime": {
    source: "iana",
    extensions: [
      "p7m",
      "p7c"
    ]
  },
  "application/pkcs7-signature": {
    source: "iana",
    extensions: [
      "p7s"
    ]
  },
  "application/pkcs8": {
    source: "iana",
    extensions: [
      "p8"
    ]
  },
  "application/pkcs8-encrypted": {
    source: "iana"
  },
  "application/pkix-attr-cert": {
    source: "iana",
    extensions: [
      "ac"
    ]
  },
  "application/pkix-cert": {
    source: "iana",
    extensions: [
      "cer"
    ]
  },
  "application/pkix-crl": {
    source: "iana",
    extensions: [
      "crl"
    ]
  },
  "application/pkix-pkipath": {
    source: "iana",
    extensions: [
      "pkipath"
    ]
  },
  "application/pkixcmp": {
    source: "iana",
    extensions: [
      "pki"
    ]
  },
  "application/pls+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pls"
    ]
  },
  "application/poc-settings+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/postscript": {
    source: "iana",
    compressible: true,
    extensions: [
      "ai",
      "eps",
      "ps"
    ]
  },
  "application/ppsp-tracker+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+json": {
    source: "iana",
    compressible: true
  },
  "application/problem+xml": {
    source: "iana",
    compressible: true
  },
  "application/provenance+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "provx"
    ]
  },
  "application/prs.alvestrand.titrax-sheet": {
    source: "iana"
  },
  "application/prs.cww": {
    source: "iana",
    extensions: [
      "cww"
    ]
  },
  "application/prs.cyn": {
    source: "iana",
    charset: "7-BIT"
  },
  "application/prs.hpub+zip": {
    source: "iana",
    compressible: false
  },
  "application/prs.nprend": {
    source: "iana"
  },
  "application/prs.plucker": {
    source: "iana"
  },
  "application/prs.rdf-xml-crypt": {
    source: "iana"
  },
  "application/prs.xsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/pskc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "pskcxml"
    ]
  },
  "application/pvd+json": {
    source: "iana",
    compressible: true
  },
  "application/qsig": {
    source: "iana"
  },
  "application/raml+yaml": {
    compressible: true,
    extensions: [
      "raml"
    ]
  },
  "application/raptorfec": {
    source: "iana"
  },
  "application/rdap+json": {
    source: "iana",
    compressible: true
  },
  "application/rdf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rdf",
      "owl"
    ]
  },
  "application/reginfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rif"
    ]
  },
  "application/relax-ng-compact-syntax": {
    source: "iana",
    extensions: [
      "rnc"
    ]
  },
  "application/remote-printing": {
    source: "iana"
  },
  "application/reputon+json": {
    source: "iana",
    compressible: true
  },
  "application/resource-lists+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rl"
    ]
  },
  "application/resource-lists-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rld"
    ]
  },
  "application/rfc+xml": {
    source: "iana",
    compressible: true
  },
  "application/riscos": {
    source: "iana"
  },
  "application/rlmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/rls-services+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rs"
    ]
  },
  "application/route-apd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rapd"
    ]
  },
  "application/route-s-tsid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sls"
    ]
  },
  "application/route-usd+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rusd"
    ]
  },
  "application/rpki-ghostbusters": {
    source: "iana",
    extensions: [
      "gbr"
    ]
  },
  "application/rpki-manifest": {
    source: "iana",
    extensions: [
      "mft"
    ]
  },
  "application/rpki-publication": {
    source: "iana"
  },
  "application/rpki-roa": {
    source: "iana",
    extensions: [
      "roa"
    ]
  },
  "application/rpki-updown": {
    source: "iana"
  },
  "application/rsd+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rsd"
    ]
  },
  "application/rss+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "rss"
    ]
  },
  "application/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "application/rtploopback": {
    source: "iana"
  },
  "application/rtx": {
    source: "iana"
  },
  "application/samlassertion+xml": {
    source: "iana",
    compressible: true
  },
  "application/samlmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/sarif+json": {
    source: "iana",
    compressible: true
  },
  "application/sarif-external-properties+json": {
    source: "iana",
    compressible: true
  },
  "application/sbe": {
    source: "iana"
  },
  "application/sbml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sbml"
    ]
  },
  "application/scaip+xml": {
    source: "iana",
    compressible: true
  },
  "application/scim+json": {
    source: "iana",
    compressible: true
  },
  "application/scvp-cv-request": {
    source: "iana",
    extensions: [
      "scq"
    ]
  },
  "application/scvp-cv-response": {
    source: "iana",
    extensions: [
      "scs"
    ]
  },
  "application/scvp-vp-request": {
    source: "iana",
    extensions: [
      "spq"
    ]
  },
  "application/scvp-vp-response": {
    source: "iana",
    extensions: [
      "spp"
    ]
  },
  "application/sdp": {
    source: "iana",
    extensions: [
      "sdp"
    ]
  },
  "application/secevent+jwt": {
    source: "iana"
  },
  "application/senml+cbor": {
    source: "iana"
  },
  "application/senml+json": {
    source: "iana",
    compressible: true
  },
  "application/senml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "senmlx"
    ]
  },
  "application/senml-etch+cbor": {
    source: "iana"
  },
  "application/senml-etch+json": {
    source: "iana",
    compressible: true
  },
  "application/senml-exi": {
    source: "iana"
  },
  "application/sensml+cbor": {
    source: "iana"
  },
  "application/sensml+json": {
    source: "iana",
    compressible: true
  },
  "application/sensml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sensmlx"
    ]
  },
  "application/sensml-exi": {
    source: "iana"
  },
  "application/sep+xml": {
    source: "iana",
    compressible: true
  },
  "application/sep-exi": {
    source: "iana"
  },
  "application/session-info": {
    source: "iana"
  },
  "application/set-payment": {
    source: "iana"
  },
  "application/set-payment-initiation": {
    source: "iana",
    extensions: [
      "setpay"
    ]
  },
  "application/set-registration": {
    source: "iana"
  },
  "application/set-registration-initiation": {
    source: "iana",
    extensions: [
      "setreg"
    ]
  },
  "application/sgml": {
    source: "iana"
  },
  "application/sgml-open-catalog": {
    source: "iana"
  },
  "application/shf+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "shf"
    ]
  },
  "application/sieve": {
    source: "iana",
    extensions: [
      "siv",
      "sieve"
    ]
  },
  "application/simple-filter+xml": {
    source: "iana",
    compressible: true
  },
  "application/simple-message-summary": {
    source: "iana"
  },
  "application/simplesymbolcontainer": {
    source: "iana"
  },
  "application/sipc": {
    source: "iana"
  },
  "application/slate": {
    source: "iana"
  },
  "application/smil": {
    source: "iana"
  },
  "application/smil+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "smi",
      "smil"
    ]
  },
  "application/smpte336m": {
    source: "iana"
  },
  "application/soap+fastinfoset": {
    source: "iana"
  },
  "application/soap+xml": {
    source: "iana",
    compressible: true
  },
  "application/sparql-query": {
    source: "iana",
    extensions: [
      "rq"
    ]
  },
  "application/sparql-results+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "srx"
    ]
  },
  "application/spdx+json": {
    source: "iana",
    compressible: true
  },
  "application/spirits-event+xml": {
    source: "iana",
    compressible: true
  },
  "application/sql": {
    source: "iana"
  },
  "application/srgs": {
    source: "iana",
    extensions: [
      "gram"
    ]
  },
  "application/srgs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "grxml"
    ]
  },
  "application/sru+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sru"
    ]
  },
  "application/ssdl+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ssdl"
    ]
  },
  "application/ssml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ssml"
    ]
  },
  "application/stix+json": {
    source: "iana",
    compressible: true
  },
  "application/swid+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "swidtag"
    ]
  },
  "application/tamp-apex-update": {
    source: "iana"
  },
  "application/tamp-apex-update-confirm": {
    source: "iana"
  },
  "application/tamp-community-update": {
    source: "iana"
  },
  "application/tamp-community-update-confirm": {
    source: "iana"
  },
  "application/tamp-error": {
    source: "iana"
  },
  "application/tamp-sequence-adjust": {
    source: "iana"
  },
  "application/tamp-sequence-adjust-confirm": {
    source: "iana"
  },
  "application/tamp-status-query": {
    source: "iana"
  },
  "application/tamp-status-response": {
    source: "iana"
  },
  "application/tamp-update": {
    source: "iana"
  },
  "application/tamp-update-confirm": {
    source: "iana"
  },
  "application/tar": {
    compressible: true
  },
  "application/taxii+json": {
    source: "iana",
    compressible: true
  },
  "application/td+json": {
    source: "iana",
    compressible: true
  },
  "application/tei+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tei",
      "teicorpus"
    ]
  },
  "application/tetra_isi": {
    source: "iana"
  },
  "application/thraud+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "tfi"
    ]
  },
  "application/timestamp-query": {
    source: "iana"
  },
  "application/timestamp-reply": {
    source: "iana"
  },
  "application/timestamped-data": {
    source: "iana",
    extensions: [
      "tsd"
    ]
  },
  "application/tlsrpt+gzip": {
    source: "iana"
  },
  "application/tlsrpt+json": {
    source: "iana",
    compressible: true
  },
  "application/tnauthlist": {
    source: "iana"
  },
  "application/token-introspection+jwt": {
    source: "iana"
  },
  "application/toml": {
    compressible: true,
    extensions: [
      "toml"
    ]
  },
  "application/trickle-ice-sdpfrag": {
    source: "iana"
  },
  "application/trig": {
    source: "iana",
    extensions: [
      "trig"
    ]
  },
  "application/ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttml"
    ]
  },
  "application/tve-trigger": {
    source: "iana"
  },
  "application/tzif": {
    source: "iana"
  },
  "application/tzif-leap": {
    source: "iana"
  },
  "application/ubjson": {
    compressible: false,
    extensions: [
      "ubj"
    ]
  },
  "application/ulpfec": {
    source: "iana"
  },
  "application/urc-grpsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/urc-ressheet+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "rsheet"
    ]
  },
  "application/urc-targetdesc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "td"
    ]
  },
  "application/urc-uisocketdesc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vcard+json": {
    source: "iana",
    compressible: true
  },
  "application/vcard+xml": {
    source: "iana",
    compressible: true
  },
  "application/vemmi": {
    source: "iana"
  },
  "application/vividence.scriptfile": {
    source: "apache"
  },
  "application/vnd.1000minds.decision-model+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "1km"
    ]
  },
  "application/vnd.3gpp-prose+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-prose-pc3ch+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp-v2x-local-service-information": {
    source: "iana"
  },
  "application/vnd.3gpp.5gnas": {
    source: "iana"
  },
  "application/vnd.3gpp.access-transfer-events+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.bsf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gmop+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.gtpc": {
    source: "iana"
  },
  "application/vnd.3gpp.interworking-data": {
    source: "iana"
  },
  "application/vnd.3gpp.lpp": {
    source: "iana"
  },
  "application/vnd.3gpp.mc-signalling-ear": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-payload": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-signalling": {
    source: "iana"
  },
  "application/vnd.3gpp.mcdata-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcdata-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-floor-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-signed+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-ue-init-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcptt-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-command+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-affiliation-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-location-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-service-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-transmission-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-ue-config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mcvideo-user-profile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.mid-call+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ngap": {
    source: "iana"
  },
  "application/vnd.3gpp.pfcp": {
    source: "iana"
  },
  "application/vnd.3gpp.pic-bw-large": {
    source: "iana",
    extensions: [
      "plb"
    ]
  },
  "application/vnd.3gpp.pic-bw-small": {
    source: "iana",
    extensions: [
      "psb"
    ]
  },
  "application/vnd.3gpp.pic-bw-var": {
    source: "iana",
    extensions: [
      "pvb"
    ]
  },
  "application/vnd.3gpp.s1ap": {
    source: "iana"
  },
  "application/vnd.3gpp.sms": {
    source: "iana"
  },
  "application/vnd.3gpp.sms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-ext+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.srvcc-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.state-and-event-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp.ussd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.bcmcsinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.3gpp2.sms": {
    source: "iana"
  },
  "application/vnd.3gpp2.tcap": {
    source: "iana",
    extensions: [
      "tcap"
    ]
  },
  "application/vnd.3lightssoftware.imagescal": {
    source: "iana"
  },
  "application/vnd.3m.post-it-notes": {
    source: "iana",
    extensions: [
      "pwn"
    ]
  },
  "application/vnd.accpac.simply.aso": {
    source: "iana",
    extensions: [
      "aso"
    ]
  },
  "application/vnd.accpac.simply.imp": {
    source: "iana",
    extensions: [
      "imp"
    ]
  },
  "application/vnd.acucobol": {
    source: "iana",
    extensions: [
      "acu"
    ]
  },
  "application/vnd.acucorp": {
    source: "iana",
    extensions: [
      "atc",
      "acutc"
    ]
  },
  "application/vnd.adobe.air-application-installer-package+zip": {
    source: "apache",
    compressible: false,
    extensions: [
      "air"
    ]
  },
  "application/vnd.adobe.flash.movie": {
    source: "iana"
  },
  "application/vnd.adobe.formscentral.fcdt": {
    source: "iana",
    extensions: [
      "fcdt"
    ]
  },
  "application/vnd.adobe.fxp": {
    source: "iana",
    extensions: [
      "fxp",
      "fxpl"
    ]
  },
  "application/vnd.adobe.partial-upload": {
    source: "iana"
  },
  "application/vnd.adobe.xdp+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdp"
    ]
  },
  "application/vnd.adobe.xfdf": {
    source: "iana",
    extensions: [
      "xfdf"
    ]
  },
  "application/vnd.aether.imp": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata": {
    source: "iana"
  },
  "application/vnd.afpc.afplinedata-pagedef": {
    source: "iana"
  },
  "application/vnd.afpc.cmoca-cmresource": {
    source: "iana"
  },
  "application/vnd.afpc.foca-charset": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codedfont": {
    source: "iana"
  },
  "application/vnd.afpc.foca-codepage": {
    source: "iana"
  },
  "application/vnd.afpc.modca": {
    source: "iana"
  },
  "application/vnd.afpc.modca-cmtable": {
    source: "iana"
  },
  "application/vnd.afpc.modca-formdef": {
    source: "iana"
  },
  "application/vnd.afpc.modca-mediummap": {
    source: "iana"
  },
  "application/vnd.afpc.modca-objectcontainer": {
    source: "iana"
  },
  "application/vnd.afpc.modca-overlay": {
    source: "iana"
  },
  "application/vnd.afpc.modca-pagesegment": {
    source: "iana"
  },
  "application/vnd.age": {
    source: "iana",
    extensions: [
      "age"
    ]
  },
  "application/vnd.ah-barcode": {
    source: "iana"
  },
  "application/vnd.ahead.space": {
    source: "iana",
    extensions: [
      "ahead"
    ]
  },
  "application/vnd.airzip.filesecure.azf": {
    source: "iana",
    extensions: [
      "azf"
    ]
  },
  "application/vnd.airzip.filesecure.azs": {
    source: "iana",
    extensions: [
      "azs"
    ]
  },
  "application/vnd.amadeus+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.amazon.ebook": {
    source: "apache",
    extensions: [
      "azw"
    ]
  },
  "application/vnd.amazon.mobi8-ebook": {
    source: "iana"
  },
  "application/vnd.americandynamics.acc": {
    source: "iana",
    extensions: [
      "acc"
    ]
  },
  "application/vnd.amiga.ami": {
    source: "iana",
    extensions: [
      "ami"
    ]
  },
  "application/vnd.amundsen.maze+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.android.ota": {
    source: "iana"
  },
  "application/vnd.android.package-archive": {
    source: "apache",
    compressible: false,
    extensions: [
      "apk"
    ]
  },
  "application/vnd.anki": {
    source: "iana"
  },
  "application/vnd.anser-web-certificate-issue-initiation": {
    source: "iana",
    extensions: [
      "cii"
    ]
  },
  "application/vnd.anser-web-funds-transfer-initiation": {
    source: "apache",
    extensions: [
      "fti"
    ]
  },
  "application/vnd.antix.game-component": {
    source: "iana",
    extensions: [
      "atx"
    ]
  },
  "application/vnd.apache.arrow.file": {
    source: "iana"
  },
  "application/vnd.apache.arrow.stream": {
    source: "iana"
  },
  "application/vnd.apache.thrift.binary": {
    source: "iana"
  },
  "application/vnd.apache.thrift.compact": {
    source: "iana"
  },
  "application/vnd.apache.thrift.json": {
    source: "iana"
  },
  "application/vnd.api+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.aplextor.warrp+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apothekende.reservation+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.apple.installer+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mpkg"
    ]
  },
  "application/vnd.apple.keynote": {
    source: "iana",
    extensions: [
      "key"
    ]
  },
  "application/vnd.apple.mpegurl": {
    source: "iana",
    extensions: [
      "m3u8"
    ]
  },
  "application/vnd.apple.numbers": {
    source: "iana",
    extensions: [
      "numbers"
    ]
  },
  "application/vnd.apple.pages": {
    source: "iana",
    extensions: [
      "pages"
    ]
  },
  "application/vnd.apple.pkpass": {
    compressible: false,
    extensions: [
      "pkpass"
    ]
  },
  "application/vnd.arastra.swi": {
    source: "iana"
  },
  "application/vnd.aristanetworks.swi": {
    source: "iana",
    extensions: [
      "swi"
    ]
  },
  "application/vnd.artisan+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.artsquare": {
    source: "iana"
  },
  "application/vnd.astraea-software.iota": {
    source: "iana",
    extensions: [
      "iota"
    ]
  },
  "application/vnd.audiograph": {
    source: "iana",
    extensions: [
      "aep"
    ]
  },
  "application/vnd.autopackage": {
    source: "iana"
  },
  "application/vnd.avalon+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.avistar+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.balsamiq.bmml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmml"
    ]
  },
  "application/vnd.balsamiq.bmpr": {
    source: "iana"
  },
  "application/vnd.banana-accounting": {
    source: "iana"
  },
  "application/vnd.bbf.usp.error": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg": {
    source: "iana"
  },
  "application/vnd.bbf.usp.msg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bekitzur-stech+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.bint.med-content": {
    source: "iana"
  },
  "application/vnd.biopax.rdf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.blink-idb-value-wrapper": {
    source: "iana"
  },
  "application/vnd.blueice.multipass": {
    source: "iana",
    extensions: [
      "mpm"
    ]
  },
  "application/vnd.bluetooth.ep.oob": {
    source: "iana"
  },
  "application/vnd.bluetooth.le.oob": {
    source: "iana"
  },
  "application/vnd.bmi": {
    source: "iana",
    extensions: [
      "bmi"
    ]
  },
  "application/vnd.bpf": {
    source: "iana"
  },
  "application/vnd.bpf3": {
    source: "iana"
  },
  "application/vnd.businessobjects": {
    source: "iana",
    extensions: [
      "rep"
    ]
  },
  "application/vnd.byu.uapi+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cab-jscript": {
    source: "iana"
  },
  "application/vnd.canon-cpdl": {
    source: "iana"
  },
  "application/vnd.canon-lips": {
    source: "iana"
  },
  "application/vnd.capasystems-pg+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cendio.thinlinc.clientconf": {
    source: "iana"
  },
  "application/vnd.century-systems.tcp_stream": {
    source: "iana"
  },
  "application/vnd.chemdraw+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "cdxml"
    ]
  },
  "application/vnd.chess-pgn": {
    source: "iana"
  },
  "application/vnd.chipnuts.karaoke-mmd": {
    source: "iana",
    extensions: [
      "mmd"
    ]
  },
  "application/vnd.ciedi": {
    source: "iana"
  },
  "application/vnd.cinderella": {
    source: "iana",
    extensions: [
      "cdy"
    ]
  },
  "application/vnd.cirpack.isdn-ext": {
    source: "iana"
  },
  "application/vnd.citationstyles.style+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "csl"
    ]
  },
  "application/vnd.claymore": {
    source: "iana",
    extensions: [
      "cla"
    ]
  },
  "application/vnd.cloanto.rp9": {
    source: "iana",
    extensions: [
      "rp9"
    ]
  },
  "application/vnd.clonk.c4group": {
    source: "iana",
    extensions: [
      "c4g",
      "c4d",
      "c4f",
      "c4p",
      "c4u"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config": {
    source: "iana",
    extensions: [
      "c11amc"
    ]
  },
  "application/vnd.cluetrust.cartomobile-config-pkg": {
    source: "iana",
    extensions: [
      "c11amz"
    ]
  },
  "application/vnd.coffeescript": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.document-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.presentation-template": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet": {
    source: "iana"
  },
  "application/vnd.collabio.xodocuments.spreadsheet-template": {
    source: "iana"
  },
  "application/vnd.collection+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.doc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.collection.next+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.comicbook+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.comicbook-rar": {
    source: "iana"
  },
  "application/vnd.commerce-battelle": {
    source: "iana"
  },
  "application/vnd.commonspace": {
    source: "iana",
    extensions: [
      "csp"
    ]
  },
  "application/vnd.contact.cmsg": {
    source: "iana",
    extensions: [
      "cdbcmsg"
    ]
  },
  "application/vnd.coreos.ignition+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cosmocaller": {
    source: "iana",
    extensions: [
      "cmc"
    ]
  },
  "application/vnd.crick.clicker": {
    source: "iana",
    extensions: [
      "clkx"
    ]
  },
  "application/vnd.crick.clicker.keyboard": {
    source: "iana",
    extensions: [
      "clkk"
    ]
  },
  "application/vnd.crick.clicker.palette": {
    source: "iana",
    extensions: [
      "clkp"
    ]
  },
  "application/vnd.crick.clicker.template": {
    source: "iana",
    extensions: [
      "clkt"
    ]
  },
  "application/vnd.crick.clicker.wordbank": {
    source: "iana",
    extensions: [
      "clkw"
    ]
  },
  "application/vnd.criticaltools.wbs+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wbs"
    ]
  },
  "application/vnd.cryptii.pipe+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.crypto-shade-file": {
    source: "iana"
  },
  "application/vnd.cryptomator.encrypted": {
    source: "iana"
  },
  "application/vnd.cryptomator.vault": {
    source: "iana"
  },
  "application/vnd.ctc-posml": {
    source: "iana",
    extensions: [
      "pml"
    ]
  },
  "application/vnd.ctct.ws+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cups-pdf": {
    source: "iana"
  },
  "application/vnd.cups-postscript": {
    source: "iana"
  },
  "application/vnd.cups-ppd": {
    source: "iana",
    extensions: [
      "ppd"
    ]
  },
  "application/vnd.cups-raster": {
    source: "iana"
  },
  "application/vnd.cups-raw": {
    source: "iana"
  },
  "application/vnd.curl": {
    source: "iana"
  },
  "application/vnd.curl.car": {
    source: "apache",
    extensions: [
      "car"
    ]
  },
  "application/vnd.curl.pcurl": {
    source: "apache",
    extensions: [
      "pcurl"
    ]
  },
  "application/vnd.cyan.dean.root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cybank": {
    source: "iana"
  },
  "application/vnd.cyclonedx+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.cyclonedx+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.d2l.coursepackage1p0+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.d3m-dataset": {
    source: "iana"
  },
  "application/vnd.d3m-problem": {
    source: "iana"
  },
  "application/vnd.dart": {
    source: "iana",
    compressible: true,
    extensions: [
      "dart"
    ]
  },
  "application/vnd.data-vision.rdz": {
    source: "iana",
    extensions: [
      "rdz"
    ]
  },
  "application/vnd.datapackage+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dataresource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dbf": {
    source: "iana",
    extensions: [
      "dbf"
    ]
  },
  "application/vnd.debian.binary-package": {
    source: "iana"
  },
  "application/vnd.dece.data": {
    source: "iana",
    extensions: [
      "uvf",
      "uvvf",
      "uvd",
      "uvvd"
    ]
  },
  "application/vnd.dece.ttml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uvt",
      "uvvt"
    ]
  },
  "application/vnd.dece.unspecified": {
    source: "iana",
    extensions: [
      "uvx",
      "uvvx"
    ]
  },
  "application/vnd.dece.zip": {
    source: "iana",
    extensions: [
      "uvz",
      "uvvz"
    ]
  },
  "application/vnd.denovo.fcselayout-link": {
    source: "iana",
    extensions: [
      "fe_launch"
    ]
  },
  "application/vnd.desmume.movie": {
    source: "iana"
  },
  "application/vnd.dir-bi.plate-dl-nosuffix": {
    source: "iana"
  },
  "application/vnd.dm.delegation+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dna": {
    source: "iana",
    extensions: [
      "dna"
    ]
  },
  "application/vnd.document+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dolby.mlp": {
    source: "apache",
    extensions: [
      "mlp"
    ]
  },
  "application/vnd.dolby.mobile.1": {
    source: "iana"
  },
  "application/vnd.dolby.mobile.2": {
    source: "iana"
  },
  "application/vnd.doremir.scorecloud-binary-document": {
    source: "iana"
  },
  "application/vnd.dpgraph": {
    source: "iana",
    extensions: [
      "dpg"
    ]
  },
  "application/vnd.dreamfactory": {
    source: "iana",
    extensions: [
      "dfac"
    ]
  },
  "application/vnd.drive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ds-keypoint": {
    source: "apache",
    extensions: [
      "kpxx"
    ]
  },
  "application/vnd.dtg.local": {
    source: "iana"
  },
  "application/vnd.dtg.local.flash": {
    source: "iana"
  },
  "application/vnd.dtg.local.html": {
    source: "iana"
  },
  "application/vnd.dvb.ait": {
    source: "iana",
    extensions: [
      "ait"
    ]
  },
  "application/vnd.dvb.dvbisl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.dvbj": {
    source: "iana"
  },
  "application/vnd.dvb.esgcontainer": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcdftnotifaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgaccess2": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcesgpdd": {
    source: "iana"
  },
  "application/vnd.dvb.ipdcroaming": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-base": {
    source: "iana"
  },
  "application/vnd.dvb.iptv.alfec-enhancement": {
    source: "iana"
  },
  "application/vnd.dvb.notif-aggregate-root+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-container+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-generic+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-msglist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-ia-registration-response+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.notif-init+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.dvb.pfr": {
    source: "iana"
  },
  "application/vnd.dvb.service": {
    source: "iana",
    extensions: [
      "svc"
    ]
  },
  "application/vnd.dxr": {
    source: "iana"
  },
  "application/vnd.dynageo": {
    source: "iana",
    extensions: [
      "geo"
    ]
  },
  "application/vnd.dzr": {
    source: "iana"
  },
  "application/vnd.easykaraoke.cdgdownload": {
    source: "iana"
  },
  "application/vnd.ecdis-update": {
    source: "iana"
  },
  "application/vnd.ecip.rlp": {
    source: "iana"
  },
  "application/vnd.eclipse.ditto+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ecowin.chart": {
    source: "iana",
    extensions: [
      "mag"
    ]
  },
  "application/vnd.ecowin.filerequest": {
    source: "iana"
  },
  "application/vnd.ecowin.fileupdate": {
    source: "iana"
  },
  "application/vnd.ecowin.series": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesrequest": {
    source: "iana"
  },
  "application/vnd.ecowin.seriesupdate": {
    source: "iana"
  },
  "application/vnd.efi.img": {
    source: "iana"
  },
  "application/vnd.efi.iso": {
    source: "iana"
  },
  "application/vnd.emclient.accessrequest+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.enliven": {
    source: "iana",
    extensions: [
      "nml"
    ]
  },
  "application/vnd.enphase.envoy": {
    source: "iana"
  },
  "application/vnd.eprints.data+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.epson.esf": {
    source: "iana",
    extensions: [
      "esf"
    ]
  },
  "application/vnd.epson.msf": {
    source: "iana",
    extensions: [
      "msf"
    ]
  },
  "application/vnd.epson.quickanime": {
    source: "iana",
    extensions: [
      "qam"
    ]
  },
  "application/vnd.epson.salt": {
    source: "iana",
    extensions: [
      "slt"
    ]
  },
  "application/vnd.epson.ssf": {
    source: "iana",
    extensions: [
      "ssf"
    ]
  },
  "application/vnd.ericsson.quickcall": {
    source: "iana"
  },
  "application/vnd.espass-espass+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.eszigno3+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "es3",
      "et3"
    ]
  },
  "application/vnd.etsi.aoc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.asic-e+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.asic-s+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.etsi.cug+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvcommand+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-bc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-cod+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsad-npvr+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvservice+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvsync+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.iptvueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mcid+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.mheg5": {
    source: "iana"
  },
  "application/vnd.etsi.overload-control-policy-dataset+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.pstn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.sci+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.simservs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.timestamp-token": {
    source: "iana"
  },
  "application/vnd.etsi.tsl+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.etsi.tsl.der": {
    source: "iana"
  },
  "application/vnd.eu.kasparian.car+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.eudora.data": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.profile": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.settings": {
    source: "iana"
  },
  "application/vnd.evolv.ecig.theme": {
    source: "iana"
  },
  "application/vnd.exstream-empower+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.exstream-package": {
    source: "iana"
  },
  "application/vnd.ezpix-album": {
    source: "iana",
    extensions: [
      "ez2"
    ]
  },
  "application/vnd.ezpix-package": {
    source: "iana",
    extensions: [
      "ez3"
    ]
  },
  "application/vnd.f-secure.mobile": {
    source: "iana"
  },
  "application/vnd.familysearch.gedcom+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.fastcopy-disk-image": {
    source: "iana"
  },
  "application/vnd.fdf": {
    source: "iana",
    extensions: [
      "fdf"
    ]
  },
  "application/vnd.fdsn.mseed": {
    source: "iana",
    extensions: [
      "mseed"
    ]
  },
  "application/vnd.fdsn.seed": {
    source: "iana",
    extensions: [
      "seed",
      "dataless"
    ]
  },
  "application/vnd.ffsns": {
    source: "iana"
  },
  "application/vnd.ficlab.flb+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.filmit.zfc": {
    source: "iana"
  },
  "application/vnd.fints": {
    source: "iana"
  },
  "application/vnd.firemonkeys.cloudcell": {
    source: "iana"
  },
  "application/vnd.flographit": {
    source: "iana",
    extensions: [
      "gph"
    ]
  },
  "application/vnd.fluxtime.clip": {
    source: "iana",
    extensions: [
      "ftc"
    ]
  },
  "application/vnd.font-fontforge-sfd": {
    source: "iana"
  },
  "application/vnd.framemaker": {
    source: "iana",
    extensions: [
      "fm",
      "frame",
      "maker",
      "book"
    ]
  },
  "application/vnd.frogans.fnc": {
    source: "iana",
    extensions: [
      "fnc"
    ]
  },
  "application/vnd.frogans.ltf": {
    source: "iana",
    extensions: [
      "ltf"
    ]
  },
  "application/vnd.fsc.weblaunch": {
    source: "iana",
    extensions: [
      "fsc"
    ]
  },
  "application/vnd.fujifilm.fb.docuworks": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.binder": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujifilm.fb.jfi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fujitsu.oasys": {
    source: "iana",
    extensions: [
      "oas"
    ]
  },
  "application/vnd.fujitsu.oasys2": {
    source: "iana",
    extensions: [
      "oa2"
    ]
  },
  "application/vnd.fujitsu.oasys3": {
    source: "iana",
    extensions: [
      "oa3"
    ]
  },
  "application/vnd.fujitsu.oasysgp": {
    source: "iana",
    extensions: [
      "fg5"
    ]
  },
  "application/vnd.fujitsu.oasysprs": {
    source: "iana",
    extensions: [
      "bh2"
    ]
  },
  "application/vnd.fujixerox.art-ex": {
    source: "iana"
  },
  "application/vnd.fujixerox.art4": {
    source: "iana"
  },
  "application/vnd.fujixerox.ddd": {
    source: "iana",
    extensions: [
      "ddd"
    ]
  },
  "application/vnd.fujixerox.docuworks": {
    source: "iana",
    extensions: [
      "xdw"
    ]
  },
  "application/vnd.fujixerox.docuworks.binder": {
    source: "iana",
    extensions: [
      "xbd"
    ]
  },
  "application/vnd.fujixerox.docuworks.container": {
    source: "iana"
  },
  "application/vnd.fujixerox.hbpl": {
    source: "iana"
  },
  "application/vnd.fut-misnet": {
    source: "iana"
  },
  "application/vnd.futoin+cbor": {
    source: "iana"
  },
  "application/vnd.futoin+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.fuzzysheet": {
    source: "iana",
    extensions: [
      "fzs"
    ]
  },
  "application/vnd.genomatix.tuxedo": {
    source: "iana",
    extensions: [
      "txd"
    ]
  },
  "application/vnd.gentics.grd+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geo+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geocube+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.geogebra.file": {
    source: "iana",
    extensions: [
      "ggb"
    ]
  },
  "application/vnd.geogebra.slides": {
    source: "iana"
  },
  "application/vnd.geogebra.tool": {
    source: "iana",
    extensions: [
      "ggt"
    ]
  },
  "application/vnd.geometry-explorer": {
    source: "iana",
    extensions: [
      "gex",
      "gre"
    ]
  },
  "application/vnd.geonext": {
    source: "iana",
    extensions: [
      "gxt"
    ]
  },
  "application/vnd.geoplan": {
    source: "iana",
    extensions: [
      "g2w"
    ]
  },
  "application/vnd.geospace": {
    source: "iana",
    extensions: [
      "g3w"
    ]
  },
  "application/vnd.gerber": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt": {
    source: "iana"
  },
  "application/vnd.globalplatform.card-content-mgt-response": {
    source: "iana"
  },
  "application/vnd.gmx": {
    source: "iana",
    extensions: [
      "gmx"
    ]
  },
  "application/vnd.google-apps.document": {
    compressible: false,
    extensions: [
      "gdoc"
    ]
  },
  "application/vnd.google-apps.presentation": {
    compressible: false,
    extensions: [
      "gslides"
    ]
  },
  "application/vnd.google-apps.spreadsheet": {
    compressible: false,
    extensions: [
      "gsheet"
    ]
  },
  "application/vnd.google-earth.kml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "kml"
    ]
  },
  "application/vnd.google-earth.kmz": {
    source: "iana",
    compressible: false,
    extensions: [
      "kmz"
    ]
  },
  "application/vnd.gov.sk.e-form+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.gov.sk.e-form+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.gov.sk.xmldatacontainer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.grafeq": {
    source: "iana",
    extensions: [
      "gqf",
      "gqs"
    ]
  },
  "application/vnd.gridmp": {
    source: "iana"
  },
  "application/vnd.groove-account": {
    source: "iana",
    extensions: [
      "gac"
    ]
  },
  "application/vnd.groove-help": {
    source: "iana",
    extensions: [
      "ghf"
    ]
  },
  "application/vnd.groove-identity-message": {
    source: "iana",
    extensions: [
      "gim"
    ]
  },
  "application/vnd.groove-injector": {
    source: "iana",
    extensions: [
      "grv"
    ]
  },
  "application/vnd.groove-tool-message": {
    source: "iana",
    extensions: [
      "gtm"
    ]
  },
  "application/vnd.groove-tool-template": {
    source: "iana",
    extensions: [
      "tpl"
    ]
  },
  "application/vnd.groove-vcard": {
    source: "iana",
    extensions: [
      "vcg"
    ]
  },
  "application/vnd.hal+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hal+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "hal"
    ]
  },
  "application/vnd.handheld-entertainment+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zmm"
    ]
  },
  "application/vnd.hbci": {
    source: "iana",
    extensions: [
      "hbci"
    ]
  },
  "application/vnd.hc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hcl-bireports": {
    source: "iana"
  },
  "application/vnd.hdt": {
    source: "iana"
  },
  "application/vnd.heroku+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hhe.lesson-player": {
    source: "iana",
    extensions: [
      "les"
    ]
  },
  "application/vnd.hl7cda+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hl7v2+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.hp-hpgl": {
    source: "iana",
    extensions: [
      "hpgl"
    ]
  },
  "application/vnd.hp-hpid": {
    source: "iana",
    extensions: [
      "hpid"
    ]
  },
  "application/vnd.hp-hps": {
    source: "iana",
    extensions: [
      "hps"
    ]
  },
  "application/vnd.hp-jlyt": {
    source: "iana",
    extensions: [
      "jlt"
    ]
  },
  "application/vnd.hp-pcl": {
    source: "iana",
    extensions: [
      "pcl"
    ]
  },
  "application/vnd.hp-pclxl": {
    source: "iana",
    extensions: [
      "pclxl"
    ]
  },
  "application/vnd.httphone": {
    source: "iana"
  },
  "application/vnd.hydrostatix.sof-data": {
    source: "iana",
    extensions: [
      "sfd-hdstx"
    ]
  },
  "application/vnd.hyper+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyper-item+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hyperdrive+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.hzn-3d-crossword": {
    source: "iana"
  },
  "application/vnd.ibm.afplinedata": {
    source: "iana"
  },
  "application/vnd.ibm.electronic-media": {
    source: "iana"
  },
  "application/vnd.ibm.minipay": {
    source: "iana",
    extensions: [
      "mpy"
    ]
  },
  "application/vnd.ibm.modcap": {
    source: "iana",
    extensions: [
      "afp",
      "listafp",
      "list3820"
    ]
  },
  "application/vnd.ibm.rights-management": {
    source: "iana",
    extensions: [
      "irm"
    ]
  },
  "application/vnd.ibm.secure-container": {
    source: "iana",
    extensions: [
      "sc"
    ]
  },
  "application/vnd.iccprofile": {
    source: "iana",
    extensions: [
      "icc",
      "icm"
    ]
  },
  "application/vnd.ieee.1905": {
    source: "iana"
  },
  "application/vnd.igloader": {
    source: "iana",
    extensions: [
      "igl"
    ]
  },
  "application/vnd.imagemeter.folder+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.imagemeter.image+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.immervision-ivp": {
    source: "iana",
    extensions: [
      "ivp"
    ]
  },
  "application/vnd.immervision-ivu": {
    source: "iana",
    extensions: [
      "ivu"
    ]
  },
  "application/vnd.ims.imsccv1p1": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p2": {
    source: "iana"
  },
  "application/vnd.ims.imsccv1p3": {
    source: "iana"
  },
  "application/vnd.ims.lis.v2.result+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolconsumerprofile+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolproxy.id+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ims.lti.v2.toolsettings.simple+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informedcontrol.rms+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.informix-visionary": {
    source: "iana"
  },
  "application/vnd.infotech.project": {
    source: "iana"
  },
  "application/vnd.infotech.project+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.innopath.wamp.notification": {
    source: "iana"
  },
  "application/vnd.insors.igm": {
    source: "iana",
    extensions: [
      "igm"
    ]
  },
  "application/vnd.intercon.formnet": {
    source: "iana",
    extensions: [
      "xpw",
      "xpx"
    ]
  },
  "application/vnd.intergeo": {
    source: "iana",
    extensions: [
      "i2g"
    ]
  },
  "application/vnd.intertrust.digibox": {
    source: "iana"
  },
  "application/vnd.intertrust.nncp": {
    source: "iana"
  },
  "application/vnd.intu.qbo": {
    source: "iana",
    extensions: [
      "qbo"
    ]
  },
  "application/vnd.intu.qfx": {
    source: "iana",
    extensions: [
      "qfx"
    ]
  },
  "application/vnd.iptc.g2.catalogitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.conceptitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.knowledgeitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.newsmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.packageitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.iptc.g2.planningitem+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ipunplugged.rcprofile": {
    source: "iana",
    extensions: [
      "rcprofile"
    ]
  },
  "application/vnd.irepository.package+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "irp"
    ]
  },
  "application/vnd.is-xpr": {
    source: "iana",
    extensions: [
      "xpr"
    ]
  },
  "application/vnd.isac.fcs": {
    source: "iana",
    extensions: [
      "fcs"
    ]
  },
  "application/vnd.iso11783-10+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.jam": {
    source: "iana",
    extensions: [
      "jam"
    ]
  },
  "application/vnd.japannet-directory-service": {
    source: "iana"
  },
  "application/vnd.japannet-jpnstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-payment-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-registration": {
    source: "iana"
  },
  "application/vnd.japannet-registration-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-setstore-wakeup": {
    source: "iana"
  },
  "application/vnd.japannet-verification": {
    source: "iana"
  },
  "application/vnd.japannet-verification-wakeup": {
    source: "iana"
  },
  "application/vnd.jcp.javame.midlet-rms": {
    source: "iana",
    extensions: [
      "rms"
    ]
  },
  "application/vnd.jisp": {
    source: "iana",
    extensions: [
      "jisp"
    ]
  },
  "application/vnd.joost.joda-archive": {
    source: "iana",
    extensions: [
      "joda"
    ]
  },
  "application/vnd.jsk.isdn-ngn": {
    source: "iana"
  },
  "application/vnd.kahootz": {
    source: "iana",
    extensions: [
      "ktz",
      "ktr"
    ]
  },
  "application/vnd.kde.karbon": {
    source: "iana",
    extensions: [
      "karbon"
    ]
  },
  "application/vnd.kde.kchart": {
    source: "iana",
    extensions: [
      "chrt"
    ]
  },
  "application/vnd.kde.kformula": {
    source: "iana",
    extensions: [
      "kfo"
    ]
  },
  "application/vnd.kde.kivio": {
    source: "iana",
    extensions: [
      "flw"
    ]
  },
  "application/vnd.kde.kontour": {
    source: "iana",
    extensions: [
      "kon"
    ]
  },
  "application/vnd.kde.kpresenter": {
    source: "iana",
    extensions: [
      "kpr",
      "kpt"
    ]
  },
  "application/vnd.kde.kspread": {
    source: "iana",
    extensions: [
      "ksp"
    ]
  },
  "application/vnd.kde.kword": {
    source: "iana",
    extensions: [
      "kwd",
      "kwt"
    ]
  },
  "application/vnd.kenameaapp": {
    source: "iana",
    extensions: [
      "htke"
    ]
  },
  "application/vnd.kidspiration": {
    source: "iana",
    extensions: [
      "kia"
    ]
  },
  "application/vnd.kinar": {
    source: "iana",
    extensions: [
      "kne",
      "knp"
    ]
  },
  "application/vnd.koan": {
    source: "iana",
    extensions: [
      "skp",
      "skd",
      "skt",
      "skm"
    ]
  },
  "application/vnd.kodak-descriptor": {
    source: "iana",
    extensions: [
      "sse"
    ]
  },
  "application/vnd.las": {
    source: "iana"
  },
  "application/vnd.las.las+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.las.las+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lasxml"
    ]
  },
  "application/vnd.laszip": {
    source: "iana"
  },
  "application/vnd.leap+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.liberty-request+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.llamagraphics.life-balance.desktop": {
    source: "iana",
    extensions: [
      "lbd"
    ]
  },
  "application/vnd.llamagraphics.life-balance.exchange+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "lbe"
    ]
  },
  "application/vnd.logipipe.circuit+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.loom": {
    source: "iana"
  },
  "application/vnd.lotus-1-2-3": {
    source: "iana",
    extensions: [
      "123"
    ]
  },
  "application/vnd.lotus-approach": {
    source: "iana",
    extensions: [
      "apr"
    ]
  },
  "application/vnd.lotus-freelance": {
    source: "iana",
    extensions: [
      "pre"
    ]
  },
  "application/vnd.lotus-notes": {
    source: "iana",
    extensions: [
      "nsf"
    ]
  },
  "application/vnd.lotus-organizer": {
    source: "iana",
    extensions: [
      "org"
    ]
  },
  "application/vnd.lotus-screencam": {
    source: "iana",
    extensions: [
      "scm"
    ]
  },
  "application/vnd.lotus-wordpro": {
    source: "iana",
    extensions: [
      "lwp"
    ]
  },
  "application/vnd.macports.portpkg": {
    source: "iana",
    extensions: [
      "portpkg"
    ]
  },
  "application/vnd.mapbox-vector-tile": {
    source: "iana",
    extensions: [
      "mvt"
    ]
  },
  "application/vnd.marlin.drm.actiontoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.conftoken+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.license+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.marlin.drm.mdcf": {
    source: "iana"
  },
  "application/vnd.mason+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.maxar.archive.3tz+zip": {
    source: "iana",
    compressible: false
  },
  "application/vnd.maxmind.maxmind-db": {
    source: "iana"
  },
  "application/vnd.mcd": {
    source: "iana",
    extensions: [
      "mcd"
    ]
  },
  "application/vnd.medcalcdata": {
    source: "iana",
    extensions: [
      "mc1"
    ]
  },
  "application/vnd.mediastation.cdkey": {
    source: "iana",
    extensions: [
      "cdkey"
    ]
  },
  "application/vnd.meridian-slingshot": {
    source: "iana"
  },
  "application/vnd.mfer": {
    source: "iana",
    extensions: [
      "mwf"
    ]
  },
  "application/vnd.mfmp": {
    source: "iana",
    extensions: [
      "mfm"
    ]
  },
  "application/vnd.micro+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.micrografx.flo": {
    source: "iana",
    extensions: [
      "flo"
    ]
  },
  "application/vnd.micrografx.igx": {
    source: "iana",
    extensions: [
      "igx"
    ]
  },
  "application/vnd.microsoft.portable-executable": {
    source: "iana"
  },
  "application/vnd.microsoft.windows.thumbnail-cache": {
    source: "iana"
  },
  "application/vnd.miele+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.mif": {
    source: "iana",
    extensions: [
      "mif"
    ]
  },
  "application/vnd.minisoft-hp3000-save": {
    source: "iana"
  },
  "application/vnd.mitsubishi.misty-guard.trustweb": {
    source: "iana"
  },
  "application/vnd.mobius.daf": {
    source: "iana",
    extensions: [
      "daf"
    ]
  },
  "application/vnd.mobius.dis": {
    source: "iana",
    extensions: [
      "dis"
    ]
  },
  "application/vnd.mobius.mbk": {
    source: "iana",
    extensions: [
      "mbk"
    ]
  },
  "application/vnd.mobius.mqy": {
    source: "iana",
    extensions: [
      "mqy"
    ]
  },
  "application/vnd.mobius.msl": {
    source: "iana",
    extensions: [
      "msl"
    ]
  },
  "application/vnd.mobius.plc": {
    source: "iana",
    extensions: [
      "plc"
    ]
  },
  "application/vnd.mobius.txf": {
    source: "iana",
    extensions: [
      "txf"
    ]
  },
  "application/vnd.mophun.application": {
    source: "iana",
    extensions: [
      "mpn"
    ]
  },
  "application/vnd.mophun.certificate": {
    source: "iana",
    extensions: [
      "mpc"
    ]
  },
  "application/vnd.motorola.flexsuite": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.adsi": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.fis": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.gotap": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.kmr": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.ttc": {
    source: "iana"
  },
  "application/vnd.motorola.flexsuite.wem": {
    source: "iana"
  },
  "application/vnd.motorola.iprm": {
    source: "iana"
  },
  "application/vnd.mozilla.xul+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xul"
    ]
  },
  "application/vnd.ms-3mfdocument": {
    source: "iana"
  },
  "application/vnd.ms-artgalry": {
    source: "iana",
    extensions: [
      "cil"
    ]
  },
  "application/vnd.ms-asf": {
    source: "iana"
  },
  "application/vnd.ms-cab-compressed": {
    source: "iana",
    extensions: [
      "cab"
    ]
  },
  "application/vnd.ms-color.iccprofile": {
    source: "apache"
  },
  "application/vnd.ms-excel": {
    source: "iana",
    compressible: false,
    extensions: [
      "xls",
      "xlm",
      "xla",
      "xlc",
      "xlt",
      "xlw"
    ]
  },
  "application/vnd.ms-excel.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlam"
    ]
  },
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsb"
    ]
  },
  "application/vnd.ms-excel.sheet.macroenabled.12": {
    source: "iana",
    extensions: [
      "xlsm"
    ]
  },
  "application/vnd.ms-excel.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "xltm"
    ]
  },
  "application/vnd.ms-fontobject": {
    source: "iana",
    compressible: true,
    extensions: [
      "eot"
    ]
  },
  "application/vnd.ms-htmlhelp": {
    source: "iana",
    extensions: [
      "chm"
    ]
  },
  "application/vnd.ms-ims": {
    source: "iana",
    extensions: [
      "ims"
    ]
  },
  "application/vnd.ms-lrm": {
    source: "iana",
    extensions: [
      "lrm"
    ]
  },
  "application/vnd.ms-office.activex+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-officetheme": {
    source: "iana",
    extensions: [
      "thmx"
    ]
  },
  "application/vnd.ms-opentype": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-outlook": {
    compressible: false,
    extensions: [
      "msg"
    ]
  },
  "application/vnd.ms-package.obfuscated-opentype": {
    source: "apache"
  },
  "application/vnd.ms-pki.seccat": {
    source: "apache",
    extensions: [
      "cat"
    ]
  },
  "application/vnd.ms-pki.stl": {
    source: "apache",
    extensions: [
      "stl"
    ]
  },
  "application/vnd.ms-playready.initiator+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-powerpoint": {
    source: "iana",
    compressible: false,
    extensions: [
      "ppt",
      "pps",
      "pot"
    ]
  },
  "application/vnd.ms-powerpoint.addin.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppam"
    ]
  },
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": {
    source: "iana",
    extensions: [
      "pptm"
    ]
  },
  "application/vnd.ms-powerpoint.slide.macroenabled.12": {
    source: "iana",
    extensions: [
      "sldm"
    ]
  },
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
    source: "iana",
    extensions: [
      "ppsm"
    ]
  },
  "application/vnd.ms-powerpoint.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "potm"
    ]
  },
  "application/vnd.ms-printdevicecapabilities+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-printing.printticket+xml": {
    source: "apache",
    compressible: true
  },
  "application/vnd.ms-printschematicket+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ms-project": {
    source: "iana",
    extensions: [
      "mpp",
      "mpt"
    ]
  },
  "application/vnd.ms-tnef": {
    source: "iana"
  },
  "application/vnd.ms-windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.nwprinting.oob": {
    source: "iana"
  },
  "application/vnd.ms-windows.printerpairing": {
    source: "iana"
  },
  "application/vnd.ms-windows.wsd.oob": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.lic-resp": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-chlg-req": {
    source: "iana"
  },
  "application/vnd.ms-wmdrm.meter-resp": {
    source: "iana"
  },
  "application/vnd.ms-word.document.macroenabled.12": {
    source: "iana",
    extensions: [
      "docm"
    ]
  },
  "application/vnd.ms-word.template.macroenabled.12": {
    source: "iana",
    extensions: [
      "dotm"
    ]
  },
  "application/vnd.ms-works": {
    source: "iana",
    extensions: [
      "wps",
      "wks",
      "wcm",
      "wdb"
    ]
  },
  "application/vnd.ms-wpl": {
    source: "iana",
    extensions: [
      "wpl"
    ]
  },
  "application/vnd.ms-xpsdocument": {
    source: "iana",
    compressible: false,
    extensions: [
      "xps"
    ]
  },
  "application/vnd.msa-disk-image": {
    source: "iana"
  },
  "application/vnd.mseq": {
    source: "iana",
    extensions: [
      "mseq"
    ]
  },
  "application/vnd.msign": {
    source: "iana"
  },
  "application/vnd.multiad.creator": {
    source: "iana"
  },
  "application/vnd.multiad.creator.cif": {
    source: "iana"
  },
  "application/vnd.music-niff": {
    source: "iana"
  },
  "application/vnd.musician": {
    source: "iana",
    extensions: [
      "mus"
    ]
  },
  "application/vnd.muvee.style": {
    source: "iana",
    extensions: [
      "msty"
    ]
  },
  "application/vnd.mynfc": {
    source: "iana",
    extensions: [
      "taglet"
    ]
  },
  "application/vnd.nacamar.ybrid+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.ncd.control": {
    source: "iana"
  },
  "application/vnd.ncd.reference": {
    source: "iana"
  },
  "application/vnd.nearst.inv+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nebumind.line": {
    source: "iana"
  },
  "application/vnd.nervana": {
    source: "iana"
  },
  "application/vnd.netfpx": {
    source: "iana"
  },
  "application/vnd.neurolanguage.nlu": {
    source: "iana",
    extensions: [
      "nlu"
    ]
  },
  "application/vnd.nimn": {
    source: "iana"
  },
  "application/vnd.nintendo.nitro.rom": {
    source: "iana"
  },
  "application/vnd.nintendo.snes.rom": {
    source: "iana"
  },
  "application/vnd.nitf": {
    source: "iana",
    extensions: [
      "ntf",
      "nitf"
    ]
  },
  "application/vnd.noblenet-directory": {
    source: "iana",
    extensions: [
      "nnd"
    ]
  },
  "application/vnd.noblenet-sealer": {
    source: "iana",
    extensions: [
      "nns"
    ]
  },
  "application/vnd.noblenet-web": {
    source: "iana",
    extensions: [
      "nnw"
    ]
  },
  "application/vnd.nokia.catalogs": {
    source: "iana"
  },
  "application/vnd.nokia.conml+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.conml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.iptv.config+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.isds-radio-presets": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.landmark+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.landmarkcollection+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.n-gage.ac+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "ac"
    ]
  },
  "application/vnd.nokia.n-gage.data": {
    source: "iana",
    extensions: [
      "ngdat"
    ]
  },
  "application/vnd.nokia.n-gage.symbian.install": {
    source: "iana",
    extensions: [
      "n-gage"
    ]
  },
  "application/vnd.nokia.ncd": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+wbxml": {
    source: "iana"
  },
  "application/vnd.nokia.pcd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.nokia.radio-preset": {
    source: "iana",
    extensions: [
      "rpst"
    ]
  },
  "application/vnd.nokia.radio-presets": {
    source: "iana",
    extensions: [
      "rpss"
    ]
  },
  "application/vnd.novadigm.edm": {
    source: "iana",
    extensions: [
      "edm"
    ]
  },
  "application/vnd.novadigm.edx": {
    source: "iana",
    extensions: [
      "edx"
    ]
  },
  "application/vnd.novadigm.ext": {
    source: "iana",
    extensions: [
      "ext"
    ]
  },
  "application/vnd.ntt-local.content-share": {
    source: "iana"
  },
  "application/vnd.ntt-local.file-transfer": {
    source: "iana"
  },
  "application/vnd.ntt-local.ogw_remote-access": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_remote": {
    source: "iana"
  },
  "application/vnd.ntt-local.sip-ta_tcp_stream": {
    source: "iana"
  },
  "application/vnd.oasis.opendocument.chart": {
    source: "iana",
    extensions: [
      "odc"
    ]
  },
  "application/vnd.oasis.opendocument.chart-template": {
    source: "iana",
    extensions: [
      "otc"
    ]
  },
  "application/vnd.oasis.opendocument.database": {
    source: "iana",
    extensions: [
      "odb"
    ]
  },
  "application/vnd.oasis.opendocument.formula": {
    source: "iana",
    extensions: [
      "odf"
    ]
  },
  "application/vnd.oasis.opendocument.formula-template": {
    source: "iana",
    extensions: [
      "odft"
    ]
  },
  "application/vnd.oasis.opendocument.graphics": {
    source: "iana",
    compressible: false,
    extensions: [
      "odg"
    ]
  },
  "application/vnd.oasis.opendocument.graphics-template": {
    source: "iana",
    extensions: [
      "otg"
    ]
  },
  "application/vnd.oasis.opendocument.image": {
    source: "iana",
    extensions: [
      "odi"
    ]
  },
  "application/vnd.oasis.opendocument.image-template": {
    source: "iana",
    extensions: [
      "oti"
    ]
  },
  "application/vnd.oasis.opendocument.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "odp"
    ]
  },
  "application/vnd.oasis.opendocument.presentation-template": {
    source: "iana",
    extensions: [
      "otp"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "ods"
    ]
  },
  "application/vnd.oasis.opendocument.spreadsheet-template": {
    source: "iana",
    extensions: [
      "ots"
    ]
  },
  "application/vnd.oasis.opendocument.text": {
    source: "iana",
    compressible: false,
    extensions: [
      "odt"
    ]
  },
  "application/vnd.oasis.opendocument.text-master": {
    source: "iana",
    extensions: [
      "odm"
    ]
  },
  "application/vnd.oasis.opendocument.text-template": {
    source: "iana",
    extensions: [
      "ott"
    ]
  },
  "application/vnd.oasis.opendocument.text-web": {
    source: "iana",
    extensions: [
      "oth"
    ]
  },
  "application/vnd.obn": {
    source: "iana"
  },
  "application/vnd.ocf+cbor": {
    source: "iana"
  },
  "application/vnd.oci.image.manifest.v1+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oftn.l10n+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessdownload+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.contentaccessstreaming+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.cspg-hexbinary": {
    source: "iana"
  },
  "application/vnd.oipf.dae.svg+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.dae.xhtml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.mippvcontrolmessage+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.pae.gem": {
    source: "iana"
  },
  "application/vnd.oipf.spdiscovery+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.spdlist+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.ueprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oipf.userprofile+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.olpc-sugar": {
    source: "iana",
    extensions: [
      "xo"
    ]
  },
  "application/vnd.oma-scws-config": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-request": {
    source: "iana"
  },
  "application/vnd.oma-scws-http-response": {
    source: "iana"
  },
  "application/vnd.oma.bcast.associated-procedure-parameter+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.drm-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.imd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.ltkm": {
    source: "iana"
  },
  "application/vnd.oma.bcast.notification+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.provisioningtrigger": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgboot": {
    source: "iana"
  },
  "application/vnd.oma.bcast.sgdd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sgdu": {
    source: "iana"
  },
  "application/vnd.oma.bcast.simple-symbol-container": {
    source: "iana"
  },
  "application/vnd.oma.bcast.smartcard-trigger+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.sprov+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.bcast.stkm": {
    source: "iana"
  },
  "application/vnd.oma.cab-address-book+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-feature-handler+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-pcc+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-subs-invite+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.cab-user-prefs+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.dcd": {
    source: "iana"
  },
  "application/vnd.oma.dcdc": {
    source: "iana"
  },
  "application/vnd.oma.dd2+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dd2"
    ]
  },
  "application/vnd.oma.drm.risd+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.group-usage-list+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+cbor": {
    source: "iana"
  },
  "application/vnd.oma.lwm2m+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.lwm2m+tlv": {
    source: "iana"
  },
  "application/vnd.oma.pal+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.detailed-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.final-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.groups+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.invocation-descriptor+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.poc.optimized-progress-report+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.push": {
    source: "iana"
  },
  "application/vnd.oma.scidm.messages+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oma.xcap-directory+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.omads-email+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-file+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omads-folder+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.omaloc-supl-init": {
    source: "iana"
  },
  "application/vnd.onepager": {
    source: "iana"
  },
  "application/vnd.onepagertamp": {
    source: "iana"
  },
  "application/vnd.onepagertamx": {
    source: "iana"
  },
  "application/vnd.onepagertat": {
    source: "iana"
  },
  "application/vnd.onepagertatp": {
    source: "iana"
  },
  "application/vnd.onepagertatx": {
    source: "iana"
  },
  "application/vnd.openblox.game+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "obgx"
    ]
  },
  "application/vnd.openblox.game-binary": {
    source: "iana"
  },
  "application/vnd.openeye.oeb": {
    source: "iana"
  },
  "application/vnd.openofficeorg.extension": {
    source: "apache",
    extensions: [
      "oxt"
    ]
  },
  "application/vnd.openstreetmap.data+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osm"
    ]
  },
  "application/vnd.opentimestamps.ots": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.custom-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawing+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.extended-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": {
    source: "iana",
    compressible: false,
    extensions: [
      "pptx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide": {
    source: "iana",
    extensions: [
      "sldx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
    source: "iana",
    extensions: [
      "ppsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template": {
    source: "iana",
    extensions: [
      "potx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
    source: "iana",
    compressible: false,
    extensions: [
      "xlsx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
    source: "iana",
    extensions: [
      "xltx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.theme+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.themeoverride+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.vmldrawing": {
    source: "iana"
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
    source: "iana",
    compressible: false,
    extensions: [
      "docx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
    source: "iana",
    extensions: [
      "dotx"
    ]
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.core-properties+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.openxmlformats-package.relationships+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oracle.resource+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.orange.indata": {
    source: "iana"
  },
  "application/vnd.osa.netdeploy": {
    source: "iana"
  },
  "application/vnd.osgeo.mapguide.package": {
    source: "iana",
    extensions: [
      "mgp"
    ]
  },
  "application/vnd.osgi.bundle": {
    source: "iana"
  },
  "application/vnd.osgi.dp": {
    source: "iana",
    extensions: [
      "dp"
    ]
  },
  "application/vnd.osgi.subsystem": {
    source: "iana",
    extensions: [
      "esa"
    ]
  },
  "application/vnd.otps.ct-kip+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.oxli.countgraph": {
    source: "iana"
  },
  "application/vnd.pagerduty+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.palm": {
    source: "iana",
    extensions: [
      "pdb",
      "pqa",
      "oprc"
    ]
  },
  "application/vnd.panoply": {
    source: "iana"
  },
  "application/vnd.paos.xml": {
    source: "iana"
  },
  "application/vnd.patentdive": {
    source: "iana"
  },
  "application/vnd.patientecommsdoc": {
    source: "iana"
  },
  "application/vnd.pawaafile": {
    source: "iana",
    extensions: [
      "paw"
    ]
  },
  "application/vnd.pcos": {
    source: "iana"
  },
  "application/vnd.pg.format": {
    source: "iana",
    extensions: [
      "str"
    ]
  },
  "application/vnd.pg.osasli": {
    source: "iana",
    extensions: [
      "ei6"
    ]
  },
  "application/vnd.piaccess.application-licence": {
    source: "iana"
  },
  "application/vnd.picsel": {
    source: "iana",
    extensions: [
      "efif"
    ]
  },
  "application/vnd.pmi.widget": {
    source: "iana",
    extensions: [
      "wg"
    ]
  },
  "application/vnd.poc.group-advertisement+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.pocketlearn": {
    source: "iana",
    extensions: [
      "plf"
    ]
  },
  "application/vnd.powerbuilder6": {
    source: "iana",
    extensions: [
      "pbd"
    ]
  },
  "application/vnd.powerbuilder6-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder7": {
    source: "iana"
  },
  "application/vnd.powerbuilder7-s": {
    source: "iana"
  },
  "application/vnd.powerbuilder75": {
    source: "iana"
  },
  "application/vnd.powerbuilder75-s": {
    source: "iana"
  },
  "application/vnd.preminet": {
    source: "iana"
  },
  "application/vnd.previewsystems.box": {
    source: "iana",
    extensions: [
      "box"
    ]
  },
  "application/vnd.proteus.magazine": {
    source: "iana",
    extensions: [
      "mgz"
    ]
  },
  "application/vnd.psfs": {
    source: "iana"
  },
  "application/vnd.publishare-delta-tree": {
    source: "iana",
    extensions: [
      "qps"
    ]
  },
  "application/vnd.pvi.ptid1": {
    source: "iana",
    extensions: [
      "ptid"
    ]
  },
  "application/vnd.pwg-multiplexed": {
    source: "iana"
  },
  "application/vnd.pwg-xhtml-print+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.qualcomm.brew-app-res": {
    source: "iana"
  },
  "application/vnd.quarantainenet": {
    source: "iana"
  },
  "application/vnd.quark.quarkxpress": {
    source: "iana",
    extensions: [
      "qxd",
      "qxt",
      "qwd",
      "qwt",
      "qxl",
      "qxb"
    ]
  },
  "application/vnd.quobject-quoxdocument": {
    source: "iana"
  },
  "application/vnd.radisys.moml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-conn+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-audit-stream+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-conf+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-base+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-detect+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-group+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-speech+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.radisys.msml-dialog-transform+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rainstor.data": {
    source: "iana"
  },
  "application/vnd.rapid": {
    source: "iana"
  },
  "application/vnd.rar": {
    source: "iana",
    extensions: [
      "rar"
    ]
  },
  "application/vnd.realvnc.bed": {
    source: "iana",
    extensions: [
      "bed"
    ]
  },
  "application/vnd.recordare.musicxml": {
    source: "iana",
    extensions: [
      "mxl"
    ]
  },
  "application/vnd.recordare.musicxml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "musicxml"
    ]
  },
  "application/vnd.renlearn.rlprint": {
    source: "iana"
  },
  "application/vnd.resilient.logic": {
    source: "iana"
  },
  "application/vnd.restful+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.rig.cryptonote": {
    source: "iana",
    extensions: [
      "cryptonote"
    ]
  },
  "application/vnd.rim.cod": {
    source: "apache",
    extensions: [
      "cod"
    ]
  },
  "application/vnd.rn-realmedia": {
    source: "apache",
    extensions: [
      "rm"
    ]
  },
  "application/vnd.rn-realmedia-vbr": {
    source: "apache",
    extensions: [
      "rmvb"
    ]
  },
  "application/vnd.route66.link66+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "link66"
    ]
  },
  "application/vnd.rs-274x": {
    source: "iana"
  },
  "application/vnd.ruckus.download": {
    source: "iana"
  },
  "application/vnd.s3sms": {
    source: "iana"
  },
  "application/vnd.sailingtracker.track": {
    source: "iana",
    extensions: [
      "st"
    ]
  },
  "application/vnd.sar": {
    source: "iana"
  },
  "application/vnd.sbm.cid": {
    source: "iana"
  },
  "application/vnd.sbm.mid2": {
    source: "iana"
  },
  "application/vnd.scribus": {
    source: "iana"
  },
  "application/vnd.sealed.3df": {
    source: "iana"
  },
  "application/vnd.sealed.csf": {
    source: "iana"
  },
  "application/vnd.sealed.doc": {
    source: "iana"
  },
  "application/vnd.sealed.eml": {
    source: "iana"
  },
  "application/vnd.sealed.mht": {
    source: "iana"
  },
  "application/vnd.sealed.net": {
    source: "iana"
  },
  "application/vnd.sealed.ppt": {
    source: "iana"
  },
  "application/vnd.sealed.tiff": {
    source: "iana"
  },
  "application/vnd.sealed.xls": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.html": {
    source: "iana"
  },
  "application/vnd.sealedmedia.softseal.pdf": {
    source: "iana"
  },
  "application/vnd.seemail": {
    source: "iana",
    extensions: [
      "see"
    ]
  },
  "application/vnd.seis+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.sema": {
    source: "iana",
    extensions: [
      "sema"
    ]
  },
  "application/vnd.semd": {
    source: "iana",
    extensions: [
      "semd"
    ]
  },
  "application/vnd.semf": {
    source: "iana",
    extensions: [
      "semf"
    ]
  },
  "application/vnd.shade-save-file": {
    source: "iana"
  },
  "application/vnd.shana.informed.formdata": {
    source: "iana",
    extensions: [
      "ifm"
    ]
  },
  "application/vnd.shana.informed.formtemplate": {
    source: "iana",
    extensions: [
      "itp"
    ]
  },
  "application/vnd.shana.informed.interchange": {
    source: "iana",
    extensions: [
      "iif"
    ]
  },
  "application/vnd.shana.informed.package": {
    source: "iana",
    extensions: [
      "ipk"
    ]
  },
  "application/vnd.shootproof+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shopkick+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.shp": {
    source: "iana"
  },
  "application/vnd.shx": {
    source: "iana"
  },
  "application/vnd.sigrok.session": {
    source: "iana"
  },
  "application/vnd.simtech-mindmapper": {
    source: "iana",
    extensions: [
      "twd",
      "twds"
    ]
  },
  "application/vnd.siren+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.smaf": {
    source: "iana",
    extensions: [
      "mmf"
    ]
  },
  "application/vnd.smart.notebook": {
    source: "iana"
  },
  "application/vnd.smart.teacher": {
    source: "iana",
    extensions: [
      "teacher"
    ]
  },
  "application/vnd.snesdev-page-table": {
    source: "iana"
  },
  "application/vnd.software602.filler.form+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "fo"
    ]
  },
  "application/vnd.software602.filler.form-xml-zip": {
    source: "iana"
  },
  "application/vnd.solent.sdkm+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "sdkm",
      "sdkd"
    ]
  },
  "application/vnd.spotfire.dxp": {
    source: "iana",
    extensions: [
      "dxp"
    ]
  },
  "application/vnd.spotfire.sfs": {
    source: "iana",
    extensions: [
      "sfs"
    ]
  },
  "application/vnd.sqlite3": {
    source: "iana"
  },
  "application/vnd.sss-cod": {
    source: "iana"
  },
  "application/vnd.sss-dtf": {
    source: "iana"
  },
  "application/vnd.sss-ntf": {
    source: "iana"
  },
  "application/vnd.stardivision.calc": {
    source: "apache",
    extensions: [
      "sdc"
    ]
  },
  "application/vnd.stardivision.draw": {
    source: "apache",
    extensions: [
      "sda"
    ]
  },
  "application/vnd.stardivision.impress": {
    source: "apache",
    extensions: [
      "sdd"
    ]
  },
  "application/vnd.stardivision.math": {
    source: "apache",
    extensions: [
      "smf"
    ]
  },
  "application/vnd.stardivision.writer": {
    source: "apache",
    extensions: [
      "sdw",
      "vor"
    ]
  },
  "application/vnd.stardivision.writer-global": {
    source: "apache",
    extensions: [
      "sgl"
    ]
  },
  "application/vnd.stepmania.package": {
    source: "iana",
    extensions: [
      "smzip"
    ]
  },
  "application/vnd.stepmania.stepchart": {
    source: "iana",
    extensions: [
      "sm"
    ]
  },
  "application/vnd.street-stream": {
    source: "iana"
  },
  "application/vnd.sun.wadl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wadl"
    ]
  },
  "application/vnd.sun.xml.calc": {
    source: "apache",
    extensions: [
      "sxc"
    ]
  },
  "application/vnd.sun.xml.calc.template": {
    source: "apache",
    extensions: [
      "stc"
    ]
  },
  "application/vnd.sun.xml.draw": {
    source: "apache",
    extensions: [
      "sxd"
    ]
  },
  "application/vnd.sun.xml.draw.template": {
    source: "apache",
    extensions: [
      "std"
    ]
  },
  "application/vnd.sun.xml.impress": {
    source: "apache",
    extensions: [
      "sxi"
    ]
  },
  "application/vnd.sun.xml.impress.template": {
    source: "apache",
    extensions: [
      "sti"
    ]
  },
  "application/vnd.sun.xml.math": {
    source: "apache",
    extensions: [
      "sxm"
    ]
  },
  "application/vnd.sun.xml.writer": {
    source: "apache",
    extensions: [
      "sxw"
    ]
  },
  "application/vnd.sun.xml.writer.global": {
    source: "apache",
    extensions: [
      "sxg"
    ]
  },
  "application/vnd.sun.xml.writer.template": {
    source: "apache",
    extensions: [
      "stw"
    ]
  },
  "application/vnd.sus-calendar": {
    source: "iana",
    extensions: [
      "sus",
      "susp"
    ]
  },
  "application/vnd.svd": {
    source: "iana",
    extensions: [
      "svd"
    ]
  },
  "application/vnd.swiftview-ics": {
    source: "iana"
  },
  "application/vnd.sycle+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.syft+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.symbian.install": {
    source: "apache",
    extensions: [
      "sis",
      "sisx"
    ]
  },
  "application/vnd.syncml+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xsm"
    ]
  },
  "application/vnd.syncml.dm+wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "bdm"
    ]
  },
  "application/vnd.syncml.dm+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "xdm"
    ]
  },
  "application/vnd.syncml.dm.notification": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmddf+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "ddf"
    ]
  },
  "application/vnd.syncml.dmtnds+wbxml": {
    source: "iana"
  },
  "application/vnd.syncml.dmtnds+xml": {
    source: "iana",
    charset: "UTF-8",
    compressible: true
  },
  "application/vnd.syncml.ds.notification": {
    source: "iana"
  },
  "application/vnd.tableschema+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tao.intent-module-archive": {
    source: "iana",
    extensions: [
      "tao"
    ]
  },
  "application/vnd.tcpdump.pcap": {
    source: "iana",
    extensions: [
      "pcap",
      "cap",
      "dmp"
    ]
  },
  "application/vnd.think-cell.ppttc+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tmd.mediaflex.api+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.tml": {
    source: "iana"
  },
  "application/vnd.tmobile-livetv": {
    source: "iana",
    extensions: [
      "tmo"
    ]
  },
  "application/vnd.tri.onesource": {
    source: "iana"
  },
  "application/vnd.trid.tpt": {
    source: "iana",
    extensions: [
      "tpt"
    ]
  },
  "application/vnd.triscape.mxs": {
    source: "iana",
    extensions: [
      "mxs"
    ]
  },
  "application/vnd.trueapp": {
    source: "iana",
    extensions: [
      "tra"
    ]
  },
  "application/vnd.truedoc": {
    source: "iana"
  },
  "application/vnd.ubisoft.webplayer": {
    source: "iana"
  },
  "application/vnd.ufdl": {
    source: "iana",
    extensions: [
      "ufd",
      "ufdl"
    ]
  },
  "application/vnd.uiq.theme": {
    source: "iana",
    extensions: [
      "utz"
    ]
  },
  "application/vnd.umajin": {
    source: "iana",
    extensions: [
      "umj"
    ]
  },
  "application/vnd.unity": {
    source: "iana",
    extensions: [
      "unityweb"
    ]
  },
  "application/vnd.uoml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "uoml"
    ]
  },
  "application/vnd.uplanet.alert": {
    source: "iana"
  },
  "application/vnd.uplanet.alert-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice": {
    source: "iana"
  },
  "application/vnd.uplanet.bearer-choice-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop": {
    source: "iana"
  },
  "application/vnd.uplanet.cacheop-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.channel": {
    source: "iana"
  },
  "application/vnd.uplanet.channel-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.list": {
    source: "iana"
  },
  "application/vnd.uplanet.list-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd": {
    source: "iana"
  },
  "application/vnd.uplanet.listcmd-wbxml": {
    source: "iana"
  },
  "application/vnd.uplanet.signal": {
    source: "iana"
  },
  "application/vnd.uri-map": {
    source: "iana"
  },
  "application/vnd.valve.source.material": {
    source: "iana"
  },
  "application/vnd.vcx": {
    source: "iana",
    extensions: [
      "vcx"
    ]
  },
  "application/vnd.vd-study": {
    source: "iana"
  },
  "application/vnd.vectorworks": {
    source: "iana"
  },
  "application/vnd.vel+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.verimatrix.vcas": {
    source: "iana"
  },
  "application/vnd.veritone.aion+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.veryant.thin": {
    source: "iana"
  },
  "application/vnd.ves.encrypted": {
    source: "iana"
  },
  "application/vnd.vidsoft.vidconference": {
    source: "iana"
  },
  "application/vnd.visio": {
    source: "iana",
    extensions: [
      "vsd",
      "vst",
      "vss",
      "vsw"
    ]
  },
  "application/vnd.visionary": {
    source: "iana",
    extensions: [
      "vis"
    ]
  },
  "application/vnd.vividence.scriptfile": {
    source: "iana"
  },
  "application/vnd.vsf": {
    source: "iana",
    extensions: [
      "vsf"
    ]
  },
  "application/vnd.wap.sic": {
    source: "iana"
  },
  "application/vnd.wap.slc": {
    source: "iana"
  },
  "application/vnd.wap.wbxml": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "wbxml"
    ]
  },
  "application/vnd.wap.wmlc": {
    source: "iana",
    extensions: [
      "wmlc"
    ]
  },
  "application/vnd.wap.wmlscriptc": {
    source: "iana",
    extensions: [
      "wmlsc"
    ]
  },
  "application/vnd.webturbo": {
    source: "iana",
    extensions: [
      "wtb"
    ]
  },
  "application/vnd.wfa.dpp": {
    source: "iana"
  },
  "application/vnd.wfa.p2p": {
    source: "iana"
  },
  "application/vnd.wfa.wsc": {
    source: "iana"
  },
  "application/vnd.windows.devicepairing": {
    source: "iana"
  },
  "application/vnd.wmc": {
    source: "iana"
  },
  "application/vnd.wmf.bootstrap": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica": {
    source: "iana"
  },
  "application/vnd.wolfram.mathematica.package": {
    source: "iana"
  },
  "application/vnd.wolfram.player": {
    source: "iana",
    extensions: [
      "nbp"
    ]
  },
  "application/vnd.wordperfect": {
    source: "iana",
    extensions: [
      "wpd"
    ]
  },
  "application/vnd.wqd": {
    source: "iana",
    extensions: [
      "wqd"
    ]
  },
  "application/vnd.wrq-hp3000-labelled": {
    source: "iana"
  },
  "application/vnd.wt.stf": {
    source: "iana",
    extensions: [
      "stf"
    ]
  },
  "application/vnd.wv.csp+wbxml": {
    source: "iana"
  },
  "application/vnd.wv.csp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.wv.ssp+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xacml+json": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xara": {
    source: "iana",
    extensions: [
      "xar"
    ]
  },
  "application/vnd.xfdl": {
    source: "iana",
    extensions: [
      "xfdl"
    ]
  },
  "application/vnd.xfdl.webform": {
    source: "iana"
  },
  "application/vnd.xmi+xml": {
    source: "iana",
    compressible: true
  },
  "application/vnd.xmpie.cpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.dpkg": {
    source: "iana"
  },
  "application/vnd.xmpie.plan": {
    source: "iana"
  },
  "application/vnd.xmpie.ppkg": {
    source: "iana"
  },
  "application/vnd.xmpie.xlim": {
    source: "iana"
  },
  "application/vnd.yamaha.hv-dic": {
    source: "iana",
    extensions: [
      "hvd"
    ]
  },
  "application/vnd.yamaha.hv-script": {
    source: "iana",
    extensions: [
      "hvs"
    ]
  },
  "application/vnd.yamaha.hv-voice": {
    source: "iana",
    extensions: [
      "hvp"
    ]
  },
  "application/vnd.yamaha.openscoreformat": {
    source: "iana",
    extensions: [
      "osf"
    ]
  },
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "osfpvg"
    ]
  },
  "application/vnd.yamaha.remote-setup": {
    source: "iana"
  },
  "application/vnd.yamaha.smaf-audio": {
    source: "iana",
    extensions: [
      "saf"
    ]
  },
  "application/vnd.yamaha.smaf-phrase": {
    source: "iana",
    extensions: [
      "spf"
    ]
  },
  "application/vnd.yamaha.through-ngn": {
    source: "iana"
  },
  "application/vnd.yamaha.tunnel-udpencap": {
    source: "iana"
  },
  "application/vnd.yaoweme": {
    source: "iana"
  },
  "application/vnd.yellowriver-custom-menu": {
    source: "iana",
    extensions: [
      "cmp"
    ]
  },
  "application/vnd.youtube.yt": {
    source: "iana"
  },
  "application/vnd.zul": {
    source: "iana",
    extensions: [
      "zir",
      "zirz"
    ]
  },
  "application/vnd.zzazz.deck+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "zaz"
    ]
  },
  "application/voicexml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "vxml"
    ]
  },
  "application/voucher-cms+json": {
    source: "iana",
    compressible: true
  },
  "application/vq-rtcpxr": {
    source: "iana"
  },
  "application/wasm": {
    source: "iana",
    compressible: true,
    extensions: [
      "wasm"
    ]
  },
  "application/watcherinfo+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wif"
    ]
  },
  "application/webpush-options+json": {
    source: "iana",
    compressible: true
  },
  "application/whoispp-query": {
    source: "iana"
  },
  "application/whoispp-response": {
    source: "iana"
  },
  "application/widget": {
    source: "iana",
    extensions: [
      "wgt"
    ]
  },
  "application/winhlp": {
    source: "apache",
    extensions: [
      "hlp"
    ]
  },
  "application/wita": {
    source: "iana"
  },
  "application/wordperfect5.1": {
    source: "iana"
  },
  "application/wsdl+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wsdl"
    ]
  },
  "application/wspolicy+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "wspolicy"
    ]
  },
  "application/x-7z-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "7z"
    ]
  },
  "application/x-abiword": {
    source: "apache",
    extensions: [
      "abw"
    ]
  },
  "application/x-ace-compressed": {
    source: "apache",
    extensions: [
      "ace"
    ]
  },
  "application/x-amf": {
    source: "apache"
  },
  "application/x-apple-diskimage": {
    source: "apache",
    extensions: [
      "dmg"
    ]
  },
  "application/x-arj": {
    compressible: false,
    extensions: [
      "arj"
    ]
  },
  "application/x-authorware-bin": {
    source: "apache",
    extensions: [
      "aab",
      "x32",
      "u32",
      "vox"
    ]
  },
  "application/x-authorware-map": {
    source: "apache",
    extensions: [
      "aam"
    ]
  },
  "application/x-authorware-seg": {
    source: "apache",
    extensions: [
      "aas"
    ]
  },
  "application/x-bcpio": {
    source: "apache",
    extensions: [
      "bcpio"
    ]
  },
  "application/x-bdoc": {
    compressible: false,
    extensions: [
      "bdoc"
    ]
  },
  "application/x-bittorrent": {
    source: "apache",
    extensions: [
      "torrent"
    ]
  },
  "application/x-blorb": {
    source: "apache",
    extensions: [
      "blb",
      "blorb"
    ]
  },
  "application/x-bzip": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz"
    ]
  },
  "application/x-bzip2": {
    source: "apache",
    compressible: false,
    extensions: [
      "bz2",
      "boz"
    ]
  },
  "application/x-cbr": {
    source: "apache",
    extensions: [
      "cbr",
      "cba",
      "cbt",
      "cbz",
      "cb7"
    ]
  },
  "application/x-cdlink": {
    source: "apache",
    extensions: [
      "vcd"
    ]
  },
  "application/x-cfs-compressed": {
    source: "apache",
    extensions: [
      "cfs"
    ]
  },
  "application/x-chat": {
    source: "apache",
    extensions: [
      "chat"
    ]
  },
  "application/x-chess-pgn": {
    source: "apache",
    extensions: [
      "pgn"
    ]
  },
  "application/x-chrome-extension": {
    extensions: [
      "crx"
    ]
  },
  "application/x-cocoa": {
    source: "nginx",
    extensions: [
      "cco"
    ]
  },
  "application/x-compress": {
    source: "apache"
  },
  "application/x-conference": {
    source: "apache",
    extensions: [
      "nsc"
    ]
  },
  "application/x-cpio": {
    source: "apache",
    extensions: [
      "cpio"
    ]
  },
  "application/x-csh": {
    source: "apache",
    extensions: [
      "csh"
    ]
  },
  "application/x-deb": {
    compressible: false
  },
  "application/x-debian-package": {
    source: "apache",
    extensions: [
      "deb",
      "udeb"
    ]
  },
  "application/x-dgc-compressed": {
    source: "apache",
    extensions: [
      "dgc"
    ]
  },
  "application/x-director": {
    source: "apache",
    extensions: [
      "dir",
      "dcr",
      "dxr",
      "cst",
      "cct",
      "cxt",
      "w3d",
      "fgd",
      "swa"
    ]
  },
  "application/x-doom": {
    source: "apache",
    extensions: [
      "wad"
    ]
  },
  "application/x-dtbncx+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "ncx"
    ]
  },
  "application/x-dtbook+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "dtb"
    ]
  },
  "application/x-dtbresource+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "res"
    ]
  },
  "application/x-dvi": {
    source: "apache",
    compressible: false,
    extensions: [
      "dvi"
    ]
  },
  "application/x-envoy": {
    source: "apache",
    extensions: [
      "evy"
    ]
  },
  "application/x-eva": {
    source: "apache",
    extensions: [
      "eva"
    ]
  },
  "application/x-font-bdf": {
    source: "apache",
    extensions: [
      "bdf"
    ]
  },
  "application/x-font-dos": {
    source: "apache"
  },
  "application/x-font-framemaker": {
    source: "apache"
  },
  "application/x-font-ghostscript": {
    source: "apache",
    extensions: [
      "gsf"
    ]
  },
  "application/x-font-libgrx": {
    source: "apache"
  },
  "application/x-font-linux-psf": {
    source: "apache",
    extensions: [
      "psf"
    ]
  },
  "application/x-font-pcf": {
    source: "apache",
    extensions: [
      "pcf"
    ]
  },
  "application/x-font-snf": {
    source: "apache",
    extensions: [
      "snf"
    ]
  },
  "application/x-font-speedo": {
    source: "apache"
  },
  "application/x-font-sunos-news": {
    source: "apache"
  },
  "application/x-font-type1": {
    source: "apache",
    extensions: [
      "pfa",
      "pfb",
      "pfm",
      "afm"
    ]
  },
  "application/x-font-vfont": {
    source: "apache"
  },
  "application/x-freearc": {
    source: "apache",
    extensions: [
      "arc"
    ]
  },
  "application/x-futuresplash": {
    source: "apache",
    extensions: [
      "spl"
    ]
  },
  "application/x-gca-compressed": {
    source: "apache",
    extensions: [
      "gca"
    ]
  },
  "application/x-glulx": {
    source: "apache",
    extensions: [
      "ulx"
    ]
  },
  "application/x-gnumeric": {
    source: "apache",
    extensions: [
      "gnumeric"
    ]
  },
  "application/x-gramps-xml": {
    source: "apache",
    extensions: [
      "gramps"
    ]
  },
  "application/x-gtar": {
    source: "apache",
    extensions: [
      "gtar"
    ]
  },
  "application/x-gzip": {
    source: "apache"
  },
  "application/x-hdf": {
    source: "apache",
    extensions: [
      "hdf"
    ]
  },
  "application/x-httpd-php": {
    compressible: true,
    extensions: [
      "php"
    ]
  },
  "application/x-install-instructions": {
    source: "apache",
    extensions: [
      "install"
    ]
  },
  "application/x-iso9660-image": {
    source: "apache",
    extensions: [
      "iso"
    ]
  },
  "application/x-iwork-keynote-sffkey": {
    extensions: [
      "key"
    ]
  },
  "application/x-iwork-numbers-sffnumbers": {
    extensions: [
      "numbers"
    ]
  },
  "application/x-iwork-pages-sffpages": {
    extensions: [
      "pages"
    ]
  },
  "application/x-java-archive-diff": {
    source: "nginx",
    extensions: [
      "jardiff"
    ]
  },
  "application/x-java-jnlp-file": {
    source: "apache",
    compressible: false,
    extensions: [
      "jnlp"
    ]
  },
  "application/x-javascript": {
    compressible: true
  },
  "application/x-keepass2": {
    extensions: [
      "kdbx"
    ]
  },
  "application/x-latex": {
    source: "apache",
    compressible: false,
    extensions: [
      "latex"
    ]
  },
  "application/x-lua-bytecode": {
    extensions: [
      "luac"
    ]
  },
  "application/x-lzh-compressed": {
    source: "apache",
    extensions: [
      "lzh",
      "lha"
    ]
  },
  "application/x-makeself": {
    source: "nginx",
    extensions: [
      "run"
    ]
  },
  "application/x-mie": {
    source: "apache",
    extensions: [
      "mie"
    ]
  },
  "application/x-mobipocket-ebook": {
    source: "apache",
    extensions: [
      "prc",
      "mobi"
    ]
  },
  "application/x-mpegurl": {
    compressible: false
  },
  "application/x-ms-application": {
    source: "apache",
    extensions: [
      "application"
    ]
  },
  "application/x-ms-shortcut": {
    source: "apache",
    extensions: [
      "lnk"
    ]
  },
  "application/x-ms-wmd": {
    source: "apache",
    extensions: [
      "wmd"
    ]
  },
  "application/x-ms-wmz": {
    source: "apache",
    extensions: [
      "wmz"
    ]
  },
  "application/x-ms-xbap": {
    source: "apache",
    extensions: [
      "xbap"
    ]
  },
  "application/x-msaccess": {
    source: "apache",
    extensions: [
      "mdb"
    ]
  },
  "application/x-msbinder": {
    source: "apache",
    extensions: [
      "obd"
    ]
  },
  "application/x-mscardfile": {
    source: "apache",
    extensions: [
      "crd"
    ]
  },
  "application/x-msclip": {
    source: "apache",
    extensions: [
      "clp"
    ]
  },
  "application/x-msdos-program": {
    extensions: [
      "exe"
    ]
  },
  "application/x-msdownload": {
    source: "apache",
    extensions: [
      "exe",
      "dll",
      "com",
      "bat",
      "msi"
    ]
  },
  "application/x-msmediaview": {
    source: "apache",
    extensions: [
      "mvb",
      "m13",
      "m14"
    ]
  },
  "application/x-msmetafile": {
    source: "apache",
    extensions: [
      "wmf",
      "wmz",
      "emf",
      "emz"
    ]
  },
  "application/x-msmoney": {
    source: "apache",
    extensions: [
      "mny"
    ]
  },
  "application/x-mspublisher": {
    source: "apache",
    extensions: [
      "pub"
    ]
  },
  "application/x-msschedule": {
    source: "apache",
    extensions: [
      "scd"
    ]
  },
  "application/x-msterminal": {
    source: "apache",
    extensions: [
      "trm"
    ]
  },
  "application/x-mswrite": {
    source: "apache",
    extensions: [
      "wri"
    ]
  },
  "application/x-netcdf": {
    source: "apache",
    extensions: [
      "nc",
      "cdf"
    ]
  },
  "application/x-ns-proxy-autoconfig": {
    compressible: true,
    extensions: [
      "pac"
    ]
  },
  "application/x-nzb": {
    source: "apache",
    extensions: [
      "nzb"
    ]
  },
  "application/x-perl": {
    source: "nginx",
    extensions: [
      "pl",
      "pm"
    ]
  },
  "application/x-pilot": {
    source: "nginx",
    extensions: [
      "prc",
      "pdb"
    ]
  },
  "application/x-pkcs12": {
    source: "apache",
    compressible: false,
    extensions: [
      "p12",
      "pfx"
    ]
  },
  "application/x-pkcs7-certificates": {
    source: "apache",
    extensions: [
      "p7b",
      "spc"
    ]
  },
  "application/x-pkcs7-certreqresp": {
    source: "apache",
    extensions: [
      "p7r"
    ]
  },
  "application/x-pki-message": {
    source: "iana"
  },
  "application/x-rar-compressed": {
    source: "apache",
    compressible: false,
    extensions: [
      "rar"
    ]
  },
  "application/x-redhat-package-manager": {
    source: "nginx",
    extensions: [
      "rpm"
    ]
  },
  "application/x-research-info-systems": {
    source: "apache",
    extensions: [
      "ris"
    ]
  },
  "application/x-sea": {
    source: "nginx",
    extensions: [
      "sea"
    ]
  },
  "application/x-sh": {
    source: "apache",
    compressible: true,
    extensions: [
      "sh"
    ]
  },
  "application/x-shar": {
    source: "apache",
    extensions: [
      "shar"
    ]
  },
  "application/x-shockwave-flash": {
    source: "apache",
    compressible: false,
    extensions: [
      "swf"
    ]
  },
  "application/x-silverlight-app": {
    source: "apache",
    extensions: [
      "xap"
    ]
  },
  "application/x-sql": {
    source: "apache",
    extensions: [
      "sql"
    ]
  },
  "application/x-stuffit": {
    source: "apache",
    compressible: false,
    extensions: [
      "sit"
    ]
  },
  "application/x-stuffitx": {
    source: "apache",
    extensions: [
      "sitx"
    ]
  },
  "application/x-subrip": {
    source: "apache",
    extensions: [
      "srt"
    ]
  },
  "application/x-sv4cpio": {
    source: "apache",
    extensions: [
      "sv4cpio"
    ]
  },
  "application/x-sv4crc": {
    source: "apache",
    extensions: [
      "sv4crc"
    ]
  },
  "application/x-t3vm-image": {
    source: "apache",
    extensions: [
      "t3"
    ]
  },
  "application/x-tads": {
    source: "apache",
    extensions: [
      "gam"
    ]
  },
  "application/x-tar": {
    source: "apache",
    compressible: true,
    extensions: [
      "tar"
    ]
  },
  "application/x-tcl": {
    source: "apache",
    extensions: [
      "tcl",
      "tk"
    ]
  },
  "application/x-tex": {
    source: "apache",
    extensions: [
      "tex"
    ]
  },
  "application/x-tex-tfm": {
    source: "apache",
    extensions: [
      "tfm"
    ]
  },
  "application/x-texinfo": {
    source: "apache",
    extensions: [
      "texinfo",
      "texi"
    ]
  },
  "application/x-tgif": {
    source: "apache",
    extensions: [
      "obj"
    ]
  },
  "application/x-ustar": {
    source: "apache",
    extensions: [
      "ustar"
    ]
  },
  "application/x-virtualbox-hdd": {
    compressible: true,
    extensions: [
      "hdd"
    ]
  },
  "application/x-virtualbox-ova": {
    compressible: true,
    extensions: [
      "ova"
    ]
  },
  "application/x-virtualbox-ovf": {
    compressible: true,
    extensions: [
      "ovf"
    ]
  },
  "application/x-virtualbox-vbox": {
    compressible: true,
    extensions: [
      "vbox"
    ]
  },
  "application/x-virtualbox-vbox-extpack": {
    compressible: false,
    extensions: [
      "vbox-extpack"
    ]
  },
  "application/x-virtualbox-vdi": {
    compressible: true,
    extensions: [
      "vdi"
    ]
  },
  "application/x-virtualbox-vhd": {
    compressible: true,
    extensions: [
      "vhd"
    ]
  },
  "application/x-virtualbox-vmdk": {
    compressible: true,
    extensions: [
      "vmdk"
    ]
  },
  "application/x-wais-source": {
    source: "apache",
    extensions: [
      "src"
    ]
  },
  "application/x-web-app-manifest+json": {
    compressible: true,
    extensions: [
      "webapp"
    ]
  },
  "application/x-www-form-urlencoded": {
    source: "iana",
    compressible: true
  },
  "application/x-x509-ca-cert": {
    source: "iana",
    extensions: [
      "der",
      "crt",
      "pem"
    ]
  },
  "application/x-x509-ca-ra-cert": {
    source: "iana"
  },
  "application/x-x509-next-ca-cert": {
    source: "iana"
  },
  "application/x-xfig": {
    source: "apache",
    extensions: [
      "fig"
    ]
  },
  "application/x-xliff+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/x-xpinstall": {
    source: "apache",
    compressible: false,
    extensions: [
      "xpi"
    ]
  },
  "application/x-xz": {
    source: "apache",
    extensions: [
      "xz"
    ]
  },
  "application/x-zmachine": {
    source: "apache",
    extensions: [
      "z1",
      "z2",
      "z3",
      "z4",
      "z5",
      "z6",
      "z7",
      "z8"
    ]
  },
  "application/x400-bp": {
    source: "iana"
  },
  "application/xacml+xml": {
    source: "iana",
    compressible: true
  },
  "application/xaml+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xaml"
    ]
  },
  "application/xcap-att+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xav"
    ]
  },
  "application/xcap-caps+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xca"
    ]
  },
  "application/xcap-diff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xdf"
    ]
  },
  "application/xcap-el+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xel"
    ]
  },
  "application/xcap-error+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcap-ns+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xns"
    ]
  },
  "application/xcon-conference-info+xml": {
    source: "iana",
    compressible: true
  },
  "application/xcon-conference-info-diff+xml": {
    source: "iana",
    compressible: true
  },
  "application/xenc+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xenc"
    ]
  },
  "application/xhtml+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xhtml",
      "xht"
    ]
  },
  "application/xhtml-voice+xml": {
    source: "apache",
    compressible: true
  },
  "application/xliff+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xlf"
    ]
  },
  "application/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml",
      "xsl",
      "xsd",
      "rng"
    ]
  },
  "application/xml-dtd": {
    source: "iana",
    compressible: true,
    extensions: [
      "dtd"
    ]
  },
  "application/xml-external-parsed-entity": {
    source: "iana"
  },
  "application/xml-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/xmpp+xml": {
    source: "iana",
    compressible: true
  },
  "application/xop+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xop"
    ]
  },
  "application/xproc+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xpl"
    ]
  },
  "application/xslt+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xsl",
      "xslt"
    ]
  },
  "application/xspf+xml": {
    source: "apache",
    compressible: true,
    extensions: [
      "xspf"
    ]
  },
  "application/xv+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "mxml",
      "xhvml",
      "xvml",
      "xvm"
    ]
  },
  "application/yang": {
    source: "iana",
    extensions: [
      "yang"
    ]
  },
  "application/yang-data+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-data+xml": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+json": {
    source: "iana",
    compressible: true
  },
  "application/yang-patch+xml": {
    source: "iana",
    compressible: true
  },
  "application/yin+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "yin"
    ]
  },
  "application/zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "zip"
    ]
  },
  "application/zlib": {
    source: "iana"
  },
  "application/zstd": {
    source: "iana"
  },
  "audio/1d-interleaved-parityfec": {
    source: "iana"
  },
  "audio/32kadpcm": {
    source: "iana"
  },
  "audio/3gpp": {
    source: "iana",
    compressible: false,
    extensions: [
      "3gpp"
    ]
  },
  "audio/3gpp2": {
    source: "iana"
  },
  "audio/aac": {
    source: "iana"
  },
  "audio/ac3": {
    source: "iana"
  },
  "audio/adpcm": {
    source: "apache",
    extensions: [
      "adp"
    ]
  },
  "audio/amr": {
    source: "iana",
    extensions: [
      "amr"
    ]
  },
  "audio/amr-wb": {
    source: "iana"
  },
  "audio/amr-wb+": {
    source: "iana"
  },
  "audio/aptx": {
    source: "iana"
  },
  "audio/asc": {
    source: "iana"
  },
  "audio/atrac-advanced-lossless": {
    source: "iana"
  },
  "audio/atrac-x": {
    source: "iana"
  },
  "audio/atrac3": {
    source: "iana"
  },
  "audio/basic": {
    source: "iana",
    compressible: false,
    extensions: [
      "au",
      "snd"
    ]
  },
  "audio/bv16": {
    source: "iana"
  },
  "audio/bv32": {
    source: "iana"
  },
  "audio/clearmode": {
    source: "iana"
  },
  "audio/cn": {
    source: "iana"
  },
  "audio/dat12": {
    source: "iana"
  },
  "audio/dls": {
    source: "iana"
  },
  "audio/dsr-es201108": {
    source: "iana"
  },
  "audio/dsr-es202050": {
    source: "iana"
  },
  "audio/dsr-es202211": {
    source: "iana"
  },
  "audio/dsr-es202212": {
    source: "iana"
  },
  "audio/dv": {
    source: "iana"
  },
  "audio/dvi4": {
    source: "iana"
  },
  "audio/eac3": {
    source: "iana"
  },
  "audio/encaprtp": {
    source: "iana"
  },
  "audio/evrc": {
    source: "iana"
  },
  "audio/evrc-qcp": {
    source: "iana"
  },
  "audio/evrc0": {
    source: "iana"
  },
  "audio/evrc1": {
    source: "iana"
  },
  "audio/evrcb": {
    source: "iana"
  },
  "audio/evrcb0": {
    source: "iana"
  },
  "audio/evrcb1": {
    source: "iana"
  },
  "audio/evrcnw": {
    source: "iana"
  },
  "audio/evrcnw0": {
    source: "iana"
  },
  "audio/evrcnw1": {
    source: "iana"
  },
  "audio/evrcwb": {
    source: "iana"
  },
  "audio/evrcwb0": {
    source: "iana"
  },
  "audio/evrcwb1": {
    source: "iana"
  },
  "audio/evs": {
    source: "iana"
  },
  "audio/flexfec": {
    source: "iana"
  },
  "audio/fwdred": {
    source: "iana"
  },
  "audio/g711-0": {
    source: "iana"
  },
  "audio/g719": {
    source: "iana"
  },
  "audio/g722": {
    source: "iana"
  },
  "audio/g7221": {
    source: "iana"
  },
  "audio/g723": {
    source: "iana"
  },
  "audio/g726-16": {
    source: "iana"
  },
  "audio/g726-24": {
    source: "iana"
  },
  "audio/g726-32": {
    source: "iana"
  },
  "audio/g726-40": {
    source: "iana"
  },
  "audio/g728": {
    source: "iana"
  },
  "audio/g729": {
    source: "iana"
  },
  "audio/g7291": {
    source: "iana"
  },
  "audio/g729d": {
    source: "iana"
  },
  "audio/g729e": {
    source: "iana"
  },
  "audio/gsm": {
    source: "iana"
  },
  "audio/gsm-efr": {
    source: "iana"
  },
  "audio/gsm-hr-08": {
    source: "iana"
  },
  "audio/ilbc": {
    source: "iana"
  },
  "audio/ip-mr_v2.5": {
    source: "iana"
  },
  "audio/isac": {
    source: "apache"
  },
  "audio/l16": {
    source: "iana"
  },
  "audio/l20": {
    source: "iana"
  },
  "audio/l24": {
    source: "iana",
    compressible: false
  },
  "audio/l8": {
    source: "iana"
  },
  "audio/lpc": {
    source: "iana"
  },
  "audio/melp": {
    source: "iana"
  },
  "audio/melp1200": {
    source: "iana"
  },
  "audio/melp2400": {
    source: "iana"
  },
  "audio/melp600": {
    source: "iana"
  },
  "audio/mhas": {
    source: "iana"
  },
  "audio/midi": {
    source: "apache",
    extensions: [
      "mid",
      "midi",
      "kar",
      "rmi"
    ]
  },
  "audio/mobile-xmf": {
    source: "iana",
    extensions: [
      "mxmf"
    ]
  },
  "audio/mp3": {
    compressible: false,
    extensions: [
      "mp3"
    ]
  },
  "audio/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "m4a",
      "mp4a"
    ]
  },
  "audio/mp4a-latm": {
    source: "iana"
  },
  "audio/mpa": {
    source: "iana"
  },
  "audio/mpa-robust": {
    source: "iana"
  },
  "audio/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpga",
      "mp2",
      "mp2a",
      "mp3",
      "m2a",
      "m3a"
    ]
  },
  "audio/mpeg4-generic": {
    source: "iana"
  },
  "audio/musepack": {
    source: "apache"
  },
  "audio/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "oga",
      "ogg",
      "spx",
      "opus"
    ]
  },
  "audio/opus": {
    source: "iana"
  },
  "audio/parityfec": {
    source: "iana"
  },
  "audio/pcma": {
    source: "iana"
  },
  "audio/pcma-wb": {
    source: "iana"
  },
  "audio/pcmu": {
    source: "iana"
  },
  "audio/pcmu-wb": {
    source: "iana"
  },
  "audio/prs.sid": {
    source: "iana"
  },
  "audio/qcelp": {
    source: "iana"
  },
  "audio/raptorfec": {
    source: "iana"
  },
  "audio/red": {
    source: "iana"
  },
  "audio/rtp-enc-aescm128": {
    source: "iana"
  },
  "audio/rtp-midi": {
    source: "iana"
  },
  "audio/rtploopback": {
    source: "iana"
  },
  "audio/rtx": {
    source: "iana"
  },
  "audio/s3m": {
    source: "apache",
    extensions: [
      "s3m"
    ]
  },
  "audio/scip": {
    source: "iana"
  },
  "audio/silk": {
    source: "apache",
    extensions: [
      "sil"
    ]
  },
  "audio/smv": {
    source: "iana"
  },
  "audio/smv-qcp": {
    source: "iana"
  },
  "audio/smv0": {
    source: "iana"
  },
  "audio/sofa": {
    source: "iana"
  },
  "audio/sp-midi": {
    source: "iana"
  },
  "audio/speex": {
    source: "iana"
  },
  "audio/t140c": {
    source: "iana"
  },
  "audio/t38": {
    source: "iana"
  },
  "audio/telephone-event": {
    source: "iana"
  },
  "audio/tetra_acelp": {
    source: "iana"
  },
  "audio/tetra_acelp_bb": {
    source: "iana"
  },
  "audio/tone": {
    source: "iana"
  },
  "audio/tsvcis": {
    source: "iana"
  },
  "audio/uemclip": {
    source: "iana"
  },
  "audio/ulpfec": {
    source: "iana"
  },
  "audio/usac": {
    source: "iana"
  },
  "audio/vdvi": {
    source: "iana"
  },
  "audio/vmr-wb": {
    source: "iana"
  },
  "audio/vnd.3gpp.iufp": {
    source: "iana"
  },
  "audio/vnd.4sb": {
    source: "iana"
  },
  "audio/vnd.audiokoz": {
    source: "iana"
  },
  "audio/vnd.celp": {
    source: "iana"
  },
  "audio/vnd.cisco.nse": {
    source: "iana"
  },
  "audio/vnd.cmles.radio-events": {
    source: "iana"
  },
  "audio/vnd.cns.anp1": {
    source: "iana"
  },
  "audio/vnd.cns.inf1": {
    source: "iana"
  },
  "audio/vnd.dece.audio": {
    source: "iana",
    extensions: [
      "uva",
      "uvva"
    ]
  },
  "audio/vnd.digital-winds": {
    source: "iana",
    extensions: [
      "eol"
    ]
  },
  "audio/vnd.dlna.adts": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.1": {
    source: "iana"
  },
  "audio/vnd.dolby.heaac.2": {
    source: "iana"
  },
  "audio/vnd.dolby.mlp": {
    source: "iana"
  },
  "audio/vnd.dolby.mps": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2x": {
    source: "iana"
  },
  "audio/vnd.dolby.pl2z": {
    source: "iana"
  },
  "audio/vnd.dolby.pulse.1": {
    source: "iana"
  },
  "audio/vnd.dra": {
    source: "iana",
    extensions: [
      "dra"
    ]
  },
  "audio/vnd.dts": {
    source: "iana",
    extensions: [
      "dts"
    ]
  },
  "audio/vnd.dts.hd": {
    source: "iana",
    extensions: [
      "dtshd"
    ]
  },
  "audio/vnd.dts.uhd": {
    source: "iana"
  },
  "audio/vnd.dvb.file": {
    source: "iana"
  },
  "audio/vnd.everad.plj": {
    source: "iana"
  },
  "audio/vnd.hns.audio": {
    source: "iana"
  },
  "audio/vnd.lucent.voice": {
    source: "iana",
    extensions: [
      "lvp"
    ]
  },
  "audio/vnd.ms-playready.media.pya": {
    source: "iana",
    extensions: [
      "pya"
    ]
  },
  "audio/vnd.nokia.mobile-xmf": {
    source: "iana"
  },
  "audio/vnd.nortel.vbk": {
    source: "iana"
  },
  "audio/vnd.nuera.ecelp4800": {
    source: "iana",
    extensions: [
      "ecelp4800"
    ]
  },
  "audio/vnd.nuera.ecelp7470": {
    source: "iana",
    extensions: [
      "ecelp7470"
    ]
  },
  "audio/vnd.nuera.ecelp9600": {
    source: "iana",
    extensions: [
      "ecelp9600"
    ]
  },
  "audio/vnd.octel.sbc": {
    source: "iana"
  },
  "audio/vnd.presonus.multitrack": {
    source: "iana"
  },
  "audio/vnd.qcelp": {
    source: "iana"
  },
  "audio/vnd.rhetorex.32kadpcm": {
    source: "iana"
  },
  "audio/vnd.rip": {
    source: "iana",
    extensions: [
      "rip"
    ]
  },
  "audio/vnd.rn-realaudio": {
    compressible: false
  },
  "audio/vnd.sealedmedia.softseal.mpeg": {
    source: "iana"
  },
  "audio/vnd.vmx.cvsd": {
    source: "iana"
  },
  "audio/vnd.wave": {
    compressible: false
  },
  "audio/vorbis": {
    source: "iana",
    compressible: false
  },
  "audio/vorbis-config": {
    source: "iana"
  },
  "audio/wav": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/wave": {
    compressible: false,
    extensions: [
      "wav"
    ]
  },
  "audio/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "weba"
    ]
  },
  "audio/x-aac": {
    source: "apache",
    compressible: false,
    extensions: [
      "aac"
    ]
  },
  "audio/x-aiff": {
    source: "apache",
    extensions: [
      "aif",
      "aiff",
      "aifc"
    ]
  },
  "audio/x-caf": {
    source: "apache",
    compressible: false,
    extensions: [
      "caf"
    ]
  },
  "audio/x-flac": {
    source: "apache",
    extensions: [
      "flac"
    ]
  },
  "audio/x-m4a": {
    source: "nginx",
    extensions: [
      "m4a"
    ]
  },
  "audio/x-matroska": {
    source: "apache",
    extensions: [
      "mka"
    ]
  },
  "audio/x-mpegurl": {
    source: "apache",
    extensions: [
      "m3u"
    ]
  },
  "audio/x-ms-wax": {
    source: "apache",
    extensions: [
      "wax"
    ]
  },
  "audio/x-ms-wma": {
    source: "apache",
    extensions: [
      "wma"
    ]
  },
  "audio/x-pn-realaudio": {
    source: "apache",
    extensions: [
      "ram",
      "ra"
    ]
  },
  "audio/x-pn-realaudio-plugin": {
    source: "apache",
    extensions: [
      "rmp"
    ]
  },
  "audio/x-realaudio": {
    source: "nginx",
    extensions: [
      "ra"
    ]
  },
  "audio/x-tta": {
    source: "apache"
  },
  "audio/x-wav": {
    source: "apache",
    extensions: [
      "wav"
    ]
  },
  "audio/xm": {
    source: "apache",
    extensions: [
      "xm"
    ]
  },
  "chemical/x-cdx": {
    source: "apache",
    extensions: [
      "cdx"
    ]
  },
  "chemical/x-cif": {
    source: "apache",
    extensions: [
      "cif"
    ]
  },
  "chemical/x-cmdf": {
    source: "apache",
    extensions: [
      "cmdf"
    ]
  },
  "chemical/x-cml": {
    source: "apache",
    extensions: [
      "cml"
    ]
  },
  "chemical/x-csml": {
    source: "apache",
    extensions: [
      "csml"
    ]
  },
  "chemical/x-pdb": {
    source: "apache"
  },
  "chemical/x-xyz": {
    source: "apache",
    extensions: [
      "xyz"
    ]
  },
  "font/collection": {
    source: "iana",
    extensions: [
      "ttc"
    ]
  },
  "font/otf": {
    source: "iana",
    compressible: true,
    extensions: [
      "otf"
    ]
  },
  "font/sfnt": {
    source: "iana"
  },
  "font/ttf": {
    source: "iana",
    compressible: true,
    extensions: [
      "ttf"
    ]
  },
  "font/woff": {
    source: "iana",
    extensions: [
      "woff"
    ]
  },
  "font/woff2": {
    source: "iana",
    extensions: [
      "woff2"
    ]
  },
  "image/aces": {
    source: "iana",
    extensions: [
      "exr"
    ]
  },
  "image/apng": {
    compressible: false,
    extensions: [
      "apng"
    ]
  },
  "image/avci": {
    source: "iana",
    extensions: [
      "avci"
    ]
  },
  "image/avcs": {
    source: "iana",
    extensions: [
      "avcs"
    ]
  },
  "image/avif": {
    source: "iana",
    compressible: false,
    extensions: [
      "avif"
    ]
  },
  "image/bmp": {
    source: "iana",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/cgm": {
    source: "iana",
    extensions: [
      "cgm"
    ]
  },
  "image/dicom-rle": {
    source: "iana",
    extensions: [
      "drle"
    ]
  },
  "image/emf": {
    source: "iana",
    extensions: [
      "emf"
    ]
  },
  "image/fits": {
    source: "iana",
    extensions: [
      "fits"
    ]
  },
  "image/g3fax": {
    source: "iana",
    extensions: [
      "g3"
    ]
  },
  "image/gif": {
    source: "iana",
    compressible: false,
    extensions: [
      "gif"
    ]
  },
  "image/heic": {
    source: "iana",
    extensions: [
      "heic"
    ]
  },
  "image/heic-sequence": {
    source: "iana",
    extensions: [
      "heics"
    ]
  },
  "image/heif": {
    source: "iana",
    extensions: [
      "heif"
    ]
  },
  "image/heif-sequence": {
    source: "iana",
    extensions: [
      "heifs"
    ]
  },
  "image/hej2k": {
    source: "iana",
    extensions: [
      "hej2"
    ]
  },
  "image/hsj2": {
    source: "iana",
    extensions: [
      "hsj2"
    ]
  },
  "image/ief": {
    source: "iana",
    extensions: [
      "ief"
    ]
  },
  "image/jls": {
    source: "iana",
    extensions: [
      "jls"
    ]
  },
  "image/jp2": {
    source: "iana",
    compressible: false,
    extensions: [
      "jp2",
      "jpg2"
    ]
  },
  "image/jpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpeg",
      "jpg",
      "jpe"
    ]
  },
  "image/jph": {
    source: "iana",
    extensions: [
      "jph"
    ]
  },
  "image/jphc": {
    source: "iana",
    extensions: [
      "jhc"
    ]
  },
  "image/jpm": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpm"
    ]
  },
  "image/jpx": {
    source: "iana",
    compressible: false,
    extensions: [
      "jpx",
      "jpf"
    ]
  },
  "image/jxr": {
    source: "iana",
    extensions: [
      "jxr"
    ]
  },
  "image/jxra": {
    source: "iana",
    extensions: [
      "jxra"
    ]
  },
  "image/jxrs": {
    source: "iana",
    extensions: [
      "jxrs"
    ]
  },
  "image/jxs": {
    source: "iana",
    extensions: [
      "jxs"
    ]
  },
  "image/jxsc": {
    source: "iana",
    extensions: [
      "jxsc"
    ]
  },
  "image/jxsi": {
    source: "iana",
    extensions: [
      "jxsi"
    ]
  },
  "image/jxss": {
    source: "iana",
    extensions: [
      "jxss"
    ]
  },
  "image/ktx": {
    source: "iana",
    extensions: [
      "ktx"
    ]
  },
  "image/ktx2": {
    source: "iana",
    extensions: [
      "ktx2"
    ]
  },
  "image/naplps": {
    source: "iana"
  },
  "image/pjpeg": {
    compressible: false
  },
  "image/png": {
    source: "iana",
    compressible: false,
    extensions: [
      "png"
    ]
  },
  "image/prs.btif": {
    source: "iana",
    extensions: [
      "btif"
    ]
  },
  "image/prs.pti": {
    source: "iana",
    extensions: [
      "pti"
    ]
  },
  "image/pwg-raster": {
    source: "iana"
  },
  "image/sgi": {
    source: "apache",
    extensions: [
      "sgi"
    ]
  },
  "image/svg+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "svg",
      "svgz"
    ]
  },
  "image/t38": {
    source: "iana",
    extensions: [
      "t38"
    ]
  },
  "image/tiff": {
    source: "iana",
    compressible: false,
    extensions: [
      "tif",
      "tiff"
    ]
  },
  "image/tiff-fx": {
    source: "iana",
    extensions: [
      "tfx"
    ]
  },
  "image/vnd.adobe.photoshop": {
    source: "iana",
    compressible: true,
    extensions: [
      "psd"
    ]
  },
  "image/vnd.airzip.accelerator.azv": {
    source: "iana",
    extensions: [
      "azv"
    ]
  },
  "image/vnd.cns.inf2": {
    source: "iana"
  },
  "image/vnd.dece.graphic": {
    source: "iana",
    extensions: [
      "uvi",
      "uvvi",
      "uvg",
      "uvvg"
    ]
  },
  "image/vnd.djvu": {
    source: "iana",
    extensions: [
      "djvu",
      "djv"
    ]
  },
  "image/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "image/vnd.dwg": {
    source: "iana",
    extensions: [
      "dwg"
    ]
  },
  "image/vnd.dxf": {
    source: "iana",
    extensions: [
      "dxf"
    ]
  },
  "image/vnd.fastbidsheet": {
    source: "iana",
    extensions: [
      "fbs"
    ]
  },
  "image/vnd.fpx": {
    source: "iana",
    extensions: [
      "fpx"
    ]
  },
  "image/vnd.fst": {
    source: "iana",
    extensions: [
      "fst"
    ]
  },
  "image/vnd.fujixerox.edmics-mmr": {
    source: "iana",
    extensions: [
      "mmr"
    ]
  },
  "image/vnd.fujixerox.edmics-rlc": {
    source: "iana",
    extensions: [
      "rlc"
    ]
  },
  "image/vnd.globalgraphics.pgb": {
    source: "iana"
  },
  "image/vnd.microsoft.icon": {
    source: "iana",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/vnd.mix": {
    source: "iana"
  },
  "image/vnd.mozilla.apng": {
    source: "iana"
  },
  "image/vnd.ms-dds": {
    compressible: true,
    extensions: [
      "dds"
    ]
  },
  "image/vnd.ms-modi": {
    source: "iana",
    extensions: [
      "mdi"
    ]
  },
  "image/vnd.ms-photo": {
    source: "apache",
    extensions: [
      "wdp"
    ]
  },
  "image/vnd.net-fpx": {
    source: "iana",
    extensions: [
      "npx"
    ]
  },
  "image/vnd.pco.b16": {
    source: "iana",
    extensions: [
      "b16"
    ]
  },
  "image/vnd.radiance": {
    source: "iana"
  },
  "image/vnd.sealed.png": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.gif": {
    source: "iana"
  },
  "image/vnd.sealedmedia.softseal.jpg": {
    source: "iana"
  },
  "image/vnd.svf": {
    source: "iana"
  },
  "image/vnd.tencent.tap": {
    source: "iana",
    extensions: [
      "tap"
    ]
  },
  "image/vnd.valve.source.texture": {
    source: "iana",
    extensions: [
      "vtf"
    ]
  },
  "image/vnd.wap.wbmp": {
    source: "iana",
    extensions: [
      "wbmp"
    ]
  },
  "image/vnd.xiff": {
    source: "iana",
    extensions: [
      "xif"
    ]
  },
  "image/vnd.zbrush.pcx": {
    source: "iana",
    extensions: [
      "pcx"
    ]
  },
  "image/webp": {
    source: "apache",
    extensions: [
      "webp"
    ]
  },
  "image/wmf": {
    source: "iana",
    extensions: [
      "wmf"
    ]
  },
  "image/x-3ds": {
    source: "apache",
    extensions: [
      "3ds"
    ]
  },
  "image/x-cmu-raster": {
    source: "apache",
    extensions: [
      "ras"
    ]
  },
  "image/x-cmx": {
    source: "apache",
    extensions: [
      "cmx"
    ]
  },
  "image/x-freehand": {
    source: "apache",
    extensions: [
      "fh",
      "fhc",
      "fh4",
      "fh5",
      "fh7"
    ]
  },
  "image/x-icon": {
    source: "apache",
    compressible: true,
    extensions: [
      "ico"
    ]
  },
  "image/x-jng": {
    source: "nginx",
    extensions: [
      "jng"
    ]
  },
  "image/x-mrsid-image": {
    source: "apache",
    extensions: [
      "sid"
    ]
  },
  "image/x-ms-bmp": {
    source: "nginx",
    compressible: true,
    extensions: [
      "bmp"
    ]
  },
  "image/x-pcx": {
    source: "apache",
    extensions: [
      "pcx"
    ]
  },
  "image/x-pict": {
    source: "apache",
    extensions: [
      "pic",
      "pct"
    ]
  },
  "image/x-portable-anymap": {
    source: "apache",
    extensions: [
      "pnm"
    ]
  },
  "image/x-portable-bitmap": {
    source: "apache",
    extensions: [
      "pbm"
    ]
  },
  "image/x-portable-graymap": {
    source: "apache",
    extensions: [
      "pgm"
    ]
  },
  "image/x-portable-pixmap": {
    source: "apache",
    extensions: [
      "ppm"
    ]
  },
  "image/x-rgb": {
    source: "apache",
    extensions: [
      "rgb"
    ]
  },
  "image/x-tga": {
    source: "apache",
    extensions: [
      "tga"
    ]
  },
  "image/x-xbitmap": {
    source: "apache",
    extensions: [
      "xbm"
    ]
  },
  "image/x-xcf": {
    compressible: false
  },
  "image/x-xpixmap": {
    source: "apache",
    extensions: [
      "xpm"
    ]
  },
  "image/x-xwindowdump": {
    source: "apache",
    extensions: [
      "xwd"
    ]
  },
  "message/cpim": {
    source: "iana"
  },
  "message/delivery-status": {
    source: "iana"
  },
  "message/disposition-notification": {
    source: "iana",
    extensions: [
      "disposition-notification"
    ]
  },
  "message/external-body": {
    source: "iana"
  },
  "message/feedback-report": {
    source: "iana"
  },
  "message/global": {
    source: "iana",
    extensions: [
      "u8msg"
    ]
  },
  "message/global-delivery-status": {
    source: "iana",
    extensions: [
      "u8dsn"
    ]
  },
  "message/global-disposition-notification": {
    source: "iana",
    extensions: [
      "u8mdn"
    ]
  },
  "message/global-headers": {
    source: "iana",
    extensions: [
      "u8hdr"
    ]
  },
  "message/http": {
    source: "iana",
    compressible: false
  },
  "message/imdn+xml": {
    source: "iana",
    compressible: true
  },
  "message/news": {
    source: "iana"
  },
  "message/partial": {
    source: "iana",
    compressible: false
  },
  "message/rfc822": {
    source: "iana",
    compressible: true,
    extensions: [
      "eml",
      "mime"
    ]
  },
  "message/s-http": {
    source: "iana"
  },
  "message/sip": {
    source: "iana"
  },
  "message/sipfrag": {
    source: "iana"
  },
  "message/tracking-status": {
    source: "iana"
  },
  "message/vnd.si.simp": {
    source: "iana"
  },
  "message/vnd.wfa.wsc": {
    source: "iana",
    extensions: [
      "wsc"
    ]
  },
  "model/3mf": {
    source: "iana",
    extensions: [
      "3mf"
    ]
  },
  "model/e57": {
    source: "iana"
  },
  "model/gltf+json": {
    source: "iana",
    compressible: true,
    extensions: [
      "gltf"
    ]
  },
  "model/gltf-binary": {
    source: "iana",
    compressible: true,
    extensions: [
      "glb"
    ]
  },
  "model/iges": {
    source: "iana",
    compressible: false,
    extensions: [
      "igs",
      "iges"
    ]
  },
  "model/mesh": {
    source: "iana",
    compressible: false,
    extensions: [
      "msh",
      "mesh",
      "silo"
    ]
  },
  "model/mtl": {
    source: "iana",
    extensions: [
      "mtl"
    ]
  },
  "model/obj": {
    source: "iana",
    extensions: [
      "obj"
    ]
  },
  "model/step": {
    source: "iana"
  },
  "model/step+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "stpx"
    ]
  },
  "model/step+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpz"
    ]
  },
  "model/step-xml+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "stpxz"
    ]
  },
  "model/stl": {
    source: "iana",
    extensions: [
      "stl"
    ]
  },
  "model/vnd.collada+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "dae"
    ]
  },
  "model/vnd.dwf": {
    source: "iana",
    extensions: [
      "dwf"
    ]
  },
  "model/vnd.flatland.3dml": {
    source: "iana"
  },
  "model/vnd.gdl": {
    source: "iana",
    extensions: [
      "gdl"
    ]
  },
  "model/vnd.gs-gdl": {
    source: "apache"
  },
  "model/vnd.gs.gdl": {
    source: "iana"
  },
  "model/vnd.gtw": {
    source: "iana",
    extensions: [
      "gtw"
    ]
  },
  "model/vnd.moml+xml": {
    source: "iana",
    compressible: true
  },
  "model/vnd.mts": {
    source: "iana",
    extensions: [
      "mts"
    ]
  },
  "model/vnd.opengex": {
    source: "iana",
    extensions: [
      "ogex"
    ]
  },
  "model/vnd.parasolid.transmit.binary": {
    source: "iana",
    extensions: [
      "x_b"
    ]
  },
  "model/vnd.parasolid.transmit.text": {
    source: "iana",
    extensions: [
      "x_t"
    ]
  },
  "model/vnd.pytha.pyox": {
    source: "iana"
  },
  "model/vnd.rosette.annotated-data-model": {
    source: "iana"
  },
  "model/vnd.sap.vds": {
    source: "iana",
    extensions: [
      "vds"
    ]
  },
  "model/vnd.usdz+zip": {
    source: "iana",
    compressible: false,
    extensions: [
      "usdz"
    ]
  },
  "model/vnd.valve.source.compiled-map": {
    source: "iana",
    extensions: [
      "bsp"
    ]
  },
  "model/vnd.vtu": {
    source: "iana",
    extensions: [
      "vtu"
    ]
  },
  "model/vrml": {
    source: "iana",
    compressible: false,
    extensions: [
      "wrl",
      "vrml"
    ]
  },
  "model/x3d+binary": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3db",
      "x3dbz"
    ]
  },
  "model/x3d+fastinfoset": {
    source: "iana",
    extensions: [
      "x3db"
    ]
  },
  "model/x3d+vrml": {
    source: "apache",
    compressible: false,
    extensions: [
      "x3dv",
      "x3dvz"
    ]
  },
  "model/x3d+xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "x3d",
      "x3dz"
    ]
  },
  "model/x3d-vrml": {
    source: "iana",
    extensions: [
      "x3dv"
    ]
  },
  "multipart/alternative": {
    source: "iana",
    compressible: false
  },
  "multipart/appledouble": {
    source: "iana"
  },
  "multipart/byteranges": {
    source: "iana"
  },
  "multipart/digest": {
    source: "iana"
  },
  "multipart/encrypted": {
    source: "iana",
    compressible: false
  },
  "multipart/form-data": {
    source: "iana",
    compressible: false
  },
  "multipart/header-set": {
    source: "iana"
  },
  "multipart/mixed": {
    source: "iana"
  },
  "multipart/multilingual": {
    source: "iana"
  },
  "multipart/parallel": {
    source: "iana"
  },
  "multipart/related": {
    source: "iana",
    compressible: false
  },
  "multipart/report": {
    source: "iana"
  },
  "multipart/signed": {
    source: "iana",
    compressible: false
  },
  "multipart/vnd.bint.med-plus": {
    source: "iana"
  },
  "multipart/voice-message": {
    source: "iana"
  },
  "multipart/x-mixed-replace": {
    source: "iana"
  },
  "text/1d-interleaved-parityfec": {
    source: "iana"
  },
  "text/cache-manifest": {
    source: "iana",
    compressible: true,
    extensions: [
      "appcache",
      "manifest"
    ]
  },
  "text/calendar": {
    source: "iana",
    extensions: [
      "ics",
      "ifb"
    ]
  },
  "text/calender": {
    compressible: true
  },
  "text/cmd": {
    compressible: true
  },
  "text/coffeescript": {
    extensions: [
      "coffee",
      "litcoffee"
    ]
  },
  "text/cql": {
    source: "iana"
  },
  "text/cql-expression": {
    source: "iana"
  },
  "text/cql-identifier": {
    source: "iana"
  },
  "text/css": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "css"
    ]
  },
  "text/csv": {
    source: "iana",
    compressible: true,
    extensions: [
      "csv"
    ]
  },
  "text/csv-schema": {
    source: "iana"
  },
  "text/directory": {
    source: "iana"
  },
  "text/dns": {
    source: "iana"
  },
  "text/ecmascript": {
    source: "iana"
  },
  "text/encaprtp": {
    source: "iana"
  },
  "text/enriched": {
    source: "iana"
  },
  "text/fhirpath": {
    source: "iana"
  },
  "text/flexfec": {
    source: "iana"
  },
  "text/fwdred": {
    source: "iana"
  },
  "text/gff3": {
    source: "iana"
  },
  "text/grammar-ref-list": {
    source: "iana"
  },
  "text/html": {
    source: "iana",
    compressible: true,
    extensions: [
      "html",
      "htm",
      "shtml"
    ]
  },
  "text/jade": {
    extensions: [
      "jade"
    ]
  },
  "text/javascript": {
    source: "iana",
    compressible: true
  },
  "text/jcr-cnd": {
    source: "iana"
  },
  "text/jsx": {
    compressible: true,
    extensions: [
      "jsx"
    ]
  },
  "text/less": {
    compressible: true,
    extensions: [
      "less"
    ]
  },
  "text/markdown": {
    source: "iana",
    compressible: true,
    extensions: [
      "markdown",
      "md"
    ]
  },
  "text/mathml": {
    source: "nginx",
    extensions: [
      "mml"
    ]
  },
  "text/mdx": {
    compressible: true,
    extensions: [
      "mdx"
    ]
  },
  "text/mizar": {
    source: "iana"
  },
  "text/n3": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "n3"
    ]
  },
  "text/parameters": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/parityfec": {
    source: "iana"
  },
  "text/plain": {
    source: "iana",
    compressible: true,
    extensions: [
      "txt",
      "text",
      "conf",
      "def",
      "list",
      "log",
      "in",
      "ini"
    ]
  },
  "text/provenance-notation": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/prs.fallenstein.rst": {
    source: "iana"
  },
  "text/prs.lines.tag": {
    source: "iana",
    extensions: [
      "dsc"
    ]
  },
  "text/prs.prop.logic": {
    source: "iana"
  },
  "text/raptorfec": {
    source: "iana"
  },
  "text/red": {
    source: "iana"
  },
  "text/rfc822-headers": {
    source: "iana"
  },
  "text/richtext": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtx"
    ]
  },
  "text/rtf": {
    source: "iana",
    compressible: true,
    extensions: [
      "rtf"
    ]
  },
  "text/rtp-enc-aescm128": {
    source: "iana"
  },
  "text/rtploopback": {
    source: "iana"
  },
  "text/rtx": {
    source: "iana"
  },
  "text/sgml": {
    source: "iana",
    extensions: [
      "sgml",
      "sgm"
    ]
  },
  "text/shaclc": {
    source: "iana"
  },
  "text/shex": {
    source: "iana",
    extensions: [
      "shex"
    ]
  },
  "text/slim": {
    extensions: [
      "slim",
      "slm"
    ]
  },
  "text/spdx": {
    source: "iana",
    extensions: [
      "spdx"
    ]
  },
  "text/strings": {
    source: "iana"
  },
  "text/stylus": {
    extensions: [
      "stylus",
      "styl"
    ]
  },
  "text/t140": {
    source: "iana"
  },
  "text/tab-separated-values": {
    source: "iana",
    compressible: true,
    extensions: [
      "tsv"
    ]
  },
  "text/troff": {
    source: "iana",
    extensions: [
      "t",
      "tr",
      "roff",
      "man",
      "me",
      "ms"
    ]
  },
  "text/turtle": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "ttl"
    ]
  },
  "text/ulpfec": {
    source: "iana"
  },
  "text/uri-list": {
    source: "iana",
    compressible: true,
    extensions: [
      "uri",
      "uris",
      "urls"
    ]
  },
  "text/vcard": {
    source: "iana",
    compressible: true,
    extensions: [
      "vcard"
    ]
  },
  "text/vnd.a": {
    source: "iana"
  },
  "text/vnd.abc": {
    source: "iana"
  },
  "text/vnd.ascii-art": {
    source: "iana"
  },
  "text/vnd.curl": {
    source: "iana",
    extensions: [
      "curl"
    ]
  },
  "text/vnd.curl.dcurl": {
    source: "apache",
    extensions: [
      "dcurl"
    ]
  },
  "text/vnd.curl.mcurl": {
    source: "apache",
    extensions: [
      "mcurl"
    ]
  },
  "text/vnd.curl.scurl": {
    source: "apache",
    extensions: [
      "scurl"
    ]
  },
  "text/vnd.debian.copyright": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.dmclientscript": {
    source: "iana"
  },
  "text/vnd.dvb.subtitle": {
    source: "iana",
    extensions: [
      "sub"
    ]
  },
  "text/vnd.esmertec.theme-descriptor": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.familysearch.gedcom": {
    source: "iana",
    extensions: [
      "ged"
    ]
  },
  "text/vnd.ficlab.flt": {
    source: "iana"
  },
  "text/vnd.fly": {
    source: "iana",
    extensions: [
      "fly"
    ]
  },
  "text/vnd.fmi.flexstor": {
    source: "iana",
    extensions: [
      "flx"
    ]
  },
  "text/vnd.gml": {
    source: "iana"
  },
  "text/vnd.graphviz": {
    source: "iana",
    extensions: [
      "gv"
    ]
  },
  "text/vnd.hans": {
    source: "iana"
  },
  "text/vnd.hgl": {
    source: "iana"
  },
  "text/vnd.in3d.3dml": {
    source: "iana",
    extensions: [
      "3dml"
    ]
  },
  "text/vnd.in3d.spot": {
    source: "iana",
    extensions: [
      "spot"
    ]
  },
  "text/vnd.iptc.newsml": {
    source: "iana"
  },
  "text/vnd.iptc.nitf": {
    source: "iana"
  },
  "text/vnd.latex-z": {
    source: "iana"
  },
  "text/vnd.motorola.reflex": {
    source: "iana"
  },
  "text/vnd.ms-mediapackage": {
    source: "iana"
  },
  "text/vnd.net2phone.commcenter.command": {
    source: "iana"
  },
  "text/vnd.radisys.msml-basic-layout": {
    source: "iana"
  },
  "text/vnd.senx.warpscript": {
    source: "iana"
  },
  "text/vnd.si.uricatalogue": {
    source: "iana"
  },
  "text/vnd.sosi": {
    source: "iana"
  },
  "text/vnd.sun.j2me.app-descriptor": {
    source: "iana",
    charset: "UTF-8",
    extensions: [
      "jad"
    ]
  },
  "text/vnd.trolltech.linguist": {
    source: "iana",
    charset: "UTF-8"
  },
  "text/vnd.wap.si": {
    source: "iana"
  },
  "text/vnd.wap.sl": {
    source: "iana"
  },
  "text/vnd.wap.wml": {
    source: "iana",
    extensions: [
      "wml"
    ]
  },
  "text/vnd.wap.wmlscript": {
    source: "iana",
    extensions: [
      "wmls"
    ]
  },
  "text/vtt": {
    source: "iana",
    charset: "UTF-8",
    compressible: true,
    extensions: [
      "vtt"
    ]
  },
  "text/x-asm": {
    source: "apache",
    extensions: [
      "s",
      "asm"
    ]
  },
  "text/x-c": {
    source: "apache",
    extensions: [
      "c",
      "cc",
      "cxx",
      "cpp",
      "h",
      "hh",
      "dic"
    ]
  },
  "text/x-component": {
    source: "nginx",
    extensions: [
      "htc"
    ]
  },
  "text/x-fortran": {
    source: "apache",
    extensions: [
      "f",
      "for",
      "f77",
      "f90"
    ]
  },
  "text/x-gwt-rpc": {
    compressible: true
  },
  "text/x-handlebars-template": {
    extensions: [
      "hbs"
    ]
  },
  "text/x-java-source": {
    source: "apache",
    extensions: [
      "java"
    ]
  },
  "text/x-jquery-tmpl": {
    compressible: true
  },
  "text/x-lua": {
    extensions: [
      "lua"
    ]
  },
  "text/x-markdown": {
    compressible: true,
    extensions: [
      "mkd"
    ]
  },
  "text/x-nfo": {
    source: "apache",
    extensions: [
      "nfo"
    ]
  },
  "text/x-opml": {
    source: "apache",
    extensions: [
      "opml"
    ]
  },
  "text/x-org": {
    compressible: true,
    extensions: [
      "org"
    ]
  },
  "text/x-pascal": {
    source: "apache",
    extensions: [
      "p",
      "pas"
    ]
  },
  "text/x-processing": {
    compressible: true,
    extensions: [
      "pde"
    ]
  },
  "text/x-sass": {
    extensions: [
      "sass"
    ]
  },
  "text/x-scss": {
    extensions: [
      "scss"
    ]
  },
  "text/x-setext": {
    source: "apache",
    extensions: [
      "etx"
    ]
  },
  "text/x-sfv": {
    source: "apache",
    extensions: [
      "sfv"
    ]
  },
  "text/x-suse-ymp": {
    compressible: true,
    extensions: [
      "ymp"
    ]
  },
  "text/x-uuencode": {
    source: "apache",
    extensions: [
      "uu"
    ]
  },
  "text/x-vcalendar": {
    source: "apache",
    extensions: [
      "vcs"
    ]
  },
  "text/x-vcard": {
    source: "apache",
    extensions: [
      "vcf"
    ]
  },
  "text/xml": {
    source: "iana",
    compressible: true,
    extensions: [
      "xml"
    ]
  },
  "text/xml-external-parsed-entity": {
    source: "iana"
  },
  "text/yaml": {
    compressible: true,
    extensions: [
      "yaml",
      "yml"
    ]
  },
  "video/1d-interleaved-parityfec": {
    source: "iana"
  },
  "video/3gpp": {
    source: "iana",
    extensions: [
      "3gp",
      "3gpp"
    ]
  },
  "video/3gpp-tt": {
    source: "iana"
  },
  "video/3gpp2": {
    source: "iana",
    extensions: [
      "3g2"
    ]
  },
  "video/av1": {
    source: "iana"
  },
  "video/bmpeg": {
    source: "iana"
  },
  "video/bt656": {
    source: "iana"
  },
  "video/celb": {
    source: "iana"
  },
  "video/dv": {
    source: "iana"
  },
  "video/encaprtp": {
    source: "iana"
  },
  "video/ffv1": {
    source: "iana"
  },
  "video/flexfec": {
    source: "iana"
  },
  "video/h261": {
    source: "iana",
    extensions: [
      "h261"
    ]
  },
  "video/h263": {
    source: "iana",
    extensions: [
      "h263"
    ]
  },
  "video/h263-1998": {
    source: "iana"
  },
  "video/h263-2000": {
    source: "iana"
  },
  "video/h264": {
    source: "iana",
    extensions: [
      "h264"
    ]
  },
  "video/h264-rcdo": {
    source: "iana"
  },
  "video/h264-svc": {
    source: "iana"
  },
  "video/h265": {
    source: "iana"
  },
  "video/iso.segment": {
    source: "iana",
    extensions: [
      "m4s"
    ]
  },
  "video/jpeg": {
    source: "iana",
    extensions: [
      "jpgv"
    ]
  },
  "video/jpeg2000": {
    source: "iana"
  },
  "video/jpm": {
    source: "apache",
    extensions: [
      "jpm",
      "jpgm"
    ]
  },
  "video/jxsv": {
    source: "iana"
  },
  "video/mj2": {
    source: "iana",
    extensions: [
      "mj2",
      "mjp2"
    ]
  },
  "video/mp1s": {
    source: "iana"
  },
  "video/mp2p": {
    source: "iana"
  },
  "video/mp2t": {
    source: "iana",
    extensions: [
      "ts"
    ]
  },
  "video/mp4": {
    source: "iana",
    compressible: false,
    extensions: [
      "mp4",
      "mp4v",
      "mpg4"
    ]
  },
  "video/mp4v-es": {
    source: "iana"
  },
  "video/mpeg": {
    source: "iana",
    compressible: false,
    extensions: [
      "mpeg",
      "mpg",
      "mpe",
      "m1v",
      "m2v"
    ]
  },
  "video/mpeg4-generic": {
    source: "iana"
  },
  "video/mpv": {
    source: "iana"
  },
  "video/nv": {
    source: "iana"
  },
  "video/ogg": {
    source: "iana",
    compressible: false,
    extensions: [
      "ogv"
    ]
  },
  "video/parityfec": {
    source: "iana"
  },
  "video/pointer": {
    source: "iana"
  },
  "video/quicktime": {
    source: "iana",
    compressible: false,
    extensions: [
      "qt",
      "mov"
    ]
  },
  "video/raptorfec": {
    source: "iana"
  },
  "video/raw": {
    source: "iana"
  },
  "video/rtp-enc-aescm128": {
    source: "iana"
  },
  "video/rtploopback": {
    source: "iana"
  },
  "video/rtx": {
    source: "iana"
  },
  "video/scip": {
    source: "iana"
  },
  "video/smpte291": {
    source: "iana"
  },
  "video/smpte292m": {
    source: "iana"
  },
  "video/ulpfec": {
    source: "iana"
  },
  "video/vc1": {
    source: "iana"
  },
  "video/vc2": {
    source: "iana"
  },
  "video/vnd.cctv": {
    source: "iana"
  },
  "video/vnd.dece.hd": {
    source: "iana",
    extensions: [
      "uvh",
      "uvvh"
    ]
  },
  "video/vnd.dece.mobile": {
    source: "iana",
    extensions: [
      "uvm",
      "uvvm"
    ]
  },
  "video/vnd.dece.mp4": {
    source: "iana"
  },
  "video/vnd.dece.pd": {
    source: "iana",
    extensions: [
      "uvp",
      "uvvp"
    ]
  },
  "video/vnd.dece.sd": {
    source: "iana",
    extensions: [
      "uvs",
      "uvvs"
    ]
  },
  "video/vnd.dece.video": {
    source: "iana",
    extensions: [
      "uvv",
      "uvvv"
    ]
  },
  "video/vnd.directv.mpeg": {
    source: "iana"
  },
  "video/vnd.directv.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dlna.mpeg-tts": {
    source: "iana"
  },
  "video/vnd.dvb.file": {
    source: "iana",
    extensions: [
      "dvb"
    ]
  },
  "video/vnd.fvt": {
    source: "iana",
    extensions: [
      "fvt"
    ]
  },
  "video/vnd.hns.video": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.1dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-1010": {
    source: "iana"
  },
  "video/vnd.iptvforum.2dparityfec-2005": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsavc": {
    source: "iana"
  },
  "video/vnd.iptvforum.ttsmpeg2": {
    source: "iana"
  },
  "video/vnd.motorola.video": {
    source: "iana"
  },
  "video/vnd.motorola.videop": {
    source: "iana"
  },
  "video/vnd.mpegurl": {
    source: "iana",
    extensions: [
      "mxu",
      "m4u"
    ]
  },
  "video/vnd.ms-playready.media.pyv": {
    source: "iana",
    extensions: [
      "pyv"
    ]
  },
  "video/vnd.nokia.interleaved-multimedia": {
    source: "iana"
  },
  "video/vnd.nokia.mp4vr": {
    source: "iana"
  },
  "video/vnd.nokia.videovoip": {
    source: "iana"
  },
  "video/vnd.objectvideo": {
    source: "iana"
  },
  "video/vnd.radgamettools.bink": {
    source: "iana"
  },
  "video/vnd.radgamettools.smacker": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg1": {
    source: "iana"
  },
  "video/vnd.sealed.mpeg4": {
    source: "iana"
  },
  "video/vnd.sealed.swf": {
    source: "iana"
  },
  "video/vnd.sealedmedia.softseal.mov": {
    source: "iana"
  },
  "video/vnd.uvvu.mp4": {
    source: "iana",
    extensions: [
      "uvu",
      "uvvu"
    ]
  },
  "video/vnd.vivo": {
    source: "iana",
    extensions: [
      "viv"
    ]
  },
  "video/vnd.youtube.yt": {
    source: "iana"
  },
  "video/vp8": {
    source: "iana"
  },
  "video/vp9": {
    source: "iana"
  },
  "video/webm": {
    source: "apache",
    compressible: false,
    extensions: [
      "webm"
    ]
  },
  "video/x-f4v": {
    source: "apache",
    extensions: [
      "f4v"
    ]
  },
  "video/x-fli": {
    source: "apache",
    extensions: [
      "fli"
    ]
  },
  "video/x-flv": {
    source: "apache",
    compressible: false,
    extensions: [
      "flv"
    ]
  },
  "video/x-m4v": {
    source: "apache",
    extensions: [
      "m4v"
    ]
  },
  "video/x-matroska": {
    source: "apache",
    compressible: false,
    extensions: [
      "mkv",
      "mk3d",
      "mks"
    ]
  },
  "video/x-mng": {
    source: "apache",
    extensions: [
      "mng"
    ]
  },
  "video/x-ms-asf": {
    source: "apache",
    extensions: [
      "asf",
      "asx"
    ]
  },
  "video/x-ms-vob": {
    source: "apache",
    extensions: [
      "vob"
    ]
  },
  "video/x-ms-wm": {
    source: "apache",
    extensions: [
      "wm"
    ]
  },
  "video/x-ms-wmv": {
    source: "apache",
    compressible: false,
    extensions: [
      "wmv"
    ]
  },
  "video/x-ms-wmx": {
    source: "apache",
    extensions: [
      "wmx"
    ]
  },
  "video/x-ms-wvx": {
    source: "apache",
    extensions: [
      "wvx"
    ]
  },
  "video/x-msvideo": {
    source: "apache",
    extensions: [
      "avi"
    ]
  },
  "video/x-sgi-movie": {
    source: "apache",
    extensions: [
      "movie"
    ]
  },
  "video/x-smv": {
    source: "apache",
    extensions: [
      "smv"
    ]
  },
  "x-conference/x-cooltalk": {
    source: "apache",
    extensions: [
      "ice"
    ]
  },
  "x-shader/x-fragment": {
    compressible: true
  },
  "x-shader/x-vertex": {
    compressible: true
  }
};
/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var mimeDb = require$$0$1;
/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports) {
  var db = mimeDb;
  var extname2 = require$$1$2.extname;
  var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
  var TEXT_TYPE_REGEXP = /^text\//i;
  exports.charset = charset3;
  exports.charsets = { lookup: charset3 };
  exports.contentType = contentType3;
  exports.extension = extension;
  exports.extensions = /* @__PURE__ */ Object.create(null);
  exports.lookup = lookup2;
  exports.types = /* @__PURE__ */ Object.create(null);
  populateMaps(exports.extensions, exports.types);
  function charset3(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var mime2 = match2 && db[match2[1].toLowerCase()];
    if (mime2 && mime2.charset) {
      return mime2.charset;
    }
    if (match2 && TEXT_TYPE_REGEXP.test(match2[1])) {
      return "UTF-8";
    }
    return false;
  }
  function contentType3(str2) {
    if (!str2 || typeof str2 !== "string") {
      return false;
    }
    var mime2 = str2.indexOf("/") === -1 ? exports.lookup(str2) : str2;
    if (!mime2) {
      return false;
    }
    if (mime2.indexOf("charset") === -1) {
      var charset4 = exports.charset(mime2);
      if (charset4) mime2 += "; charset=" + charset4.toLowerCase();
    }
    return mime2;
  }
  function extension(type3) {
    if (!type3 || typeof type3 !== "string") {
      return false;
    }
    var match2 = EXTRACT_TYPE_REGEXP.exec(type3);
    var exts = match2 && exports.extensions[match2[1].toLowerCase()];
    if (!exts || !exts.length) {
      return false;
    }
    return exts[0];
  }
  function lookup2(path3) {
    if (!path3 || typeof path3 !== "string") {
      return false;
    }
    var extension2 = extname2("x." + path3).toLowerCase().substr(1);
    if (!extension2) {
      return false;
    }
    return exports.types[extension2] || false;
  }
  function populateMaps(extensions2, types2) {
    var preference = ["nginx", "apache", void 0, "iana"];
    Object.keys(db).forEach(function forEachMimeType(type3) {
      var mime2 = db[type3];
      var exts = mime2.extensions;
      if (!exts || !exts.length) {
        return;
      }
      extensions2[type3] = exts;
      for (var i = 0; i < exts.length; i++) {
        var extension2 = exts[i];
        if (types2[extension2]) {
          var from2 = preference.indexOf(db[types2[extension2]].source);
          var to = preference.indexOf(mime2.source);
          if (types2[extension2] !== "application/octet-stream" && (from2 > to || from2 === to && types2[extension2].substr(0, 12) === "application/")) {
            continue;
          }
        }
        types2[extension2] = type3;
      }
    });
  }
})(mimeTypes);
/*!
 * type-is
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var typer = mediaTyper;
var mime$5 = mimeTypes;
typeIs.exports = typeofrequest;
typeIs.exports.is = typeis$1;
typeIs.exports.hasBody = hasbody;
typeIs.exports.normalize = normalize$1;
typeIs.exports.match = mimeMatch;
function typeis$1(value2, types_) {
  var i;
  var types2 = types_;
  var val = tryNormalizeType(value2);
  if (!val) {
    return false;
  }
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length - 1);
    for (i = 0; i < types2.length; i++) {
      types2[i] = arguments[i + 1];
    }
  }
  if (!types2 || !types2.length) {
    return val;
  }
  var type3;
  for (i = 0; i < types2.length; i++) {
    if (mimeMatch(normalize$1(type3 = types2[i]), val)) {
      return type3[0] === "+" || type3.indexOf("*") !== -1 ? val : type3;
    }
  }
  return false;
}
function hasbody(req2) {
  return req2.headers["transfer-encoding"] !== void 0 || !isNaN(req2.headers["content-length"]);
}
function typeofrequest(req2, types_) {
  var types2 = types_;
  if (!hasbody(req2)) {
    return null;
  }
  if (arguments.length > 2) {
    types2 = new Array(arguments.length - 1);
    for (var i = 0; i < types2.length; i++) {
      types2[i] = arguments[i + 1];
    }
  }
  var value2 = req2.headers["content-type"];
  return typeis$1(value2, types2);
}
function normalize$1(type3) {
  if (typeof type3 !== "string") {
    return false;
  }
  switch (type3) {
    case "urlencoded":
      return "application/x-www-form-urlencoded";
    case "multipart":
      return "multipart/*";
  }
  if (type3[0] === "+") {
    return "*/*" + type3;
  }
  return type3.indexOf("/") === -1 ? mime$5.lookup(type3) : type3;
}
function mimeMatch(expected, actual) {
  if (expected === false) {
    return false;
  }
  var actualParts = actual.split("/");
  var expectedParts = expected.split("/");
  if (actualParts.length !== 2 || expectedParts.length !== 2) {
    return false;
  }
  if (expectedParts[0] !== "*" && expectedParts[0] !== actualParts[0]) {
    return false;
  }
  if (expectedParts[1].substr(0, 2) === "*+") {
    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);
  }
  if (expectedParts[1] !== "*" && expectedParts[1] !== actualParts[1]) {
    return false;
  }
  return true;
}
function normalizeType$1(value2) {
  var type3 = typer.parse(value2);
  type3.parameters = void 0;
  return typer.format(type3);
}
function tryNormalizeType(value2) {
  if (!value2) {
    return null;
  }
  try {
    return normalizeType$1(value2);
  } catch (err) {
    return null;
  }
}
var typeIsExports = typeIs.exports;
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var json_1;
var hasRequiredJson;
function requireJson() {
  if (hasRequiredJson) return json_1;
  hasRequiredJson = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = requireSrc()("body-parser:json");
  var read = requireRead();
  var typeis2 = typeIsExports;
  json_1 = json3;
  var FIRST_CHAR_REGEXP = /^[\x20\x09\x0a\x0d]*([^\x20\x09\x0a\x0d])/;
  var JSON_SYNTAX_CHAR = "#";
  var JSON_SYNTAX_REGEXP = /#+/g;
  function json3(options) {
    var opts = options || {};
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var inflate2 = opts.inflate !== false;
    var reviver = opts.reviver;
    var strict = opts.strict !== false;
    var type3 = opts.type || "application/json";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      if (body.length === 0) {
        return {};
      }
      if (strict) {
        var first2 = firstchar(body);
        if (first2 !== "{" && first2 !== "[") {
          debug2("strict violation");
          throw createStrictSyntaxError(body, first2);
        }
      }
      try {
        debug2("parse json");
        return JSON.parse(body, reviver);
      } catch (e) {
        throw normalizeJsonSyntaxError(e, {
          message: e.message,
          stack: e.stack
        });
      }
    }
    return function jsonParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3.slice(0, 4) !== "utf-") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate: inflate2,
        limit,
        verify
      });
    };
  }
  function createStrictSyntaxError(str2, char) {
    var index2 = str2.indexOf(char);
    var partial = "";
    if (index2 !== -1) {
      partial = str2.substring(0, index2) + JSON_SYNTAX_CHAR;
      for (var i = index2 + 1; i < str2.length; i++) {
        partial += JSON_SYNTAX_CHAR;
      }
    }
    try {
      JSON.parse(partial);
      throw new SyntaxError("strict violation");
    } catch (e) {
      return normalizeJsonSyntaxError(e, {
        message: e.message.replace(JSON_SYNTAX_REGEXP, function(placeholder) {
          return str2.substring(index2, index2 + placeholder.length);
        }),
        stack: e.stack
      });
    }
  }
  function firstchar(str2) {
    var match2 = FIRST_CHAR_REGEXP.exec(str2);
    return match2 ? match2[1] : void 0;
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function normalizeJsonSyntaxError(error2, obj) {
    var keys2 = Object.getOwnPropertyNames(error2);
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (key !== "stack" && key !== "message") {
        delete error2[key];
      }
    }
    error2.stack = obj.stack.replace(error2.message, obj.message);
    error2.message = obj.message;
    return error2;
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return json_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var raw_1;
var hasRequiredRaw;
function requireRaw() {
  if (hasRequiredRaw) return raw_1;
  hasRequiredRaw = 1;
  var bytes2 = requireBytes();
  var debug2 = requireSrc()("body-parser:raw");
  var read = requireRead();
  var typeis2 = typeIsExports;
  raw_1 = raw;
  function raw(options) {
    var opts = options || {};
    var inflate2 = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/octet-stream";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function rawParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        encoding: null,
        inflate: inflate2,
        limit,
        verify
      });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return raw_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var text_1;
var hasRequiredText;
function requireText() {
  if (hasRequiredText) return text_1;
  hasRequiredText = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var debug2 = requireSrc()("body-parser:text");
  var read = requireRead();
  var typeis2 = typeIsExports;
  text_1 = text;
  function text(options) {
    var opts = options || {};
    var defaultCharset = opts.defaultCharset || "utf-8";
    var inflate2 = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "text/plain";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(buf) {
      return buf;
    }
    return function textParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || defaultCharset;
      read(req2, res2, next, parse2, debug2, {
        encoding: charset3,
        inflate: inflate2,
        limit,
        verify
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return text_1;
}
var esErrors;
var hasRequiredEsErrors;
function requireEsErrors() {
  if (hasRequiredEsErrors) return esErrors;
  hasRequiredEsErrors = 1;
  esErrors = Error;
  return esErrors;
}
var _eval;
var hasRequired_eval;
function require_eval() {
  if (hasRequired_eval) return _eval;
  hasRequired_eval = 1;
  _eval = EvalError;
  return _eval;
}
var range;
var hasRequiredRange;
function requireRange() {
  if (hasRequiredRange) return range;
  hasRequiredRange = 1;
  range = RangeError;
  return range;
}
var ref;
var hasRequiredRef;
function requireRef() {
  if (hasRequiredRef) return ref;
  hasRequiredRef = 1;
  ref = ReferenceError;
  return ref;
}
var syntax;
var hasRequiredSyntax;
function requireSyntax() {
  if (hasRequiredSyntax) return syntax;
  hasRequiredSyntax = 1;
  syntax = SyntaxError;
  return syntax;
}
var type;
var hasRequiredType;
function requireType() {
  if (hasRequiredType) return type;
  hasRequiredType = 1;
  type = TypeError;
  return type;
}
var uri;
var hasRequiredUri;
function requireUri() {
  if (hasRequiredUri) return uri;
  hasRequiredUri = 1;
  uri = URIError;
  return uri;
}
var shams;
var hasRequiredShams;
function requireShams() {
  if (hasRequiredShams) return shams;
  hasRequiredShams = 1;
  shams = function hasSymbols2() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
  return shams;
}
var hasSymbols;
var hasRequiredHasSymbols;
function requireHasSymbols() {
  if (hasRequiredHasSymbols) return hasSymbols;
  hasRequiredHasSymbols = 1;
  var origSymbol = typeof Symbol !== "undefined" && Symbol;
  var hasSymbolSham = requireShams();
  hasSymbols = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
  return hasSymbols;
}
var hasProto;
var hasRequiredHasProto;
function requireHasProto() {
  if (hasRequiredHasProto) return hasProto;
  hasRequiredHasProto = 1;
  var test2 = {
    __proto__: null,
    foo: {}
  };
  var $Object = Object;
  hasProto = function hasProto2() {
    return { __proto__: test2 }.foo === test2.foo && !(test2 instanceof $Object);
  };
  return hasProto;
}
var implementation$1;
var hasRequiredImplementation$1;
function requireImplementation$1() {
  if (hasRequiredImplementation$1) return implementation$1;
  hasRequiredImplementation$1 = 1;
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var toStr = Object.prototype.toString;
  var max2 = Math.max;
  var funcType = "[object Function]";
  var concatty = function concatty2(a, b) {
    var arr = [];
    for (var i = 0; i < a.length; i += 1) {
      arr[i] = a[i];
    }
    for (var j2 = 0; j2 < b.length; j2 += 1) {
      arr[j2 + a.length] = b[j2];
    }
    return arr;
  };
  var slicy = function slicy2(arrLike, offset) {
    var arr = [];
    for (var i = offset, j2 = 0; i < arrLike.length; i += 1, j2 += 1) {
      arr[j2] = arrLike[i];
    }
    return arr;
  };
  var joiny = function(arr, joiner) {
    var str2 = "";
    for (var i = 0; i < arr.length; i += 1) {
      str2 += arr[i];
      if (i + 1 < arr.length) {
        str2 += joiner;
      }
    }
    return str2;
  };
  implementation$1 = function bind2(that) {
    var target = this;
    if (typeof target !== "function" || toStr.apply(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slicy(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(
          this,
          concatty(args, arguments)
        );
        if (Object(result) === result) {
          return result;
        }
        return this;
      }
      return target.apply(
        that,
        concatty(args, arguments)
      );
    };
    var boundLength = max2(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs[i] = "$" + i;
    }
    bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
  return implementation$1;
}
var functionBind;
var hasRequiredFunctionBind;
function requireFunctionBind() {
  if (hasRequiredFunctionBind) return functionBind;
  hasRequiredFunctionBind = 1;
  var implementation2 = requireImplementation$1();
  functionBind = Function.prototype.bind || implementation2;
  return functionBind;
}
var hasown;
var hasRequiredHasown;
function requireHasown() {
  if (hasRequiredHasown) return hasown;
  hasRequiredHasown = 1;
  var call2 = Function.prototype.call;
  var $hasOwn = Object.prototype.hasOwnProperty;
  var bind2 = requireFunctionBind();
  hasown = bind2.call(call2, $hasOwn);
  return hasown;
}
var getIntrinsic;
var hasRequiredGetIntrinsic;
function requireGetIntrinsic() {
  if (hasRequiredGetIntrinsic) return getIntrinsic;
  hasRequiredGetIntrinsic = 1;
  var undefined$1;
  var $Error = requireEsErrors();
  var $EvalError = require_eval();
  var $RangeError = requireRange();
  var $ReferenceError = requireRef();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var $URIError = requireUri();
  var $Function = Function;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols2 = requireHasSymbols()();
  var hasProto2 = requireHasProto()();
  var getProto = Object.getPrototypeOf || (hasProto2 ? function(x) {
    return x.__proto__;
  } : null);
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" || !getProto ? undefined$1 : getProto(Uint8Array);
  var INTRINSICS = {
    __proto__: null,
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined$1 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined$1 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols2 && getProto ? getProto([][Symbol.iterator]()) : undefined$1,
    "%AsyncFromSyncIteratorPrototype%": undefined$1,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined$1 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined$1 : BigInt,
    "%BigInt64Array%": typeof BigInt64Array === "undefined" ? undefined$1 : BigInt64Array,
    "%BigUint64Array%": typeof BigUint64Array === "undefined" ? undefined$1 : BigUint64Array,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined$1 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": $Error,
    "%eval%": eval,
    // eslint-disable-line no-eval
    "%EvalError%": $EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined$1 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined$1 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined$1 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined$1 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined$1 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined$1 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols2 && getProto ? getProto(getProto([][Symbol.iterator]())) : undefined$1,
    "%JSON%": typeof JSON === "object" ? JSON : undefined$1,
    "%Map%": typeof Map === "undefined" ? undefined$1 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Map())[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined$1 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined$1 : Proxy,
    "%RangeError%": $RangeError,
    "%ReferenceError%": $ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined$1 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined$1 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols2 || !getProto ? undefined$1 : getProto((/* @__PURE__ */ new Set())[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined$1 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols2 && getProto ? getProto(""[Symbol.iterator]()) : undefined$1,
    "%Symbol%": hasSymbols2 ? Symbol : undefined$1,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined$1 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined$1 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined$1 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined$1 : Uint32Array,
    "%URIError%": $URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined$1 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined$1 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined$1 : WeakSet
  };
  if (getProto) {
    try {
      null.error;
    } catch (e) {
      var errorProto = getProto(getProto(e));
      INTRINSICS["%Error.prototype%"] = errorProto;
    }
  }
  var doEval = function doEval2(name2) {
    var value2;
    if (name2 === "%AsyncFunction%") {
      value2 = getEvalledConstructor("async function () {}");
    } else if (name2 === "%GeneratorFunction%") {
      value2 = getEvalledConstructor("function* () {}");
    } else if (name2 === "%AsyncGeneratorFunction%") {
      value2 = getEvalledConstructor("async function* () {}");
    } else if (name2 === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value2 = fn.prototype;
      }
    } else if (name2 === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen && getProto) {
        value2 = getProto(gen.prototype);
      }
    }
    INTRINSICS[name2] = value2;
    return value2;
  };
  var LEGACY_ALIASES = {
    __proto__: null,
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind2 = requireFunctionBind();
  var hasOwn = requireHasown();
  var $concat = bind2.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind2.call(Function.apply, Array.prototype.splice);
  var $replace = bind2.call(Function.call, String.prototype.replace);
  var $strSlice = bind2.call(Function.call, String.prototype.slice);
  var $exec = bind2.call(Function.call, RegExp.prototype.exec);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string2) {
    var first2 = $strSlice(string2, 0, 1);
    var last = $strSlice(string2, -1);
    if (first2 === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first2 !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string2, rePropName, function(match2, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match2;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name2, allowMissing) {
    var intrinsicName = name2;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value2 = INTRINSICS[intrinsicName];
      if (value2 === needsEval) {
        value2 = doEval(intrinsicName);
      }
      if (typeof value2 === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name2 + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value: value2
      };
    }
    throw new $SyntaxError("intrinsic " + name2 + " does not exist!");
  };
  getIntrinsic = function GetIntrinsic(name2, allowMissing) {
    if (typeof name2 !== "string" || name2.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    if ($exec(/^%?[^%]*%?$/, name2) === null) {
      throw new $SyntaxError("`%` may not be present anywhere but at the beginning and end of the intrinsic name");
    }
    var parts = stringToPath(name2);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value2 = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first2 = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first2 === '"' || first2 === "'" || first2 === "`" || (last === '"' || last === "'" || last === "`")) && first2 !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value2 = INTRINSICS[intrinsicRealName];
      } else if (value2 != null) {
        if (!(part in value2)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name2 + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc2 = $gOPD(value2, part);
          isOwn = !!desc2;
          if (isOwn && "get" in desc2 && !("originalValue" in desc2.get)) {
            value2 = desc2.get;
          } else {
            value2 = value2[part];
          }
        } else {
          isOwn = hasOwn(value2, part);
          value2 = value2[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value2;
        }
      }
    }
    return value2;
  };
  return getIntrinsic;
}
var callBind = { exports: {} };
var esDefineProperty;
var hasRequiredEsDefineProperty;
function requireEsDefineProperty() {
  if (hasRequiredEsDefineProperty) return esDefineProperty;
  hasRequiredEsDefineProperty = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true) || false;
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", { value: 1 });
    } catch (e) {
      $defineProperty = false;
    }
  }
  esDefineProperty = $defineProperty;
  return esDefineProperty;
}
var gopd;
var hasRequiredGopd;
function requireGopd() {
  if (hasRequiredGopd) return gopd;
  hasRequiredGopd = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  gopd = $gOPD;
  return gopd;
}
var defineDataProperty;
var hasRequiredDefineDataProperty;
function requireDefineDataProperty() {
  if (hasRequiredDefineDataProperty) return defineDataProperty;
  hasRequiredDefineDataProperty = 1;
  var $defineProperty = requireEsDefineProperty();
  var $SyntaxError = requireSyntax();
  var $TypeError = requireType();
  var gopd2 = requireGopd();
  defineDataProperty = function defineDataProperty2(obj, property, value2) {
    if (!obj || typeof obj !== "object" && typeof obj !== "function") {
      throw new $TypeError("`obj` must be an object or a function`");
    }
    if (typeof property !== "string" && typeof property !== "symbol") {
      throw new $TypeError("`property` must be a string or a symbol`");
    }
    if (arguments.length > 3 && typeof arguments[3] !== "boolean" && arguments[3] !== null) {
      throw new $TypeError("`nonEnumerable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 4 && typeof arguments[4] !== "boolean" && arguments[4] !== null) {
      throw new $TypeError("`nonWritable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 5 && typeof arguments[5] !== "boolean" && arguments[5] !== null) {
      throw new $TypeError("`nonConfigurable`, if provided, must be a boolean or null");
    }
    if (arguments.length > 6 && typeof arguments[6] !== "boolean") {
      throw new $TypeError("`loose`, if provided, must be a boolean");
    }
    var nonEnumerable = arguments.length > 3 ? arguments[3] : null;
    var nonWritable = arguments.length > 4 ? arguments[4] : null;
    var nonConfigurable = arguments.length > 5 ? arguments[5] : null;
    var loose = arguments.length > 6 ? arguments[6] : false;
    var desc2 = !!gopd2 && gopd2(obj, property);
    if ($defineProperty) {
      $defineProperty(obj, property, {
        configurable: nonConfigurable === null && desc2 ? desc2.configurable : !nonConfigurable,
        enumerable: nonEnumerable === null && desc2 ? desc2.enumerable : !nonEnumerable,
        value: value2,
        writable: nonWritable === null && desc2 ? desc2.writable : !nonWritable
      });
    } else if (loose || !nonEnumerable && !nonWritable && !nonConfigurable) {
      obj[property] = value2;
    } else {
      throw new $SyntaxError("This environment does not support defining a property as non-configurable, non-writable, or non-enumerable.");
    }
  };
  return defineDataProperty;
}
var hasPropertyDescriptors_1;
var hasRequiredHasPropertyDescriptors;
function requireHasPropertyDescriptors() {
  if (hasRequiredHasPropertyDescriptors) return hasPropertyDescriptors_1;
  hasRequiredHasPropertyDescriptors = 1;
  var $defineProperty = requireEsDefineProperty();
  var hasPropertyDescriptors = function hasPropertyDescriptors2() {
    return !!$defineProperty;
  };
  hasPropertyDescriptors.hasArrayLengthDefineBug = function hasArrayLengthDefineBug() {
    if (!$defineProperty) {
      return null;
    }
    try {
      return $defineProperty([], "length", { value: 1 }).length !== 1;
    } catch (e) {
      return true;
    }
  };
  hasPropertyDescriptors_1 = hasPropertyDescriptors;
  return hasPropertyDescriptors_1;
}
var setFunctionLength;
var hasRequiredSetFunctionLength;
function requireSetFunctionLength() {
  if (hasRequiredSetFunctionLength) return setFunctionLength;
  hasRequiredSetFunctionLength = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var define2 = requireDefineDataProperty();
  var hasDescriptors = requireHasPropertyDescriptors()();
  var gOPD = requireGopd();
  var $TypeError = requireType();
  var $floor = GetIntrinsic("%Math.floor%");
  setFunctionLength = function setFunctionLength2(fn, length) {
    if (typeof fn !== "function") {
      throw new $TypeError("`fn` is not a function");
    }
    if (typeof length !== "number" || length < 0 || length > 4294967295 || $floor(length) !== length) {
      throw new $TypeError("`length` must be a positive 32-bit integer");
    }
    var loose = arguments.length > 2 && !!arguments[2];
    var functionLengthIsConfigurable = true;
    var functionLengthIsWritable = true;
    if ("length" in fn && gOPD) {
      var desc2 = gOPD(fn, "length");
      if (desc2 && !desc2.configurable) {
        functionLengthIsConfigurable = false;
      }
      if (desc2 && !desc2.writable) {
        functionLengthIsWritable = false;
      }
    }
    if (functionLengthIsConfigurable || functionLengthIsWritable || !loose) {
      if (hasDescriptors) {
        define2(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length,
          true,
          true
        );
      } else {
        define2(
          /** @type {Parameters<define>[0]} */
          fn,
          "length",
          length
        );
      }
    }
    return fn;
  };
  return setFunctionLength;
}
var hasRequiredCallBind;
function requireCallBind() {
  if (hasRequiredCallBind) return callBind.exports;
  hasRequiredCallBind = 1;
  (function(module2) {
    var bind2 = requireFunctionBind();
    var GetIntrinsic = requireGetIntrinsic();
    var setFunctionLength2 = requireSetFunctionLength();
    var $TypeError = requireType();
    var $apply = GetIntrinsic("%Function.prototype.apply%");
    var $call = GetIntrinsic("%Function.prototype.call%");
    var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind2.call($call, $apply);
    var $defineProperty = requireEsDefineProperty();
    var $max = GetIntrinsic("%Math.max%");
    module2.exports = function callBind2(originalFunction) {
      if (typeof originalFunction !== "function") {
        throw new $TypeError("a function is required");
      }
      var func = $reflectApply(bind2, $call, arguments);
      return setFunctionLength2(
        func,
        1 + $max(0, originalFunction.length - (arguments.length - 1)),
        true
      );
    };
    var applyBind = function applyBind2() {
      return $reflectApply(bind2, $apply, arguments);
    };
    if ($defineProperty) {
      $defineProperty(module2.exports, "apply", { value: applyBind });
    } else {
      module2.exports.apply = applyBind;
    }
  })(callBind);
  return callBind.exports;
}
var callBound;
var hasRequiredCallBound;
function requireCallBound() {
  if (hasRequiredCallBound) return callBound;
  hasRequiredCallBound = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBind2 = requireCallBind();
  var $indexOf = callBind2(GetIntrinsic("String.prototype.indexOf"));
  callBound = function callBoundIntrinsic(name2, allowMissing) {
    var intrinsic = GetIntrinsic(name2, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name2, ".prototype.") > -1) {
      return callBind2(intrinsic);
    }
    return intrinsic;
  };
  return callBound;
}
var util_inspect;
var hasRequiredUtil_inspect;
function requireUtil_inspect() {
  if (hasRequiredUtil_inspect) return util_inspect;
  hasRequiredUtil_inspect = 1;
  util_inspect = require$$1$3.inspect;
  return util_inspect;
}
var objectInspect;
var hasRequiredObjectInspect;
function requireObjectInspect() {
  if (hasRequiredObjectInspect) return objectInspect;
  hasRequiredObjectInspect = 1;
  var hasMap = typeof Map === "function" && Map.prototype;
  var mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, "size") : null;
  var mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === "function" ? mapSizeDescriptor.get : null;
  var mapForEach = hasMap && Map.prototype.forEach;
  var hasSet = typeof Set === "function" && Set.prototype;
  var setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, "size") : null;
  var setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === "function" ? setSizeDescriptor.get : null;
  var setForEach = hasSet && Set.prototype.forEach;
  var hasWeakMap = typeof WeakMap === "function" && WeakMap.prototype;
  var weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;
  var hasWeakSet = typeof WeakSet === "function" && WeakSet.prototype;
  var weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;
  var hasWeakRef = typeof WeakRef === "function" && WeakRef.prototype;
  var weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;
  var booleanValueOf = Boolean.prototype.valueOf;
  var objectToString2 = Object.prototype.toString;
  var functionToString2 = Function.prototype.toString;
  var $match = String.prototype.match;
  var $slice = String.prototype.slice;
  var $replace = String.prototype.replace;
  var $toUpperCase = String.prototype.toUpperCase;
  var $toLowerCase = String.prototype.toLowerCase;
  var $test = RegExp.prototype.test;
  var $concat = Array.prototype.concat;
  var $join = Array.prototype.join;
  var $arrSlice = Array.prototype.slice;
  var $floor = Math.floor;
  var bigIntValueOf = typeof BigInt === "function" ? BigInt.prototype.valueOf : null;
  var gOPS = Object.getOwnPropertySymbols;
  var symToString = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? Symbol.prototype.toString : null;
  var hasShammedSymbols = typeof Symbol === "function" && typeof Symbol.iterator === "object";
  var toStringTag = typeof Symbol === "function" && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? "object" : "symbol") ? Symbol.toStringTag : null;
  var isEnumerable = Object.prototype.propertyIsEnumerable;
  var gPO = (typeof Reflect === "function" ? Reflect.getPrototypeOf : Object.getPrototypeOf) || ([].__proto__ === Array.prototype ? function(O) {
    return O.__proto__;
  } : null);
  function addNumericSeparator(num, str2) {
    if (num === Infinity || num === -Infinity || num !== num || num && num > -1e3 && num < 1e3 || $test.call(/e/, str2)) {
      return str2;
    }
    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;
    if (typeof num === "number") {
      var int = num < 0 ? -$floor(-num) : $floor(num);
      if (int !== num) {
        var intStr = String(int);
        var dec = $slice.call(str2, intStr.length + 1);
        return $replace.call(intStr, sepRegex, "$&_") + "." + $replace.call($replace.call(dec, /([0-9]{3})/g, "$&_"), /_$/, "");
      }
    }
    return $replace.call(str2, sepRegex, "$&_");
  }
  var utilInspect = requireUtil_inspect();
  var inspectCustom = utilInspect.custom;
  var inspectSymbol = isSymbol2(inspectCustom) ? inspectCustom : null;
  objectInspect = function inspect_(obj, options, depth, seen) {
    var opts = options || {};
    if (has(opts, "quoteStyle") && (opts.quoteStyle !== "single" && opts.quoteStyle !== "double")) {
      throw new TypeError('option "quoteStyle" must be "single" or "double"');
    }
    if (has(opts, "maxStringLength") && (typeof opts.maxStringLength === "number" ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity : opts.maxStringLength !== null)) {
      throw new TypeError('option "maxStringLength", if provided, must be a positive integer, Infinity, or `null`');
    }
    var customInspect = has(opts, "customInspect") ? opts.customInspect : true;
    if (typeof customInspect !== "boolean" && customInspect !== "symbol") {
      throw new TypeError("option \"customInspect\", if provided, must be `true`, `false`, or `'symbol'`");
    }
    if (has(opts, "indent") && opts.indent !== null && opts.indent !== "	" && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)) {
      throw new TypeError('option "indent" must be "\\t", an integer > 0, or `null`');
    }
    if (has(opts, "numericSeparator") && typeof opts.numericSeparator !== "boolean") {
      throw new TypeError('option "numericSeparator", if provided, must be `true` or `false`');
    }
    var numericSeparator = opts.numericSeparator;
    if (typeof obj === "undefined") {
      return "undefined";
    }
    if (obj === null) {
      return "null";
    }
    if (typeof obj === "boolean") {
      return obj ? "true" : "false";
    }
    if (typeof obj === "string") {
      return inspectString(obj, opts);
    }
    if (typeof obj === "number") {
      if (obj === 0) {
        return Infinity / obj > 0 ? "0" : "-0";
      }
      var str2 = String(obj);
      return numericSeparator ? addNumericSeparator(obj, str2) : str2;
    }
    if (typeof obj === "bigint") {
      var bigIntStr = String(obj) + "n";
      return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;
    }
    var maxDepth = typeof opts.depth === "undefined" ? 5 : opts.depth;
    if (typeof depth === "undefined") {
      depth = 0;
    }
    if (depth >= maxDepth && maxDepth > 0 && typeof obj === "object") {
      return isArray2(obj) ? "[Array]" : "[Object]";
    }
    var indent = getIndent(opts, depth);
    if (typeof seen === "undefined") {
      seen = [];
    } else if (indexOf2(seen, obj) >= 0) {
      return "[Circular]";
    }
    function inspect(value2, from2, noIndent) {
      if (from2) {
        seen = $arrSlice.call(seen);
        seen.push(from2);
      }
      if (noIndent) {
        var newOpts = {
          depth: opts.depth
        };
        if (has(opts, "quoteStyle")) {
          newOpts.quoteStyle = opts.quoteStyle;
        }
        return inspect_(value2, newOpts, depth + 1, seen);
      }
      return inspect_(value2, opts, depth + 1, seen);
    }
    if (typeof obj === "function" && !isRegExp2(obj)) {
      var name2 = nameOf(obj);
      var keys2 = arrObjKeys(obj, inspect);
      return "[Function" + (name2 ? ": " + name2 : " (anonymous)") + "]" + (keys2.length > 0 ? " { " + $join.call(keys2, ", ") + " }" : "");
    }
    if (isSymbol2(obj)) {
      var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\(.*\))_[^)]*$/, "$1") : symToString.call(obj);
      return typeof obj === "object" && !hasShammedSymbols ? markBoxed(symString) : symString;
    }
    if (isElement(obj)) {
      var s2 = "<" + $toLowerCase.call(String(obj.nodeName));
      var attrs = obj.attributes || [];
      for (var i = 0; i < attrs.length; i++) {
        s2 += " " + attrs[i].name + "=" + wrapQuotes(quote(attrs[i].value), "double", opts);
      }
      s2 += ">";
      if (obj.childNodes && obj.childNodes.length) {
        s2 += "...";
      }
      s2 += "</" + $toLowerCase.call(String(obj.nodeName)) + ">";
      return s2;
    }
    if (isArray2(obj)) {
      if (obj.length === 0) {
        return "[]";
      }
      var xs = arrObjKeys(obj, inspect);
      if (indent && !singleLineValues(xs)) {
        return "[" + indentedJoin(xs, indent) + "]";
      }
      return "[ " + $join.call(xs, ", ") + " ]";
    }
    if (isError(obj)) {
      var parts = arrObjKeys(obj, inspect);
      if (!("cause" in Error.prototype) && "cause" in obj && !isEnumerable.call(obj, "cause")) {
        return "{ [" + String(obj) + "] " + $join.call($concat.call("[cause]: " + inspect(obj.cause), parts), ", ") + " }";
      }
      if (parts.length === 0) {
        return "[" + String(obj) + "]";
      }
      return "{ [" + String(obj) + "] " + $join.call(parts, ", ") + " }";
    }
    if (typeof obj === "object" && customInspect) {
      if (inspectSymbol && typeof obj[inspectSymbol] === "function" && utilInspect) {
        return utilInspect(obj, { depth: maxDepth - depth });
      } else if (customInspect !== "symbol" && typeof obj.inspect === "function") {
        return obj.inspect();
      }
    }
    if (isMap(obj)) {
      var mapParts = [];
      if (mapForEach) {
        mapForEach.call(obj, function(value2, key) {
          mapParts.push(inspect(key, obj, true) + " => " + inspect(value2, obj));
        });
      }
      return collectionOf("Map", mapSize.call(obj), mapParts, indent);
    }
    if (isSet(obj)) {
      var setParts = [];
      if (setForEach) {
        setForEach.call(obj, function(value2) {
          setParts.push(inspect(value2, obj));
        });
      }
      return collectionOf("Set", setSize.call(obj), setParts, indent);
    }
    if (isWeakMap(obj)) {
      return weakCollectionOf("WeakMap");
    }
    if (isWeakSet(obj)) {
      return weakCollectionOf("WeakSet");
    }
    if (isWeakRef(obj)) {
      return weakCollectionOf("WeakRef");
    }
    if (isNumber2(obj)) {
      return markBoxed(inspect(Number(obj)));
    }
    if (isBigInt(obj)) {
      return markBoxed(inspect(bigIntValueOf.call(obj)));
    }
    if (isBoolean2(obj)) {
      return markBoxed(booleanValueOf.call(obj));
    }
    if (isString2(obj)) {
      return markBoxed(inspect(String(obj)));
    }
    if (typeof window !== "undefined" && obj === window) {
      return "{ [object Window] }";
    }
    if (typeof globalThis !== "undefined" && obj === globalThis || typeof commonjsGlobal !== "undefined" && obj === commonjsGlobal) {
      return "{ [object globalThis] }";
    }
    if (!isDate2(obj) && !isRegExp2(obj)) {
      var ys = arrObjKeys(obj, inspect);
      var isPlainObject2 = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;
      var protoTag = obj instanceof Object ? "" : "null prototype";
      var stringTag = !isPlainObject2 && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? "Object" : "";
      var constructorTag = isPlainObject2 || typeof obj.constructor !== "function" ? "" : obj.constructor.name ? obj.constructor.name + " " : "";
      var tag = constructorTag + (stringTag || protoTag ? "[" + $join.call($concat.call([], stringTag || [], protoTag || []), ": ") + "] " : "");
      if (ys.length === 0) {
        return tag + "{}";
      }
      if (indent) {
        return tag + "{" + indentedJoin(ys, indent) + "}";
      }
      return tag + "{ " + $join.call(ys, ", ") + " }";
    }
    return String(obj);
  };
  function wrapQuotes(s2, defaultStyle, opts) {
    var quoteChar = (opts.quoteStyle || defaultStyle) === "double" ? '"' : "'";
    return quoteChar + s2 + quoteChar;
  }
  function quote(s2) {
    return $replace.call(String(s2), /"/g, "&quot;");
  }
  function isArray2(obj) {
    return toStr(obj) === "[object Array]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isDate2(obj) {
    return toStr(obj) === "[object Date]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isRegExp2(obj) {
    return toStr(obj) === "[object RegExp]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isError(obj) {
    return toStr(obj) === "[object Error]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isString2(obj) {
    return toStr(obj) === "[object String]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isNumber2(obj) {
    return toStr(obj) === "[object Number]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isBoolean2(obj) {
    return toStr(obj) === "[object Boolean]" && (!toStringTag || !(typeof obj === "object" && toStringTag in obj));
  }
  function isSymbol2(obj) {
    if (hasShammedSymbols) {
      return obj && typeof obj === "object" && obj instanceof Symbol;
    }
    if (typeof obj === "symbol") {
      return true;
    }
    if (!obj || typeof obj !== "object" || !symToString) {
      return false;
    }
    try {
      symToString.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isBigInt(obj) {
    if (!obj || typeof obj !== "object" || !bigIntValueOf) {
      return false;
    }
    try {
      bigIntValueOf.call(obj);
      return true;
    } catch (e) {
    }
    return false;
  }
  var hasOwn = Object.prototype.hasOwnProperty || function(key) {
    return key in this;
  };
  function has(obj, key) {
    return hasOwn.call(obj, key);
  }
  function toStr(obj) {
    return objectToString2.call(obj);
  }
  function nameOf(f) {
    if (f.name) {
      return f.name;
    }
    var m2 = $match.call(functionToString2.call(f), /^function\s*([\w$]+)/);
    if (m2) {
      return m2[1];
    }
    return null;
  }
  function indexOf2(xs, x) {
    if (xs.indexOf) {
      return xs.indexOf(x);
    }
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x) {
        return i;
      }
    }
    return -1;
  }
  function isMap(x) {
    if (!mapSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      mapSize.call(x);
      try {
        setSize.call(x);
      } catch (s2) {
        return true;
      }
      return x instanceof Map;
    } catch (e) {
    }
    return false;
  }
  function isWeakMap(x) {
    if (!weakMapHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakMapHas.call(x, weakMapHas);
      try {
        weakSetHas.call(x, weakSetHas);
      } catch (s2) {
        return true;
      }
      return x instanceof WeakMap;
    } catch (e) {
    }
    return false;
  }
  function isWeakRef(x) {
    if (!weakRefDeref || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakRefDeref.call(x);
      return true;
    } catch (e) {
    }
    return false;
  }
  function isSet(x) {
    if (!setSize || !x || typeof x !== "object") {
      return false;
    }
    try {
      setSize.call(x);
      try {
        mapSize.call(x);
      } catch (m2) {
        return true;
      }
      return x instanceof Set;
    } catch (e) {
    }
    return false;
  }
  function isWeakSet(x) {
    if (!weakSetHas || !x || typeof x !== "object") {
      return false;
    }
    try {
      weakSetHas.call(x, weakSetHas);
      try {
        weakMapHas.call(x, weakMapHas);
      } catch (s2) {
        return true;
      }
      return x instanceof WeakSet;
    } catch (e) {
    }
    return false;
  }
  function isElement(x) {
    if (!x || typeof x !== "object") {
      return false;
    }
    if (typeof HTMLElement !== "undefined" && x instanceof HTMLElement) {
      return true;
    }
    return typeof x.nodeName === "string" && typeof x.getAttribute === "function";
  }
  function inspectString(str2, opts) {
    if (str2.length > opts.maxStringLength) {
      var remaining = str2.length - opts.maxStringLength;
      var trailer = "... " + remaining + " more character" + (remaining > 1 ? "s" : "");
      return inspectString($slice.call(str2, 0, opts.maxStringLength), opts) + trailer;
    }
    var s2 = $replace.call($replace.call(str2, /(['\\])/g, "\\$1"), /[\x00-\x1f]/g, lowbyte);
    return wrapQuotes(s2, "single", opts);
  }
  function lowbyte(c) {
    var n = c.charCodeAt(0);
    var x = {
      8: "b",
      9: "t",
      10: "n",
      12: "f",
      13: "r"
    }[n];
    if (x) {
      return "\\" + x;
    }
    return "\\x" + (n < 16 ? "0" : "") + $toUpperCase.call(n.toString(16));
  }
  function markBoxed(str2) {
    return "Object(" + str2 + ")";
  }
  function weakCollectionOf(type3) {
    return type3 + " { ? }";
  }
  function collectionOf(type3, size, entries, indent) {
    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ", ");
    return type3 + " (" + size + ") {" + joinedEntries + "}";
  }
  function singleLineValues(xs) {
    for (var i = 0; i < xs.length; i++) {
      if (indexOf2(xs[i], "\n") >= 0) {
        return false;
      }
    }
    return true;
  }
  function getIndent(opts, depth) {
    var baseIndent;
    if (opts.indent === "	") {
      baseIndent = "	";
    } else if (typeof opts.indent === "number" && opts.indent > 0) {
      baseIndent = $join.call(Array(opts.indent + 1), " ");
    } else {
      return null;
    }
    return {
      base: baseIndent,
      prev: $join.call(Array(depth + 1), baseIndent)
    };
  }
  function indentedJoin(xs, indent) {
    if (xs.length === 0) {
      return "";
    }
    var lineJoiner = "\n" + indent.prev + indent.base;
    return lineJoiner + $join.call(xs, "," + lineJoiner) + "\n" + indent.prev;
  }
  function arrObjKeys(obj, inspect) {
    var isArr = isArray2(obj);
    var xs = [];
    if (isArr) {
      xs.length = obj.length;
      for (var i = 0; i < obj.length; i++) {
        xs[i] = has(obj, i) ? inspect(obj[i], obj) : "";
      }
    }
    var syms = typeof gOPS === "function" ? gOPS(obj) : [];
    var symMap;
    if (hasShammedSymbols) {
      symMap = {};
      for (var k = 0; k < syms.length; k++) {
        symMap["$" + syms[k]] = syms[k];
      }
    }
    for (var key in obj) {
      if (!has(obj, key)) {
        continue;
      }
      if (isArr && String(Number(key)) === key && key < obj.length) {
        continue;
      }
      if (hasShammedSymbols && symMap["$" + key] instanceof Symbol) {
        continue;
      } else if ($test.call(/[^\w$]/, key)) {
        xs.push(inspect(key, obj) + ": " + inspect(obj[key], obj));
      } else {
        xs.push(key + ": " + inspect(obj[key], obj));
      }
    }
    if (typeof gOPS === "function") {
      for (var j2 = 0; j2 < syms.length; j2++) {
        if (isEnumerable.call(obj, syms[j2])) {
          xs.push("[" + inspect(syms[j2]) + "]: " + inspect(obj[syms[j2]], obj));
        }
      }
    }
    return xs;
  }
  return objectInspect;
}
var sideChannel;
var hasRequiredSideChannel;
function requireSideChannel() {
  if (hasRequiredSideChannel) return sideChannel;
  hasRequiredSideChannel = 1;
  var GetIntrinsic = requireGetIntrinsic();
  var callBound2 = requireCallBound();
  var inspect = requireObjectInspect();
  var $TypeError = requireType();
  var $WeakMap = GetIntrinsic("%WeakMap%", true);
  var $Map = GetIntrinsic("%Map%", true);
  var $weakMapGet = callBound2("WeakMap.prototype.get", true);
  var $weakMapSet = callBound2("WeakMap.prototype.set", true);
  var $weakMapHas = callBound2("WeakMap.prototype.has", true);
  var $mapGet = callBound2("Map.prototype.get", true);
  var $mapSet = callBound2("Map.prototype.set", true);
  var $mapHas = callBound2("Map.prototype.has", true);
  var listGetNode = function(list, key) {
    var prev = list;
    var curr;
    for (; (curr = prev.next) !== null; prev = curr) {
      if (curr.key === key) {
        prev.next = curr.next;
        curr.next = /** @type {NonNullable<typeof list.next>} */
        list.next;
        list.next = curr;
        return curr;
      }
    }
  };
  var listGet = function(objects, key) {
    var node2 = listGetNode(objects, key);
    return node2 && node2.value;
  };
  var listSet = function(objects, key, value2) {
    var node2 = listGetNode(objects, key);
    if (node2) {
      node2.value = value2;
    } else {
      objects.next = /** @type {import('.').ListNode<typeof value>} */
      {
        // eslint-disable-line no-param-reassign, no-extra-parens
        key,
        next: objects.next,
        value: value2
      };
    }
  };
  var listHas = function(objects, key) {
    return !!listGetNode(objects, key);
  };
  sideChannel = function getSideChannel() {
    var $wm;
    var $m;
    var $o;
    var channel = {
      assert: function(key) {
        if (!channel.has(key)) {
          throw new $TypeError("Side channel does not contain " + inspect(key));
        }
      },
      get: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapGet($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapGet($m, key);
          }
        } else {
          if ($o) {
            return listGet($o, key);
          }
        }
      },
      has: function(key) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if ($wm) {
            return $weakMapHas($wm, key);
          }
        } else if ($Map) {
          if ($m) {
            return $mapHas($m, key);
          }
        } else {
          if ($o) {
            return listHas($o, key);
          }
        }
        return false;
      },
      set: function(key, value2) {
        if ($WeakMap && key && (typeof key === "object" || typeof key === "function")) {
          if (!$wm) {
            $wm = new $WeakMap();
          }
          $weakMapSet($wm, key, value2);
        } else if ($Map) {
          if (!$m) {
            $m = new $Map();
          }
          $mapSet($m, key, value2);
        } else {
          if (!$o) {
            $o = { key: {}, next: null };
          }
          listSet($o, key, value2);
        }
      }
    };
    return channel;
  };
  return sideChannel;
}
var formats;
var hasRequiredFormats;
function requireFormats() {
  if (hasRequiredFormats) return formats;
  hasRequiredFormats = 1;
  var replace = String.prototype.replace;
  var percentTwenties = /%20/g;
  var Format = {
    RFC1738: "RFC1738",
    RFC3986: "RFC3986"
  };
  formats = {
    "default": Format.RFC3986,
    formatters: {
      RFC1738: function(value2) {
        return replace.call(value2, percentTwenties, "+");
      },
      RFC3986: function(value2) {
        return String(value2);
      }
    },
    RFC1738: Format.RFC1738,
    RFC3986: Format.RFC3986
  };
  return formats;
}
var utils$7;
var hasRequiredUtils;
function requireUtils() {
  if (hasRequiredUtils) return utils$7;
  hasRequiredUtils = 1;
  var formats2 = requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var hexTable = function() {
    var array2 = [];
    for (var i = 0; i < 256; ++i) {
      array2.push("%" + ((i < 16 ? "0" : "") + i.toString(16)).toUpperCase());
    }
    return array2;
  }();
  var compactQueue = function compactQueue2(queue) {
    while (queue.length > 1) {
      var item = queue.pop();
      var obj = item.obj[item.prop];
      if (isArray2(obj)) {
        var compacted = [];
        for (var j2 = 0; j2 < obj.length; ++j2) {
          if (typeof obj[j2] !== "undefined") {
            compacted.push(obj[j2]);
          }
        }
        item.obj[item.prop] = compacted;
      }
    }
  };
  var arrayToObject2 = function arrayToObject3(source, options) {
    var obj = options && options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
      if (typeof source[i] !== "undefined") {
        obj[i] = source[i];
      }
    }
    return obj;
  };
  var merge2 = function merge3(target, source, options) {
    if (!source) {
      return target;
    }
    if (typeof source !== "object") {
      if (isArray2(target)) {
        target.push(source);
      } else if (target && typeof target === "object") {
        if (options && (options.plainObjects || options.allowPrototypes) || !has.call(Object.prototype, source)) {
          target[source] = true;
        }
      } else {
        return [target, source];
      }
      return target;
    }
    if (!target || typeof target !== "object") {
      return [target].concat(source);
    }
    var mergeTarget = target;
    if (isArray2(target) && !isArray2(source)) {
      mergeTarget = arrayToObject2(target, options);
    }
    if (isArray2(target) && isArray2(source)) {
      source.forEach(function(item, i) {
        if (has.call(target, i)) {
          var targetItem = target[i];
          if (targetItem && typeof targetItem === "object" && item && typeof item === "object") {
            target[i] = merge3(targetItem, item, options);
          } else {
            target.push(item);
          }
        } else {
          target[i] = item;
        }
      });
      return target;
    }
    return Object.keys(source).reduce(function(acc, key) {
      var value2 = source[key];
      if (has.call(acc, key)) {
        acc[key] = merge3(acc[key], value2, options);
      } else {
        acc[key] = value2;
      }
      return acc;
    }, mergeTarget);
  };
  var assign2 = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function(acc, key) {
      acc[key] = source[key];
      return acc;
    }, target);
  };
  var decode2 = function(str2, decoder, charset3) {
    var strWithoutPlus = str2.replace(/\+/g, " ");
    if (charset3 === "iso-8859-1") {
      return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    try {
      return decodeURIComponent(strWithoutPlus);
    } catch (e) {
      return strWithoutPlus;
    }
  };
  var encode2 = function encode3(str2, defaultEncoder, charset3, kind, format2) {
    if (str2.length === 0) {
      return str2;
    }
    var string2 = str2;
    if (typeof str2 === "symbol") {
      string2 = Symbol.prototype.toString.call(str2);
    } else if (typeof str2 !== "string") {
      string2 = String(str2);
    }
    if (charset3 === "iso-8859-1") {
      return escape(string2).replace(/%u[0-9a-f]{4}/gi, function($0) {
        return "%26%23" + parseInt($0.slice(2), 16) + "%3B";
      });
    }
    var out = "";
    for (var i = 0; i < string2.length; ++i) {
      var c = string2.charCodeAt(i);
      if (c === 45 || c === 46 || c === 95 || c === 126 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 || format2 === formats2.RFC1738 && (c === 40 || c === 41)) {
        out += string2.charAt(i);
        continue;
      }
      if (c < 128) {
        out = out + hexTable[c];
        continue;
      }
      if (c < 2048) {
        out = out + (hexTable[192 | c >> 6] + hexTable[128 | c & 63]);
        continue;
      }
      if (c < 55296 || c >= 57344) {
        out = out + (hexTable[224 | c >> 12] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63]);
        continue;
      }
      i += 1;
      c = 65536 + ((c & 1023) << 10 | string2.charCodeAt(i) & 1023);
      out += hexTable[240 | c >> 18] + hexTable[128 | c >> 12 & 63] + hexTable[128 | c >> 6 & 63] + hexTable[128 | c & 63];
    }
    return out;
  };
  var compact2 = function compact3(value2) {
    var queue = [{ obj: { o: value2 }, prop: "o" }];
    var refs = [];
    for (var i = 0; i < queue.length; ++i) {
      var item = queue[i];
      var obj = item.obj[item.prop];
      var keys2 = Object.keys(obj);
      for (var j2 = 0; j2 < keys2.length; ++j2) {
        var key = keys2[j2];
        var val = obj[key];
        if (typeof val === "object" && val !== null && refs.indexOf(val) === -1) {
          queue.push({ obj, prop: key });
          refs.push(val);
        }
      }
    }
    compactQueue(queue);
    return value2;
  };
  var isRegExp2 = function isRegExp3(obj) {
    return Object.prototype.toString.call(obj) === "[object RegExp]";
  };
  var isBuffer2 = function isBuffer3(obj) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
  };
  var combine = function combine2(a, b) {
    return [].concat(a, b);
  };
  var maybeMap = function maybeMap2(val, fn) {
    if (isArray2(val)) {
      var mapped = [];
      for (var i = 0; i < val.length; i += 1) {
        mapped.push(fn(val[i]));
      }
      return mapped;
    }
    return fn(val);
  };
  utils$7 = {
    arrayToObject: arrayToObject2,
    assign: assign2,
    combine,
    compact: compact2,
    decode: decode2,
    encode: encode2,
    isBuffer: isBuffer2,
    isRegExp: isRegExp2,
    maybeMap,
    merge: merge2
  };
  return utils$7;
}
var stringify_1;
var hasRequiredStringify;
function requireStringify() {
  if (hasRequiredStringify) return stringify_1;
  hasRequiredStringify = 1;
  var getSideChannel = requireSideChannel();
  var utils2 = requireUtils();
  var formats2 = requireFormats();
  var has = Object.prototype.hasOwnProperty;
  var arrayPrefixGenerators = {
    brackets: function brackets(prefix) {
      return prefix + "[]";
    },
    comma: "comma",
    indices: function indices(prefix, key) {
      return prefix + "[" + key + "]";
    },
    repeat: function repeat2(prefix) {
      return prefix;
    }
  };
  var isArray2 = Array.isArray;
  var split = String.prototype.split;
  var push = Array.prototype.push;
  var pushToArray = function(arr, valueOrArray) {
    push.apply(arr, isArray2(valueOrArray) ? valueOrArray : [valueOrArray]);
  };
  var toISO = Date.prototype.toISOString;
  var defaultFormat = formats2["default"];
  var defaults2 = {
    addQueryPrefix: false,
    allowDots: false,
    charset: "utf-8",
    charsetSentinel: false,
    delimiter: "&",
    encode: true,
    encoder: utils2.encode,
    encodeValuesOnly: false,
    format: defaultFormat,
    formatter: formats2.formatters[defaultFormat],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) {
      return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
  };
  var isNonNullishPrimitive = function isNonNullishPrimitive2(v) {
    return typeof v === "string" || typeof v === "number" || typeof v === "boolean" || typeof v === "symbol" || typeof v === "bigint";
  };
  var sentinel = {};
  var stringify2 = function stringify3(object, prefix, generateArrayPrefix, commaRoundTrip, strictNullHandling, skipNulls, encoder, filter3, sort, allowDots, serializeDate, format2, formatter, encodeValuesOnly, charset3, sideChannel2) {
    var obj = object;
    var tmpSc = sideChannel2;
    var step = 0;
    var findFlag = false;
    while ((tmpSc = tmpSc.get(sentinel)) !== void 0 && !findFlag) {
      var pos = tmpSc.get(object);
      step += 1;
      if (typeof pos !== "undefined") {
        if (pos === step) {
          throw new RangeError("Cyclic object value");
        } else {
          findFlag = true;
        }
      }
      if (typeof tmpSc.get(sentinel) === "undefined") {
        step = 0;
      }
    }
    if (typeof filter3 === "function") {
      obj = filter3(prefix, obj);
    } else if (obj instanceof Date) {
      obj = serializeDate(obj);
    } else if (generateArrayPrefix === "comma" && isArray2(obj)) {
      obj = utils2.maybeMap(obj, function(value3) {
        if (value3 instanceof Date) {
          return serializeDate(value3);
        }
        return value3;
      });
    }
    if (obj === null) {
      if (strictNullHandling) {
        return encoder && !encodeValuesOnly ? encoder(prefix, defaults2.encoder, charset3, "key", format2) : prefix;
      }
      obj = "";
    }
    if (isNonNullishPrimitive(obj) || utils2.isBuffer(obj)) {
      if (encoder) {
        var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults2.encoder, charset3, "key", format2);
        if (generateArrayPrefix === "comma" && encodeValuesOnly) {
          var valuesArray = split.call(String(obj), ",");
          var valuesJoined = "";
          for (var i = 0; i < valuesArray.length; ++i) {
            valuesJoined += (i === 0 ? "" : ",") + formatter(encoder(valuesArray[i], defaults2.encoder, charset3, "value", format2));
          }
          return [formatter(keyValue) + (commaRoundTrip && isArray2(obj) && valuesArray.length === 1 ? "[]" : "") + "=" + valuesJoined];
        }
        return [formatter(keyValue) + "=" + formatter(encoder(obj, defaults2.encoder, charset3, "value", format2))];
      }
      return [formatter(prefix) + "=" + formatter(String(obj))];
    }
    var values = [];
    if (typeof obj === "undefined") {
      return values;
    }
    var objKeys;
    if (generateArrayPrefix === "comma" && isArray2(obj)) {
      objKeys = [{ value: obj.length > 0 ? obj.join(",") || null : void 0 }];
    } else if (isArray2(filter3)) {
      objKeys = filter3;
    } else {
      var keys2 = Object.keys(obj);
      objKeys = sort ? keys2.sort(sort) : keys2;
    }
    var adjustedPrefix = commaRoundTrip && isArray2(obj) && obj.length === 1 ? prefix + "[]" : prefix;
    for (var j2 = 0; j2 < objKeys.length; ++j2) {
      var key = objKeys[j2];
      var value2 = typeof key === "object" && typeof key.value !== "undefined" ? key.value : obj[key];
      if (skipNulls && value2 === null) {
        continue;
      }
      var keyPrefix = isArray2(obj) ? typeof generateArrayPrefix === "function" ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix : adjustedPrefix + (allowDots ? "." + key : "[" + key + "]");
      sideChannel2.set(object, step);
      var valueSideChannel = getSideChannel();
      valueSideChannel.set(sentinel, sideChannel2);
      pushToArray(values, stringify3(
        value2,
        keyPrefix,
        generateArrayPrefix,
        commaRoundTrip,
        strictNullHandling,
        skipNulls,
        encoder,
        filter3,
        sort,
        allowDots,
        serializeDate,
        format2,
        formatter,
        encodeValuesOnly,
        charset3,
        valueSideChannel
      ));
    }
    return values;
  };
  var normalizeStringifyOptions = function normalizeStringifyOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (opts.encoder !== null && typeof opts.encoder !== "undefined" && typeof opts.encoder !== "function") {
      throw new TypeError("Encoder has to be a function.");
    }
    var charset3 = opts.charset || defaults2.charset;
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var format2 = formats2["default"];
    if (typeof opts.format !== "undefined") {
      if (!has.call(formats2.formatters, opts.format)) {
        throw new TypeError("Unknown format option provided.");
      }
      format2 = opts.format;
    }
    var formatter = formats2.formatters[format2];
    var filter3 = defaults2.filter;
    if (typeof opts.filter === "function" || isArray2(opts.filter)) {
      filter3 = opts.filter;
    }
    return {
      addQueryPrefix: typeof opts.addQueryPrefix === "boolean" ? opts.addQueryPrefix : defaults2.addQueryPrefix,
      allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
      charset: charset3,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      delimiter: typeof opts.delimiter === "undefined" ? defaults2.delimiter : opts.delimiter,
      encode: typeof opts.encode === "boolean" ? opts.encode : defaults2.encode,
      encoder: typeof opts.encoder === "function" ? opts.encoder : defaults2.encoder,
      encodeValuesOnly: typeof opts.encodeValuesOnly === "boolean" ? opts.encodeValuesOnly : defaults2.encodeValuesOnly,
      filter: filter3,
      format: format2,
      formatter,
      serializeDate: typeof opts.serializeDate === "function" ? opts.serializeDate : defaults2.serializeDate,
      skipNulls: typeof opts.skipNulls === "boolean" ? opts.skipNulls : defaults2.skipNulls,
      sort: typeof opts.sort === "function" ? opts.sort : null,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  stringify_1 = function(object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);
    var objKeys;
    var filter3;
    if (typeof options.filter === "function") {
      filter3 = options.filter;
      obj = filter3("", obj);
    } else if (isArray2(options.filter)) {
      filter3 = options.filter;
      objKeys = filter3;
    }
    var keys2 = [];
    if (typeof obj !== "object" || obj === null) {
      return "";
    }
    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
      arrayFormat = opts.arrayFormat;
    } else if (opts && "indices" in opts) {
      arrayFormat = opts.indices ? "indices" : "repeat";
    } else {
      arrayFormat = "indices";
    }
    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];
    if (opts && "commaRoundTrip" in opts && typeof opts.commaRoundTrip !== "boolean") {
      throw new TypeError("`commaRoundTrip` must be a boolean, or absent");
    }
    var commaRoundTrip = generateArrayPrefix === "comma" && opts && opts.commaRoundTrip;
    if (!objKeys) {
      objKeys = Object.keys(obj);
    }
    if (options.sort) {
      objKeys.sort(options.sort);
    }
    var sideChannel2 = getSideChannel();
    for (var i = 0; i < objKeys.length; ++i) {
      var key = objKeys[i];
      if (options.skipNulls && obj[key] === null) {
        continue;
      }
      pushToArray(keys2, stringify2(
        obj[key],
        key,
        generateArrayPrefix,
        commaRoundTrip,
        options.strictNullHandling,
        options.skipNulls,
        options.encode ? options.encoder : null,
        options.filter,
        options.sort,
        options.allowDots,
        options.serializeDate,
        options.format,
        options.formatter,
        options.encodeValuesOnly,
        options.charset,
        sideChannel2
      ));
    }
    var joined = keys2.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? "?" : "";
    if (options.charsetSentinel) {
      if (options.charset === "iso-8859-1") {
        prefix += "utf8=%26%2310003%3B&";
      } else {
        prefix += "utf8=%E2%9C%93&";
      }
    }
    return joined.length > 0 ? prefix + joined : "";
  };
  return stringify_1;
}
var parse$7;
var hasRequiredParse;
function requireParse() {
  if (hasRequiredParse) return parse$7;
  hasRequiredParse = 1;
  var utils2 = requireUtils();
  var has = Object.prototype.hasOwnProperty;
  var isArray2 = Array.isArray;
  var defaults2 = {
    allowDots: false,
    allowPrototypes: false,
    allowSparse: false,
    arrayLimit: 20,
    charset: "utf-8",
    charsetSentinel: false,
    comma: false,
    decoder: utils2.decode,
    delimiter: "&",
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1e3,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
  };
  var interpretNumericEntities = function(str2) {
    return str2.replace(/&#(\d+);/g, function($0, numberStr) {
      return String.fromCharCode(parseInt(numberStr, 10));
    });
  };
  var parseArrayValue = function(val, options) {
    if (val && typeof val === "string" && options.comma && val.indexOf(",") > -1) {
      return val.split(",");
    }
    return val;
  };
  var isoSentinel = "utf8=%26%2310003%3B";
  var charsetSentinel = "utf8=%E2%9C%93";
  var parseValues = function parseQueryStringValues(str2, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str2.replace(/^\?/, "") : str2;
    var limit = options.parameterLimit === Infinity ? void 0 : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1;
    var i;
    var charset3 = options.charset;
    if (options.charsetSentinel) {
      for (i = 0; i < parts.length; ++i) {
        if (parts[i].indexOf("utf8=") === 0) {
          if (parts[i] === charsetSentinel) {
            charset3 = "utf-8";
          } else if (parts[i] === isoSentinel) {
            charset3 = "iso-8859-1";
          }
          skipIndex = i;
          i = parts.length;
        }
      }
    }
    for (i = 0; i < parts.length; ++i) {
      if (i === skipIndex) {
        continue;
      }
      var part = parts[i];
      var bracketEqualsPos = part.indexOf("]=");
      var pos = bracketEqualsPos === -1 ? part.indexOf("=") : bracketEqualsPos + 1;
      var key, val;
      if (pos === -1) {
        key = options.decoder(part, defaults2.decoder, charset3, "key");
        val = options.strictNullHandling ? null : "";
      } else {
        key = options.decoder(part.slice(0, pos), defaults2.decoder, charset3, "key");
        val = utils2.maybeMap(
          parseArrayValue(part.slice(pos + 1), options),
          function(encodedVal) {
            return options.decoder(encodedVal, defaults2.decoder, charset3, "value");
          }
        );
      }
      if (val && options.interpretNumericEntities && charset3 === "iso-8859-1") {
        val = interpretNumericEntities(val);
      }
      if (part.indexOf("[]=") > -1) {
        val = isArray2(val) ? [val] : val;
      }
      if (has.call(obj, key)) {
        obj[key] = utils2.combine(obj[key], val);
      } else {
        obj[key] = val;
      }
    }
    return obj;
  };
  var parseObject = function(chain, val, options, valuesParsed) {
    var leaf = valuesParsed ? val : parseArrayValue(val, options);
    for (var i = chain.length - 1; i >= 0; --i) {
      var obj;
      var root2 = chain[i];
      if (root2 === "[]" && options.parseArrays) {
        obj = [].concat(leaf);
      } else {
        obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
        var cleanRoot = root2.charAt(0) === "[" && root2.charAt(root2.length - 1) === "]" ? root2.slice(1, -1) : root2;
        var index2 = parseInt(cleanRoot, 10);
        if (!options.parseArrays && cleanRoot === "") {
          obj = { 0: leaf };
        } else if (!isNaN(index2) && root2 !== cleanRoot && String(index2) === cleanRoot && index2 >= 0 && (options.parseArrays && index2 <= options.arrayLimit)) {
          obj = [];
          obj[index2] = leaf;
        } else if (cleanRoot !== "__proto__") {
          obj[cleanRoot] = leaf;
        }
      }
      leaf = obj;
    }
    return leaf;
  };
  var parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {
    if (!givenKey) {
      return;
    }
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, "[$1]") : givenKey;
    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;
    var segment = options.depth > 0 && brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;
    var keys2 = [];
    if (parent) {
      if (!options.plainObjects && has.call(Object.prototype, parent)) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys2.push(parent);
    }
    var i = 0;
    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {
      i += 1;
      if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
        if (!options.allowPrototypes) {
          return;
        }
      }
      keys2.push(segment[1]);
    }
    if (segment) {
      keys2.push("[" + key.slice(segment.index) + "]");
    }
    return parseObject(keys2, val, options, valuesParsed);
  };
  var normalizeParseOptions = function normalizeParseOptions2(opts) {
    if (!opts) {
      return defaults2;
    }
    if (opts.decoder !== null && opts.decoder !== void 0 && typeof opts.decoder !== "function") {
      throw new TypeError("Decoder has to be a function.");
    }
    if (typeof opts.charset !== "undefined" && opts.charset !== "utf-8" && opts.charset !== "iso-8859-1") {
      throw new TypeError("The charset option must be either utf-8, iso-8859-1, or undefined");
    }
    var charset3 = typeof opts.charset === "undefined" ? defaults2.charset : opts.charset;
    return {
      allowDots: typeof opts.allowDots === "undefined" ? defaults2.allowDots : !!opts.allowDots,
      allowPrototypes: typeof opts.allowPrototypes === "boolean" ? opts.allowPrototypes : defaults2.allowPrototypes,
      allowSparse: typeof opts.allowSparse === "boolean" ? opts.allowSparse : defaults2.allowSparse,
      arrayLimit: typeof opts.arrayLimit === "number" ? opts.arrayLimit : defaults2.arrayLimit,
      charset: charset3,
      charsetSentinel: typeof opts.charsetSentinel === "boolean" ? opts.charsetSentinel : defaults2.charsetSentinel,
      comma: typeof opts.comma === "boolean" ? opts.comma : defaults2.comma,
      decoder: typeof opts.decoder === "function" ? opts.decoder : defaults2.decoder,
      delimiter: typeof opts.delimiter === "string" || utils2.isRegExp(opts.delimiter) ? opts.delimiter : defaults2.delimiter,
      // eslint-disable-next-line no-implicit-coercion, no-extra-parens
      depth: typeof opts.depth === "number" || opts.depth === false ? +opts.depth : defaults2.depth,
      ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
      interpretNumericEntities: typeof opts.interpretNumericEntities === "boolean" ? opts.interpretNumericEntities : defaults2.interpretNumericEntities,
      parameterLimit: typeof opts.parameterLimit === "number" ? opts.parameterLimit : defaults2.parameterLimit,
      parseArrays: opts.parseArrays !== false,
      plainObjects: typeof opts.plainObjects === "boolean" ? opts.plainObjects : defaults2.plainObjects,
      strictNullHandling: typeof opts.strictNullHandling === "boolean" ? opts.strictNullHandling : defaults2.strictNullHandling
    };
  };
  parse$7 = function(str2, opts) {
    var options = normalizeParseOptions(opts);
    if (str2 === "" || str2 === null || typeof str2 === "undefined") {
      return options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    }
    var tempObj = typeof str2 === "string" ? parseValues(str2, options) : str2;
    var obj = options.plainObjects ? /* @__PURE__ */ Object.create(null) : {};
    var keys2 = Object.keys(tempObj);
    for (var i = 0; i < keys2.length; ++i) {
      var key = keys2[i];
      var newObj = parseKeys(key, tempObj[key], options, typeof str2 === "string");
      obj = utils2.merge(obj, newObj, options);
    }
    if (options.allowSparse === true) {
      return obj;
    }
    return utils2.compact(obj);
  };
  return parse$7;
}
var lib$4;
var hasRequiredLib;
function requireLib() {
  if (hasRequiredLib) return lib$4;
  hasRequiredLib = 1;
  var stringify2 = requireStringify();
  var parse2 = requireParse();
  var formats2 = requireFormats();
  lib$4 = {
    formats: formats2,
    parse: parse2,
    stringify: stringify2
  };
  return lib$4;
}
/*!
 * body-parser
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var urlencoded_1;
var hasRequiredUrlencoded;
function requireUrlencoded() {
  if (hasRequiredUrlencoded) return urlencoded_1;
  hasRequiredUrlencoded = 1;
  var bytes2 = requireBytes();
  var contentType$1 = contentType;
  var createError2 = httpErrorsExports;
  var debug2 = requireSrc()("body-parser:urlencoded");
  var deprecate2 = depd_1("body-parser");
  var read = requireRead();
  var typeis2 = typeIsExports;
  urlencoded_1 = urlencoded2;
  var parsers = /* @__PURE__ */ Object.create(null);
  function urlencoded2(options) {
    var opts = options || {};
    if (opts.extended === void 0) {
      deprecate2("undefined extended: provide extended option");
    }
    var extended = opts.extended !== false;
    var inflate2 = opts.inflate !== false;
    var limit = typeof opts.limit !== "number" ? bytes2.parse(opts.limit || "100kb") : opts.limit;
    var type3 = opts.type || "application/x-www-form-urlencoded";
    var verify = opts.verify || false;
    if (verify !== false && typeof verify !== "function") {
      throw new TypeError("option verify must be function");
    }
    var queryparse = extended ? extendedparser(opts) : simpleparser(opts);
    var shouldParse = typeof type3 !== "function" ? typeChecker(type3) : type3;
    function parse2(body) {
      return body.length ? queryparse(body) : {};
    }
    return function urlencodedParser(req2, res2, next) {
      if (req2._body) {
        debug2("body already parsed");
        next();
        return;
      }
      req2.body = req2.body || {};
      if (!typeis2.hasBody(req2)) {
        debug2("skip empty body");
        next();
        return;
      }
      debug2("content-type %j", req2.headers["content-type"]);
      if (!shouldParse(req2)) {
        debug2("skip parsing");
        next();
        return;
      }
      var charset3 = getCharset(req2) || "utf-8";
      if (charset3 !== "utf-8") {
        debug2("invalid charset");
        next(createError2(415, 'unsupported charset "' + charset3.toUpperCase() + '"', {
          charset: charset3,
          type: "charset.unsupported"
        }));
        return;
      }
      read(req2, res2, next, parse2, debug2, {
        debug: debug2,
        encoding: charset3,
        inflate: inflate2,
        limit,
        verify
      });
    };
  }
  function extendedparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("qs");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      var arrayLimit = Math.max(100, paramCount);
      debug2("parse extended urlencoding");
      return parse2(body, {
        allowPrototypes: true,
        arrayLimit,
        depth: Infinity,
        parameterLimit
      });
    };
  }
  function getCharset(req2) {
    try {
      return (contentType$1.parse(req2).parameters.charset || "").toLowerCase();
    } catch (e) {
      return void 0;
    }
  }
  function parameterCount(body, limit) {
    var count = 0;
    var index2 = 0;
    while ((index2 = body.indexOf("&", index2)) !== -1) {
      count++;
      index2++;
      if (count === limit) {
        return void 0;
      }
    }
    return count;
  }
  function parser(name2) {
    var mod = parsers[name2];
    if (mod !== void 0) {
      return mod.parse;
    }
    switch (name2) {
      case "qs":
        mod = requireLib();
        break;
      case "querystring":
        mod = require$$8;
        break;
    }
    parsers[name2] = mod;
    return mod.parse;
  }
  function simpleparser(options) {
    var parameterLimit = options.parameterLimit !== void 0 ? options.parameterLimit : 1e3;
    var parse2 = parser("querystring");
    if (isNaN(parameterLimit) || parameterLimit < 1) {
      throw new TypeError("option parameterLimit must be a positive number");
    }
    if (isFinite(parameterLimit)) {
      parameterLimit = parameterLimit | 0;
    }
    return function queryparse(body) {
      var paramCount = parameterCount(body, parameterLimit);
      if (paramCount === void 0) {
        debug2("too many parameters");
        throw createError2(413, "too many parameters", {
          type: "parameters.too.many"
        });
      }
      debug2("parse urlencoding");
      return parse2(body, void 0, void 0, { maxKeys: parameterLimit });
    };
  }
  function typeChecker(type3) {
    return function checkType(req2) {
      return Boolean(typeis2(req2, type3));
    };
  }
  return urlencoded_1;
}
/*!
 * body-parser
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module2, exports) {
  var deprecate2 = depd_1("body-parser");
  var parsers = /* @__PURE__ */ Object.create(null);
  exports = module2.exports = deprecate2.function(
    bodyParser2,
    "bodyParser: use individual json/urlencoded middlewares"
  );
  Object.defineProperty(exports, "json", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("json")
  });
  Object.defineProperty(exports, "raw", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("raw")
  });
  Object.defineProperty(exports, "text", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("text")
  });
  Object.defineProperty(exports, "urlencoded", {
    configurable: true,
    enumerable: true,
    get: createParserGetter("urlencoded")
  });
  function bodyParser2(options) {
    var opts = Object.create(options || null, {
      type: {
        configurable: true,
        enumerable: true,
        value: void 0,
        writable: true
      }
    });
    var _urlencoded = exports.urlencoded(opts);
    var _json = exports.json(opts);
    return function bodyParser3(req2, res2, next) {
      _json(req2, res2, function(err) {
        if (err) return next(err);
        _urlencoded(req2, res2, next);
      });
    };
  }
  function createParserGetter(name2) {
    return function get2() {
      return loadParser(name2);
    };
  }
  function loadParser(parserName) {
    var parser = parsers[parserName];
    if (parser !== void 0) {
      return parser;
    }
    switch (parserName) {
      case "json":
        parser = requireJson();
        break;
      case "raw":
        parser = requireRaw();
        break;
      case "text":
        parser = requireText();
        break;
      case "urlencoded":
        parser = requireUrlencoded();
        break;
    }
    return parsers[parserName] = parser;
  }
})(bodyParser, bodyParser.exports);
var bodyParserExports = bodyParser.exports;
/*!
 * merge-descriptors
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var mergeDescriptors = merge$2;
var hasOwnProperty$4 = Object.prototype.hasOwnProperty;
function merge$2(dest, src2, redefine) {
  if (!dest) {
    throw new TypeError("argument dest is required");
  }
  if (!src2) {
    throw new TypeError("argument src is required");
  }
  if (redefine === void 0) {
    redefine = true;
  }
  Object.getOwnPropertyNames(src2).forEach(function forEachOwnPropertyName(name2) {
    if (!redefine && hasOwnProperty$4.call(dest, name2)) {
      return;
    }
    var descriptor = Object.getOwnPropertyDescriptor(src2, name2);
    Object.defineProperty(dest, name2, descriptor);
  });
  return dest;
}
var application = { exports: {} };
var src$4 = { exports: {} };
var browser$3 = { exports: {} };
var debug$l = { exports: {} };
var ms$5;
var hasRequiredMs$3;
function requireMs$3() {
  if (hasRequiredMs$3) return ms$5;
  hasRequiredMs$3 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$5 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name2) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name2;
    }
    return Math.ceil(ms2 / n) + " " + name2 + "s";
  }
  return ms$5;
}
var hasRequiredDebug$2;
function requireDebug$2() {
  if (hasRequiredDebug$2) return debug$l.exports;
  hasRequiredDebug$2 = 1;
  (function(module2, exports) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce2;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$3();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports.colors[Math.abs(hash2) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled) return;
        var self3 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self3.diff = ms2;
        self3.prev = prevTime;
        self3.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self3, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self3, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self3, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name2) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$l, debug$l.exports);
  return debug$l.exports;
}
var hasRequiredBrowser$3;
function requireBrowser$3() {
  if (hasRequiredBrowser$3) return browser$3.exports;
  hasRequiredBrowser$3 = 1;
  (function(module2, exports) {
    exports = module2.exports = requireDebug$2();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$3, browser$3.exports);
  return browser$3.exports;
}
var node$4 = { exports: {} };
var hasRequiredNode$3;
function requireNode$3() {
  if (hasRequiredNode$3) return node$4.exports;
  hasRequiredNode$3 = 1;
  (function(module2, exports) {
    var tty = require$$0$5;
    var util2 = require$$1$3;
    exports = module2.exports = requireDebug$2();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$0$7;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$0$6;
          stream22 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$4, node$4.exports);
  return node$4.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$4.exports = requireBrowser$3();
} else {
  src$4.exports = requireNode$3();
}
var srcExports$3 = src$4.exports;
/*!
 * encodeurl
 * Copyright(c) 2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var encodeurl = encodeUrl$3;
var ENCODE_CHARS_REGEXP = /(?:[^\x21\x25\x26-\x3B\x3D\x3F-\x5B\x5D\x5F\x61-\x7A\x7E]|%(?:[^0-9A-Fa-f]|[0-9A-Fa-f][^0-9A-Fa-f]|$))+/g;
var UNMATCHED_SURROGATE_PAIR_REGEXP = /(^|[^\uD800-\uDBFF])[\uDC00-\uDFFF]|[\uD800-\uDBFF]([^\uDC00-\uDFFF]|$)/g;
var UNMATCHED_SURROGATE_PAIR_REPLACE = "$1ï¿½$2";
function encodeUrl$3(url2) {
  return String(url2).replace(UNMATCHED_SURROGATE_PAIR_REGEXP, UNMATCHED_SURROGATE_PAIR_REPLACE).replace(ENCODE_CHARS_REGEXP, encodeURI);
}
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */
var matchHtmlRegExp = /["'&<>]/;
var escapeHtml_1 = escapeHtml$3;
function escapeHtml$3(string2) {
  var str2 = "" + string2;
  var match2 = matchHtmlRegExp.exec(str2);
  if (!match2) {
    return str2;
  }
  var escape2;
  var html = "";
  var index2 = 0;
  var lastIndex = 0;
  for (index2 = match2.index; index2 < str2.length; index2++) {
    switch (str2.charCodeAt(index2)) {
      case 34:
        escape2 = "&quot;";
        break;
      case 38:
        escape2 = "&amp;";
        break;
      case 39:
        escape2 = "&#39;";
        break;
      case 60:
        escape2 = "&lt;";
        break;
      case 62:
        escape2 = "&gt;";
        break;
      default:
        continue;
    }
    if (lastIndex !== index2) {
      html += str2.substring(lastIndex, index2);
    }
    lastIndex = index2 + 1;
    html += escape2;
  }
  return lastIndex !== index2 ? html + str2.substring(lastIndex, index2) : html;
}
var parseurl$1 = { exports: {} };
/*!
 * parseurl
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var url$3 = require$$5$2;
var parse$6 = url$3.parse;
var Url = url$3.Url;
parseurl$1.exports = parseurl;
parseurl$1.exports.original = originalurl;
function parseurl(req2) {
  var url2 = req2.url;
  if (url2 === void 0) {
    return void 0;
  }
  var parsed = req2._parsedUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedUrl = parsed;
}
function originalurl(req2) {
  var url2 = req2.originalUrl;
  if (typeof url2 !== "string") {
    return parseurl(req2);
  }
  var parsed = req2._parsedOriginalUrl;
  if (fresh$3(url2, parsed)) {
    return parsed;
  }
  parsed = fastparse(url2);
  parsed._raw = url2;
  return req2._parsedOriginalUrl = parsed;
}
function fastparse(str2) {
  if (typeof str2 !== "string" || str2.charCodeAt(0) !== 47) {
    return parse$6(str2);
  }
  var pathname = str2;
  var query = null;
  var search = null;
  for (var i = 1; i < str2.length; i++) {
    switch (str2.charCodeAt(i)) {
      case 63:
        if (search === null) {
          pathname = str2.substring(0, i);
          query = str2.substring(i + 1);
          search = str2.substring(i);
        }
        break;
      case 9:
      case 10:
      case 12:
      case 13:
      case 32:
      case 35:
      case 160:
      case 65279:
        return parse$6(str2);
    }
  }
  var url2 = Url !== void 0 ? new Url() : {};
  url2.path = str2;
  url2.href = str2;
  url2.pathname = pathname;
  if (search !== null) {
    url2.query = query;
    url2.search = search;
  }
  return url2;
}
function fresh$3(url2, parsedUrl) {
  return typeof parsedUrl === "object" && parsedUrl !== null && (Url === void 0 || parsedUrl instanceof Url) && parsedUrl._raw === url2;
}
var parseurlExports = parseurl$1.exports;
/*!
 * finalhandler
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$k = srcExports$3("finalhandler");
var encodeUrl$2 = encodeurl;
var escapeHtml$2 = escapeHtml_1;
var onFinished$2 = onFinishedExports;
var parseUrl$4 = parseurlExports;
var statuses$2 = statuses$3;
var unpipe = unpipe_1;
var DOUBLE_SPACE_REGEXP = /\x20{2}/g;
var NEWLINE_REGEXP = /\n/g;
var defer$2 = typeof setImmediate === "function" ? setImmediate : function(fn) {
  process.nextTick(fn.bind.apply(fn, arguments));
};
var isFinished = onFinished$2.isFinished;
function createHtmlDocument$1(message) {
  var body = escapeHtml$2(message).replace(NEWLINE_REGEXP, "<br>").replace(DOUBLE_SPACE_REGEXP, " &nbsp;");
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>Error</title>\n</head>\n<body>\n<pre>' + body + "</pre>\n</body>\n</html>\n";
}
var finalhandler_1 = finalhandler;
function finalhandler(req2, res2, options) {
  var opts = options || {};
  var env = opts.env || process.env.NODE_ENV || "development";
  var onerror = opts.onerror;
  return function(err) {
    var headers;
    var msg;
    var status3;
    if (!err && headersSent$1(res2)) {
      debug$k("cannot 404 after headers sent");
      return;
    }
    if (err) {
      status3 = getErrorStatusCode(err);
      if (status3 === void 0) {
        status3 = getResponseStatusCode(res2);
      } else {
        headers = getErrorHeaders(err);
      }
      msg = getErrorMessage(err, status3, env);
    } else {
      status3 = 404;
      msg = "Cannot " + req2.method + " " + encodeUrl$2(getResourceName(req2));
    }
    debug$k("default %s", status3);
    if (err && onerror) {
      defer$2(onerror, err, req2, res2);
    }
    if (headersSent$1(res2)) {
      debug$k("cannot %d after headers sent", status3);
      req2.socket.destroy();
      return;
    }
    send$3(req2, res2, status3, headers, msg);
  };
}
function getErrorHeaders(err) {
  if (!err.headers || typeof err.headers !== "object") {
    return void 0;
  }
  var headers = /* @__PURE__ */ Object.create(null);
  var keys2 = Object.keys(err.headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    headers[key] = err.headers[key];
  }
  return headers;
}
function getErrorMessage(err, status3, env) {
  var msg;
  if (env !== "production") {
    msg = err.stack;
    if (!msg && typeof err.toString === "function") {
      msg = err.toString();
    }
  }
  return msg || statuses$2.message[status3];
}
function getErrorStatusCode(err) {
  if (typeof err.status === "number" && err.status >= 400 && err.status < 600) {
    return err.status;
  }
  if (typeof err.statusCode === "number" && err.statusCode >= 400 && err.statusCode < 600) {
    return err.statusCode;
  }
  return void 0;
}
function getResourceName(req2) {
  try {
    return parseUrl$4.original(req2).pathname;
  } catch (e) {
    return "resource";
  }
}
function getResponseStatusCode(res2) {
  var status3 = res2.statusCode;
  if (typeof status3 !== "number" || status3 < 400 || status3 > 599) {
    status3 = 500;
  }
  return status3;
}
function headersSent$1(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function send$3(req2, res2, status3, headers, message) {
  function write() {
    var body = createHtmlDocument$1(message);
    res2.statusCode = status3;
    res2.statusMessage = statuses$2.message[status3];
    res2.removeHeader("Content-Encoding");
    res2.removeHeader("Content-Language");
    res2.removeHeader("Content-Range");
    setHeaders$1(res2, headers);
    res2.setHeader("Content-Security-Policy", "default-src 'none'");
    res2.setHeader("X-Content-Type-Options", "nosniff");
    res2.setHeader("Content-Type", "text/html; charset=utf-8");
    res2.setHeader("Content-Length", Buffer.byteLength(body, "utf8"));
    if (req2.method === "HEAD") {
      res2.end();
      return;
    }
    res2.end(body, "utf8");
  }
  if (isFinished(req2)) {
    write();
    return;
  }
  unpipe(req2);
  onFinished$2(req2, write);
  req2.resume();
}
function setHeaders$1(res2, headers) {
  if (!headers) {
    return;
  }
  var keys2 = Object.keys(headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    res2.setHeader(key, headers[key]);
  }
}
var router = { exports: {} };
var src$3 = { exports: {} };
var browser$2 = { exports: {} };
var debug$j = { exports: {} };
var ms$4;
var hasRequiredMs$2;
function requireMs$2() {
  if (hasRequiredMs$2) return ms$4;
  hasRequiredMs$2 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$4 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name2) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name2;
    }
    return Math.ceil(ms2 / n) + " " + name2 + "s";
  }
  return ms$4;
}
var hasRequiredDebug$1;
function requireDebug$1() {
  if (hasRequiredDebug$1) return debug$j.exports;
  hasRequiredDebug$1 = 1;
  (function(module2, exports) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce2;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$2();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports.colors[Math.abs(hash2) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled) return;
        var self3 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self3.diff = ms2;
        self3.prev = prevTime;
        self3.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self3, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self3, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self3, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name2) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$j, debug$j.exports);
  return debug$j.exports;
}
var hasRequiredBrowser$2;
function requireBrowser$2() {
  if (hasRequiredBrowser$2) return browser$2.exports;
  hasRequiredBrowser$2 = 1;
  (function(module2, exports) {
    exports = module2.exports = requireDebug$1();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$2, browser$2.exports);
  return browser$2.exports;
}
var node$3 = { exports: {} };
var hasRequiredNode$2;
function requireNode$2() {
  if (hasRequiredNode$2) return node$3.exports;
  hasRequiredNode$2 = 1;
  (function(module2, exports) {
    var tty = require$$0$5;
    var util2 = require$$1$3;
    exports = module2.exports = requireDebug$1();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$0$7;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$0$6;
          stream22 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$3, node$3.exports);
  return node$3.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$3.exports = requireBrowser$2();
} else {
  src$3.exports = requireNode$2();
}
var srcExports$2 = src$3.exports;
var arrayFlatten_1 = arrayFlatten;
function flattenWithDepth(array2, result, depth) {
  for (var i = 0; i < array2.length; i++) {
    var value2 = array2[i];
    if (depth > 0 && Array.isArray(value2)) {
      flattenWithDepth(value2, result, depth - 1);
    } else {
      result.push(value2);
    }
  }
  return result;
}
function flattenForever(array2, result) {
  for (var i = 0; i < array2.length; i++) {
    var value2 = array2[i];
    if (Array.isArray(value2)) {
      flattenForever(value2, result);
    } else {
      result.push(value2);
    }
  }
  return result;
}
function arrayFlatten(array2, depth) {
  if (depth == null) {
    return flattenForever(array2, []);
  }
  return flattenWithDepth(array2, [], depth);
}
var pathToRegexp = pathtoRegexp;
var MATCHING_GROUP_REGEXP = /\((?!\?)/g;
function pathtoRegexp(path3, keys2, options) {
  options = options || {};
  keys2 = keys2 || [];
  var strict = options.strict;
  var end = options.end !== false;
  var flags = options.sensitive ? "" : "i";
  var extraOffset = 0;
  var keysOffset = keys2.length;
  var i = 0;
  var name2 = 0;
  var m2;
  if (path3 instanceof RegExp) {
    while (m2 = MATCHING_GROUP_REGEXP.exec(path3.source)) {
      keys2.push({
        name: name2++,
        optional: false,
        offset: m2.index
      });
    }
    return path3;
  }
  if (Array.isArray(path3)) {
    path3 = path3.map(function(value2) {
      return pathtoRegexp(value2, keys2, options).source;
    });
    return new RegExp("(?:" + path3.join("|") + ")", flags);
  }
  path3 = ("^" + path3 + (strict ? "" : path3[path3.length - 1] === "/" ? "?" : "/?")).replace(/\/\(/g, "/(?:").replace(/([\/\.])/g, "\\$1").replace(/(\\\/)?(\\\.)?:(\w+)(\(.*?\))?(\*)?(\?)?/g, function(match2, slash, format2, key, capture, star, optional, offset) {
    slash = slash || "";
    format2 = format2 || "";
    capture = capture || "([^\\/" + format2 + "]+?)";
    optional = optional || "";
    keys2.push({
      name: key,
      optional: !!optional,
      offset: offset + extraOffset
    });
    var result = "" + (optional ? "" : slash) + "(?:" + format2 + (optional ? slash : "") + capture + (star ? "((?:[\\/" + format2 + "].+?)?)" : "") + ")" + optional;
    extraOffset += result.length - match2.length;
    return result;
  }).replace(/\*/g, function(star, index3) {
    var len = keys2.length;
    while (len-- > keysOffset && keys2[len].offset > index3) {
      keys2[len].offset += 3;
    }
    return "(.*)";
  });
  while (m2 = MATCHING_GROUP_REGEXP.exec(path3)) {
    var escapeCount = 0;
    var index2 = m2.index;
    while (path3.charAt(--index2) === "\\") {
      escapeCount++;
    }
    if (escapeCount % 2 === 1) {
      continue;
    }
    if (keysOffset + i === keys2.length || keys2[keysOffset + i].offset > m2.index) {
      keys2.splice(keysOffset + i, 0, {
        name: name2++,
        // Unnamed matching groups must be consistently linear.
        optional: false,
        offset: m2.index
      });
    }
    i++;
  }
  path3 += end ? "$" : path3[path3.length - 1] === "/" ? "" : "(?=\\/|$)";
  return new RegExp(path3, flags);
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var pathRegexp = pathToRegexp;
var debug$i = srcExports$2("express:router:layer");
var hasOwnProperty$3 = Object.prototype.hasOwnProperty;
var layer = Layer$2;
function Layer$2(path3, options, fn) {
  if (!(this instanceof Layer$2)) {
    return new Layer$2(path3, options, fn);
  }
  debug$i("new %o", path3);
  var opts = options || {};
  this.handle = fn;
  this.name = fn.name || "<anonymous>";
  this.params = void 0;
  this.path = void 0;
  this.regexp = pathRegexp(path3, this.keys = [], opts);
  this.regexp.fast_star = path3 === "*";
  this.regexp.fast_slash = path3 === "/" && opts.end === false;
}
Layer$2.prototype.handle_error = function handle_error(error2, req2, res2, next) {
  var fn = this.handle;
  if (fn.length !== 4) {
    return next(error2);
  }
  try {
    fn(error2, req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.handle_request = function handle(req2, res2, next) {
  var fn = this.handle;
  if (fn.length > 3) {
    return next();
  }
  try {
    fn(req2, res2, next);
  } catch (err) {
    next(err);
  }
};
Layer$2.prototype.match = function match(path3) {
  var match2;
  if (path3 != null) {
    if (this.regexp.fast_slash) {
      this.params = {};
      this.path = "";
      return true;
    }
    if (this.regexp.fast_star) {
      this.params = { "0": decode_param(path3) };
      this.path = path3;
      return true;
    }
    match2 = this.regexp.exec(path3);
  }
  if (!match2) {
    this.params = void 0;
    this.path = void 0;
    return false;
  }
  this.params = {};
  this.path = match2[0];
  var keys2 = this.keys;
  var params = this.params;
  for (var i = 1; i < match2.length; i++) {
    var key = keys2[i - 1];
    var prop = key.name;
    var val = decode_param(match2[i]);
    if (val !== void 0 || !hasOwnProperty$3.call(params, prop)) {
      params[prop] = val;
    }
  }
  return true;
};
function decode_param(val) {
  if (typeof val !== "string" || val.length === 0) {
    return val;
  }
  try {
    return decodeURIComponent(val);
  } catch (err) {
    if (err instanceof URIError) {
      err.message = "Failed to decode param '" + val + "'";
      err.status = err.statusCode = 400;
    }
    throw err;
  }
}
/*!
 * methods
 * Copyright(c) 2013-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var http$a = require$$0$a;
var methods$4 = getCurrentNodeMethods() || getBasicNodeMethods();
function getCurrentNodeMethods() {
  return http$a.METHODS && http$a.METHODS.map(function lowerCaseMethod(method) {
    return method.toLowerCase();
  });
}
function getBasicNodeMethods() {
  return [
    "get",
    "post",
    "put",
    "head",
    "delete",
    "options",
    "trace",
    "copy",
    "lock",
    "mkcol",
    "move",
    "purge",
    "propfind",
    "proppatch",
    "unlock",
    "report",
    "mkactivity",
    "checkout",
    "merge",
    "m-search",
    "notify",
    "subscribe",
    "unsubscribe",
    "patch",
    "search",
    "connect"
  ];
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$h = srcExports$2("express:router:route");
var flatten$1 = arrayFlatten_1;
var Layer$1 = layer;
var methods$3 = methods$4;
var slice$3 = Array.prototype.slice;
var toString$3 = Object.prototype.toString;
var route = Route$1;
function Route$1(path3) {
  this.path = path3;
  this.stack = [];
  debug$h("new %o", path3);
  this.methods = {};
}
Route$1.prototype._handles_method = function _handles_method(method) {
  if (this.methods._all) {
    return true;
  }
  var name2 = typeof method === "string" ? method.toLowerCase() : method;
  if (name2 === "head" && !this.methods["head"]) {
    name2 = "get";
  }
  return Boolean(this.methods[name2]);
};
Route$1.prototype._options = function _options() {
  var methods2 = Object.keys(this.methods);
  if (this.methods.get && !this.methods.head) {
    methods2.push("head");
  }
  for (var i = 0; i < methods2.length; i++) {
    methods2[i] = methods2[i].toUpperCase();
  }
  return methods2;
};
Route$1.prototype.dispatch = function dispatch(req2, res2, done) {
  var idx = 0;
  var stack = this.stack;
  var sync = 0;
  if (stack.length === 0) {
    return done();
  }
  var method = typeof req2.method === "string" ? req2.method.toLowerCase() : req2.method;
  if (method === "head" && !this.methods["head"]) {
    method = "get";
  }
  req2.route = this;
  next();
  function next(err) {
    if (err && err === "route") {
      return done();
    }
    if (err && err === "router") {
      return done(err);
    }
    if (++sync > 100) {
      return setImmediate(next, err);
    }
    var layer2 = stack[idx++];
    if (!layer2) {
      return done(err);
    }
    if (layer2.method && layer2.method !== method) {
      next(err);
    } else if (err) {
      layer2.handle_error(err, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
    sync = 0;
  }
};
Route$1.prototype.all = function all() {
  var handles = flatten$1(slice$3.call(arguments));
  for (var i = 0; i < handles.length; i++) {
    var handle3 = handles[i];
    if (typeof handle3 !== "function") {
      var type3 = toString$3.call(handle3);
      var msg = "Route.all() requires a callback function but got a " + type3;
      throw new TypeError(msg);
    }
    var layer2 = Layer$1("/", {}, handle3);
    layer2.method = void 0;
    this.methods._all = true;
    this.stack.push(layer2);
  }
  return this;
};
methods$3.forEach(function(method) {
  Route$1.prototype[method] = function() {
    var handles = flatten$1(slice$3.call(arguments));
    for (var i = 0; i < handles.length; i++) {
      var handle3 = handles[i];
      if (typeof handle3 !== "function") {
        var type3 = toString$3.call(handle3);
        var msg = "Route." + method + "() requires a callback function but got a " + type3;
        throw new Error(msg);
      }
      debug$h("%s %o", method, this.path);
      var layer2 = Layer$1("/", {}, handle3);
      layer2.method = method;
      this.methods[method] = true;
      this.stack.push(layer2);
    }
    return this;
  };
});
var utilsMerge = { exports: {} };
(function(module2, exports) {
  module2.exports = function(a, b) {
    if (a && b) {
      for (var key in b) {
        a[key] = b[key];
      }
    }
    return a;
  };
})(utilsMerge);
var utilsMergeExports = utilsMerge.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Route = route;
var Layer = layer;
var methods$2 = methods$4;
var mixin$2 = utilsMergeExports;
var debug$g = srcExports$2("express:router");
var deprecate$3 = depd_1("express");
var flatten = arrayFlatten_1;
var parseUrl$3 = parseurlExports;
var setPrototypeOf$3 = setprototypeof;
var objectRegExp = /^\[object (\S+)\]$/;
var slice$2 = Array.prototype.slice;
var toString$2 = Object.prototype.toString;
var proto$1 = router.exports = function(options) {
  var opts = options || {};
  function router2(req2, res2, next) {
    router2.handle(req2, res2, next);
  }
  setPrototypeOf$3(router2, proto$1);
  router2.params = {};
  router2._params = [];
  router2.caseSensitive = opts.caseSensitive;
  router2.mergeParams = opts.mergeParams;
  router2.strict = opts.strict;
  router2.stack = [];
  return router2;
};
proto$1.param = function param(name2, fn) {
  if (typeof name2 === "function") {
    deprecate$3("router.param(fn): Refactor to use path params");
    this._params.push(name2);
    return;
  }
  var params = this._params;
  var len = params.length;
  var ret;
  if (name2[0] === ":") {
    deprecate$3("router.param(" + JSON.stringify(name2) + ", fn): Use router.param(" + JSON.stringify(name2.slice(1)) + ", fn) instead");
    name2 = name2.slice(1);
  }
  for (var i = 0; i < len; ++i) {
    if (ret = params[i](name2, fn)) {
      fn = ret;
    }
  }
  if ("function" !== typeof fn) {
    throw new Error("invalid param() call for " + name2 + ", got " + fn);
  }
  (this.params[name2] = this.params[name2] || []).push(fn);
  return this;
};
proto$1.handle = function handle2(req2, res2, out) {
  var self3 = this;
  debug$g("dispatching %s %s", req2.method, req2.url);
  var idx = 0;
  var protohost = getProtohost(req2.url) || "";
  var removed = "";
  var slashAdded = false;
  var sync = 0;
  var paramcalled = {};
  var options = [];
  var stack = self3.stack;
  var parentParams = req2.params;
  var parentUrl = req2.baseUrl || "";
  var done = restore(out, req2, "baseUrl", "next", "params");
  req2.next = next;
  if (req2.method === "OPTIONS") {
    done = wrap$1(done, function(old, err) {
      if (err || options.length === 0) return old(err);
      sendOptionsResponse(res2, options, old);
    });
  }
  req2.baseUrl = parentUrl;
  req2.originalUrl = req2.originalUrl || req2.url;
  next();
  function next(err) {
    var layerError = err === "route" ? null : err;
    if (slashAdded) {
      req2.url = req2.url.slice(1);
      slashAdded = false;
    }
    if (removed.length !== 0) {
      req2.baseUrl = parentUrl;
      req2.url = protohost + removed + req2.url.slice(protohost.length);
      removed = "";
    }
    if (layerError === "router") {
      setImmediate(done, null);
      return;
    }
    if (idx >= stack.length) {
      setImmediate(done, layerError);
      return;
    }
    if (++sync > 100) {
      return setImmediate(next, err);
    }
    var path3 = getPathname(req2);
    if (path3 == null) {
      return done(layerError);
    }
    var layer2;
    var match2;
    var route3;
    while (match2 !== true && idx < stack.length) {
      layer2 = stack[idx++];
      match2 = matchLayer(layer2, path3);
      route3 = layer2.route;
      if (typeof match2 !== "boolean") {
        layerError = layerError || match2;
      }
      if (match2 !== true) {
        continue;
      }
      if (!route3) {
        continue;
      }
      if (layerError) {
        match2 = false;
        continue;
      }
      var method = req2.method;
      var has_method = route3._handles_method(method);
      if (!has_method && method === "OPTIONS") {
        appendMethods(options, route3._options());
      }
      if (!has_method && method !== "HEAD") {
        match2 = false;
      }
    }
    if (match2 !== true) {
      return done(layerError);
    }
    if (route3) {
      req2.route = route3;
    }
    req2.params = self3.mergeParams ? mergeParams(layer2.params, parentParams) : layer2.params;
    var layerPath = layer2.path;
    self3.process_params(layer2, paramcalled, req2, res2, function(err2) {
      if (err2) {
        next(layerError || err2);
      } else if (route3) {
        layer2.handle_request(req2, res2, next);
      } else {
        trim_prefix(layer2, layerError, layerPath, path3);
      }
      sync = 0;
    });
  }
  function trim_prefix(layer2, layerError, layerPath, path3) {
    if (layerPath.length !== 0) {
      if (layerPath !== path3.slice(0, layerPath.length)) {
        next(layerError);
        return;
      }
      var c = path3[layerPath.length];
      if (c && c !== "/" && c !== ".") return next(layerError);
      debug$g("trim prefix (%s) from url %s", layerPath, req2.url);
      removed = layerPath;
      req2.url = protohost + req2.url.slice(protohost.length + removed.length);
      if (!protohost && req2.url[0] !== "/") {
        req2.url = "/" + req2.url;
        slashAdded = true;
      }
      req2.baseUrl = parentUrl + (removed[removed.length - 1] === "/" ? removed.substring(0, removed.length - 1) : removed);
    }
    debug$g("%s %s : %s", layer2.name, layerPath, req2.originalUrl);
    if (layerError) {
      layer2.handle_error(layerError, req2, res2, next);
    } else {
      layer2.handle_request(req2, res2, next);
    }
  }
};
proto$1.process_params = function process_params(layer2, called, req2, res2, done) {
  var params = this.params;
  var keys2 = layer2.keys;
  if (!keys2 || keys2.length === 0) {
    return done();
  }
  var i = 0;
  var name2;
  var paramIndex = 0;
  var key;
  var paramVal;
  var paramCallbacks;
  var paramCalled;
  function param3(err) {
    if (err) {
      return done(err);
    }
    if (i >= keys2.length) {
      return done();
    }
    paramIndex = 0;
    key = keys2[i++];
    name2 = key.name;
    paramVal = req2.params[name2];
    paramCallbacks = params[name2];
    paramCalled = called[name2];
    if (paramVal === void 0 || !paramCallbacks) {
      return param3();
    }
    if (paramCalled && (paramCalled.match === paramVal || paramCalled.error && paramCalled.error !== "route")) {
      req2.params[name2] = paramCalled.value;
      return param3(paramCalled.error);
    }
    called[name2] = paramCalled = {
      error: null,
      match: paramVal,
      value: paramVal
    };
    paramCallback();
  }
  function paramCallback(err) {
    var fn = paramCallbacks[paramIndex++];
    paramCalled.value = req2.params[key.name];
    if (err) {
      paramCalled.error = err;
      param3(err);
      return;
    }
    if (!fn) return param3();
    try {
      fn(req2, res2, paramCallback, paramVal, key.name);
    } catch (e) {
      paramCallback(e);
    }
  }
  param3();
};
proto$1.use = function use(fn) {
  var offset = 0;
  var path3 = "/";
  if (typeof fn !== "function") {
    var arg = fn;
    while (Array.isArray(arg) && arg.length !== 0) {
      arg = arg[0];
    }
    if (typeof arg !== "function") {
      offset = 1;
      path3 = fn;
    }
  }
  var callbacks = flatten(slice$2.call(arguments, offset));
  if (callbacks.length === 0) {
    throw new TypeError("Router.use() requires a middleware function");
  }
  for (var i = 0; i < callbacks.length; i++) {
    var fn = callbacks[i];
    if (typeof fn !== "function") {
      throw new TypeError("Router.use() requires a middleware function but got a " + gettype(fn));
    }
    debug$g("use %o %s", path3, fn.name || "<anonymous>");
    var layer2 = new Layer(path3, {
      sensitive: this.caseSensitive,
      strict: false,
      end: false
    }, fn);
    layer2.route = void 0;
    this.stack.push(layer2);
  }
  return this;
};
proto$1.route = function route2(path3) {
  var route3 = new Route(path3);
  var layer2 = new Layer(path3, {
    sensitive: this.caseSensitive,
    strict: this.strict,
    end: true
  }, route3.dispatch.bind(route3));
  layer2.route = route3;
  this.stack.push(layer2);
  return route3;
};
methods$2.concat("all").forEach(function(method) {
  proto$1[method] = function(path3) {
    var route3 = this.route(path3);
    route3[method].apply(route3, slice$2.call(arguments, 1));
    return this;
  };
});
function appendMethods(list, addition) {
  for (var i = 0; i < addition.length; i++) {
    var method = addition[i];
    if (list.indexOf(method) === -1) {
      list.push(method);
    }
  }
}
function getPathname(req2) {
  try {
    return parseUrl$3(req2).pathname;
  } catch (err) {
    return void 0;
  }
}
function getProtohost(url2) {
  if (typeof url2 !== "string" || url2.length === 0 || url2[0] === "/") {
    return void 0;
  }
  var searchIndex = url2.indexOf("?");
  var pathLength = searchIndex !== -1 ? searchIndex : url2.length;
  var fqdnIndex = url2.slice(0, pathLength).indexOf("://");
  return fqdnIndex !== -1 ? url2.substring(0, url2.indexOf("/", 3 + fqdnIndex)) : void 0;
}
function gettype(obj) {
  var type3 = typeof obj;
  if (type3 !== "object") {
    return type3;
  }
  return toString$2.call(obj).replace(objectRegExp, "$1");
}
function matchLayer(layer2, path3) {
  try {
    return layer2.match(path3);
  } catch (err) {
    return err;
  }
}
function mergeParams(params, parent) {
  if (typeof parent !== "object" || !parent) {
    return params;
  }
  var obj = mixin$2({}, parent);
  if (!(0 in params) || !(0 in parent)) {
    return mixin$2(obj, params);
  }
  var i = 0;
  var o = 0;
  while (i in params) {
    i++;
  }
  while (o in parent) {
    o++;
  }
  for (i--; i >= 0; i--) {
    params[i + o] = params[i];
    if (i < o) {
      delete params[i];
    }
  }
  return mixin$2(obj, params);
}
function restore(fn, obj) {
  var props = new Array(arguments.length - 2);
  var vals = new Array(arguments.length - 2);
  for (var i = 0; i < props.length; i++) {
    props[i] = arguments[i + 2];
    vals[i] = obj[props[i]];
  }
  return function() {
    for (var i2 = 0; i2 < props.length; i2++) {
      obj[props[i2]] = vals[i2];
    }
    return fn.apply(this, arguments);
  };
}
function sendOptionsResponse(res2, options, next) {
  try {
    var body = options.join(",");
    res2.set("Allow", body);
    res2.send(body);
  } catch (err) {
    next(err);
  }
}
function wrap$1(old, fn) {
  return function proxy() {
    var args = new Array(arguments.length + 1);
    args[0] = old;
    for (var i = 0, len = arguments.length; i < len; i++) {
      args[i + 1] = arguments[i];
    }
    fn.apply(this, args);
  };
}
var routerExports = router.exports;
var init$1 = {};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var setPrototypeOf$2 = setprototypeof;
init$1.init = function(app2) {
  return function expressInit(req2, res2, next) {
    if (app2.enabled("x-powered-by")) res2.setHeader("X-Powered-By", "Express");
    req2.res = res2;
    res2.req = req2;
    req2.next = next;
    setPrototypeOf$2(req2, app2.request);
    setPrototypeOf$2(res2, app2.response);
    res2.locals = res2.locals || /* @__PURE__ */ Object.create(null);
    next();
  };
};
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var query$1;
var hasRequiredQuery;
function requireQuery() {
  if (hasRequiredQuery) return query$1;
  hasRequiredQuery = 1;
  var merge2 = utilsMergeExports;
  var parseUrl2 = parseurlExports;
  var qs = requireLib();
  query$1 = function query(options) {
    var opts = merge2({}, options);
    var queryparse = qs.parse;
    if (typeof options === "function") {
      queryparse = options;
      opts = void 0;
    }
    if (opts !== void 0 && opts.allowPrototypes === void 0) {
      opts.allowPrototypes = true;
    }
    return function query2(req2, res2, next) {
      if (!req2.query) {
        var val = parseUrl2(req2).query;
        req2.query = queryparse(val, opts);
      }
      next();
    };
  };
  return query$1;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var debug$f = srcExports$2("express:view");
var path$l = require$$1$2;
var fs$p = require$$0$7;
var dirname = path$l.dirname;
var basename$3 = path$l.basename;
var extname$2 = path$l.extname;
var join$2 = path$l.join;
var resolve$2 = path$l.resolve;
var view = View;
function View(name2, options) {
  var opts = options || {};
  this.defaultEngine = opts.defaultEngine;
  this.ext = extname$2(name2);
  this.name = name2;
  this.root = opts.root;
  if (!this.ext && !this.defaultEngine) {
    throw new Error("No default engine was specified and no extension was provided.");
  }
  var fileName = name2;
  if (!this.ext) {
    this.ext = this.defaultEngine[0] !== "." ? "." + this.defaultEngine : this.defaultEngine;
    fileName += this.ext;
  }
  if (!opts.engines[this.ext]) {
    var mod = this.ext.slice(1);
    debug$f('require "%s"', mod);
    var fn = commonjsRequire(mod).__express;
    if (typeof fn !== "function") {
      throw new Error('Module "' + mod + '" does not provide a view engine.');
    }
    opts.engines[this.ext] = fn;
  }
  this.engine = opts.engines[this.ext];
  this.path = this.lookup(fileName);
}
View.prototype.lookup = function lookup(name2) {
  var path3;
  var roots = [].concat(this.root);
  debug$f('lookup "%s"', name2);
  for (var i = 0; i < roots.length && !path3; i++) {
    var root2 = roots[i];
    var loc = resolve$2(root2, name2);
    var dir = dirname(loc);
    var file2 = basename$3(loc);
    path3 = this.resolve(dir, file2);
  }
  return path3;
};
View.prototype.render = function render(options, callback) {
  debug$f('render "%s"', this.path);
  this.engine(this.path, options, callback);
};
View.prototype.resolve = function resolve(dir, file2) {
  var ext = this.ext;
  var path3 = join$2(dir, file2);
  var stat2 = tryStat(path3);
  if (stat2 && stat2.isFile()) {
    return path3;
  }
  path3 = join$2(dir, basename$3(file2, ext), "index" + ext);
  stat2 = tryStat(path3);
  if (stat2 && stat2.isFile()) {
    return path3;
  }
};
function tryStat(path3) {
  debug$f('stat "%s"', path3);
  try {
    return fs$p.statSync(path3);
  } catch (e) {
    return void 0;
  }
}
var utils$6 = {};
var safeBuffer = { exports: {} };
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
(function(module2, exports) {
  var buffer = require$$0$9;
  var Buffer2 = buffer.Buffer;
  function copyProps(src2, dst) {
    for (var key in src2) {
      dst[key] = src2[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding3) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding3 === "string") {
        buf.fill(fill, encoding3);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
})(safeBuffer, safeBuffer.exports);
var safeBufferExports = safeBuffer.exports;
var contentDisposition$2 = { exports: {} };
/*!
 * content-disposition
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
contentDisposition$2.exports = contentDisposition$1;
contentDisposition$2.exports.parse = parse$5;
var basename$2 = require$$1$2.basename;
var Buffer$2 = safeBufferExports.Buffer;
var ENCODE_URL_ATTR_CHAR_REGEXP = /[\x00-\x20"'()*,/:;<=>?@[\\\]{}\x7f]/g;
var HEX_ESCAPE_REGEXP = /%[0-9A-Fa-f]{2}/;
var HEX_ESCAPE_REPLACE_REGEXP = /%([0-9A-Fa-f]{2})/g;
var NON_LATIN1_REGEXP = /[^\x20-\x7e\xa0-\xff]/g;
var QESC_REGEXP = /\\([\u0000-\u007f])/g;
var QUOTE_REGEXP = /([\\"])/g;
var PARAM_REGEXP = /;[\x09\x20]*([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*=[\x09\x20]*("(?:[\x20!\x23-\x5b\x5d-\x7e\x80-\xff]|\\[\x20-\x7e])*"|[!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*/g;
var TEXT_REGEXP = /^[\x20-\x7e\x80-\xff]+$/;
var TOKEN_REGEXP = /^[!#$%&'*+.0-9A-Z^_`a-z|~-]+$/;
var EXT_VALUE_REGEXP = /^([A-Za-z0-9!#$%&+\-^_`{}~]+)'(?:[A-Za-z]{2,3}(?:-[A-Za-z]{3}){0,3}|[A-Za-z]{4,8}|)'((?:%[0-9A-Fa-f]{2}|[A-Za-z0-9!#$&+.^_`|~-])+)$/;
var DISPOSITION_TYPE_REGEXP = /^([!#$%&'*+.0-9A-Z^_`a-z|~-]+)[\x09\x20]*(?:$|;)/;
function contentDisposition$1(filename, options) {
  var opts = options || {};
  var type3 = opts.type || "attachment";
  var params = createparams(filename, opts.fallback);
  return format(new ContentDisposition(type3, params));
}
function createparams(filename, fallback) {
  if (filename === void 0) {
    return;
  }
  var params = {};
  if (typeof filename !== "string") {
    throw new TypeError("filename must be a string");
  }
  if (fallback === void 0) {
    fallback = true;
  }
  if (typeof fallback !== "string" && typeof fallback !== "boolean") {
    throw new TypeError("fallback must be a string or boolean");
  }
  if (typeof fallback === "string" && NON_LATIN1_REGEXP.test(fallback)) {
    throw new TypeError("fallback must be ISO-8859-1 string");
  }
  var name2 = basename$2(filename);
  var isQuotedString = TEXT_REGEXP.test(name2);
  var fallbackName = typeof fallback !== "string" ? fallback && getlatin1(name2) : basename$2(fallback);
  var hasFallback = typeof fallbackName === "string" && fallbackName !== name2;
  if (hasFallback || !isQuotedString || HEX_ESCAPE_REGEXP.test(name2)) {
    params["filename*"] = name2;
  }
  if (isQuotedString || hasFallback) {
    params.filename = hasFallback ? fallbackName : name2;
  }
  return params;
}
function format(obj) {
  var parameters = obj.parameters;
  var type3 = obj.type;
  if (!type3 || typeof type3 !== "string" || !TOKEN_REGEXP.test(type3)) {
    throw new TypeError("invalid type");
  }
  var string2 = String(type3).toLowerCase();
  if (parameters && typeof parameters === "object") {
    var param3;
    var params = Object.keys(parameters).sort();
    for (var i = 0; i < params.length; i++) {
      param3 = params[i];
      var val = param3.substr(-1) === "*" ? ustring(parameters[param3]) : qstring(parameters[param3]);
      string2 += "; " + param3 + "=" + val;
    }
  }
  return string2;
}
function decodefield(str2) {
  var match2 = EXT_VALUE_REGEXP.exec(str2);
  if (!match2) {
    throw new TypeError("invalid extended field value");
  }
  var charset3 = match2[1].toLowerCase();
  var encoded = match2[2];
  var value2;
  var binary = encoded.replace(HEX_ESCAPE_REPLACE_REGEXP, pdecode);
  switch (charset3) {
    case "iso-8859-1":
      value2 = getlatin1(binary);
      break;
    case "utf-8":
      value2 = Buffer$2.from(binary, "binary").toString("utf8");
      break;
    default:
      throw new TypeError("unsupported charset in extended field");
  }
  return value2;
}
function getlatin1(val) {
  return String(val).replace(NON_LATIN1_REGEXP, "?");
}
function parse$5(string2) {
  if (!string2 || typeof string2 !== "string") {
    throw new TypeError("argument string is required");
  }
  var match2 = DISPOSITION_TYPE_REGEXP.exec(string2);
  if (!match2) {
    throw new TypeError("invalid type format");
  }
  var index2 = match2[0].length;
  var type3 = match2[1].toLowerCase();
  var key;
  var names = [];
  var params = {};
  var value2;
  index2 = PARAM_REGEXP.lastIndex = match2[0].substr(-1) === ";" ? index2 - 1 : index2;
  while (match2 = PARAM_REGEXP.exec(string2)) {
    if (match2.index !== index2) {
      throw new TypeError("invalid parameter format");
    }
    index2 += match2[0].length;
    key = match2[1].toLowerCase();
    value2 = match2[2];
    if (names.indexOf(key) !== -1) {
      throw new TypeError("invalid duplicate parameter");
    }
    names.push(key);
    if (key.indexOf("*") + 1 === key.length) {
      key = key.slice(0, -1);
      value2 = decodefield(value2);
      params[key] = value2;
      continue;
    }
    if (typeof params[key] === "string") {
      continue;
    }
    if (value2[0] === '"') {
      value2 = value2.substr(1, value2.length - 2).replace(QESC_REGEXP, "$1");
    }
    params[key] = value2;
  }
  if (index2 !== -1 && index2 !== string2.length) {
    throw new TypeError("invalid parameter format");
  }
  return new ContentDisposition(type3, params);
}
function pdecode(str2, hex) {
  return String.fromCharCode(parseInt(hex, 16));
}
function pencode(char) {
  return "%" + String(char).charCodeAt(0).toString(16).toUpperCase();
}
function qstring(val) {
  var str2 = String(val);
  return '"' + str2.replace(QUOTE_REGEXP, "\\$1") + '"';
}
function ustring(val) {
  var str2 = String(val);
  var encoded = encodeURIComponent(str2).replace(ENCODE_URL_ATTR_CHAR_REGEXP, pencode);
  return "UTF-8''" + encoded;
}
function ContentDisposition(type3, parameters) {
  this.type = type3;
  this.parameters = parameters;
}
var contentDispositionExports = contentDisposition$2.exports;
var send$2 = { exports: {} };
var src$2 = { exports: {} };
var browser$1 = { exports: {} };
var debug$e = { exports: {} };
var ms$3;
var hasRequiredMs$1;
function requireMs$1() {
  if (hasRequiredMs$1) return ms$3;
  hasRequiredMs$1 = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var y2 = d2 * 365.25;
  ms$3 = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isNaN(val) === false) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    if (ms2 >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (ms2 >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (ms2 >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (ms2 >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    return plural2(ms2, d2, "day") || plural2(ms2, h2, "hour") || plural2(ms2, m2, "minute") || plural2(ms2, s2, "second") || ms2 + " ms";
  }
  function plural2(ms2, n, name2) {
    if (ms2 < n) {
      return;
    }
    if (ms2 < n * 1.5) {
      return Math.floor(ms2 / n) + " " + name2;
    }
    return Math.ceil(ms2 / n) + " " + name2 + "s";
  }
  return ms$3;
}
var hasRequiredDebug;
function requireDebug() {
  if (hasRequiredDebug) return debug$e.exports;
  hasRequiredDebug = 1;
  (function(module2, exports) {
    exports = module2.exports = createDebug.debug = createDebug["default"] = createDebug;
    exports.coerce = coerce2;
    exports.disable = disable;
    exports.enable = enable;
    exports.enabled = enabled;
    exports.humanize = requireMs$1();
    exports.names = [];
    exports.skips = [];
    exports.formatters = {};
    var prevTime;
    function selectColor(namespace) {
      var hash2 = 0, i;
      for (i in namespace) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return exports.colors[Math.abs(hash2) % exports.colors.length];
    }
    function createDebug(namespace) {
      function debug2() {
        if (!debug2.enabled) return;
        var self3 = debug2;
        var curr = +/* @__PURE__ */ new Date();
        var ms2 = curr - (prevTime || curr);
        self3.diff = ms2;
        self3.prev = prevTime;
        self3.curr = curr;
        prevTime = curr;
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        args[0] = exports.coerce(args[0]);
        if ("string" !== typeof args[0]) {
          args.unshift("%O");
        }
        var index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format2) {
          if (match2 === "%%") return match2;
          index2++;
          var formatter = exports.formatters[format2];
          if ("function" === typeof formatter) {
            var val = args[index2];
            match2 = formatter.call(self3, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        exports.formatArgs.call(self3, args);
        var logFn = debug2.log || exports.log || console.log.bind(console);
        logFn.apply(self3, args);
      }
      debug2.namespace = namespace;
      debug2.enabled = exports.enabled(namespace);
      debug2.useColors = exports.useColors();
      debug2.color = selectColor(namespace);
      if ("function" === typeof exports.init) {
        exports.init(debug2);
      }
      return debug2;
    }
    function enable(namespaces) {
      exports.save(namespaces);
      exports.names = [];
      exports.skips = [];
      var split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      var len = split.length;
      for (var i = 0; i < len; i++) {
        if (!split[i]) continue;
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          exports.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      exports.enable("");
    }
    function enabled(name2) {
      var i, len;
      for (i = 0, len = exports.skips.length; i < len; i++) {
        if (exports.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = exports.names.length; i < len; i++) {
        if (exports.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function coerce2(val) {
      if (val instanceof Error) return val.stack || val.message;
      return val;
    }
  })(debug$e, debug$e.exports);
  return debug$e.exports;
}
var hasRequiredBrowser$1;
function requireBrowser$1() {
  if (hasRequiredBrowser$1) return browser$1.exports;
  hasRequiredBrowser$1 = 1;
  (function(module2, exports) {
    exports = module2.exports = requireDebug();
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
    exports.colors = [
      "lightseagreen",
      "forestgreen",
      "goldenrod",
      "dodgerblue",
      "darkorchid",
      "crimson"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
        return true;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    exports.formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (err) {
        return "[UnexpectedJSONParseError]: " + err.message;
      }
    };
    function formatArgs(args) {
      var useColors2 = this.useColors;
      args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
      if (!useColors2) return;
      var c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      var index2 = 0;
      var lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, function(match2) {
        if ("%%" === match2) return;
        index2++;
        if ("%c" === match2) {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    function log2() {
      return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
    }
    function save(namespaces) {
      try {
        if (null == namespaces) {
          exports.storage.removeItem("debug");
        } else {
          exports.storage.debug = namespaces;
        }
      } catch (e) {
      }
    }
    function load() {
      var r;
      try {
        r = exports.storage.debug;
      } catch (e) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    exports.enable(load());
    function localstorage() {
      try {
        return window.localStorage;
      } catch (e) {
      }
    }
  })(browser$1, browser$1.exports);
  return browser$1.exports;
}
var node$2 = { exports: {} };
var hasRequiredNode$1;
function requireNode$1() {
  if (hasRequiredNode$1) return node$2.exports;
  hasRequiredNode$1 = 1;
  (function(module2, exports) {
    var tty = require$$0$5;
    var util2 = require$$1$3;
    exports = module2.exports = requireDebug();
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.colors = [6, 2, 3, 4, 5, 1];
    exports.inspectOpts = Object.keys(process.env).filter(function(key) {
      return /^debug_/i.test(key);
    }).reduce(function(obj, key) {
      var prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, function(_, k) {
        return k.toUpperCase();
      });
      var val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) val = true;
      else if (/^(no|off|false|disabled)$/i.test(val)) val = false;
      else if (val === "null") val = null;
      else val = Number(val);
      obj[prop] = val;
      return obj;
    }, {});
    var fd = parseInt(process.env.DEBUG_FD, 10) || 2;
    if (1 !== fd && 2 !== fd) {
      util2.deprecate(function() {
      }, "except for stderr(2) and stdout(1), any other usage of DEBUG_FD is deprecated. Override debug.log if you want to use a different log function (https://git.io/debug_fd)")();
    }
    var stream3 = 1 === fd ? process.stdout : 2 === fd ? process.stderr : createWritableStdioStream(fd);
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(fd);
    }
    exports.formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map(function(str2) {
        return str2.trim();
      }).join(" ");
    };
    exports.formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
    function formatArgs(args) {
      var name2 = this.namespace;
      var useColors2 = this.useColors;
      if (useColors2) {
        var c = this.color;
        var prefix = "  \x1B[3" + c + ";1m" + name2 + " \x1B[0m";
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push("\x1B[3" + c + "m+" + exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = (/* @__PURE__ */ new Date()).toUTCString() + " " + name2 + " " + args[0];
      }
    }
    function log2() {
      return stream3.write(util2.format.apply(util2, arguments) + "\n");
    }
    function save(namespaces) {
      if (null == namespaces) {
        delete process.env.DEBUG;
      } else {
        process.env.DEBUG = namespaces;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function createWritableStdioStream(fd2) {
      var stream22;
      var tty_wrap = process.binding("tty_wrap");
      switch (tty_wrap.guessHandleType(fd2)) {
        case "TTY":
          stream22 = new tty.WriteStream(fd2);
          stream22._type = "tty";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        case "FILE":
          var fs2 = require$$0$7;
          stream22 = new fs2.SyncWriteStream(fd2, { autoClose: false });
          stream22._type = "fs";
          break;
        case "PIPE":
        case "TCP":
          var net2 = require$$0$6;
          stream22 = new net2.Socket({
            fd: fd2,
            readable: false,
            writable: true
          });
          stream22.readable = false;
          stream22.read = null;
          stream22._type = "pipe";
          if (stream22._handle && stream22._handle.unref) {
            stream22._handle.unref();
          }
          break;
        default:
          throw new Error("Implement me. Unknown stream file type!");
      }
      stream22.fd = fd2;
      stream22._isStdio = true;
      return stream22;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      var keys2 = Object.keys(exports.inspectOpts);
      for (var i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    exports.enable(load());
  })(node$2, node$2.exports);
  return node$2.exports;
}
if (typeof process !== "undefined" && process.type === "renderer") {
  src$2.exports = requireBrowser$1();
} else {
  src$2.exports = requireNode$1();
}
var srcExports$1 = src$2.exports;
/*!
 * etag
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var etag_1 = etag$1;
var crypto$6 = require$$2$3;
var Stats = require$$0$7.Stats;
var toString$1 = Object.prototype.toString;
function entitytag(entity) {
  if (entity.length === 0) {
    return '"0-2jmj7l5rSw0yVb/vlWAYkK/YBwk"';
  }
  var hash2 = crypto$6.createHash("sha1").update(entity, "utf8").digest("base64").substring(0, 27);
  var len = typeof entity === "string" ? Buffer.byteLength(entity, "utf8") : entity.length;
  return '"' + len.toString(16) + "-" + hash2 + '"';
}
function etag$1(entity, options) {
  if (entity == null) {
    throw new TypeError("argument entity is required");
  }
  var isStats = isstats(entity);
  var weak = options && typeof options.weak === "boolean" ? options.weak : isStats;
  if (!isStats && typeof entity !== "string" && !Buffer.isBuffer(entity)) {
    throw new TypeError("argument entity must be string, Buffer, or fs.Stats");
  }
  var tag = isStats ? stattag(entity) : entitytag(entity);
  return weak ? "W/" + tag : tag;
}
function isstats(obj) {
  if (typeof Stats === "function" && obj instanceof Stats) {
    return true;
  }
  return obj && typeof obj === "object" && "ctime" in obj && toString$1.call(obj.ctime) === "[object Date]" && "mtime" in obj && toString$1.call(obj.mtime) === "[object Date]" && "ino" in obj && typeof obj.ino === "number" && "size" in obj && typeof obj.size === "number";
}
function stattag(stat2) {
  var mtime = stat2.mtime.getTime().toString(16);
  var size = stat2.size.toString(16);
  return '"' + size + "-" + mtime + '"';
}
/*!
 * fresh
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2016-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var CACHE_CONTROL_NO_CACHE_REGEXP = /(?:^|,)\s*?no-cache\s*?(?:,|$)/;
var fresh_1 = fresh$2;
function fresh$2(reqHeaders, resHeaders) {
  var modifiedSince = reqHeaders["if-modified-since"];
  var noneMatch = reqHeaders["if-none-match"];
  if (!modifiedSince && !noneMatch) {
    return false;
  }
  var cacheControl = reqHeaders["cache-control"];
  if (cacheControl && CACHE_CONTROL_NO_CACHE_REGEXP.test(cacheControl)) {
    return false;
  }
  if (noneMatch && noneMatch !== "*") {
    var etag3 = resHeaders["etag"];
    if (!etag3) {
      return false;
    }
    var etagStale = true;
    var matches2 = parseTokenList$1(noneMatch);
    for (var i = 0; i < matches2.length; i++) {
      var match2 = matches2[i];
      if (match2 === etag3 || match2 === "W/" + etag3 || "W/" + match2 === etag3) {
        etagStale = false;
        break;
      }
    }
    if (etagStale) {
      return false;
    }
  }
  if (modifiedSince) {
    var lastModified = resHeaders["last-modified"];
    var modifiedStale = !lastModified || !(parseHttpDate$1(lastModified) <= parseHttpDate$1(modifiedSince));
    if (modifiedStale) {
      return false;
    }
  }
  return true;
}
function parseHttpDate$1(date) {
  var timestamp = date && Date.parse(date);
  return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList$1(str2) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = str2.length; i < len; i++) {
    switch (str2.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(str2.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(str2.substring(start, end));
  return list;
}
const require$$2 = {
  "application/andrew-inset": [
    "ez"
  ],
  "application/applixware": [
    "aw"
  ],
  "application/atom+xml": [
    "atom"
  ],
  "application/atomcat+xml": [
    "atomcat"
  ],
  "application/atomsvc+xml": [
    "atomsvc"
  ],
  "application/bdoc": [
    "bdoc"
  ],
  "application/ccxml+xml": [
    "ccxml"
  ],
  "application/cdmi-capability": [
    "cdmia"
  ],
  "application/cdmi-container": [
    "cdmic"
  ],
  "application/cdmi-domain": [
    "cdmid"
  ],
  "application/cdmi-object": [
    "cdmio"
  ],
  "application/cdmi-queue": [
    "cdmiq"
  ],
  "application/cu-seeme": [
    "cu"
  ],
  "application/dash+xml": [
    "mpd"
  ],
  "application/davmount+xml": [
    "davmount"
  ],
  "application/docbook+xml": [
    "dbk"
  ],
  "application/dssc+der": [
    "dssc"
  ],
  "application/dssc+xml": [
    "xdssc"
  ],
  "application/ecmascript": [
    "ecma"
  ],
  "application/emma+xml": [
    "emma"
  ],
  "application/epub+zip": [
    "epub"
  ],
  "application/exi": [
    "exi"
  ],
  "application/font-tdpfr": [
    "pfr"
  ],
  "application/font-woff": [],
  "application/font-woff2": [],
  "application/geo+json": [
    "geojson"
  ],
  "application/gml+xml": [
    "gml"
  ],
  "application/gpx+xml": [
    "gpx"
  ],
  "application/gxf": [
    "gxf"
  ],
  "application/gzip": [
    "gz"
  ],
  "application/hyperstudio": [
    "stk"
  ],
  "application/inkml+xml": [
    "ink",
    "inkml"
  ],
  "application/ipfix": [
    "ipfix"
  ],
  "application/java-archive": [
    "jar",
    "war",
    "ear"
  ],
  "application/java-serialized-object": [
    "ser"
  ],
  "application/java-vm": [
    "class"
  ],
  "application/javascript": [
    "js",
    "mjs"
  ],
  "application/json": [
    "json",
    "map"
  ],
  "application/json5": [
    "json5"
  ],
  "application/jsonml+json": [
    "jsonml"
  ],
  "application/ld+json": [
    "jsonld"
  ],
  "application/lost+xml": [
    "lostxml"
  ],
  "application/mac-binhex40": [
    "hqx"
  ],
  "application/mac-compactpro": [
    "cpt"
  ],
  "application/mads+xml": [
    "mads"
  ],
  "application/manifest+json": [
    "webmanifest"
  ],
  "application/marc": [
    "mrc"
  ],
  "application/marcxml+xml": [
    "mrcx"
  ],
  "application/mathematica": [
    "ma",
    "nb",
    "mb"
  ],
  "application/mathml+xml": [
    "mathml"
  ],
  "application/mbox": [
    "mbox"
  ],
  "application/mediaservercontrol+xml": [
    "mscml"
  ],
  "application/metalink+xml": [
    "metalink"
  ],
  "application/metalink4+xml": [
    "meta4"
  ],
  "application/mets+xml": [
    "mets"
  ],
  "application/mods+xml": [
    "mods"
  ],
  "application/mp21": [
    "m21",
    "mp21"
  ],
  "application/mp4": [
    "mp4s",
    "m4p"
  ],
  "application/msword": [
    "doc",
    "dot"
  ],
  "application/mxf": [
    "mxf"
  ],
  "application/octet-stream": [
    "bin",
    "dms",
    "lrf",
    "mar",
    "so",
    "dist",
    "distz",
    "pkg",
    "bpk",
    "dump",
    "elc",
    "deploy",
    "exe",
    "dll",
    "deb",
    "dmg",
    "iso",
    "img",
    "msi",
    "msp",
    "msm",
    "buffer"
  ],
  "application/oda": [
    "oda"
  ],
  "application/oebps-package+xml": [
    "opf"
  ],
  "application/ogg": [
    "ogx"
  ],
  "application/omdoc+xml": [
    "omdoc"
  ],
  "application/onenote": [
    "onetoc",
    "onetoc2",
    "onetmp",
    "onepkg"
  ],
  "application/oxps": [
    "oxps"
  ],
  "application/patch-ops-error+xml": [
    "xer"
  ],
  "application/pdf": [
    "pdf"
  ],
  "application/pgp-encrypted": [
    "pgp"
  ],
  "application/pgp-signature": [
    "asc",
    "sig"
  ],
  "application/pics-rules": [
    "prf"
  ],
  "application/pkcs10": [
    "p10"
  ],
  "application/pkcs7-mime": [
    "p7m",
    "p7c"
  ],
  "application/pkcs7-signature": [
    "p7s"
  ],
  "application/pkcs8": [
    "p8"
  ],
  "application/pkix-attr-cert": [
    "ac"
  ],
  "application/pkix-cert": [
    "cer"
  ],
  "application/pkix-crl": [
    "crl"
  ],
  "application/pkix-pkipath": [
    "pkipath"
  ],
  "application/pkixcmp": [
    "pki"
  ],
  "application/pls+xml": [
    "pls"
  ],
  "application/postscript": [
    "ai",
    "eps",
    "ps"
  ],
  "application/prs.cww": [
    "cww"
  ],
  "application/pskc+xml": [
    "pskcxml"
  ],
  "application/raml+yaml": [
    "raml"
  ],
  "application/rdf+xml": [
    "rdf"
  ],
  "application/reginfo+xml": [
    "rif"
  ],
  "application/relax-ng-compact-syntax": [
    "rnc"
  ],
  "application/resource-lists+xml": [
    "rl"
  ],
  "application/resource-lists-diff+xml": [
    "rld"
  ],
  "application/rls-services+xml": [
    "rs"
  ],
  "application/rpki-ghostbusters": [
    "gbr"
  ],
  "application/rpki-manifest": [
    "mft"
  ],
  "application/rpki-roa": [
    "roa"
  ],
  "application/rsd+xml": [
    "rsd"
  ],
  "application/rss+xml": [
    "rss"
  ],
  "application/rtf": [
    "rtf"
  ],
  "application/sbml+xml": [
    "sbml"
  ],
  "application/scvp-cv-request": [
    "scq"
  ],
  "application/scvp-cv-response": [
    "scs"
  ],
  "application/scvp-vp-request": [
    "spq"
  ],
  "application/scvp-vp-response": [
    "spp"
  ],
  "application/sdp": [
    "sdp"
  ],
  "application/set-payment-initiation": [
    "setpay"
  ],
  "application/set-registration-initiation": [
    "setreg"
  ],
  "application/shf+xml": [
    "shf"
  ],
  "application/smil+xml": [
    "smi",
    "smil"
  ],
  "application/sparql-query": [
    "rq"
  ],
  "application/sparql-results+xml": [
    "srx"
  ],
  "application/srgs": [
    "gram"
  ],
  "application/srgs+xml": [
    "grxml"
  ],
  "application/sru+xml": [
    "sru"
  ],
  "application/ssdl+xml": [
    "ssdl"
  ],
  "application/ssml+xml": [
    "ssml"
  ],
  "application/tei+xml": [
    "tei",
    "teicorpus"
  ],
  "application/thraud+xml": [
    "tfi"
  ],
  "application/timestamped-data": [
    "tsd"
  ],
  "application/vnd.3gpp.pic-bw-large": [
    "plb"
  ],
  "application/vnd.3gpp.pic-bw-small": [
    "psb"
  ],
  "application/vnd.3gpp.pic-bw-var": [
    "pvb"
  ],
  "application/vnd.3gpp2.tcap": [
    "tcap"
  ],
  "application/vnd.3m.post-it-notes": [
    "pwn"
  ],
  "application/vnd.accpac.simply.aso": [
    "aso"
  ],
  "application/vnd.accpac.simply.imp": [
    "imp"
  ],
  "application/vnd.acucobol": [
    "acu"
  ],
  "application/vnd.acucorp": [
    "atc",
    "acutc"
  ],
  "application/vnd.adobe.air-application-installer-package+zip": [
    "air"
  ],
  "application/vnd.adobe.formscentral.fcdt": [
    "fcdt"
  ],
  "application/vnd.adobe.fxp": [
    "fxp",
    "fxpl"
  ],
  "application/vnd.adobe.xdp+xml": [
    "xdp"
  ],
  "application/vnd.adobe.xfdf": [
    "xfdf"
  ],
  "application/vnd.ahead.space": [
    "ahead"
  ],
  "application/vnd.airzip.filesecure.azf": [
    "azf"
  ],
  "application/vnd.airzip.filesecure.azs": [
    "azs"
  ],
  "application/vnd.amazon.ebook": [
    "azw"
  ],
  "application/vnd.americandynamics.acc": [
    "acc"
  ],
  "application/vnd.amiga.ami": [
    "ami"
  ],
  "application/vnd.android.package-archive": [
    "apk"
  ],
  "application/vnd.anser-web-certificate-issue-initiation": [
    "cii"
  ],
  "application/vnd.anser-web-funds-transfer-initiation": [
    "fti"
  ],
  "application/vnd.antix.game-component": [
    "atx"
  ],
  "application/vnd.apple.installer+xml": [
    "mpkg"
  ],
  "application/vnd.apple.mpegurl": [
    "m3u8"
  ],
  "application/vnd.apple.pkpass": [
    "pkpass"
  ],
  "application/vnd.aristanetworks.swi": [
    "swi"
  ],
  "application/vnd.astraea-software.iota": [
    "iota"
  ],
  "application/vnd.audiograph": [
    "aep"
  ],
  "application/vnd.blueice.multipass": [
    "mpm"
  ],
  "application/vnd.bmi": [
    "bmi"
  ],
  "application/vnd.businessobjects": [
    "rep"
  ],
  "application/vnd.chemdraw+xml": [
    "cdxml"
  ],
  "application/vnd.chipnuts.karaoke-mmd": [
    "mmd"
  ],
  "application/vnd.cinderella": [
    "cdy"
  ],
  "application/vnd.claymore": [
    "cla"
  ],
  "application/vnd.cloanto.rp9": [
    "rp9"
  ],
  "application/vnd.clonk.c4group": [
    "c4g",
    "c4d",
    "c4f",
    "c4p",
    "c4u"
  ],
  "application/vnd.cluetrust.cartomobile-config": [
    "c11amc"
  ],
  "application/vnd.cluetrust.cartomobile-config-pkg": [
    "c11amz"
  ],
  "application/vnd.commonspace": [
    "csp"
  ],
  "application/vnd.contact.cmsg": [
    "cdbcmsg"
  ],
  "application/vnd.cosmocaller": [
    "cmc"
  ],
  "application/vnd.crick.clicker": [
    "clkx"
  ],
  "application/vnd.crick.clicker.keyboard": [
    "clkk"
  ],
  "application/vnd.crick.clicker.palette": [
    "clkp"
  ],
  "application/vnd.crick.clicker.template": [
    "clkt"
  ],
  "application/vnd.crick.clicker.wordbank": [
    "clkw"
  ],
  "application/vnd.criticaltools.wbs+xml": [
    "wbs"
  ],
  "application/vnd.ctc-posml": [
    "pml"
  ],
  "application/vnd.cups-ppd": [
    "ppd"
  ],
  "application/vnd.curl.car": [
    "car"
  ],
  "application/vnd.curl.pcurl": [
    "pcurl"
  ],
  "application/vnd.dart": [
    "dart"
  ],
  "application/vnd.data-vision.rdz": [
    "rdz"
  ],
  "application/vnd.dece.data": [
    "uvf",
    "uvvf",
    "uvd",
    "uvvd"
  ],
  "application/vnd.dece.ttml+xml": [
    "uvt",
    "uvvt"
  ],
  "application/vnd.dece.unspecified": [
    "uvx",
    "uvvx"
  ],
  "application/vnd.dece.zip": [
    "uvz",
    "uvvz"
  ],
  "application/vnd.denovo.fcselayout-link": [
    "fe_launch"
  ],
  "application/vnd.dna": [
    "dna"
  ],
  "application/vnd.dolby.mlp": [
    "mlp"
  ],
  "application/vnd.dpgraph": [
    "dpg"
  ],
  "application/vnd.dreamfactory": [
    "dfac"
  ],
  "application/vnd.ds-keypoint": [
    "kpxx"
  ],
  "application/vnd.dvb.ait": [
    "ait"
  ],
  "application/vnd.dvb.service": [
    "svc"
  ],
  "application/vnd.dynageo": [
    "geo"
  ],
  "application/vnd.ecowin.chart": [
    "mag"
  ],
  "application/vnd.enliven": [
    "nml"
  ],
  "application/vnd.epson.esf": [
    "esf"
  ],
  "application/vnd.epson.msf": [
    "msf"
  ],
  "application/vnd.epson.quickanime": [
    "qam"
  ],
  "application/vnd.epson.salt": [
    "slt"
  ],
  "application/vnd.epson.ssf": [
    "ssf"
  ],
  "application/vnd.eszigno3+xml": [
    "es3",
    "et3"
  ],
  "application/vnd.ezpix-album": [
    "ez2"
  ],
  "application/vnd.ezpix-package": [
    "ez3"
  ],
  "application/vnd.fdf": [
    "fdf"
  ],
  "application/vnd.fdsn.mseed": [
    "mseed"
  ],
  "application/vnd.fdsn.seed": [
    "seed",
    "dataless"
  ],
  "application/vnd.flographit": [
    "gph"
  ],
  "application/vnd.fluxtime.clip": [
    "ftc"
  ],
  "application/vnd.framemaker": [
    "fm",
    "frame",
    "maker",
    "book"
  ],
  "application/vnd.frogans.fnc": [
    "fnc"
  ],
  "application/vnd.frogans.ltf": [
    "ltf"
  ],
  "application/vnd.fsc.weblaunch": [
    "fsc"
  ],
  "application/vnd.fujitsu.oasys": [
    "oas"
  ],
  "application/vnd.fujitsu.oasys2": [
    "oa2"
  ],
  "application/vnd.fujitsu.oasys3": [
    "oa3"
  ],
  "application/vnd.fujitsu.oasysgp": [
    "fg5"
  ],
  "application/vnd.fujitsu.oasysprs": [
    "bh2"
  ],
  "application/vnd.fujixerox.ddd": [
    "ddd"
  ],
  "application/vnd.fujixerox.docuworks": [
    "xdw"
  ],
  "application/vnd.fujixerox.docuworks.binder": [
    "xbd"
  ],
  "application/vnd.fuzzysheet": [
    "fzs"
  ],
  "application/vnd.genomatix.tuxedo": [
    "txd"
  ],
  "application/vnd.geogebra.file": [
    "ggb"
  ],
  "application/vnd.geogebra.tool": [
    "ggt"
  ],
  "application/vnd.geometry-explorer": [
    "gex",
    "gre"
  ],
  "application/vnd.geonext": [
    "gxt"
  ],
  "application/vnd.geoplan": [
    "g2w"
  ],
  "application/vnd.geospace": [
    "g3w"
  ],
  "application/vnd.gmx": [
    "gmx"
  ],
  "application/vnd.google-apps.document": [
    "gdoc"
  ],
  "application/vnd.google-apps.presentation": [
    "gslides"
  ],
  "application/vnd.google-apps.spreadsheet": [
    "gsheet"
  ],
  "application/vnd.google-earth.kml+xml": [
    "kml"
  ],
  "application/vnd.google-earth.kmz": [
    "kmz"
  ],
  "application/vnd.grafeq": [
    "gqf",
    "gqs"
  ],
  "application/vnd.groove-account": [
    "gac"
  ],
  "application/vnd.groove-help": [
    "ghf"
  ],
  "application/vnd.groove-identity-message": [
    "gim"
  ],
  "application/vnd.groove-injector": [
    "grv"
  ],
  "application/vnd.groove-tool-message": [
    "gtm"
  ],
  "application/vnd.groove-tool-template": [
    "tpl"
  ],
  "application/vnd.groove-vcard": [
    "vcg"
  ],
  "application/vnd.hal+xml": [
    "hal"
  ],
  "application/vnd.handheld-entertainment+xml": [
    "zmm"
  ],
  "application/vnd.hbci": [
    "hbci"
  ],
  "application/vnd.hhe.lesson-player": [
    "les"
  ],
  "application/vnd.hp-hpgl": [
    "hpgl"
  ],
  "application/vnd.hp-hpid": [
    "hpid"
  ],
  "application/vnd.hp-hps": [
    "hps"
  ],
  "application/vnd.hp-jlyt": [
    "jlt"
  ],
  "application/vnd.hp-pcl": [
    "pcl"
  ],
  "application/vnd.hp-pclxl": [
    "pclxl"
  ],
  "application/vnd.hydrostatix.sof-data": [
    "sfd-hdstx"
  ],
  "application/vnd.ibm.minipay": [
    "mpy"
  ],
  "application/vnd.ibm.modcap": [
    "afp",
    "listafp",
    "list3820"
  ],
  "application/vnd.ibm.rights-management": [
    "irm"
  ],
  "application/vnd.ibm.secure-container": [
    "sc"
  ],
  "application/vnd.iccprofile": [
    "icc",
    "icm"
  ],
  "application/vnd.igloader": [
    "igl"
  ],
  "application/vnd.immervision-ivp": [
    "ivp"
  ],
  "application/vnd.immervision-ivu": [
    "ivu"
  ],
  "application/vnd.insors.igm": [
    "igm"
  ],
  "application/vnd.intercon.formnet": [
    "xpw",
    "xpx"
  ],
  "application/vnd.intergeo": [
    "i2g"
  ],
  "application/vnd.intu.qbo": [
    "qbo"
  ],
  "application/vnd.intu.qfx": [
    "qfx"
  ],
  "application/vnd.ipunplugged.rcprofile": [
    "rcprofile"
  ],
  "application/vnd.irepository.package+xml": [
    "irp"
  ],
  "application/vnd.is-xpr": [
    "xpr"
  ],
  "application/vnd.isac.fcs": [
    "fcs"
  ],
  "application/vnd.jam": [
    "jam"
  ],
  "application/vnd.jcp.javame.midlet-rms": [
    "rms"
  ],
  "application/vnd.jisp": [
    "jisp"
  ],
  "application/vnd.joost.joda-archive": [
    "joda"
  ],
  "application/vnd.kahootz": [
    "ktz",
    "ktr"
  ],
  "application/vnd.kde.karbon": [
    "karbon"
  ],
  "application/vnd.kde.kchart": [
    "chrt"
  ],
  "application/vnd.kde.kformula": [
    "kfo"
  ],
  "application/vnd.kde.kivio": [
    "flw"
  ],
  "application/vnd.kde.kontour": [
    "kon"
  ],
  "application/vnd.kde.kpresenter": [
    "kpr",
    "kpt"
  ],
  "application/vnd.kde.kspread": [
    "ksp"
  ],
  "application/vnd.kde.kword": [
    "kwd",
    "kwt"
  ],
  "application/vnd.kenameaapp": [
    "htke"
  ],
  "application/vnd.kidspiration": [
    "kia"
  ],
  "application/vnd.kinar": [
    "kne",
    "knp"
  ],
  "application/vnd.koan": [
    "skp",
    "skd",
    "skt",
    "skm"
  ],
  "application/vnd.kodak-descriptor": [
    "sse"
  ],
  "application/vnd.las.las+xml": [
    "lasxml"
  ],
  "application/vnd.llamagraphics.life-balance.desktop": [
    "lbd"
  ],
  "application/vnd.llamagraphics.life-balance.exchange+xml": [
    "lbe"
  ],
  "application/vnd.lotus-1-2-3": [
    "123"
  ],
  "application/vnd.lotus-approach": [
    "apr"
  ],
  "application/vnd.lotus-freelance": [
    "pre"
  ],
  "application/vnd.lotus-notes": [
    "nsf"
  ],
  "application/vnd.lotus-organizer": [
    "org"
  ],
  "application/vnd.lotus-screencam": [
    "scm"
  ],
  "application/vnd.lotus-wordpro": [
    "lwp"
  ],
  "application/vnd.macports.portpkg": [
    "portpkg"
  ],
  "application/vnd.mcd": [
    "mcd"
  ],
  "application/vnd.medcalcdata": [
    "mc1"
  ],
  "application/vnd.mediastation.cdkey": [
    "cdkey"
  ],
  "application/vnd.mfer": [
    "mwf"
  ],
  "application/vnd.mfmp": [
    "mfm"
  ],
  "application/vnd.micrografx.flo": [
    "flo"
  ],
  "application/vnd.micrografx.igx": [
    "igx"
  ],
  "application/vnd.mif": [
    "mif"
  ],
  "application/vnd.mobius.daf": [
    "daf"
  ],
  "application/vnd.mobius.dis": [
    "dis"
  ],
  "application/vnd.mobius.mbk": [
    "mbk"
  ],
  "application/vnd.mobius.mqy": [
    "mqy"
  ],
  "application/vnd.mobius.msl": [
    "msl"
  ],
  "application/vnd.mobius.plc": [
    "plc"
  ],
  "application/vnd.mobius.txf": [
    "txf"
  ],
  "application/vnd.mophun.application": [
    "mpn"
  ],
  "application/vnd.mophun.certificate": [
    "mpc"
  ],
  "application/vnd.mozilla.xul+xml": [
    "xul"
  ],
  "application/vnd.ms-artgalry": [
    "cil"
  ],
  "application/vnd.ms-cab-compressed": [
    "cab"
  ],
  "application/vnd.ms-excel": [
    "xls",
    "xlm",
    "xla",
    "xlc",
    "xlt",
    "xlw"
  ],
  "application/vnd.ms-excel.addin.macroenabled.12": [
    "xlam"
  ],
  "application/vnd.ms-excel.sheet.binary.macroenabled.12": [
    "xlsb"
  ],
  "application/vnd.ms-excel.sheet.macroenabled.12": [
    "xlsm"
  ],
  "application/vnd.ms-excel.template.macroenabled.12": [
    "xltm"
  ],
  "application/vnd.ms-fontobject": [
    "eot"
  ],
  "application/vnd.ms-htmlhelp": [
    "chm"
  ],
  "application/vnd.ms-ims": [
    "ims"
  ],
  "application/vnd.ms-lrm": [
    "lrm"
  ],
  "application/vnd.ms-officetheme": [
    "thmx"
  ],
  "application/vnd.ms-outlook": [
    "msg"
  ],
  "application/vnd.ms-pki.seccat": [
    "cat"
  ],
  "application/vnd.ms-pki.stl": [
    "stl"
  ],
  "application/vnd.ms-powerpoint": [
    "ppt",
    "pps",
    "pot"
  ],
  "application/vnd.ms-powerpoint.addin.macroenabled.12": [
    "ppam"
  ],
  "application/vnd.ms-powerpoint.presentation.macroenabled.12": [
    "pptm"
  ],
  "application/vnd.ms-powerpoint.slide.macroenabled.12": [
    "sldm"
  ],
  "application/vnd.ms-powerpoint.slideshow.macroenabled.12": [
    "ppsm"
  ],
  "application/vnd.ms-powerpoint.template.macroenabled.12": [
    "potm"
  ],
  "application/vnd.ms-project": [
    "mpp",
    "mpt"
  ],
  "application/vnd.ms-word.document.macroenabled.12": [
    "docm"
  ],
  "application/vnd.ms-word.template.macroenabled.12": [
    "dotm"
  ],
  "application/vnd.ms-works": [
    "wps",
    "wks",
    "wcm",
    "wdb"
  ],
  "application/vnd.ms-wpl": [
    "wpl"
  ],
  "application/vnd.ms-xpsdocument": [
    "xps"
  ],
  "application/vnd.mseq": [
    "mseq"
  ],
  "application/vnd.musician": [
    "mus"
  ],
  "application/vnd.muvee.style": [
    "msty"
  ],
  "application/vnd.mynfc": [
    "taglet"
  ],
  "application/vnd.neurolanguage.nlu": [
    "nlu"
  ],
  "application/vnd.nitf": [
    "ntf",
    "nitf"
  ],
  "application/vnd.noblenet-directory": [
    "nnd"
  ],
  "application/vnd.noblenet-sealer": [
    "nns"
  ],
  "application/vnd.noblenet-web": [
    "nnw"
  ],
  "application/vnd.nokia.n-gage.data": [
    "ngdat"
  ],
  "application/vnd.nokia.n-gage.symbian.install": [
    "n-gage"
  ],
  "application/vnd.nokia.radio-preset": [
    "rpst"
  ],
  "application/vnd.nokia.radio-presets": [
    "rpss"
  ],
  "application/vnd.novadigm.edm": [
    "edm"
  ],
  "application/vnd.novadigm.edx": [
    "edx"
  ],
  "application/vnd.novadigm.ext": [
    "ext"
  ],
  "application/vnd.oasis.opendocument.chart": [
    "odc"
  ],
  "application/vnd.oasis.opendocument.chart-template": [
    "otc"
  ],
  "application/vnd.oasis.opendocument.database": [
    "odb"
  ],
  "application/vnd.oasis.opendocument.formula": [
    "odf"
  ],
  "application/vnd.oasis.opendocument.formula-template": [
    "odft"
  ],
  "application/vnd.oasis.opendocument.graphics": [
    "odg"
  ],
  "application/vnd.oasis.opendocument.graphics-template": [
    "otg"
  ],
  "application/vnd.oasis.opendocument.image": [
    "odi"
  ],
  "application/vnd.oasis.opendocument.image-template": [
    "oti"
  ],
  "application/vnd.oasis.opendocument.presentation": [
    "odp"
  ],
  "application/vnd.oasis.opendocument.presentation-template": [
    "otp"
  ],
  "application/vnd.oasis.opendocument.spreadsheet": [
    "ods"
  ],
  "application/vnd.oasis.opendocument.spreadsheet-template": [
    "ots"
  ],
  "application/vnd.oasis.opendocument.text": [
    "odt"
  ],
  "application/vnd.oasis.opendocument.text-master": [
    "odm"
  ],
  "application/vnd.oasis.opendocument.text-template": [
    "ott"
  ],
  "application/vnd.oasis.opendocument.text-web": [
    "oth"
  ],
  "application/vnd.olpc-sugar": [
    "xo"
  ],
  "application/vnd.oma.dd2+xml": [
    "dd2"
  ],
  "application/vnd.openofficeorg.extension": [
    "oxt"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.presentation": [
    "pptx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slide": [
    "sldx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.slideshow": [
    "ppsx"
  ],
  "application/vnd.openxmlformats-officedocument.presentationml.template": [
    "potx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": [
    "xlsx"
  ],
  "application/vnd.openxmlformats-officedocument.spreadsheetml.template": [
    "xltx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.document": [
    "docx"
  ],
  "application/vnd.openxmlformats-officedocument.wordprocessingml.template": [
    "dotx"
  ],
  "application/vnd.osgeo.mapguide.package": [
    "mgp"
  ],
  "application/vnd.osgi.dp": [
    "dp"
  ],
  "application/vnd.osgi.subsystem": [
    "esa"
  ],
  "application/vnd.palm": [
    "pdb",
    "pqa",
    "oprc"
  ],
  "application/vnd.pawaafile": [
    "paw"
  ],
  "application/vnd.pg.format": [
    "str"
  ],
  "application/vnd.pg.osasli": [
    "ei6"
  ],
  "application/vnd.picsel": [
    "efif"
  ],
  "application/vnd.pmi.widget": [
    "wg"
  ],
  "application/vnd.pocketlearn": [
    "plf"
  ],
  "application/vnd.powerbuilder6": [
    "pbd"
  ],
  "application/vnd.previewsystems.box": [
    "box"
  ],
  "application/vnd.proteus.magazine": [
    "mgz"
  ],
  "application/vnd.publishare-delta-tree": [
    "qps"
  ],
  "application/vnd.pvi.ptid1": [
    "ptid"
  ],
  "application/vnd.quark.quarkxpress": [
    "qxd",
    "qxt",
    "qwd",
    "qwt",
    "qxl",
    "qxb"
  ],
  "application/vnd.realvnc.bed": [
    "bed"
  ],
  "application/vnd.recordare.musicxml": [
    "mxl"
  ],
  "application/vnd.recordare.musicxml+xml": [
    "musicxml"
  ],
  "application/vnd.rig.cryptonote": [
    "cryptonote"
  ],
  "application/vnd.rim.cod": [
    "cod"
  ],
  "application/vnd.rn-realmedia": [
    "rm"
  ],
  "application/vnd.rn-realmedia-vbr": [
    "rmvb"
  ],
  "application/vnd.route66.link66+xml": [
    "link66"
  ],
  "application/vnd.sailingtracker.track": [
    "st"
  ],
  "application/vnd.seemail": [
    "see"
  ],
  "application/vnd.sema": [
    "sema"
  ],
  "application/vnd.semd": [
    "semd"
  ],
  "application/vnd.semf": [
    "semf"
  ],
  "application/vnd.shana.informed.formdata": [
    "ifm"
  ],
  "application/vnd.shana.informed.formtemplate": [
    "itp"
  ],
  "application/vnd.shana.informed.interchange": [
    "iif"
  ],
  "application/vnd.shana.informed.package": [
    "ipk"
  ],
  "application/vnd.simtech-mindmapper": [
    "twd",
    "twds"
  ],
  "application/vnd.smaf": [
    "mmf"
  ],
  "application/vnd.smart.teacher": [
    "teacher"
  ],
  "application/vnd.solent.sdkm+xml": [
    "sdkm",
    "sdkd"
  ],
  "application/vnd.spotfire.dxp": [
    "dxp"
  ],
  "application/vnd.spotfire.sfs": [
    "sfs"
  ],
  "application/vnd.stardivision.calc": [
    "sdc"
  ],
  "application/vnd.stardivision.draw": [
    "sda"
  ],
  "application/vnd.stardivision.impress": [
    "sdd"
  ],
  "application/vnd.stardivision.math": [
    "smf"
  ],
  "application/vnd.stardivision.writer": [
    "sdw",
    "vor"
  ],
  "application/vnd.stardivision.writer-global": [
    "sgl"
  ],
  "application/vnd.stepmania.package": [
    "smzip"
  ],
  "application/vnd.stepmania.stepchart": [
    "sm"
  ],
  "application/vnd.sun.wadl+xml": [
    "wadl"
  ],
  "application/vnd.sun.xml.calc": [
    "sxc"
  ],
  "application/vnd.sun.xml.calc.template": [
    "stc"
  ],
  "application/vnd.sun.xml.draw": [
    "sxd"
  ],
  "application/vnd.sun.xml.draw.template": [
    "std"
  ],
  "application/vnd.sun.xml.impress": [
    "sxi"
  ],
  "application/vnd.sun.xml.impress.template": [
    "sti"
  ],
  "application/vnd.sun.xml.math": [
    "sxm"
  ],
  "application/vnd.sun.xml.writer": [
    "sxw"
  ],
  "application/vnd.sun.xml.writer.global": [
    "sxg"
  ],
  "application/vnd.sun.xml.writer.template": [
    "stw"
  ],
  "application/vnd.sus-calendar": [
    "sus",
    "susp"
  ],
  "application/vnd.svd": [
    "svd"
  ],
  "application/vnd.symbian.install": [
    "sis",
    "sisx"
  ],
  "application/vnd.syncml+xml": [
    "xsm"
  ],
  "application/vnd.syncml.dm+wbxml": [
    "bdm"
  ],
  "application/vnd.syncml.dm+xml": [
    "xdm"
  ],
  "application/vnd.tao.intent-module-archive": [
    "tao"
  ],
  "application/vnd.tcpdump.pcap": [
    "pcap",
    "cap",
    "dmp"
  ],
  "application/vnd.tmobile-livetv": [
    "tmo"
  ],
  "application/vnd.trid.tpt": [
    "tpt"
  ],
  "application/vnd.triscape.mxs": [
    "mxs"
  ],
  "application/vnd.trueapp": [
    "tra"
  ],
  "application/vnd.ufdl": [
    "ufd",
    "ufdl"
  ],
  "application/vnd.uiq.theme": [
    "utz"
  ],
  "application/vnd.umajin": [
    "umj"
  ],
  "application/vnd.unity": [
    "unityweb"
  ],
  "application/vnd.uoml+xml": [
    "uoml"
  ],
  "application/vnd.vcx": [
    "vcx"
  ],
  "application/vnd.visio": [
    "vsd",
    "vst",
    "vss",
    "vsw"
  ],
  "application/vnd.visionary": [
    "vis"
  ],
  "application/vnd.vsf": [
    "vsf"
  ],
  "application/vnd.wap.wbxml": [
    "wbxml"
  ],
  "application/vnd.wap.wmlc": [
    "wmlc"
  ],
  "application/vnd.wap.wmlscriptc": [
    "wmlsc"
  ],
  "application/vnd.webturbo": [
    "wtb"
  ],
  "application/vnd.wolfram.player": [
    "nbp"
  ],
  "application/vnd.wordperfect": [
    "wpd"
  ],
  "application/vnd.wqd": [
    "wqd"
  ],
  "application/vnd.wt.stf": [
    "stf"
  ],
  "application/vnd.xara": [
    "xar"
  ],
  "application/vnd.xfdl": [
    "xfdl"
  ],
  "application/vnd.yamaha.hv-dic": [
    "hvd"
  ],
  "application/vnd.yamaha.hv-script": [
    "hvs"
  ],
  "application/vnd.yamaha.hv-voice": [
    "hvp"
  ],
  "application/vnd.yamaha.openscoreformat": [
    "osf"
  ],
  "application/vnd.yamaha.openscoreformat.osfpvg+xml": [
    "osfpvg"
  ],
  "application/vnd.yamaha.smaf-audio": [
    "saf"
  ],
  "application/vnd.yamaha.smaf-phrase": [
    "spf"
  ],
  "application/vnd.yellowriver-custom-menu": [
    "cmp"
  ],
  "application/vnd.zul": [
    "zir",
    "zirz"
  ],
  "application/vnd.zzazz.deck+xml": [
    "zaz"
  ],
  "application/voicexml+xml": [
    "vxml"
  ],
  "application/wasm": [
    "wasm"
  ],
  "application/widget": [
    "wgt"
  ],
  "application/winhlp": [
    "hlp"
  ],
  "application/wsdl+xml": [
    "wsdl"
  ],
  "application/wspolicy+xml": [
    "wspolicy"
  ],
  "application/x-7z-compressed": [
    "7z"
  ],
  "application/x-abiword": [
    "abw"
  ],
  "application/x-ace-compressed": [
    "ace"
  ],
  "application/x-apple-diskimage": [],
  "application/x-arj": [
    "arj"
  ],
  "application/x-authorware-bin": [
    "aab",
    "x32",
    "u32",
    "vox"
  ],
  "application/x-authorware-map": [
    "aam"
  ],
  "application/x-authorware-seg": [
    "aas"
  ],
  "application/x-bcpio": [
    "bcpio"
  ],
  "application/x-bdoc": [],
  "application/x-bittorrent": [
    "torrent"
  ],
  "application/x-blorb": [
    "blb",
    "blorb"
  ],
  "application/x-bzip": [
    "bz"
  ],
  "application/x-bzip2": [
    "bz2",
    "boz"
  ],
  "application/x-cbr": [
    "cbr",
    "cba",
    "cbt",
    "cbz",
    "cb7"
  ],
  "application/x-cdlink": [
    "vcd"
  ],
  "application/x-cfs-compressed": [
    "cfs"
  ],
  "application/x-chat": [
    "chat"
  ],
  "application/x-chess-pgn": [
    "pgn"
  ],
  "application/x-chrome-extension": [
    "crx"
  ],
  "application/x-cocoa": [
    "cco"
  ],
  "application/x-conference": [
    "nsc"
  ],
  "application/x-cpio": [
    "cpio"
  ],
  "application/x-csh": [
    "csh"
  ],
  "application/x-debian-package": [
    "udeb"
  ],
  "application/x-dgc-compressed": [
    "dgc"
  ],
  "application/x-director": [
    "dir",
    "dcr",
    "dxr",
    "cst",
    "cct",
    "cxt",
    "w3d",
    "fgd",
    "swa"
  ],
  "application/x-doom": [
    "wad"
  ],
  "application/x-dtbncx+xml": [
    "ncx"
  ],
  "application/x-dtbook+xml": [
    "dtb"
  ],
  "application/x-dtbresource+xml": [
    "res"
  ],
  "application/x-dvi": [
    "dvi"
  ],
  "application/x-envoy": [
    "evy"
  ],
  "application/x-eva": [
    "eva"
  ],
  "application/x-font-bdf": [
    "bdf"
  ],
  "application/x-font-ghostscript": [
    "gsf"
  ],
  "application/x-font-linux-psf": [
    "psf"
  ],
  "application/x-font-pcf": [
    "pcf"
  ],
  "application/x-font-snf": [
    "snf"
  ],
  "application/x-font-type1": [
    "pfa",
    "pfb",
    "pfm",
    "afm"
  ],
  "application/x-freearc": [
    "arc"
  ],
  "application/x-futuresplash": [
    "spl"
  ],
  "application/x-gca-compressed": [
    "gca"
  ],
  "application/x-glulx": [
    "ulx"
  ],
  "application/x-gnumeric": [
    "gnumeric"
  ],
  "application/x-gramps-xml": [
    "gramps"
  ],
  "application/x-gtar": [
    "gtar"
  ],
  "application/x-hdf": [
    "hdf"
  ],
  "application/x-httpd-php": [
    "php"
  ],
  "application/x-install-instructions": [
    "install"
  ],
  "application/x-iso9660-image": [],
  "application/x-java-archive-diff": [
    "jardiff"
  ],
  "application/x-java-jnlp-file": [
    "jnlp"
  ],
  "application/x-latex": [
    "latex"
  ],
  "application/x-lua-bytecode": [
    "luac"
  ],
  "application/x-lzh-compressed": [
    "lzh",
    "lha"
  ],
  "application/x-makeself": [
    "run"
  ],
  "application/x-mie": [
    "mie"
  ],
  "application/x-mobipocket-ebook": [
    "prc",
    "mobi"
  ],
  "application/x-ms-application": [
    "application"
  ],
  "application/x-ms-shortcut": [
    "lnk"
  ],
  "application/x-ms-wmd": [
    "wmd"
  ],
  "application/x-ms-wmz": [
    "wmz"
  ],
  "application/x-ms-xbap": [
    "xbap"
  ],
  "application/x-msaccess": [
    "mdb"
  ],
  "application/x-msbinder": [
    "obd"
  ],
  "application/x-mscardfile": [
    "crd"
  ],
  "application/x-msclip": [
    "clp"
  ],
  "application/x-msdos-program": [],
  "application/x-msdownload": [
    "com",
    "bat"
  ],
  "application/x-msmediaview": [
    "mvb",
    "m13",
    "m14"
  ],
  "application/x-msmetafile": [
    "wmf",
    "emf",
    "emz"
  ],
  "application/x-msmoney": [
    "mny"
  ],
  "application/x-mspublisher": [
    "pub"
  ],
  "application/x-msschedule": [
    "scd"
  ],
  "application/x-msterminal": [
    "trm"
  ],
  "application/x-mswrite": [
    "wri"
  ],
  "application/x-netcdf": [
    "nc",
    "cdf"
  ],
  "application/x-ns-proxy-autoconfig": [
    "pac"
  ],
  "application/x-nzb": [
    "nzb"
  ],
  "application/x-perl": [
    "pl",
    "pm"
  ],
  "application/x-pilot": [],
  "application/x-pkcs12": [
    "p12",
    "pfx"
  ],
  "application/x-pkcs7-certificates": [
    "p7b",
    "spc"
  ],
  "application/x-pkcs7-certreqresp": [
    "p7r"
  ],
  "application/x-rar-compressed": [
    "rar"
  ],
  "application/x-redhat-package-manager": [
    "rpm"
  ],
  "application/x-research-info-systems": [
    "ris"
  ],
  "application/x-sea": [
    "sea"
  ],
  "application/x-sh": [
    "sh"
  ],
  "application/x-shar": [
    "shar"
  ],
  "application/x-shockwave-flash": [
    "swf"
  ],
  "application/x-silverlight-app": [
    "xap"
  ],
  "application/x-sql": [
    "sql"
  ],
  "application/x-stuffit": [
    "sit"
  ],
  "application/x-stuffitx": [
    "sitx"
  ],
  "application/x-subrip": [
    "srt"
  ],
  "application/x-sv4cpio": [
    "sv4cpio"
  ],
  "application/x-sv4crc": [
    "sv4crc"
  ],
  "application/x-t3vm-image": [
    "t3"
  ],
  "application/x-tads": [
    "gam"
  ],
  "application/x-tar": [
    "tar"
  ],
  "application/x-tcl": [
    "tcl",
    "tk"
  ],
  "application/x-tex": [
    "tex"
  ],
  "application/x-tex-tfm": [
    "tfm"
  ],
  "application/x-texinfo": [
    "texinfo",
    "texi"
  ],
  "application/x-tgif": [
    "obj"
  ],
  "application/x-ustar": [
    "ustar"
  ],
  "application/x-virtualbox-hdd": [
    "hdd"
  ],
  "application/x-virtualbox-ova": [
    "ova"
  ],
  "application/x-virtualbox-ovf": [
    "ovf"
  ],
  "application/x-virtualbox-vbox": [
    "vbox"
  ],
  "application/x-virtualbox-vbox-extpack": [
    "vbox-extpack"
  ],
  "application/x-virtualbox-vdi": [
    "vdi"
  ],
  "application/x-virtualbox-vhd": [
    "vhd"
  ],
  "application/x-virtualbox-vmdk": [
    "vmdk"
  ],
  "application/x-wais-source": [
    "src"
  ],
  "application/x-web-app-manifest+json": [
    "webapp"
  ],
  "application/x-x509-ca-cert": [
    "der",
    "crt",
    "pem"
  ],
  "application/x-xfig": [
    "fig"
  ],
  "application/x-xliff+xml": [
    "xlf"
  ],
  "application/x-xpinstall": [
    "xpi"
  ],
  "application/x-xz": [
    "xz"
  ],
  "application/x-zmachine": [
    "z1",
    "z2",
    "z3",
    "z4",
    "z5",
    "z6",
    "z7",
    "z8"
  ],
  "application/xaml+xml": [
    "xaml"
  ],
  "application/xcap-diff+xml": [
    "xdf"
  ],
  "application/xenc+xml": [
    "xenc"
  ],
  "application/xhtml+xml": [
    "xhtml",
    "xht"
  ],
  "application/xml": [
    "xml",
    "xsl",
    "xsd",
    "rng"
  ],
  "application/xml-dtd": [
    "dtd"
  ],
  "application/xop+xml": [
    "xop"
  ],
  "application/xproc+xml": [
    "xpl"
  ],
  "application/xslt+xml": [
    "xslt"
  ],
  "application/xspf+xml": [
    "xspf"
  ],
  "application/xv+xml": [
    "mxml",
    "xhvml",
    "xvml",
    "xvm"
  ],
  "application/yang": [
    "yang"
  ],
  "application/yin+xml": [
    "yin"
  ],
  "application/zip": [
    "zip"
  ],
  "audio/3gpp": [],
  "audio/adpcm": [
    "adp"
  ],
  "audio/basic": [
    "au",
    "snd"
  ],
  "audio/midi": [
    "mid",
    "midi",
    "kar",
    "rmi"
  ],
  "audio/mp3": [],
  "audio/mp4": [
    "m4a",
    "mp4a"
  ],
  "audio/mpeg": [
    "mpga",
    "mp2",
    "mp2a",
    "mp3",
    "m2a",
    "m3a"
  ],
  "audio/ogg": [
    "oga",
    "ogg",
    "spx"
  ],
  "audio/s3m": [
    "s3m"
  ],
  "audio/silk": [
    "sil"
  ],
  "audio/vnd.dece.audio": [
    "uva",
    "uvva"
  ],
  "audio/vnd.digital-winds": [
    "eol"
  ],
  "audio/vnd.dra": [
    "dra"
  ],
  "audio/vnd.dts": [
    "dts"
  ],
  "audio/vnd.dts.hd": [
    "dtshd"
  ],
  "audio/vnd.lucent.voice": [
    "lvp"
  ],
  "audio/vnd.ms-playready.media.pya": [
    "pya"
  ],
  "audio/vnd.nuera.ecelp4800": [
    "ecelp4800"
  ],
  "audio/vnd.nuera.ecelp7470": [
    "ecelp7470"
  ],
  "audio/vnd.nuera.ecelp9600": [
    "ecelp9600"
  ],
  "audio/vnd.rip": [
    "rip"
  ],
  "audio/wav": [
    "wav"
  ],
  "audio/wave": [],
  "audio/webm": [
    "weba"
  ],
  "audio/x-aac": [
    "aac"
  ],
  "audio/x-aiff": [
    "aif",
    "aiff",
    "aifc"
  ],
  "audio/x-caf": [
    "caf"
  ],
  "audio/x-flac": [
    "flac"
  ],
  "audio/x-m4a": [],
  "audio/x-matroska": [
    "mka"
  ],
  "audio/x-mpegurl": [
    "m3u"
  ],
  "audio/x-ms-wax": [
    "wax"
  ],
  "audio/x-ms-wma": [
    "wma"
  ],
  "audio/x-pn-realaudio": [
    "ram",
    "ra"
  ],
  "audio/x-pn-realaudio-plugin": [
    "rmp"
  ],
  "audio/x-realaudio": [],
  "audio/x-wav": [],
  "audio/xm": [
    "xm"
  ],
  "chemical/x-cdx": [
    "cdx"
  ],
  "chemical/x-cif": [
    "cif"
  ],
  "chemical/x-cmdf": [
    "cmdf"
  ],
  "chemical/x-cml": [
    "cml"
  ],
  "chemical/x-csml": [
    "csml"
  ],
  "chemical/x-xyz": [
    "xyz"
  ],
  "font/collection": [
    "ttc"
  ],
  "font/otf": [
    "otf"
  ],
  "font/ttf": [
    "ttf"
  ],
  "font/woff": [
    "woff"
  ],
  "font/woff2": [
    "woff2"
  ],
  "image/apng": [
    "apng"
  ],
  "image/bmp": [
    "bmp"
  ],
  "image/cgm": [
    "cgm"
  ],
  "image/g3fax": [
    "g3"
  ],
  "image/gif": [
    "gif"
  ],
  "image/ief": [
    "ief"
  ],
  "image/jp2": [
    "jp2",
    "jpg2"
  ],
  "image/jpeg": [
    "jpeg",
    "jpg",
    "jpe"
  ],
  "image/jpm": [
    "jpm"
  ],
  "image/jpx": [
    "jpx",
    "jpf"
  ],
  "image/ktx": [
    "ktx"
  ],
  "image/png": [
    "png"
  ],
  "image/prs.btif": [
    "btif"
  ],
  "image/sgi": [
    "sgi"
  ],
  "image/svg+xml": [
    "svg",
    "svgz"
  ],
  "image/tiff": [
    "tiff",
    "tif"
  ],
  "image/vnd.adobe.photoshop": [
    "psd"
  ],
  "image/vnd.dece.graphic": [
    "uvi",
    "uvvi",
    "uvg",
    "uvvg"
  ],
  "image/vnd.djvu": [
    "djvu",
    "djv"
  ],
  "image/vnd.dvb.subtitle": [],
  "image/vnd.dwg": [
    "dwg"
  ],
  "image/vnd.dxf": [
    "dxf"
  ],
  "image/vnd.fastbidsheet": [
    "fbs"
  ],
  "image/vnd.fpx": [
    "fpx"
  ],
  "image/vnd.fst": [
    "fst"
  ],
  "image/vnd.fujixerox.edmics-mmr": [
    "mmr"
  ],
  "image/vnd.fujixerox.edmics-rlc": [
    "rlc"
  ],
  "image/vnd.ms-modi": [
    "mdi"
  ],
  "image/vnd.ms-photo": [
    "wdp"
  ],
  "image/vnd.net-fpx": [
    "npx"
  ],
  "image/vnd.wap.wbmp": [
    "wbmp"
  ],
  "image/vnd.xiff": [
    "xif"
  ],
  "image/webp": [
    "webp"
  ],
  "image/x-3ds": [
    "3ds"
  ],
  "image/x-cmu-raster": [
    "ras"
  ],
  "image/x-cmx": [
    "cmx"
  ],
  "image/x-freehand": [
    "fh",
    "fhc",
    "fh4",
    "fh5",
    "fh7"
  ],
  "image/x-icon": [
    "ico"
  ],
  "image/x-jng": [
    "jng"
  ],
  "image/x-mrsid-image": [
    "sid"
  ],
  "image/x-ms-bmp": [],
  "image/x-pcx": [
    "pcx"
  ],
  "image/x-pict": [
    "pic",
    "pct"
  ],
  "image/x-portable-anymap": [
    "pnm"
  ],
  "image/x-portable-bitmap": [
    "pbm"
  ],
  "image/x-portable-graymap": [
    "pgm"
  ],
  "image/x-portable-pixmap": [
    "ppm"
  ],
  "image/x-rgb": [
    "rgb"
  ],
  "image/x-tga": [
    "tga"
  ],
  "image/x-xbitmap": [
    "xbm"
  ],
  "image/x-xpixmap": [
    "xpm"
  ],
  "image/x-xwindowdump": [
    "xwd"
  ],
  "message/rfc822": [
    "eml",
    "mime"
  ],
  "model/gltf+json": [
    "gltf"
  ],
  "model/gltf-binary": [
    "glb"
  ],
  "model/iges": [
    "igs",
    "iges"
  ],
  "model/mesh": [
    "msh",
    "mesh",
    "silo"
  ],
  "model/vnd.collada+xml": [
    "dae"
  ],
  "model/vnd.dwf": [
    "dwf"
  ],
  "model/vnd.gdl": [
    "gdl"
  ],
  "model/vnd.gtw": [
    "gtw"
  ],
  "model/vnd.mts": [
    "mts"
  ],
  "model/vnd.vtu": [
    "vtu"
  ],
  "model/vrml": [
    "wrl",
    "vrml"
  ],
  "model/x3d+binary": [
    "x3db",
    "x3dbz"
  ],
  "model/x3d+vrml": [
    "x3dv",
    "x3dvz"
  ],
  "model/x3d+xml": [
    "x3d",
    "x3dz"
  ],
  "text/cache-manifest": [
    "appcache",
    "manifest"
  ],
  "text/calendar": [
    "ics",
    "ifb"
  ],
  "text/coffeescript": [
    "coffee",
    "litcoffee"
  ],
  "text/css": [
    "css"
  ],
  "text/csv": [
    "csv"
  ],
  "text/hjson": [
    "hjson"
  ],
  "text/html": [
    "html",
    "htm",
    "shtml"
  ],
  "text/jade": [
    "jade"
  ],
  "text/jsx": [
    "jsx"
  ],
  "text/less": [
    "less"
  ],
  "text/markdown": [
    "markdown",
    "md"
  ],
  "text/mathml": [
    "mml"
  ],
  "text/n3": [
    "n3"
  ],
  "text/plain": [
    "txt",
    "text",
    "conf",
    "def",
    "list",
    "log",
    "in",
    "ini"
  ],
  "text/prs.lines.tag": [
    "dsc"
  ],
  "text/richtext": [
    "rtx"
  ],
  "text/rtf": [],
  "text/sgml": [
    "sgml",
    "sgm"
  ],
  "text/slim": [
    "slim",
    "slm"
  ],
  "text/stylus": [
    "stylus",
    "styl"
  ],
  "text/tab-separated-values": [
    "tsv"
  ],
  "text/troff": [
    "t",
    "tr",
    "roff",
    "man",
    "me",
    "ms"
  ],
  "text/turtle": [
    "ttl"
  ],
  "text/uri-list": [
    "uri",
    "uris",
    "urls"
  ],
  "text/vcard": [
    "vcard"
  ],
  "text/vnd.curl": [
    "curl"
  ],
  "text/vnd.curl.dcurl": [
    "dcurl"
  ],
  "text/vnd.curl.mcurl": [
    "mcurl"
  ],
  "text/vnd.curl.scurl": [
    "scurl"
  ],
  "text/vnd.dvb.subtitle": [
    "sub"
  ],
  "text/vnd.fly": [
    "fly"
  ],
  "text/vnd.fmi.flexstor": [
    "flx"
  ],
  "text/vnd.graphviz": [
    "gv"
  ],
  "text/vnd.in3d.3dml": [
    "3dml"
  ],
  "text/vnd.in3d.spot": [
    "spot"
  ],
  "text/vnd.sun.j2me.app-descriptor": [
    "jad"
  ],
  "text/vnd.wap.wml": [
    "wml"
  ],
  "text/vnd.wap.wmlscript": [
    "wmls"
  ],
  "text/vtt": [
    "vtt"
  ],
  "text/x-asm": [
    "s",
    "asm"
  ],
  "text/x-c": [
    "c",
    "cc",
    "cxx",
    "cpp",
    "h",
    "hh",
    "dic"
  ],
  "text/x-component": [
    "htc"
  ],
  "text/x-fortran": [
    "f",
    "for",
    "f77",
    "f90"
  ],
  "text/x-handlebars-template": [
    "hbs"
  ],
  "text/x-java-source": [
    "java"
  ],
  "text/x-lua": [
    "lua"
  ],
  "text/x-markdown": [
    "mkd"
  ],
  "text/x-nfo": [
    "nfo"
  ],
  "text/x-opml": [
    "opml"
  ],
  "text/x-org": [],
  "text/x-pascal": [
    "p",
    "pas"
  ],
  "text/x-processing": [
    "pde"
  ],
  "text/x-sass": [
    "sass"
  ],
  "text/x-scss": [
    "scss"
  ],
  "text/x-setext": [
    "etx"
  ],
  "text/x-sfv": [
    "sfv"
  ],
  "text/x-suse-ymp": [
    "ymp"
  ],
  "text/x-uuencode": [
    "uu"
  ],
  "text/x-vcalendar": [
    "vcs"
  ],
  "text/x-vcard": [
    "vcf"
  ],
  "text/xml": [],
  "text/yaml": [
    "yaml",
    "yml"
  ],
  "video/3gpp": [
    "3gp",
    "3gpp"
  ],
  "video/3gpp2": [
    "3g2"
  ],
  "video/h261": [
    "h261"
  ],
  "video/h263": [
    "h263"
  ],
  "video/h264": [
    "h264"
  ],
  "video/jpeg": [
    "jpgv"
  ],
  "video/jpm": [
    "jpgm"
  ],
  "video/mj2": [
    "mj2",
    "mjp2"
  ],
  "video/mp2t": [
    "ts"
  ],
  "video/mp4": [
    "mp4",
    "mp4v",
    "mpg4"
  ],
  "video/mpeg": [
    "mpeg",
    "mpg",
    "mpe",
    "m1v",
    "m2v"
  ],
  "video/ogg": [
    "ogv"
  ],
  "video/quicktime": [
    "qt",
    "mov"
  ],
  "video/vnd.dece.hd": [
    "uvh",
    "uvvh"
  ],
  "video/vnd.dece.mobile": [
    "uvm",
    "uvvm"
  ],
  "video/vnd.dece.pd": [
    "uvp",
    "uvvp"
  ],
  "video/vnd.dece.sd": [
    "uvs",
    "uvvs"
  ],
  "video/vnd.dece.video": [
    "uvv",
    "uvvv"
  ],
  "video/vnd.dvb.file": [
    "dvb"
  ],
  "video/vnd.fvt": [
    "fvt"
  ],
  "video/vnd.mpegurl": [
    "mxu",
    "m4u"
  ],
  "video/vnd.ms-playready.media.pyv": [
    "pyv"
  ],
  "video/vnd.uvvu.mp4": [
    "uvu",
    "uvvu"
  ],
  "video/vnd.vivo": [
    "viv"
  ],
  "video/webm": [
    "webm"
  ],
  "video/x-f4v": [
    "f4v"
  ],
  "video/x-fli": [
    "fli"
  ],
  "video/x-flv": [
    "flv"
  ],
  "video/x-m4v": [
    "m4v"
  ],
  "video/x-matroska": [
    "mkv",
    "mk3d",
    "mks"
  ],
  "video/x-mng": [
    "mng"
  ],
  "video/x-ms-asf": [
    "asf",
    "asx"
  ],
  "video/x-ms-vob": [
    "vob"
  ],
  "video/x-ms-wm": [
    "wm"
  ],
  "video/x-ms-wmv": [
    "wmv"
  ],
  "video/x-ms-wmx": [
    "wmx"
  ],
  "video/x-ms-wvx": [
    "wvx"
  ],
  "video/x-msvideo": [
    "avi"
  ],
  "video/x-sgi-movie": [
    "movie"
  ],
  "video/x-smv": [
    "smv"
  ],
  "x-conference/x-cooltalk": [
    "ice"
  ]
};
var fs$o = require$$0$7;
function Mime() {
  this.types = /* @__PURE__ */ Object.create(null);
  this.extensions = /* @__PURE__ */ Object.create(null);
}
Mime.prototype.define = function(map2) {
  for (var type3 in map2) {
    var exts = map2[type3];
    for (var i = 0; i < exts.length; i++) {
      if (process.env.DEBUG_MIME && this.types[exts[i]]) {
        console.warn((this._loading || "define()").replace(/.*\//, ""), 'changes "' + exts[i] + '" extension type from ' + this.types[exts[i]] + " to " + type3);
      }
      this.types[exts[i]] = type3;
    }
    if (!this.extensions[type3]) {
      this.extensions[type3] = exts[0];
    }
  }
};
Mime.prototype.load = function(file2) {
  this._loading = file2;
  var map2 = {}, content = fs$o.readFileSync(file2, "ascii"), lines = content.split(/[\r\n]+/);
  lines.forEach(function(line) {
    var fields = line.replace(/\s*#.*|^\s*|\s*$/g, "").split(/\s+/);
    map2[fields.shift()] = fields;
  });
  this.define(map2);
  this._loading = null;
};
Mime.prototype.lookup = function(path22, fallback) {
  var ext = path22.replace(/^.*[\.\/\\]/, "").toLowerCase();
  return this.types[ext] || fallback || this.default_type;
};
Mime.prototype.extension = function(mimeType) {
  var type3 = mimeType.match(/^\s*([^;\s]*)(?:;|\s|$)/)[1].toLowerCase();
  return this.extensions[type3];
};
var mime$4 = new Mime();
mime$4.define(require$$2);
mime$4.default_type = mime$4.lookup("bin");
mime$4.Mime = Mime;
mime$4.charsets = {
  lookup: function(mimeType, fallback) {
    return /^text\/|^application\/(javascript|json)/.test(mimeType) ? "UTF-8" : fallback;
  }
};
var mime_1 = mime$4;
var s$1 = 1e3;
var m = s$1 * 60;
var h = m * 60;
var d$5 = h * 24;
var w = d$5 * 7;
var y = d$5 * 365.25;
var ms$2 = function(val, options) {
  options = options || {};
  var type3 = typeof val;
  if (type3 === "string" && val.length > 0) {
    return parse$4(val);
  } else if (type3 === "number" && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse$4(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str2
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type3 = (match2[2] || "ms").toLowerCase();
  switch (type3) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "weeks":
    case "week":
    case "w":
      return n * w;
    case "days":
    case "day":
    case "d":
      return n * d$5;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s$1;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d$5) {
    return Math.round(ms2 / d$5) + "d";
  }
  if (msAbs >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (msAbs >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (msAbs >= s$1) {
    return Math.round(ms2 / s$1) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  var msAbs = Math.abs(ms2);
  if (msAbs >= d$5) {
    return plural(ms2, msAbs, d$5, "day");
  }
  if (msAbs >= h) {
    return plural(ms2, msAbs, h, "hour");
  }
  if (msAbs >= m) {
    return plural(ms2, msAbs, m, "minute");
  }
  if (msAbs >= s$1) {
    return plural(ms2, msAbs, s$1, "second");
  }
  return ms2 + " ms";
}
function plural(ms2, msAbs, n, name2) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
}
/*!
 * range-parser
 * Copyright(c) 2012-2014 TJ Holowaychuk
 * Copyright(c) 2015-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var rangeParser_1 = rangeParser;
function rangeParser(size, str2, options) {
  if (typeof str2 !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var index2 = str2.indexOf("=");
  if (index2 === -1) {
    return -2;
  }
  var arr = str2.slice(index2 + 1).split(",");
  var ranges = [];
  ranges.type = str2.slice(0, index2);
  for (var i = 0; i < arr.length; i++) {
    var range3 = arr[i].split("-");
    var start = parseInt(range3[0], 10);
    var end = parseInt(range3[1], 10);
    if (isNaN(start)) {
      start = size - end;
      end = size - 1;
    } else if (isNaN(end)) {
      end = size - 1;
    }
    if (end > size - 1) {
      end = size - 1;
    }
    if (isNaN(start) || isNaN(end) || start > end || start < 0) {
      continue;
    }
    ranges.push({
      start,
      end
    });
  }
  if (ranges.length < 1) {
    return -1;
  }
  return options && options.combine ? combineRanges(ranges) : ranges;
}
function combineRanges(ranges) {
  var ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);
  for (var j2 = 0, i = 1; i < ordered.length; i++) {
    var range3 = ordered[i];
    var current = ordered[j2];
    if (range3.start > current.end + 1) {
      ordered[++j2] = range3;
    } else if (range3.end > current.end) {
      current.end = range3.end;
      current.index = Math.min(current.index, range3.index);
    }
  }
  ordered.length = j2 + 1;
  var combined = ordered.sort(sortByRangeIndex).map(mapWithoutIndex);
  combined.type = ranges.type;
  return combined;
}
function mapWithIndex(range3, index2) {
  return {
    start: range3.start,
    end: range3.end,
    index: index2
  };
}
function mapWithoutIndex(range3) {
  return {
    start: range3.start,
    end: range3.end
  };
}
function sortByRangeIndex(a, b) {
  return a.index - b.index;
}
function sortByRangeStart(a, b) {
  return a.start - b.start;
}
/*!
 * send
 * Copyright(c) 2012 TJ Holowaychuk
 * Copyright(c) 2014-2022 Douglas Christopher Wilson
 * MIT Licensed
 */
var createError$1 = httpErrorsExports;
var debug$d = srcExports$1("send");
var deprecate$2 = depd_1("send");
var destroy$1 = destroy_1;
var encodeUrl$1 = encodeurl;
var escapeHtml$1 = escapeHtml_1;
var etag = etag_1;
var fresh$1 = fresh_1;
var fs$n = require$$0$7;
var mime$3 = mime_1;
var ms$1 = ms$2;
var onFinished$1 = onFinishedExports;
var parseRange$1 = rangeParser_1;
var path$k = require$$1$2;
var statuses$1 = statuses$3;
var Stream$4 = require$$1$4;
var util$c = require$$1$3;
var extname$1 = path$k.extname;
var join$1 = path$k.join;
var normalize = path$k.normalize;
var resolve$1 = path$k.resolve;
var sep = path$k.sep;
var BYTES_RANGE_REGEXP = /^ *bytes=/;
var MAX_MAXAGE = 60 * 60 * 24 * 365 * 1e3;
var UP_PATH_REGEXP = /(?:^|[\\/])\.\.(?:[\\/]|$)/;
send$2.exports = send$1;
send$2.exports.mime = mime$3;
function send$1(req2, path3, options) {
  return new SendStream(req2, path3, options);
}
function SendStream(req2, path3, options) {
  Stream$4.call(this);
  var opts = options || {};
  this.options = opts;
  this.path = path3;
  this.req = req2;
  this._acceptRanges = opts.acceptRanges !== void 0 ? Boolean(opts.acceptRanges) : true;
  this._cacheControl = opts.cacheControl !== void 0 ? Boolean(opts.cacheControl) : true;
  this._etag = opts.etag !== void 0 ? Boolean(opts.etag) : true;
  this._dotfiles = opts.dotfiles !== void 0 ? opts.dotfiles : "ignore";
  if (this._dotfiles !== "ignore" && this._dotfiles !== "allow" && this._dotfiles !== "deny") {
    throw new TypeError('dotfiles option must be "allow", "deny", or "ignore"');
  }
  this._hidden = Boolean(opts.hidden);
  if (opts.hidden !== void 0) {
    deprecate$2("hidden: use dotfiles: '" + (this._hidden ? "allow" : "ignore") + "' instead");
  }
  if (opts.dotfiles === void 0) {
    this._dotfiles = void 0;
  }
  this._extensions = opts.extensions !== void 0 ? normalizeList(opts.extensions, "extensions option") : [];
  this._immutable = opts.immutable !== void 0 ? Boolean(opts.immutable) : false;
  this._index = opts.index !== void 0 ? normalizeList(opts.index, "index option") : ["index.html"];
  this._lastModified = opts.lastModified !== void 0 ? Boolean(opts.lastModified) : true;
  this._maxage = opts.maxAge || opts.maxage;
  this._maxage = typeof this._maxage === "string" ? ms$1(this._maxage) : Number(this._maxage);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  this._root = opts.root ? resolve$1(opts.root) : null;
  if (!this._root && opts.from) {
    this.from(opts.from);
  }
}
util$c.inherits(SendStream, Stream$4);
SendStream.prototype.etag = deprecate$2.function(function etag2(val) {
  this._etag = Boolean(val);
  debug$d("etag %s", this._etag);
  return this;
}, "send.etag: pass etag as option");
SendStream.prototype.hidden = deprecate$2.function(function hidden(val) {
  this._hidden = Boolean(val);
  this._dotfiles = void 0;
  debug$d("hidden %s", this._hidden);
  return this;
}, "send.hidden: use dotfiles option");
SendStream.prototype.index = deprecate$2.function(function index(paths) {
  var index2 = !paths ? [] : normalizeList(paths, "paths argument");
  debug$d("index %o", paths);
  this._index = index2;
  return this;
}, "send.index: pass index as option");
SendStream.prototype.root = function root(path3) {
  this._root = resolve$1(String(path3));
  debug$d("root %s", this._root);
  return this;
};
SendStream.prototype.from = deprecate$2.function(
  SendStream.prototype.root,
  "send.from: pass root as option"
);
SendStream.prototype.root = deprecate$2.function(
  SendStream.prototype.root,
  "send.root: pass root as option"
);
SendStream.prototype.maxage = deprecate$2.function(function maxage(maxAge2) {
  this._maxage = typeof maxAge2 === "string" ? ms$1(maxAge2) : Number(maxAge2);
  this._maxage = !isNaN(this._maxage) ? Math.min(Math.max(0, this._maxage), MAX_MAXAGE) : 0;
  debug$d("max-age %d", this._maxage);
  return this;
}, "send.maxage: pass maxAge as option");
SendStream.prototype.error = function error(status3, err) {
  if (hasListeners(this, "error")) {
    return this.emit("error", createHttpError(status3, err));
  }
  var res2 = this.res;
  var msg = statuses$1.message[status3] || String(status3);
  var doc = createHtmlDocument("Error", escapeHtml$1(msg));
  clearHeaders(res2);
  if (err && err.headers) {
    setHeaders(res2, err.headers);
  }
  res2.statusCode = status3;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.end(doc);
};
SendStream.prototype.hasTrailingSlash = function hasTrailingSlash() {
  return this.path[this.path.length - 1] === "/";
};
SendStream.prototype.isConditionalGET = function isConditionalGET() {
  return this.req.headers["if-match"] || this.req.headers["if-unmodified-since"] || this.req.headers["if-none-match"] || this.req.headers["if-modified-since"];
};
SendStream.prototype.isPreconditionFailure = function isPreconditionFailure() {
  var req2 = this.req;
  var res2 = this.res;
  var match2 = req2.headers["if-match"];
  if (match2) {
    var etag3 = res2.getHeader("ETag");
    return !etag3 || match2 !== "*" && parseTokenList(match2).every(function(match3) {
      return match3 !== etag3 && match3 !== "W/" + etag3 && "W/" + match3 !== etag3;
    });
  }
  var unmodifiedSince = parseHttpDate(req2.headers["if-unmodified-since"]);
  if (!isNaN(unmodifiedSince)) {
    var lastModified = parseHttpDate(res2.getHeader("Last-Modified"));
    return isNaN(lastModified) || lastModified > unmodifiedSince;
  }
  return false;
};
SendStream.prototype.removeContentHeaderFields = function removeContentHeaderFields() {
  var res2 = this.res;
  res2.removeHeader("Content-Encoding");
  res2.removeHeader("Content-Language");
  res2.removeHeader("Content-Length");
  res2.removeHeader("Content-Range");
  res2.removeHeader("Content-Type");
};
SendStream.prototype.notModified = function notModified() {
  var res2 = this.res;
  debug$d("not modified");
  this.removeContentHeaderFields();
  res2.statusCode = 304;
  res2.end();
};
SendStream.prototype.headersAlreadySent = function headersAlreadySent() {
  var err = new Error("Can't set headers after they are sent.");
  debug$d("headers already sent");
  this.error(500, err);
};
SendStream.prototype.isCachable = function isCachable() {
  var statusCode = this.res.statusCode;
  return statusCode >= 200 && statusCode < 300 || statusCode === 304;
};
SendStream.prototype.onStatError = function onStatError(error2) {
  switch (error2.code) {
    case "ENAMETOOLONG":
    case "ENOENT":
    case "ENOTDIR":
      this.error(404, error2);
      break;
    default:
      this.error(500, error2);
      break;
  }
};
SendStream.prototype.isFresh = function isFresh() {
  return fresh$1(this.req.headers, {
    etag: this.res.getHeader("ETag"),
    "last-modified": this.res.getHeader("Last-Modified")
  });
};
SendStream.prototype.isRangeFresh = function isRangeFresh() {
  var ifRange = this.req.headers["if-range"];
  if (!ifRange) {
    return true;
  }
  if (ifRange.indexOf('"') !== -1) {
    var etag3 = this.res.getHeader("ETag");
    return Boolean(etag3 && ifRange.indexOf(etag3) !== -1);
  }
  var lastModified = this.res.getHeader("Last-Modified");
  return parseHttpDate(lastModified) <= parseHttpDate(ifRange);
};
SendStream.prototype.redirect = function redirect(path3) {
  var res2 = this.res;
  if (hasListeners(this, "directory")) {
    this.emit("directory", res2, path3);
    return;
  }
  if (this.hasTrailingSlash()) {
    this.error(403);
    return;
  }
  var loc = encodeUrl$1(collapseLeadingSlashes(this.path + "/"));
  var doc = createHtmlDocument("Redirecting", 'Redirecting to <a href="' + escapeHtml$1(loc) + '">' + escapeHtml$1(loc) + "</a>");
  res2.statusCode = 301;
  res2.setHeader("Content-Type", "text/html; charset=UTF-8");
  res2.setHeader("Content-Length", Buffer.byteLength(doc));
  res2.setHeader("Content-Security-Policy", "default-src 'none'");
  res2.setHeader("X-Content-Type-Options", "nosniff");
  res2.setHeader("Location", loc);
  res2.end(doc);
};
SendStream.prototype.pipe = function pipe(res2) {
  var root2 = this._root;
  this.res = res2;
  var path3 = decode$3(this.path);
  if (path3 === -1) {
    this.error(400);
    return res2;
  }
  if (~path3.indexOf("\0")) {
    this.error(400);
    return res2;
  }
  var parts;
  if (root2 !== null) {
    if (path3) {
      path3 = normalize("." + sep + path3);
    }
    if (UP_PATH_REGEXP.test(path3)) {
      debug$d('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = path3.split(sep);
    path3 = normalize(join$1(root2, path3));
  } else {
    if (UP_PATH_REGEXP.test(path3)) {
      debug$d('malicious path "%s"', path3);
      this.error(403);
      return res2;
    }
    parts = normalize(path3).split(sep);
    path3 = resolve$1(path3);
  }
  if (containsDotFile(parts)) {
    var access = this._dotfiles;
    if (access === void 0) {
      access = parts[parts.length - 1][0] === "." ? this._hidden ? "allow" : "ignore" : "allow";
    }
    debug$d('%s dotfile "%s"', access, path3);
    switch (access) {
      case "allow":
        break;
      case "deny":
        this.error(403);
        return res2;
      case "ignore":
      default:
        this.error(404);
        return res2;
    }
  }
  if (this._index.length && this.hasTrailingSlash()) {
    this.sendIndex(path3);
    return res2;
  }
  this.sendFile(path3);
  return res2;
};
SendStream.prototype.send = function send(path3, stat2) {
  var len = stat2.size;
  var options = this.options;
  var opts = {};
  var res2 = this.res;
  var req2 = this.req;
  var ranges = req2.headers.range;
  var offset = options.start || 0;
  if (headersSent(res2)) {
    this.headersAlreadySent();
    return;
  }
  debug$d('pipe "%s"', path3);
  this.setHeader(path3, stat2);
  this.type(path3);
  if (this.isConditionalGET()) {
    if (this.isPreconditionFailure()) {
      this.error(412);
      return;
    }
    if (this.isCachable() && this.isFresh()) {
      this.notModified();
      return;
    }
  }
  len = Math.max(0, len - offset);
  if (options.end !== void 0) {
    var bytes2 = options.end - offset + 1;
    if (len > bytes2) len = bytes2;
  }
  if (this._acceptRanges && BYTES_RANGE_REGEXP.test(ranges)) {
    ranges = parseRange$1(len, ranges, {
      combine: true
    });
    if (!this.isRangeFresh()) {
      debug$d("range stale");
      ranges = -2;
    }
    if (ranges === -1) {
      debug$d("range unsatisfiable");
      res2.setHeader("Content-Range", contentRange("bytes", len));
      return this.error(416, {
        headers: { "Content-Range": res2.getHeader("Content-Range") }
      });
    }
    if (ranges !== -2 && ranges.length === 1) {
      debug$d("range %j", ranges);
      res2.statusCode = 206;
      res2.setHeader("Content-Range", contentRange("bytes", len, ranges[0]));
      offset += ranges[0].start;
      len = ranges[0].end - ranges[0].start + 1;
    }
  }
  for (var prop in options) {
    opts[prop] = options[prop];
  }
  opts.start = offset;
  opts.end = Math.max(offset, offset + len - 1);
  res2.setHeader("Content-Length", len);
  if (req2.method === "HEAD") {
    res2.end();
    return;
  }
  this.stream(path3, opts);
};
SendStream.prototype.sendFile = function sendFile(path3) {
  var i = 0;
  var self3 = this;
  debug$d('stat "%s"', path3);
  fs$n.stat(path3, function onstat(err, stat2) {
    if (err && err.code === "ENOENT" && !extname$1(path3) && path3[path3.length - 1] !== sep) {
      return next(err);
    }
    if (err) return self3.onStatError(err);
    if (stat2.isDirectory()) return self3.redirect(path3);
    self3.emit("file", path3, stat2);
    self3.send(path3, stat2);
  });
  function next(err) {
    if (self3._extensions.length <= i) {
      return err ? self3.onStatError(err) : self3.error(404);
    }
    var p = path3 + "." + self3._extensions[i++];
    debug$d('stat "%s"', p);
    fs$n.stat(p, function(err2, stat2) {
      if (err2) return next(err2);
      if (stat2.isDirectory()) return next();
      self3.emit("file", p, stat2);
      self3.send(p, stat2);
    });
  }
};
SendStream.prototype.sendIndex = function sendIndex(path3) {
  var i = -1;
  var self3 = this;
  function next(err) {
    if (++i >= self3._index.length) {
      if (err) return self3.onStatError(err);
      return self3.error(404);
    }
    var p = join$1(path3, self3._index[i]);
    debug$d('stat "%s"', p);
    fs$n.stat(p, function(err2, stat2) {
      if (err2) return next(err2);
      if (stat2.isDirectory()) return next();
      self3.emit("file", p, stat2);
      self3.send(p, stat2);
    });
  }
  next();
};
SendStream.prototype.stream = function stream(path3, options) {
  var self3 = this;
  var res2 = this.res;
  var stream3 = fs$n.createReadStream(path3, options);
  this.emit("stream", stream3);
  stream3.pipe(res2);
  function cleanup() {
    destroy$1(stream3, true);
  }
  onFinished$1(res2, cleanup);
  stream3.on("error", function onerror(err) {
    cleanup();
    self3.onStatError(err);
  });
  stream3.on("end", function onend() {
    self3.emit("end");
  });
};
SendStream.prototype.type = function type2(path3) {
  var res2 = this.res;
  if (res2.getHeader("Content-Type")) return;
  var type3 = mime$3.lookup(path3);
  if (!type3) {
    debug$d("no content-type");
    return;
  }
  var charset3 = mime$3.charsets.lookup(type3);
  debug$d("content-type %s", type3);
  res2.setHeader("Content-Type", type3 + (charset3 ? "; charset=" + charset3 : ""));
};
SendStream.prototype.setHeader = function setHeader(path3, stat2) {
  var res2 = this.res;
  this.emit("headers", res2, path3, stat2);
  if (this._acceptRanges && !res2.getHeader("Accept-Ranges")) {
    debug$d("accept ranges");
    res2.setHeader("Accept-Ranges", "bytes");
  }
  if (this._cacheControl && !res2.getHeader("Cache-Control")) {
    var cacheControl = "public, max-age=" + Math.floor(this._maxage / 1e3);
    if (this._immutable) {
      cacheControl += ", immutable";
    }
    debug$d("cache-control %s", cacheControl);
    res2.setHeader("Cache-Control", cacheControl);
  }
  if (this._lastModified && !res2.getHeader("Last-Modified")) {
    var modified = stat2.mtime.toUTCString();
    debug$d("modified %s", modified);
    res2.setHeader("Last-Modified", modified);
  }
  if (this._etag && !res2.getHeader("ETag")) {
    var val = etag(stat2);
    debug$d("etag %s", val);
    res2.setHeader("ETag", val);
  }
};
function clearHeaders(res2) {
  var headers = getHeaderNames(res2);
  for (var i = 0; i < headers.length; i++) {
    res2.removeHeader(headers[i]);
  }
}
function collapseLeadingSlashes(str2) {
  for (var i = 0; i < str2.length; i++) {
    if (str2[i] !== "/") {
      break;
    }
  }
  return i > 1 ? "/" + str2.substr(i) : str2;
}
function containsDotFile(parts) {
  for (var i = 0; i < parts.length; i++) {
    var part = parts[i];
    if (part.length > 1 && part[0] === ".") {
      return true;
    }
  }
  return false;
}
function contentRange(type3, size, range3) {
  return type3 + " " + (range3 ? range3.start + "-" + range3.end : "*") + "/" + size;
}
function createHtmlDocument(title, body) {
  return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
}
function createHttpError(status3, err) {
  if (!err) {
    return createError$1(status3);
  }
  return err instanceof Error ? createError$1(status3, err, { expose: false }) : createError$1(status3, err);
}
function decode$3(path3) {
  try {
    return decodeURIComponent(path3);
  } catch (err) {
    return -1;
  }
}
function getHeaderNames(res2) {
  return typeof res2.getHeaderNames !== "function" ? Object.keys(res2._headers || {}) : res2.getHeaderNames();
}
function hasListeners(emitter, type3) {
  var count = typeof emitter.listenerCount !== "function" ? emitter.listeners(type3).length : emitter.listenerCount(type3);
  return count > 0;
}
function headersSent(res2) {
  return typeof res2.headersSent !== "boolean" ? Boolean(res2._header) : res2.headersSent;
}
function normalizeList(val, name2) {
  var list = [].concat(val || []);
  for (var i = 0; i < list.length; i++) {
    if (typeof list[i] !== "string") {
      throw new TypeError(name2 + " must be array of strings or false");
    }
  }
  return list;
}
function parseHttpDate(date) {
  var timestamp = date && Date.parse(date);
  return typeof timestamp === "number" ? timestamp : NaN;
}
function parseTokenList(str2) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = str2.length; i < len; i++) {
    switch (str2.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        if (start !== end) {
          list.push(str2.substring(start, end));
        }
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  if (start !== end) {
    list.push(str2.substring(start, end));
  }
  return list;
}
function setHeaders(res2, headers) {
  var keys2 = Object.keys(headers);
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    res2.setHeader(key, headers[key]);
  }
}
var sendExports = send$2.exports;
var proxyAddr = { exports: {} };
/*!
 * forwarded
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
var forwarded_1 = forwarded$1;
function forwarded$1(req2) {
  if (!req2) {
    throw new TypeError("argument req is required");
  }
  var proxyAddrs = parse$3(req2.headers["x-forwarded-for"] || "");
  var socketAddr = getSocketAddr(req2);
  var addrs = [socketAddr].concat(proxyAddrs);
  return addrs;
}
function getSocketAddr(req2) {
  return req2.socket ? req2.socket.remoteAddress : req2.connection.remoteAddress;
}
function parse$3(header3) {
  var end = header3.length;
  var list = [];
  var start = header3.length;
  for (var i = header3.length - 1; i >= 0; i--) {
    switch (header3.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i;
        }
        break;
      case 44:
        if (start !== end) {
          list.push(header3.substring(start, end));
        }
        start = end = i;
        break;
      default:
        start = i;
        break;
    }
  }
  if (start !== end) {
    list.push(header3.substring(start, end));
  }
  return list;
}
var ipaddr$1 = { exports: {} };
ipaddr$1.exports;
(function(module2) {
  (function() {
    var expandIPv6, ipaddr2, ipv4Part, ipv4Regexes, ipv6Part, ipv6Regexes, matchCIDR, root2, zoneIndex;
    ipaddr2 = {};
    root2 = this;
    if (module2 !== null && module2.exports) {
      module2.exports = ipaddr2;
    } else {
      root2["ipaddr"] = ipaddr2;
    }
    matchCIDR = function(first2, second, partSize, cidrBits) {
      var part, shift;
      if (first2.length !== second.length) {
        throw new Error("ipaddr: cannot match CIDR for objects with different lengths");
      }
      part = 0;
      while (cidrBits > 0) {
        shift = partSize - cidrBits;
        if (shift < 0) {
          shift = 0;
        }
        if (first2[part] >> shift !== second[part] >> shift) {
          return false;
        }
        cidrBits -= partSize;
        part += 1;
      }
      return true;
    };
    ipaddr2.subnetMatch = function(address, rangeList, defaultName) {
      var k, len, rangeName, rangeSubnets, subnet;
      if (defaultName == null) {
        defaultName = "unicast";
      }
      for (rangeName in rangeList) {
        rangeSubnets = rangeList[rangeName];
        if (rangeSubnets[0] && !(rangeSubnets[0] instanceof Array)) {
          rangeSubnets = [rangeSubnets];
        }
        for (k = 0, len = rangeSubnets.length; k < len; k++) {
          subnet = rangeSubnets[k];
          if (address.kind() === subnet[0].kind()) {
            if (address.match.apply(address, subnet)) {
              return rangeName;
            }
          }
        }
      }
      return defaultName;
    };
    ipaddr2.IPv4 = function() {
      function IPv4(octets) {
        var k, len, octet;
        if (octets.length !== 4) {
          throw new Error("ipaddr: ipv4 octet count should be 4");
        }
        for (k = 0, len = octets.length; k < len; k++) {
          octet = octets[k];
          if (!(0 <= octet && octet <= 255)) {
            throw new Error("ipaddr: ipv4 octet should fit in 8 bits");
          }
        }
        this.octets = octets;
      }
      IPv4.prototype.kind = function() {
        return "ipv4";
      };
      IPv4.prototype.toString = function() {
        return this.octets.join(".");
      };
      IPv4.prototype.toNormalizedString = function() {
        return this.toString();
      };
      IPv4.prototype.toByteArray = function() {
        return this.octets.slice(0);
      };
      IPv4.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv4") {
          throw new Error("ipaddr: cannot match ipv4 address with non-ipv4 one");
        }
        return matchCIDR(this.octets, other.octets, 8, cidrRange);
      };
      IPv4.prototype.SpecialRanges = {
        unspecified: [[new IPv4([0, 0, 0, 0]), 8]],
        broadcast: [[new IPv4([255, 255, 255, 255]), 32]],
        multicast: [[new IPv4([224, 0, 0, 0]), 4]],
        linkLocal: [[new IPv4([169, 254, 0, 0]), 16]],
        loopback: [[new IPv4([127, 0, 0, 0]), 8]],
        carrierGradeNat: [[new IPv4([100, 64, 0, 0]), 10]],
        "private": [[new IPv4([10, 0, 0, 0]), 8], [new IPv4([172, 16, 0, 0]), 12], [new IPv4([192, 168, 0, 0]), 16]],
        reserved: [[new IPv4([192, 0, 0, 0]), 24], [new IPv4([192, 0, 2, 0]), 24], [new IPv4([192, 88, 99, 0]), 24], [new IPv4([198, 51, 100, 0]), 24], [new IPv4([203, 0, 113, 0]), 24], [new IPv4([240, 0, 0, 0]), 4]]
      };
      IPv4.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv4.prototype.toIPv4MappedAddress = function() {
        return ipaddr2.IPv6.parse("::ffff:" + this.toString());
      };
      IPv4.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, octet, stop, zeros, zerotable;
        zerotable = {
          0: 8,
          128: 7,
          192: 6,
          224: 5,
          240: 4,
          248: 3,
          252: 2,
          254: 1,
          255: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 3; k >= 0; i = k += -1) {
          octet = this.octets[i];
          if (octet in zerotable) {
            zeros = zerotable[octet];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 8) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 32 - cidr;
      };
      return IPv4;
    }();
    ipv4Part = "(0?\\d+|0x[a-f0-9]+)";
    ipv4Regexes = {
      fourOctet: new RegExp("^" + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "$", "i"),
      longValue: new RegExp("^" + ipv4Part + "$", "i")
    };
    ipaddr2.IPv4.parser = function(string2) {
      var match2, parseIntAuto, part, shift, value2;
      parseIntAuto = function(string3) {
        if (string3[0] === "0" && string3[1] !== "x") {
          return parseInt(string3, 8);
        } else {
          return parseInt(string3);
        }
      };
      if (match2 = string2.match(ipv4Regexes.fourOctet)) {
        return function() {
          var k, len, ref2, results;
          ref2 = match2.slice(1, 6);
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(parseIntAuto(part));
          }
          return results;
        }();
      } else if (match2 = string2.match(ipv4Regexes.longValue)) {
        value2 = parseIntAuto(match2[1]);
        if (value2 > 4294967295 || value2 < 0) {
          throw new Error("ipaddr: address outside defined range");
        }
        return function() {
          var k, results;
          results = [];
          for (shift = k = 0; k <= 24; shift = k += 8) {
            results.push(value2 >> shift & 255);
          }
          return results;
        }().reverse();
      } else {
        return null;
      }
    };
    ipaddr2.IPv6 = function() {
      function IPv6(parts, zoneId) {
        var i, k, l, len, part, ref2;
        if (parts.length === 16) {
          this.parts = [];
          for (i = k = 0; k <= 14; i = k += 2) {
            this.parts.push(parts[i] << 8 | parts[i + 1]);
          }
        } else if (parts.length === 8) {
          this.parts = parts;
        } else {
          throw new Error("ipaddr: ipv6 part count should be 8 or 16");
        }
        ref2 = this.parts;
        for (l = 0, len = ref2.length; l < len; l++) {
          part = ref2[l];
          if (!(0 <= part && part <= 65535)) {
            throw new Error("ipaddr: ipv6 part should fit in 16 bits");
          }
        }
        if (zoneId) {
          this.zoneId = zoneId;
        }
      }
      IPv6.prototype.kind = function() {
        return "ipv6";
      };
      IPv6.prototype.toString = function() {
        return this.toNormalizedString().replace(/((^|:)(0(:|$))+)/, "::");
      };
      IPv6.prototype.toRFC5952String = function() {
        var bestMatchIndex, bestMatchLength, match2, regex, string2;
        regex = /((^|:)(0(:|$)){2,})/g;
        string2 = this.toNormalizedString();
        bestMatchIndex = 0;
        bestMatchLength = -1;
        while (match2 = regex.exec(string2)) {
          if (match2[0].length > bestMatchLength) {
            bestMatchIndex = match2.index;
            bestMatchLength = match2[0].length;
          }
        }
        if (bestMatchLength < 0) {
          return string2;
        }
        return string2.substring(0, bestMatchIndex) + "::" + string2.substring(bestMatchIndex + bestMatchLength);
      };
      IPv6.prototype.toByteArray = function() {
        var bytes2, k, len, part, ref2;
        bytes2 = [];
        ref2 = this.parts;
        for (k = 0, len = ref2.length; k < len; k++) {
          part = ref2[k];
          bytes2.push(part >> 8);
          bytes2.push(part & 255);
        }
        return bytes2;
      };
      IPv6.prototype.toNormalizedString = function() {
        var addr, part, suffix;
        addr = (function() {
          var k, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(part.toString(16));
          }
          return results;
        }).call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.toFixedLengthString = function() {
        var addr, part, suffix;
        addr = (function() {
          var k, len, ref2, results;
          ref2 = this.parts;
          results = [];
          for (k = 0, len = ref2.length; k < len; k++) {
            part = ref2[k];
            results.push(part.toString(16).padStart(4, "0"));
          }
          return results;
        }).call(this).join(":");
        suffix = "";
        if (this.zoneId) {
          suffix = "%" + this.zoneId;
        }
        return addr + suffix;
      };
      IPv6.prototype.match = function(other, cidrRange) {
        var ref2;
        if (cidrRange === void 0) {
          ref2 = other, other = ref2[0], cidrRange = ref2[1];
        }
        if (other.kind() !== "ipv6") {
          throw new Error("ipaddr: cannot match ipv6 address with non-ipv6 one");
        }
        return matchCIDR(this.parts, other.parts, 16, cidrRange);
      };
      IPv6.prototype.SpecialRanges = {
        unspecified: [new IPv6([0, 0, 0, 0, 0, 0, 0, 0]), 128],
        linkLocal: [new IPv6([65152, 0, 0, 0, 0, 0, 0, 0]), 10],
        multicast: [new IPv6([65280, 0, 0, 0, 0, 0, 0, 0]), 8],
        loopback: [new IPv6([0, 0, 0, 0, 0, 0, 0, 1]), 128],
        uniqueLocal: [new IPv6([64512, 0, 0, 0, 0, 0, 0, 0]), 7],
        ipv4Mapped: [new IPv6([0, 0, 0, 0, 0, 65535, 0, 0]), 96],
        rfc6145: [new IPv6([0, 0, 0, 0, 65535, 0, 0, 0]), 96],
        rfc6052: [new IPv6([100, 65435, 0, 0, 0, 0, 0, 0]), 96],
        "6to4": [new IPv6([8194, 0, 0, 0, 0, 0, 0, 0]), 16],
        teredo: [new IPv6([8193, 0, 0, 0, 0, 0, 0, 0]), 32],
        reserved: [[new IPv6([8193, 3512, 0, 0, 0, 0, 0, 0]), 32]]
      };
      IPv6.prototype.range = function() {
        return ipaddr2.subnetMatch(this, this.SpecialRanges);
      };
      IPv6.prototype.isIPv4MappedAddress = function() {
        return this.range() === "ipv4Mapped";
      };
      IPv6.prototype.toIPv4Address = function() {
        var high, low, ref2;
        if (!this.isIPv4MappedAddress()) {
          throw new Error("ipaddr: trying to convert a generic ipv6 address to ipv4");
        }
        ref2 = this.parts.slice(-2), high = ref2[0], low = ref2[1];
        return new ipaddr2.IPv4([high >> 8, high & 255, low >> 8, low & 255]);
      };
      IPv6.prototype.prefixLengthFromSubnetMask = function() {
        var cidr, i, k, part, stop, zeros, zerotable;
        zerotable = {
          0: 16,
          32768: 15,
          49152: 14,
          57344: 13,
          61440: 12,
          63488: 11,
          64512: 10,
          65024: 9,
          65280: 8,
          65408: 7,
          65472: 6,
          65504: 5,
          65520: 4,
          65528: 3,
          65532: 2,
          65534: 1,
          65535: 0
        };
        cidr = 0;
        stop = false;
        for (i = k = 7; k >= 0; i = k += -1) {
          part = this.parts[i];
          if (part in zerotable) {
            zeros = zerotable[part];
            if (stop && zeros !== 0) {
              return null;
            }
            if (zeros !== 16) {
              stop = true;
            }
            cidr += zeros;
          } else {
            return null;
          }
        }
        return 128 - cidr;
      };
      return IPv6;
    }();
    ipv6Part = "(?:[0-9a-f]+::?)+";
    zoneIndex = "%[0-9a-z]{1,}";
    ipv6Regexes = {
      zoneIndex: new RegExp(zoneIndex, "i"),
      "native": new RegExp("^(::)?(" + ipv6Part + ")?([0-9a-f]+)?(::)?(" + zoneIndex + ")?$", "i"),
      transitional: new RegExp("^((?:" + ipv6Part + ")|(?:::)(?:" + ipv6Part + ")?)" + (ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part + "\\." + ipv4Part) + ("(" + zoneIndex + ")?$"), "i")
    };
    expandIPv6 = function(string2, parts) {
      var colonCount, lastColon, part, replacement, replacementCount, zoneId;
      if (string2.indexOf("::") !== string2.lastIndexOf("::")) {
        return null;
      }
      zoneId = (string2.match(ipv6Regexes["zoneIndex"]) || [])[0];
      if (zoneId) {
        zoneId = zoneId.substring(1);
        string2 = string2.replace(/%.+$/, "");
      }
      colonCount = 0;
      lastColon = -1;
      while ((lastColon = string2.indexOf(":", lastColon + 1)) >= 0) {
        colonCount++;
      }
      if (string2.substr(0, 2) === "::") {
        colonCount--;
      }
      if (string2.substr(-2, 2) === "::") {
        colonCount--;
      }
      if (colonCount > parts) {
        return null;
      }
      replacementCount = parts - colonCount;
      replacement = ":";
      while (replacementCount--) {
        replacement += "0:";
      }
      string2 = string2.replace("::", replacement);
      if (string2[0] === ":") {
        string2 = string2.slice(1);
      }
      if (string2[string2.length - 1] === ":") {
        string2 = string2.slice(0, -1);
      }
      parts = function() {
        var k, len, ref2, results;
        ref2 = string2.split(":");
        results = [];
        for (k = 0, len = ref2.length; k < len; k++) {
          part = ref2[k];
          results.push(parseInt(part, 16));
        }
        return results;
      }();
      return {
        parts,
        zoneId
      };
    };
    ipaddr2.IPv6.parser = function(string2) {
      var addr, k, len, match2, octet, octets, zoneId;
      if (ipv6Regexes["native"].test(string2)) {
        return expandIPv6(string2, 8);
      } else if (match2 = string2.match(ipv6Regexes["transitional"])) {
        zoneId = match2[6] || "";
        addr = expandIPv6(match2[1].slice(0, -1) + zoneId, 6);
        if (addr.parts) {
          octets = [parseInt(match2[2]), parseInt(match2[3]), parseInt(match2[4]), parseInt(match2[5])];
          for (k = 0, len = octets.length; k < len; k++) {
            octet = octets[k];
            if (!(0 <= octet && octet <= 255)) {
              return null;
            }
          }
          addr.parts.push(octets[0] << 8 | octets[1]);
          addr.parts.push(octets[2] << 8 | octets[3]);
          return {
            parts: addr.parts,
            zoneId: addr.zoneId
          };
        }
      }
      return null;
    };
    ipaddr2.IPv4.isIPv4 = ipaddr2.IPv6.isIPv6 = function(string2) {
      return this.parser(string2) !== null;
    };
    ipaddr2.IPv4.isValid = function(string2) {
      try {
        new this(this.parser(string2));
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.isValidFourPartDecimal = function(string2) {
      if (ipaddr2.IPv4.isValid(string2) && string2.match(/^(0|[1-9]\d*)(\.(0|[1-9]\d*)){3}$/)) {
        return true;
      } else {
        return false;
      }
    };
    ipaddr2.IPv6.isValid = function(string2) {
      var addr;
      if (typeof string2 === "string" && string2.indexOf(":") === -1) {
        return false;
      }
      try {
        addr = this.parser(string2);
        new this(addr.parts, addr.zoneId);
        return true;
      } catch (error1) {
        return false;
      }
    };
    ipaddr2.IPv4.parse = function(string2) {
      var parts;
      parts = this.parser(string2);
      if (parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(parts);
    };
    ipaddr2.IPv6.parse = function(string2) {
      var addr;
      addr = this.parser(string2);
      if (addr.parts === null) {
        throw new Error("ipaddr: string is not formatted like ip address");
      }
      return new this(addr.parts, addr.zoneId);
    };
    ipaddr2.IPv4.parseCIDR = function(string2) {
      var maskLength, match2, parsed;
      if (match2 = string2.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 32) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv4 CIDR range");
    };
    ipaddr2.IPv4.subnetMaskFromPrefixLength = function(prefix) {
      var filledOctetCount, j2, octets;
      prefix = parseInt(prefix);
      if (prefix < 0 || prefix > 32) {
        throw new Error("ipaddr: invalid IPv4 prefix length");
      }
      octets = [0, 0, 0, 0];
      j2 = 0;
      filledOctetCount = Math.floor(prefix / 8);
      while (j2 < filledOctetCount) {
        octets[j2] = 255;
        j2++;
      }
      if (filledOctetCount < 4) {
        octets[filledOctetCount] = Math.pow(2, prefix % 8) - 1 << 8 - prefix % 8;
      }
      return new this(octets);
    };
    ipaddr2.IPv4.broadcastAddressFromCIDR = function(string2) {
      var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string2);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) | parseInt(subnetMaskOctets[i], 10) ^ 255);
          i++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv4.networkAddressFromCIDR = function(string2) {
      var cidr, i, ipInterfaceOctets, octets, subnetMaskOctets;
      try {
        cidr = this.parseCIDR(string2);
        ipInterfaceOctets = cidr[0].toByteArray();
        subnetMaskOctets = this.subnetMaskFromPrefixLength(cidr[1]).toByteArray();
        octets = [];
        i = 0;
        while (i < 4) {
          octets.push(parseInt(ipInterfaceOctets[i], 10) & parseInt(subnetMaskOctets[i], 10));
          i++;
        }
        return new this(octets);
      } catch (error1) {
        throw new Error("ipaddr: the address does not have IPv4 CIDR format");
      }
    };
    ipaddr2.IPv6.parseCIDR = function(string2) {
      var maskLength, match2, parsed;
      if (match2 = string2.match(/^(.+)\/(\d+)$/)) {
        maskLength = parseInt(match2[2]);
        if (maskLength >= 0 && maskLength <= 128) {
          parsed = [this.parse(match2[1]), maskLength];
          Object.defineProperty(parsed, "toString", {
            value: function() {
              return this.join("/");
            }
          });
          return parsed;
        }
      }
      throw new Error("ipaddr: string is not formatted like an IPv6 CIDR range");
    };
    ipaddr2.isValid = function(string2) {
      return ipaddr2.IPv6.isValid(string2) || ipaddr2.IPv4.isValid(string2);
    };
    ipaddr2.parse = function(string2) {
      if (ipaddr2.IPv6.isValid(string2)) {
        return ipaddr2.IPv6.parse(string2);
      } else if (ipaddr2.IPv4.isValid(string2)) {
        return ipaddr2.IPv4.parse(string2);
      } else {
        throw new Error("ipaddr: the address has neither IPv6 nor IPv4 format");
      }
    };
    ipaddr2.parseCIDR = function(string2) {
      try {
        return ipaddr2.IPv6.parseCIDR(string2);
      } catch (error1) {
        try {
          return ipaddr2.IPv4.parseCIDR(string2);
        } catch (error12) {
          throw new Error("ipaddr: the address has neither IPv6 nor IPv4 CIDR format");
        }
      }
    };
    ipaddr2.fromByteArray = function(bytes2) {
      var length;
      length = bytes2.length;
      if (length === 4) {
        return new ipaddr2.IPv4(bytes2);
      } else if (length === 16) {
        return new ipaddr2.IPv6(bytes2);
      } else {
        throw new Error("ipaddr: the binary input is neither an IPv6 nor IPv4 address");
      }
    };
    ipaddr2.process = function(string2) {
      var addr;
      addr = this.parse(string2);
      if (addr.kind() === "ipv6" && addr.isIPv4MappedAddress()) {
        return addr.toIPv4Address();
      } else {
        return addr;
      }
    };
  }).call(commonjsGlobal);
})(ipaddr$1);
var ipaddrExports = ipaddr$1.exports;
/*!
 * proxy-addr
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
proxyAddr.exports = proxyaddr$1;
proxyAddr.exports.all = alladdrs;
proxyAddr.exports.compile = compile$2;
var forwarded = forwarded_1;
var ipaddr = ipaddrExports;
var DIGIT_REGEXP = /^[0-9]+$/;
var isip = ipaddr.isValid;
var parseip = ipaddr.parse;
var IP_RANGES = {
  linklocal: ["169.254.0.0/16", "fe80::/10"],
  loopback: ["127.0.0.1/8", "::1/128"],
  uniquelocal: ["10.0.0.0/8", "172.16.0.0/12", "192.168.0.0/16", "fc00::/7"]
};
function alladdrs(req2, trust) {
  var addrs = forwarded(req2);
  if (!trust) {
    return addrs;
  }
  if (typeof trust !== "function") {
    trust = compile$2(trust);
  }
  for (var i = 0; i < addrs.length - 1; i++) {
    if (trust(addrs[i], i)) continue;
    addrs.length = i + 1;
  }
  return addrs;
}
function compile$2(val) {
  if (!val) {
    throw new TypeError("argument is required");
  }
  var trust;
  if (typeof val === "string") {
    trust = [val];
  } else if (Array.isArray(val)) {
    trust = val.slice();
  } else {
    throw new TypeError("unsupported trust argument");
  }
  for (var i = 0; i < trust.length; i++) {
    val = trust[i];
    if (!Object.prototype.hasOwnProperty.call(IP_RANGES, val)) {
      continue;
    }
    val = IP_RANGES[val];
    trust.splice.apply(trust, [i, 1].concat(val));
    i += val.length - 1;
  }
  return compileTrust(compileRangeSubnets(trust));
}
function compileRangeSubnets(arr) {
  var rangeSubnets = new Array(arr.length);
  for (var i = 0; i < arr.length; i++) {
    rangeSubnets[i] = parseipNotation(arr[i]);
  }
  return rangeSubnets;
}
function compileTrust(rangeSubnets) {
  var len = rangeSubnets.length;
  return len === 0 ? trustNone : len === 1 ? trustSingle(rangeSubnets[0]) : trustMulti(rangeSubnets);
}
function parseipNotation(note) {
  var pos = note.lastIndexOf("/");
  var str2 = pos !== -1 ? note.substring(0, pos) : note;
  if (!isip(str2)) {
    throw new TypeError("invalid IP address: " + str2);
  }
  var ip3 = parseip(str2);
  if (pos === -1 && ip3.kind() === "ipv6" && ip3.isIPv4MappedAddress()) {
    ip3 = ip3.toIPv4Address();
  }
  var max2 = ip3.kind() === "ipv6" ? 128 : 32;
  var range3 = pos !== -1 ? note.substring(pos + 1, note.length) : null;
  if (range3 === null) {
    range3 = max2;
  } else if (DIGIT_REGEXP.test(range3)) {
    range3 = parseInt(range3, 10);
  } else if (ip3.kind() === "ipv4" && isip(range3)) {
    range3 = parseNetmask(range3);
  } else {
    range3 = null;
  }
  if (range3 <= 0 || range3 > max2) {
    throw new TypeError("invalid range on address: " + note);
  }
  return [ip3, range3];
}
function parseNetmask(netmask2) {
  var ip3 = parseip(netmask2);
  var kind = ip3.kind();
  return kind === "ipv4" ? ip3.prefixLengthFromSubnetMask() : null;
}
function proxyaddr$1(req2, trust) {
  if (!req2) {
    throw new TypeError("req argument is required");
  }
  if (!trust) {
    throw new TypeError("trust argument is required");
  }
  var addrs = alladdrs(req2, trust);
  var addr = addrs[addrs.length - 1];
  return addr;
}
function trustNone() {
  return false;
}
function trustMulti(subnets) {
  return function trust(addr) {
    if (!isip(addr)) return false;
    var ip3 = parseip(addr);
    var ipconv;
    var kind = ip3.kind();
    for (var i = 0; i < subnets.length; i++) {
      var subnet = subnets[i];
      var subnetip = subnet[0];
      var subnetkind = subnetip.kind();
      var subnetrange = subnet[1];
      var trusted = ip3;
      if (kind !== subnetkind) {
        if (subnetkind === "ipv4" && !ip3.isIPv4MappedAddress()) {
          continue;
        }
        if (!ipconv) {
          ipconv = subnetkind === "ipv4" ? ip3.toIPv4Address() : ip3.toIPv4MappedAddress();
        }
        trusted = ipconv;
      }
      if (trusted.match(subnetip, subnetrange)) {
        return true;
      }
    }
    return false;
  };
}
function trustSingle(subnet) {
  var subnetip = subnet[0];
  var subnetkind = subnetip.kind();
  var subnetisipv4 = subnetkind === "ipv4";
  var subnetrange = subnet[1];
  return function trust(addr) {
    if (!isip(addr)) return false;
    var ip3 = parseip(addr);
    var kind = ip3.kind();
    if (kind !== subnetkind) {
      if (subnetisipv4 && !ip3.isIPv4MappedAddress()) {
        return false;
      }
      ip3 = subnetisipv4 ? ip3.toIPv4Address() : ip3.toIPv4MappedAddress();
    }
    return ip3.match(subnetip, subnetrange);
  };
}
var proxyAddrExports = proxyAddr.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(exports) {
  var Buffer2 = safeBufferExports.Buffer;
  var contentDisposition2 = contentDispositionExports;
  var contentType$1 = contentType;
  var deprecate2 = depd_1("express");
  var flatten2 = arrayFlatten_1;
  var mime2 = sendExports.mime;
  var etag3 = etag_1;
  var proxyaddr2 = proxyAddrExports;
  var qs = requireLib();
  var querystring = require$$8;
  exports.etag = createETagGenerator({ weak: false });
  exports.wetag = createETagGenerator({ weak: true });
  exports.isAbsolute = function(path3) {
    if ("/" === path3[0]) return true;
    if (":" === path3[1] && ("\\" === path3[2] || "/" === path3[2])) return true;
    if ("\\\\" === path3.substring(0, 2)) return true;
  };
  exports.flatten = deprecate2.function(
    flatten2,
    "utils.flatten: use array-flatten npm module instead"
  );
  exports.normalizeType = function(type3) {
    return ~type3.indexOf("/") ? acceptParams(type3) : { value: mime2.lookup(type3), params: {} };
  };
  exports.normalizeTypes = function(types2) {
    var ret = [];
    for (var i = 0; i < types2.length; ++i) {
      ret.push(exports.normalizeType(types2[i]));
    }
    return ret;
  };
  exports.contentDisposition = deprecate2.function(
    contentDisposition2,
    "utils.contentDisposition: use content-disposition npm module instead"
  );
  function acceptParams(str2) {
    var parts = str2.split(/ *; */);
    var ret = { value: parts[0], quality: 1, params: {} };
    for (var i = 1; i < parts.length; ++i) {
      var pms = parts[i].split(/ *= */);
      if ("q" === pms[0]) {
        ret.quality = parseFloat(pms[1]);
      } else {
        ret.params[pms[0]] = pms[1];
      }
    }
    return ret;
  }
  exports.compileETag = function(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "weak":
        fn = exports.wetag;
        break;
      case false:
        break;
      case "strong":
        fn = exports.etag;
        break;
      default:
        throw new TypeError("unknown value for etag function: " + val);
    }
    return fn;
  };
  exports.compileQueryParser = function compileQueryParser(val) {
    var fn;
    if (typeof val === "function") {
      return val;
    }
    switch (val) {
      case true:
      case "simple":
        fn = querystring.parse;
        break;
      case false:
        fn = newObject;
        break;
      case "extended":
        fn = parseExtendedQueryString;
        break;
      default:
        throw new TypeError("unknown value for query parser function: " + val);
    }
    return fn;
  };
  exports.compileTrust = function(val) {
    if (typeof val === "function") return val;
    if (val === true) {
      return function() {
        return true;
      };
    }
    if (typeof val === "number") {
      return function(a, i) {
        return i < val;
      };
    }
    if (typeof val === "string") {
      val = val.split(",").map(function(v) {
        return v.trim();
      });
    }
    return proxyaddr2.compile(val || []);
  };
  exports.setCharset = function setCharset2(type3, charset3) {
    if (!type3 || !charset3) {
      return type3;
    }
    var parsed = contentType$1.parse(type3);
    parsed.parameters.charset = charset3;
    return contentType$1.format(parsed);
  };
  function createETagGenerator(options) {
    return function generateETag(body, encoding3) {
      var buf = !Buffer2.isBuffer(body) ? Buffer2.from(body, encoding3) : body;
      return etag3(buf, options);
    };
  }
  function parseExtendedQueryString(str2) {
    return qs.parse(str2, {
      allowPrototypes: true
    });
  }
  function newObject() {
    return {};
  }
})(utils$6);
(function(module2, exports) {
  /*!
   * express
   * Copyright(c) 2009-2013 TJ Holowaychuk
   * Copyright(c) 2013 Roman Shtylman
   * Copyright(c) 2014-2015 Douglas Christopher Wilson
   * MIT Licensed
   */
  var finalhandler2 = finalhandler_1;
  var Router = routerExports;
  var methods2 = methods$4;
  var middleware = init$1;
  var query = requireQuery();
  var debug2 = srcExports$2("express:application");
  var View2 = view;
  var http2 = require$$0$a;
  var compileETag = utils$6.compileETag;
  var compileQueryParser = utils$6.compileQueryParser;
  var compileTrust2 = utils$6.compileTrust;
  var deprecate2 = depd_1("express");
  var flatten2 = arrayFlatten_1;
  var merge2 = utilsMergeExports;
  var resolve3 = require$$1$2.resolve;
  var setPrototypeOf2 = setprototypeof;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  var slice2 = Array.prototype.slice;
  var app2 = module2.exports = {};
  var trustProxyDefaultSymbol = "@@symbol:trust_proxy_default";
  app2.init = function init2() {
    this.cache = {};
    this.engines = {};
    this.settings = {};
    this.defaultConfiguration();
  };
  app2.defaultConfiguration = function defaultConfiguration() {
    var env = process.env.NODE_ENV || "development";
    this.enable("x-powered-by");
    this.set("etag", "weak");
    this.set("env", env);
    this.set("query parser", "extended");
    this.set("subdomain offset", 2);
    this.set("trust proxy", false);
    Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
      configurable: true,
      value: true
    });
    debug2("booting in %s mode", env);
    this.on("mount", function onmount(parent) {
      if (this.settings[trustProxyDefaultSymbol] === true && typeof parent.settings["trust proxy fn"] === "function") {
        delete this.settings["trust proxy"];
        delete this.settings["trust proxy fn"];
      }
      setPrototypeOf2(this.request, parent.request);
      setPrototypeOf2(this.response, parent.response);
      setPrototypeOf2(this.engines, parent.engines);
      setPrototypeOf2(this.settings, parent.settings);
    });
    this.locals = /* @__PURE__ */ Object.create(null);
    this.mountpath = "/";
    this.locals.settings = this.settings;
    this.set("view", View2);
    this.set("views", resolve3("views"));
    this.set("jsonp callback name", "callback");
    if (env === "production") {
      this.enable("view cache");
    }
    Object.defineProperty(this, "router", {
      get: function() {
        throw new Error("'app.router' is deprecated!\nPlease see the 3.x to 4.x migration guide for details on how to update your app.");
      }
    });
  };
  app2.lazyrouter = function lazyrouter() {
    if (!this._router) {
      this._router = new Router({
        caseSensitive: this.enabled("case sensitive routing"),
        strict: this.enabled("strict routing")
      });
      this._router.use(query(this.get("query parser fn")));
      this._router.use(middleware.init(this));
    }
  };
  app2.handle = function handle3(req2, res2, callback) {
    var router2 = this._router;
    var done = callback || finalhandler2(req2, res2, {
      env: this.get("env"),
      onerror: logerror.bind(this)
    });
    if (!router2) {
      debug2("no routes defined on app");
      done();
      return;
    }
    router2.handle(req2, res2, done);
  };
  app2.use = function use2(fn) {
    var offset = 0;
    var path22 = "/";
    if (typeof fn !== "function") {
      var arg = fn;
      while (Array.isArray(arg) && arg.length !== 0) {
        arg = arg[0];
      }
      if (typeof arg !== "function") {
        offset = 1;
        path22 = fn;
      }
    }
    var fns = flatten2(slice2.call(arguments, offset));
    if (fns.length === 0) {
      throw new TypeError("app.use() requires a middleware function");
    }
    this.lazyrouter();
    var router2 = this._router;
    fns.forEach(function(fn2) {
      if (!fn2 || !fn2.handle || !fn2.set) {
        return router2.use(path22, fn2);
      }
      debug2(".use app under %s", path22);
      fn2.mountpath = path22;
      fn2.parent = this;
      router2.use(path22, function mounted_app(req2, res2, next) {
        var orig = req2.app;
        fn2.handle(req2, res2, function(err) {
          setPrototypeOf2(req2, orig.request);
          setPrototypeOf2(res2, orig.response);
          next(err);
        });
      });
      fn2.emit("mount", this);
    }, this);
    return this;
  };
  app2.route = function route3(path22) {
    this.lazyrouter();
    return this._router.route(path22);
  };
  app2.engine = function engine(ext, fn) {
    if (typeof fn !== "function") {
      throw new Error("callback function required");
    }
    var extension = ext[0] !== "." ? "." + ext : ext;
    this.engines[extension] = fn;
    return this;
  };
  app2.param = function param3(name2, fn) {
    this.lazyrouter();
    if (Array.isArray(name2)) {
      for (var i = 0; i < name2.length; i++) {
        this.param(name2[i], fn);
      }
      return this;
    }
    this._router.param(name2, fn);
    return this;
  };
  app2.set = function set(setting, val) {
    if (arguments.length === 1) {
      var settings = this.settings;
      while (settings && settings !== Object.prototype) {
        if (hasOwnProperty2.call(settings, setting)) {
          return settings[setting];
        }
        settings = Object.getPrototypeOf(settings);
      }
      return void 0;
    }
    debug2('set "%s" to %o', setting, val);
    this.settings[setting] = val;
    switch (setting) {
      case "etag":
        this.set("etag fn", compileETag(val));
        break;
      case "query parser":
        this.set("query parser fn", compileQueryParser(val));
        break;
      case "trust proxy":
        this.set("trust proxy fn", compileTrust2(val));
        Object.defineProperty(this.settings, trustProxyDefaultSymbol, {
          configurable: true,
          value: false
        });
        break;
    }
    return this;
  };
  app2.path = function path3() {
    return this.parent ? this.parent.path() + this.mountpath : "";
  };
  app2.enabled = function enabled(setting) {
    return Boolean(this.set(setting));
  };
  app2.disabled = function disabled(setting) {
    return !this.set(setting);
  };
  app2.enable = function enable(setting) {
    return this.set(setting, true);
  };
  app2.disable = function disable(setting) {
    return this.set(setting, false);
  };
  methods2.forEach(function(method) {
    app2[method] = function(path22) {
      if (method === "get" && arguments.length === 1) {
        return this.set(path22);
      }
      this.lazyrouter();
      var route22 = this._router.route(path22);
      route22[method].apply(route22, slice2.call(arguments, 1));
      return this;
    };
  });
  app2.all = function all3(path22) {
    this.lazyrouter();
    var route22 = this._router.route(path22);
    var args = slice2.call(arguments, 1);
    for (var i = 0; i < methods2.length; i++) {
      route22[methods2[i]].apply(route22, args);
    }
    return this;
  };
  app2.del = deprecate2.function(app2.delete, "app.del: Use app.delete instead");
  app2.render = function render3(name2, options, callback) {
    var cache2 = this.cache;
    var done = callback;
    var engines2 = this.engines;
    var opts = options;
    var renderOptions = {};
    var view2;
    if (typeof options === "function") {
      done = options;
      opts = {};
    }
    merge2(renderOptions, this.locals);
    if (opts._locals) {
      merge2(renderOptions, opts._locals);
    }
    merge2(renderOptions, opts);
    if (renderOptions.cache == null) {
      renderOptions.cache = this.enabled("view cache");
    }
    if (renderOptions.cache) {
      view2 = cache2[name2];
    }
    if (!view2) {
      var View22 = this.get("view");
      view2 = new View22(name2, {
        defaultEngine: this.get("view engine"),
        root: this.get("views"),
        engines: engines2
      });
      if (!view2.path) {
        var dirs = Array.isArray(view2.root) && view2.root.length > 1 ? 'directories "' + view2.root.slice(0, -1).join('", "') + '" or "' + view2.root[view2.root.length - 1] + '"' : 'directory "' + view2.root + '"';
        var err = new Error('Failed to lookup view "' + name2 + '" in views ' + dirs);
        err.view = view2;
        return done(err);
      }
      if (renderOptions.cache) {
        cache2[name2] = view2;
      }
    }
    tryRender(view2, renderOptions, done);
  };
  app2.listen = function listen() {
    var server2 = http2.createServer(this);
    return server2.listen.apply(server2, arguments);
  };
  function logerror(err) {
    if (this.get("env") !== "test") console.error(err.stack || err.toString());
  }
  function tryRender(view2, options, callback) {
    try {
      view2.render(options, callback);
    } catch (err) {
      callback(err);
    }
  }
})(application);
var applicationExports = application.exports;
var negotiator = { exports: {} };
var charset = { exports: {} };
charset.exports = preferredCharsets$1;
charset.exports.preferredCharsets = preferredCharsets$1;
var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptCharset(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var charset3 = parseCharset(accepts2[i].trim(), i);
    if (charset3) {
      accepts2[j2++] = charset3;
    }
  }
  accepts2.length = j2;
  return accepts2;
}
function parseCharset(str2, i) {
  var match2 = simpleCharsetRegExp.exec(str2);
  if (!match2) return null;
  var charset3 = match2[1];
  var q = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j2 = 0; j2 < params.length; j2++) {
      var p = params[j2].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    charset: charset3,
    q,
    i
  };
}
function getCharsetPriority(charset3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$3(charset3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$3(charset3, spec, index2) {
  var s2 = 0;
  if (spec.charset.toLowerCase() === charset3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.charset !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredCharsets$1(accept, provided) {
  var accepts2 = parseAcceptCharset(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$3).sort(compareSpecs$3).map(getFullCharset);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getCharsetPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$3).sort(compareSpecs$3).map(function getCharset(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$3(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullCharset(spec) {
  return spec.charset;
}
function isQuality$3(spec) {
  return spec.q > 0;
}
var charsetExports = charset.exports;
var encoding = { exports: {} };
encoding.exports = preferredEncodings$1;
encoding.exports.preferredEncodings = preferredEncodings$1;
var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
function parseAcceptEncoding(accept) {
  var accepts2 = accept.split(",");
  var hasIdentity = false;
  var minQuality = 1;
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var encoding3 = parseEncoding(accepts2[i].trim(), i);
    if (encoding3) {
      accepts2[j2++] = encoding3;
      hasIdentity = hasIdentity || specify$2("identity", encoding3);
      minQuality = Math.min(minQuality, encoding3.q || 1);
    }
  }
  if (!hasIdentity) {
    accepts2[j2++] = {
      encoding: "identity",
      q: minQuality,
      i
    };
  }
  accepts2.length = j2;
  return accepts2;
}
function parseEncoding(str2, i) {
  var match2 = simpleEncodingRegExp.exec(str2);
  if (!match2) return null;
  var encoding3 = match2[1];
  var q = 1;
  if (match2[2]) {
    var params = match2[2].split(";");
    for (var j2 = 0; j2 < params.length; j2++) {
      var p = params[j2].trim().split("=");
      if (p[0] === "q") {
        q = parseFloat(p[1]);
        break;
      }
    }
  }
  return {
    encoding: encoding3,
    q,
    i
  };
}
function getEncodingPriority(encoding3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$2(encoding3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$2(encoding3, spec, index2) {
  var s2 = 0;
  if (spec.encoding.toLowerCase() === encoding3.toLowerCase()) {
    s2 |= 1;
  } else if (spec.encoding !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredEncodings$1(accept, provided) {
  var accepts2 = parseAcceptEncoding(accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$2).sort(compareSpecs$2).map(getFullEncoding);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getEncodingPriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$2).sort(compareSpecs$2).map(function getEncoding(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$2(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullEncoding(spec) {
  return spec.encoding;
}
function isQuality$2(spec) {
  return spec.q > 0;
}
var encodingExports = encoding.exports;
var language = { exports: {} };
language.exports = preferredLanguages$1;
language.exports.preferredLanguages = preferredLanguages$1;
var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
function parseAcceptLanguage(accept) {
  var accepts2 = accept.split(",");
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var language3 = parseLanguage(accepts2[i].trim(), i);
    if (language3) {
      accepts2[j2++] = language3;
    }
  }
  accepts2.length = j2;
  return accepts2;
}
function parseLanguage(str2, i) {
  var match2 = simpleLanguageRegExp.exec(str2);
  if (!match2) return null;
  var prefix = match2[1];
  var suffix = match2[2];
  var full = prefix;
  if (suffix) full += "-" + suffix;
  var q = 1;
  if (match2[3]) {
    var params = match2[3].split(";");
    for (var j2 = 0; j2 < params.length; j2++) {
      var p = params[j2].split("=");
      if (p[0] === "q") q = parseFloat(p[1]);
    }
  }
  return {
    prefix,
    suffix,
    q,
    i,
    full
  };
}
function getLanguagePriority(language3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify$1(language3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify$1(language3, spec, index2) {
  var p = parseLanguage(language3);
  if (!p) return null;
  var s2 = 0;
  if (spec.full.toLowerCase() === p.full.toLowerCase()) {
    s2 |= 4;
  } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
    s2 |= 2;
  } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
    s2 |= 1;
  } else if (spec.full !== "*") {
    return null;
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredLanguages$1(accept, provided) {
  var accepts2 = parseAcceptLanguage(accept === void 0 ? "*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality$1).sort(compareSpecs$1).map(getFullLanguage);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getLanguagePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality$1).sort(compareSpecs$1).map(function getLanguage(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs$1(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullLanguage(spec) {
  return spec.full;
}
function isQuality$1(spec) {
  return spec.q > 0;
}
var languageExports = language.exports;
var mediaType = { exports: {} };
mediaType.exports = preferredMediaTypes$1;
mediaType.exports.preferredMediaTypes = preferredMediaTypes$1;
var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
function parseAccept(accept) {
  var accepts2 = splitMediaTypes(accept);
  for (var i = 0, j2 = 0; i < accepts2.length; i++) {
    var mediaType3 = parseMediaType(accepts2[i].trim(), i);
    if (mediaType3) {
      accepts2[j2++] = mediaType3;
    }
  }
  accepts2.length = j2;
  return accepts2;
}
function parseMediaType(str2, i) {
  var match2 = simpleMediaTypeRegExp.exec(str2);
  if (!match2) return null;
  var params = /* @__PURE__ */ Object.create(null);
  var q = 1;
  var subtype = match2[2];
  var type3 = match2[1];
  if (match2[3]) {
    var kvps = splitParameters(match2[3]).map(splitKeyValuePair);
    for (var j2 = 0; j2 < kvps.length; j2++) {
      var pair = kvps[j2];
      var key = pair[0].toLowerCase();
      var val = pair[1];
      var value2 = val && val[0] === '"' && val[val.length - 1] === '"' ? val.substr(1, val.length - 2) : val;
      if (key === "q") {
        q = parseFloat(value2);
        break;
      }
      params[key] = value2;
    }
  }
  return {
    type: type3,
    subtype,
    params,
    q,
    i
  };
}
function getMediaTypePriority(type3, accepted, index2) {
  var priority = { o: -1, q: 0, s: 0 };
  for (var i = 0; i < accepted.length; i++) {
    var spec = specify(type3, accepted[i], index2);
    if (spec && (priority.s - spec.s || priority.q - spec.q || priority.o - spec.o) < 0) {
      priority = spec;
    }
  }
  return priority;
}
function specify(type3, spec, index2) {
  var p = parseMediaType(type3);
  var s2 = 0;
  if (!p) {
    return null;
  }
  if (spec.type.toLowerCase() == p.type.toLowerCase()) {
    s2 |= 4;
  } else if (spec.type != "*") {
    return null;
  }
  if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
    s2 |= 2;
  } else if (spec.subtype != "*") {
    return null;
  }
  var keys2 = Object.keys(spec.params);
  if (keys2.length > 0) {
    if (keys2.every(function(k) {
      return spec.params[k] == "*" || (spec.params[k] || "").toLowerCase() == (p.params[k] || "").toLowerCase();
    })) {
      s2 |= 1;
    } else {
      return null;
    }
  }
  return {
    i: index2,
    o: spec.i,
    q: spec.q,
    s: s2
  };
}
function preferredMediaTypes$1(accept, provided) {
  var accepts2 = parseAccept(accept === void 0 ? "*/*" : accept || "");
  if (!provided) {
    return accepts2.filter(isQuality).sort(compareSpecs).map(getFullType);
  }
  var priorities = provided.map(function getPriority(type3, index2) {
    return getMediaTypePriority(type3, accepts2, index2);
  });
  return priorities.filter(isQuality).sort(compareSpecs).map(function getType(priority) {
    return provided[priorities.indexOf(priority)];
  });
}
function compareSpecs(a, b) {
  return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
}
function getFullType(spec) {
  return spec.type + "/" + spec.subtype;
}
function isQuality(spec) {
  return spec.q > 0;
}
function quoteCount(string2) {
  var count = 0;
  var index2 = 0;
  while ((index2 = string2.indexOf('"', index2)) !== -1) {
    count++;
    index2++;
  }
  return count;
}
function splitKeyValuePair(str2) {
  var index2 = str2.indexOf("=");
  var key;
  var val;
  if (index2 === -1) {
    key = str2;
  } else {
    key = str2.substr(0, index2);
    val = str2.substr(index2 + 1);
  }
  return [key, val];
}
function splitMediaTypes(accept) {
  var accepts2 = accept.split(",");
  for (var i = 1, j2 = 0; i < accepts2.length; i++) {
    if (quoteCount(accepts2[j2]) % 2 == 0) {
      accepts2[++j2] = accepts2[i];
    } else {
      accepts2[j2] += "," + accepts2[i];
    }
  }
  accepts2.length = j2 + 1;
  return accepts2;
}
function splitParameters(str2) {
  var parameters = str2.split(";");
  for (var i = 1, j2 = 0; i < parameters.length; i++) {
    if (quoteCount(parameters[j2]) % 2 == 0) {
      parameters[++j2] = parameters[i];
    } else {
      parameters[j2] += ";" + parameters[i];
    }
  }
  parameters.length = j2 + 1;
  for (var i = 0; i < parameters.length; i++) {
    parameters[i] = parameters[i].trim();
  }
  return parameters;
}
var mediaTypeExports = mediaType.exports;
/*!
 * negotiator
 * Copyright(c) 2012 Federico Romero
 * Copyright(c) 2012-2014 Isaac Z. Schlueter
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var preferredCharsets = charsetExports;
var preferredEncodings = encodingExports;
var preferredLanguages = languageExports;
var preferredMediaTypes = mediaTypeExports;
negotiator.exports = Negotiator$1;
negotiator.exports.Negotiator = Negotiator$1;
function Negotiator$1(request2) {
  if (!(this instanceof Negotiator$1)) {
    return new Negotiator$1(request2);
  }
  this.request = request2;
}
Negotiator$1.prototype.charset = function charset2(available) {
  var set = this.charsets(available);
  return set && set[0];
};
Negotiator$1.prototype.charsets = function charsets(available) {
  return preferredCharsets(this.request.headers["accept-charset"], available);
};
Negotiator$1.prototype.encoding = function encoding2(available) {
  var set = this.encodings(available);
  return set && set[0];
};
Negotiator$1.prototype.encodings = function encodings2(available) {
  return preferredEncodings(this.request.headers["accept-encoding"], available);
};
Negotiator$1.prototype.language = function language2(available) {
  var set = this.languages(available);
  return set && set[0];
};
Negotiator$1.prototype.languages = function languages(available) {
  return preferredLanguages(this.request.headers["accept-language"], available);
};
Negotiator$1.prototype.mediaType = function mediaType2(available) {
  var set = this.mediaTypes(available);
  return set && set[0];
};
Negotiator$1.prototype.mediaTypes = function mediaTypes(available) {
  return preferredMediaTypes(this.request.headers.accept, available);
};
Negotiator$1.prototype.preferredCharset = Negotiator$1.prototype.charset;
Negotiator$1.prototype.preferredCharsets = Negotiator$1.prototype.charsets;
Negotiator$1.prototype.preferredEncoding = Negotiator$1.prototype.encoding;
Negotiator$1.prototype.preferredEncodings = Negotiator$1.prototype.encodings;
Negotiator$1.prototype.preferredLanguage = Negotiator$1.prototype.language;
Negotiator$1.prototype.preferredLanguages = Negotiator$1.prototype.languages;
Negotiator$1.prototype.preferredMediaType = Negotiator$1.prototype.mediaType;
Negotiator$1.prototype.preferredMediaTypes = Negotiator$1.prototype.mediaTypes;
var negotiatorExports = negotiator.exports;
/*!
 * accepts
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Negotiator = negotiatorExports;
var mime$2 = mimeTypes;
var accepts$1 = Accepts;
function Accepts(req2) {
  if (!(this instanceof Accepts)) {
    return new Accepts(req2);
  }
  this.headers = req2.headers;
  this.negotiator = new Negotiator(req2);
}
Accepts.prototype.type = Accepts.prototype.types = function(types_) {
  var types2 = types_;
  if (types2 && !Array.isArray(types2)) {
    types2 = new Array(arguments.length);
    for (var i = 0; i < types2.length; i++) {
      types2[i] = arguments[i];
    }
  }
  if (!types2 || types2.length === 0) {
    return this.negotiator.mediaTypes();
  }
  if (!this.headers.accept) {
    return types2[0];
  }
  var mimes = types2.map(extToMime);
  var accepts2 = this.negotiator.mediaTypes(mimes.filter(validMime));
  var first2 = accepts2[0];
  return first2 ? types2[mimes.indexOf(first2)] : false;
};
Accepts.prototype.encoding = Accepts.prototype.encodings = function(encodings_) {
  var encodings3 = encodings_;
  if (encodings3 && !Array.isArray(encodings3)) {
    encodings3 = new Array(arguments.length);
    for (var i = 0; i < encodings3.length; i++) {
      encodings3[i] = arguments[i];
    }
  }
  if (!encodings3 || encodings3.length === 0) {
    return this.negotiator.encodings();
  }
  return this.negotiator.encodings(encodings3)[0] || false;
};
Accepts.prototype.charset = Accepts.prototype.charsets = function(charsets_) {
  var charsets2 = charsets_;
  if (charsets2 && !Array.isArray(charsets2)) {
    charsets2 = new Array(arguments.length);
    for (var i = 0; i < charsets2.length; i++) {
      charsets2[i] = arguments[i];
    }
  }
  if (!charsets2 || charsets2.length === 0) {
    return this.negotiator.charsets();
  }
  return this.negotiator.charsets(charsets2)[0] || false;
};
Accepts.prototype.lang = Accepts.prototype.langs = Accepts.prototype.language = Accepts.prototype.languages = function(languages_) {
  var languages2 = languages_;
  if (languages2 && !Array.isArray(languages2)) {
    languages2 = new Array(arguments.length);
    for (var i = 0; i < languages2.length; i++) {
      languages2[i] = arguments[i];
    }
  }
  if (!languages2 || languages2.length === 0) {
    return this.negotiator.languages();
  }
  return this.negotiator.languages(languages2)[0] || false;
};
function extToMime(type3) {
  return type3.indexOf("/") === -1 ? mime$2.lookup(type3) : type3;
}
function validMime(type3) {
  return typeof type3 === "string";
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var accepts = accepts$1;
var deprecate$1 = depd_1("express");
var isIP = require$$0$6.isIP;
var typeis = typeIsExports;
var http$9 = require$$0$a;
var fresh = fresh_1;
var parseRange = rangeParser_1;
var parse$2 = parseurlExports;
var proxyaddr = proxyAddrExports;
var req$2 = Object.create(http$9.IncomingMessage.prototype);
var request$2 = req$2;
req$2.get = req$2.header = function header(name2) {
  if (!name2) {
    throw new TypeError("name argument is required to req.get");
  }
  if (typeof name2 !== "string") {
    throw new TypeError("name must be a string to req.get");
  }
  var lc = name2.toLowerCase();
  switch (lc) {
    case "referer":
    case "referrer":
      return this.headers.referrer || this.headers.referer;
    default:
      return this.headers[lc];
  }
};
req$2.accepts = function() {
  var accept = accepts(this);
  return accept.types.apply(accept, arguments);
};
req$2.acceptsEncodings = function() {
  var accept = accepts(this);
  return accept.encodings.apply(accept, arguments);
};
req$2.acceptsEncoding = deprecate$1.function(
  req$2.acceptsEncodings,
  "req.acceptsEncoding: Use acceptsEncodings instead"
);
req$2.acceptsCharsets = function() {
  var accept = accepts(this);
  return accept.charsets.apply(accept, arguments);
};
req$2.acceptsCharset = deprecate$1.function(
  req$2.acceptsCharsets,
  "req.acceptsCharset: Use acceptsCharsets instead"
);
req$2.acceptsLanguages = function() {
  var accept = accepts(this);
  return accept.languages.apply(accept, arguments);
};
req$2.acceptsLanguage = deprecate$1.function(
  req$2.acceptsLanguages,
  "req.acceptsLanguage: Use acceptsLanguages instead"
);
req$2.range = function range2(size, options) {
  var range3 = this.get("Range");
  if (!range3) return;
  return parseRange(size, range3, options);
};
req$2.param = function param2(name2, defaultValue) {
  var params = this.params || {};
  var body = this.body || {};
  var query = this.query || {};
  var args = arguments.length === 1 ? "name" : "name, default";
  deprecate$1("req.param(" + args + "): Use req.params, req.body, or req.query instead");
  if (null != params[name2] && params.hasOwnProperty(name2)) return params[name2];
  if (null != body[name2]) return body[name2];
  if (null != query[name2]) return query[name2];
  return defaultValue;
};
req$2.is = function is(types2) {
  var arr = types2;
  if (!Array.isArray(types2)) {
    arr = new Array(arguments.length);
    for (var i = 0; i < arr.length; i++) {
      arr[i] = arguments[i];
    }
  }
  return typeis(this, arr);
};
defineGetter(req$2, "protocol", function protocol() {
  var proto2 = this.connection.encrypted ? "https" : "http";
  var trust = this.app.get("trust proxy fn");
  if (!trust(this.connection.remoteAddress, 0)) {
    return proto2;
  }
  var header3 = this.get("X-Forwarded-Proto") || proto2;
  var index2 = header3.indexOf(",");
  return index2 !== -1 ? header3.substring(0, index2).trim() : header3.trim();
});
defineGetter(req$2, "secure", function secure() {
  return this.protocol === "https";
});
defineGetter(req$2, "ip", function ip() {
  var trust = this.app.get("trust proxy fn");
  return proxyaddr(this, trust);
});
defineGetter(req$2, "ips", function ips() {
  var trust = this.app.get("trust proxy fn");
  var addrs = proxyaddr.all(this, trust);
  addrs.reverse().pop();
  return addrs;
});
defineGetter(req$2, "subdomains", function subdomains() {
  var hostname2 = this.hostname;
  if (!hostname2) return [];
  var offset = this.app.get("subdomain offset");
  var subdomains2 = !isIP(hostname2) ? hostname2.split(".").reverse() : [hostname2];
  return subdomains2.slice(offset);
});
defineGetter(req$2, "path", function path() {
  return parse$2(this).pathname;
});
defineGetter(req$2, "hostname", function hostname() {
  var trust = this.app.get("trust proxy fn");
  var host2 = this.get("X-Forwarded-Host");
  if (!host2 || !trust(this.connection.remoteAddress, 0)) {
    host2 = this.get("Host");
  } else if (host2.indexOf(",") !== -1) {
    host2 = host2.substring(0, host2.indexOf(",")).trimRight();
  }
  if (!host2) return;
  var offset = host2[0] === "[" ? host2.indexOf("]") + 1 : 0;
  var index2 = host2.indexOf(":", offset);
  return index2 !== -1 ? host2.substring(0, index2) : host2;
});
defineGetter(req$2, "host", deprecate$1.function(function host() {
  return this.hostname;
}, "req.host: Use req.hostname instead"));
defineGetter(req$2, "fresh", function() {
  var method = this.method;
  var res2 = this.res;
  var status3 = res2.statusCode;
  if ("GET" !== method && "HEAD" !== method) return false;
  if (status3 >= 200 && status3 < 300 || 304 === status3) {
    return fresh(this.headers, {
      "etag": res2.get("ETag"),
      "last-modified": res2.get("Last-Modified")
    });
  }
  return false;
});
defineGetter(req$2, "stale", function stale() {
  return !this.fresh;
});
defineGetter(req$2, "xhr", function xhr() {
  var val = this.get("X-Requested-With") || "";
  return val.toLowerCase() === "xmlhttprequest";
});
function defineGetter(obj, name2, getter) {
  Object.defineProperty(obj, name2, {
    configurable: true,
    enumerable: true,
    get: getter
  });
}
var cookieSignature = {};
(function(exports) {
  var crypto2 = require$$2$3;
  exports.sign = function(val, secret) {
    if ("string" != typeof val) throw new TypeError("Cookie value must be provided as a string.");
    if ("string" != typeof secret) throw new TypeError("Secret string must be provided.");
    return val + "." + crypto2.createHmac("sha256", secret).update(val).digest("base64").replace(/\=+$/, "");
  };
  exports.unsign = function(val, secret) {
    if ("string" != typeof val) throw new TypeError("Signed cookie string must be provided.");
    if ("string" != typeof secret) throw new TypeError("Secret string must be provided.");
    var str2 = val.slice(0, val.lastIndexOf(".")), mac = exports.sign(str2, secret);
    return sha12(mac) == sha12(val) ? str2 : false;
  };
  function sha12(str2) {
    return crypto2.createHash("sha1").update(str2).digest("hex");
  }
})(cookieSignature);
var cookie$1 = {};
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
cookie$1.parse = parse$1;
cookie$1.serialize = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str2, options) {
  if (typeof str2 !== "string") {
    throw new TypeError("argument str must be a string");
  }
  var obj = {};
  var opt = options || {};
  var dec = opt.decode || decode$2;
  var index2 = 0;
  while (index2 < str2.length) {
    var eqIdx = str2.indexOf("=", index2);
    if (eqIdx === -1) {
      break;
    }
    var endIdx = str2.indexOf(";", index2);
    if (endIdx === -1) {
      endIdx = str2.length;
    } else if (endIdx < eqIdx) {
      index2 = str2.lastIndexOf(";", eqIdx - 1) + 1;
      continue;
    }
    var key = str2.slice(index2, eqIdx).trim();
    if (void 0 === obj[key]) {
      var val = str2.slice(eqIdx + 1, endIdx).trim();
      if (val.charCodeAt(0) === 34) {
        val = val.slice(1, -1);
      }
      obj[key] = tryDecode(val, dec);
    }
    index2 = endIdx + 1;
  }
  return obj;
}
function serialize(name2, val, options) {
  var opt = options || {};
  var enc = opt.encode || encode$2;
  if (typeof enc !== "function") {
    throw new TypeError("option encode is invalid");
  }
  if (!fieldContentRegExp.test(name2)) {
    throw new TypeError("argument name is invalid");
  }
  var value2 = enc(val);
  if (value2 && !fieldContentRegExp.test(value2)) {
    throw new TypeError("argument val is invalid");
  }
  var str2 = name2 + "=" + value2;
  if (null != opt.maxAge) {
    var maxAge2 = opt.maxAge - 0;
    if (isNaN(maxAge2) || !isFinite(maxAge2)) {
      throw new TypeError("option maxAge is invalid");
    }
    str2 += "; Max-Age=" + Math.floor(maxAge2);
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str2 += "; Domain=" + opt.domain;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str2 += "; Path=" + opt.path;
  }
  if (opt.expires) {
    var expires = opt.expires;
    if (!isDate$1(expires) || isNaN(expires.valueOf())) {
      throw new TypeError("option expires is invalid");
    }
    str2 += "; Expires=" + expires.toUTCString();
  }
  if (opt.httpOnly) {
    str2 += "; HttpOnly";
  }
  if (opt.secure) {
    str2 += "; Secure";
  }
  if (opt.partitioned) {
    str2 += "; Partitioned";
  }
  if (opt.priority) {
    var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
    switch (priority) {
      case "low":
        str2 += "; Priority=Low";
        break;
      case "medium":
        str2 += "; Priority=Medium";
        break;
      case "high":
        str2 += "; Priority=High";
        break;
      default:
        throw new TypeError("option priority is invalid");
    }
  }
  if (opt.sameSite) {
    var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str2 += "; SameSite=Strict";
        break;
      case "lax":
        str2 += "; SameSite=Lax";
        break;
      case "strict":
        str2 += "; SameSite=Strict";
        break;
      case "none":
        str2 += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str2;
}
function decode$2(str2) {
  return str2.indexOf("%") !== -1 ? decodeURIComponent(str2) : str2;
}
function encode$2(val) {
  return encodeURIComponent(val);
}
function isDate$1(val) {
  return __toString.call(val) === "[object Date]" || val instanceof Date;
}
function tryDecode(str2, decode2) {
  try {
    return decode2(str2);
  } catch (e) {
    return str2;
  }
}
var vary$2 = { exports: {} };
/*!
 * vary
 * Copyright(c) 2014-2017 Douglas Christopher Wilson
 * MIT Licensed
 */
vary$2.exports = vary$1;
vary$2.exports.append = append;
var FIELD_NAME_REGEXP = /^[!#$%&'*+\-.^_`|~0-9A-Za-z]+$/;
function append(header3, field) {
  if (typeof header3 !== "string") {
    throw new TypeError("header argument is required");
  }
  if (!field) {
    throw new TypeError("field argument is required");
  }
  var fields = !Array.isArray(field) ? parse(String(field)) : field;
  for (var j2 = 0; j2 < fields.length; j2++) {
    if (!FIELD_NAME_REGEXP.test(fields[j2])) {
      throw new TypeError("field argument contains an invalid header name");
    }
  }
  if (header3 === "*") {
    return header3;
  }
  var val = header3;
  var vals = parse(header3.toLowerCase());
  if (fields.indexOf("*") !== -1 || vals.indexOf("*") !== -1) {
    return "*";
  }
  for (var i = 0; i < fields.length; i++) {
    var fld = fields[i].toLowerCase();
    if (vals.indexOf(fld) === -1) {
      vals.push(fld);
      val = val ? val + ", " + fields[i] : fields[i];
    }
  }
  return val;
}
function parse(header3) {
  var end = 0;
  var list = [];
  var start = 0;
  for (var i = 0, len = header3.length; i < len; i++) {
    switch (header3.charCodeAt(i)) {
      case 32:
        if (start === end) {
          start = end = i + 1;
        }
        break;
      case 44:
        list.push(header3.substring(start, end));
        start = end = i + 1;
        break;
      default:
        end = i + 1;
        break;
    }
  }
  list.push(header3.substring(start, end));
  return list;
}
function vary$1(res2, field) {
  if (!res2 || !res2.getHeader || !res2.setHeader) {
    throw new TypeError("res argument is required");
  }
  var val = res2.getHeader("Vary") || "";
  var header3 = Array.isArray(val) ? val.join(", ") : String(val);
  if (val = append(header3, field)) {
    res2.setHeader("Vary", val);
  }
}
var varyExports = vary$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var Buffer$1 = safeBufferExports.Buffer;
var contentDisposition = contentDispositionExports;
var createError = httpErrorsExports;
var deprecate = depd_1("express");
var encodeUrl = encodeurl;
var escapeHtml = escapeHtml_1;
var http$8 = require$$0$a;
var isAbsolute = utils$6.isAbsolute;
var onFinished = onFinishedExports;
var path$j = require$$1$2;
var statuses = statuses$3;
var merge$1 = utilsMergeExports;
var sign$2 = cookieSignature.sign;
var normalizeType = utils$6.normalizeType;
var normalizeTypes = utils$6.normalizeTypes;
var setCharset = utils$6.setCharset;
var cookie = cookie$1;
var send2 = sendExports;
var extname = path$j.extname;
var mime$1 = send2.mime;
var resolve2 = path$j.resolve;
var vary = varyExports;
var res = Object.create(http$8.ServerResponse.prototype);
var response = res;
var charsetRegExp = /;\s*charset\s*=/;
var schemaAndHostRegExp = /^(?:[a-zA-Z][a-zA-Z0-9+.-]*:)?\/\/[^\\\/\?]+/;
res.status = function status2(code2) {
  if ((typeof code2 === "string" || Math.floor(code2) !== code2) && code2 > 99 && code2 < 1e3) {
    deprecate("res.status(" + JSON.stringify(code2) + "): use res.status(" + Math.floor(code2) + ") instead");
  }
  this.statusCode = code2;
  return this;
};
res.links = function(links) {
  var link2 = this.get("Link") || "";
  if (link2) link2 += ", ";
  return this.set("Link", link2 + Object.keys(links).map(function(rel) {
    return "<" + links[rel] + '>; rel="' + rel + '"';
  }).join(", "));
};
res.send = function send3(body) {
  var chunk = body;
  var encoding3;
  var req2 = this.req;
  var type3;
  var app2 = this.app;
  if (arguments.length === 2) {
    if (typeof arguments[0] !== "number" && typeof arguments[1] === "number") {
      deprecate("res.send(body, status): Use res.status(status).send(body) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.send(status, body): Use res.status(status).send(body) instead");
      this.statusCode = arguments[0];
      chunk = arguments[1];
    }
  }
  if (typeof chunk === "number" && arguments.length === 1) {
    if (!this.get("Content-Type")) {
      this.type("txt");
    }
    deprecate("res.send(status): Use res.sendStatus(status) instead");
    this.statusCode = chunk;
    chunk = statuses.message[chunk];
  }
  switch (typeof chunk) {
    case "string":
      if (!this.get("Content-Type")) {
        this.type("html");
      }
      break;
    case "boolean":
    case "number":
    case "object":
      if (chunk === null) {
        chunk = "";
      } else if (Buffer$1.isBuffer(chunk)) {
        if (!this.get("Content-Type")) {
          this.type("bin");
        }
      } else {
        return this.json(chunk);
      }
      break;
  }
  if (typeof chunk === "string") {
    encoding3 = "utf8";
    type3 = this.get("Content-Type");
    if (typeof type3 === "string") {
      this.set("Content-Type", setCharset(type3, "utf-8"));
    }
  }
  var etagFn = app2.get("etag fn");
  var generateETag = !this.get("ETag") && typeof etagFn === "function";
  var len;
  if (chunk !== void 0) {
    if (Buffer$1.isBuffer(chunk)) {
      len = chunk.length;
    } else if (!generateETag && chunk.length < 1e3) {
      len = Buffer$1.byteLength(chunk, encoding3);
    } else {
      chunk = Buffer$1.from(chunk, encoding3);
      encoding3 = void 0;
      len = chunk.length;
    }
    this.set("Content-Length", len);
  }
  var etag3;
  if (generateETag && len !== void 0) {
    if (etag3 = etagFn(chunk, encoding3)) {
      this.set("ETag", etag3);
    }
  }
  if (req2.fresh) this.statusCode = 304;
  if (204 === this.statusCode || 304 === this.statusCode) {
    this.removeHeader("Content-Type");
    this.removeHeader("Content-Length");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (this.statusCode === 205) {
    this.set("Content-Length", "0");
    this.removeHeader("Transfer-Encoding");
    chunk = "";
  }
  if (req2.method === "HEAD") {
    this.end();
  } else {
    this.end(chunk, encoding3);
  }
  return this;
};
res.json = function json(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      deprecate("res.json(obj, status): Use res.status(status).json(obj) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.json(status, obj): Use res.status(status).json(obj) instead");
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app2 = this.app;
  var escape2 = app2.get("json escape");
  var replacer = app2.get("json replacer");
  var spaces = app2.get("json spaces");
  var body = stringify$4(val, replacer, spaces, escape2);
  if (!this.get("Content-Type")) {
    this.set("Content-Type", "application/json");
  }
  return this.send(body);
};
res.jsonp = function jsonp(obj) {
  var val = obj;
  if (arguments.length === 2) {
    if (typeof arguments[1] === "number") {
      deprecate("res.jsonp(obj, status): Use res.status(status).jsonp(obj) instead");
      this.statusCode = arguments[1];
    } else {
      deprecate("res.jsonp(status, obj): Use res.status(status).jsonp(obj) instead");
      this.statusCode = arguments[0];
      val = arguments[1];
    }
  }
  var app2 = this.app;
  var escape2 = app2.get("json escape");
  var replacer = app2.get("json replacer");
  var spaces = app2.get("json spaces");
  var body = stringify$4(val, replacer, spaces, escape2);
  var callback = this.req.query[app2.get("jsonp callback name")];
  if (!this.get("Content-Type")) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "application/json");
  }
  if (Array.isArray(callback)) {
    callback = callback[0];
  }
  if (typeof callback === "string" && callback.length !== 0) {
    this.set("X-Content-Type-Options", "nosniff");
    this.set("Content-Type", "text/javascript");
    callback = callback.replace(/[^\[\]\w$.]/g, "");
    if (body === void 0) {
      body = "";
    } else if (typeof body === "string") {
      body = body.replace(/\u2028/g, "\\u2028").replace(/\u2029/g, "\\u2029");
    }
    body = "/**/ typeof " + callback + " === 'function' && " + callback + "(" + body + ");";
  }
  return this.send(body);
};
res.sendStatus = function sendStatus(statusCode) {
  var body = statuses.message[statusCode] || String(statusCode);
  this.statusCode = statusCode;
  this.type("txt");
  return this.send(body);
};
res.sendFile = function sendFile2(path3, options, callback) {
  var done = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options || {};
  if (!path3) {
    throw new TypeError("path argument is required to res.sendFile");
  }
  if (typeof path3 !== "string") {
    throw new TypeError("path must be a string to res.sendFile");
  }
  if (typeof options === "function") {
    done = options;
    opts = {};
  }
  if (!opts.root && !isAbsolute(path3)) {
    throw new TypeError("path must be absolute or specify root to res.sendFile");
  }
  var pathname = encodeURI(path3);
  var file2 = send2(req2, pathname, opts);
  sendfile(res2, file2, opts, function(err) {
    if (done) return done(err);
    if (err && err.code === "EISDIR") return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = function(path3, options, callback) {
  var done = callback;
  var req2 = this.req;
  var res2 = this;
  var next = req2.next;
  var opts = options || {};
  if (typeof options === "function") {
    done = options;
    opts = {};
  }
  var file2 = send2(req2, path3, opts);
  sendfile(res2, file2, opts, function(err) {
    if (done) return done(err);
    if (err && err.code === "EISDIR") return next();
    if (err && err.code !== "ECONNABORTED" && err.syscall !== "write") {
      next(err);
    }
  });
};
res.sendfile = deprecate.function(
  res.sendfile,
  "res.sendfile: Use res.sendFile instead"
);
res.download = function download(path3, filename, options, callback) {
  var done = callback;
  var name2 = filename;
  var opts = options || null;
  if (typeof filename === "function") {
    done = filename;
    name2 = null;
    opts = null;
  } else if (typeof options === "function") {
    done = options;
    opts = null;
  }
  if (typeof filename === "object" && (typeof options === "function" || options === void 0)) {
    name2 = null;
    opts = filename;
  }
  var headers = {
    "Content-Disposition": contentDisposition(name2 || path3)
  };
  if (opts && opts.headers) {
    var keys2 = Object.keys(opts.headers);
    for (var i = 0; i < keys2.length; i++) {
      var key = keys2[i];
      if (key.toLowerCase() !== "content-disposition") {
        headers[key] = opts.headers[key];
      }
    }
  }
  opts = Object.create(opts);
  opts.headers = headers;
  var fullPath = !opts.root ? resolve2(path3) : path3;
  return this.sendFile(fullPath, opts, done);
};
res.contentType = res.type = function contentType2(type3) {
  var ct = type3.indexOf("/") === -1 ? mime$1.lookup(type3) : type3;
  return this.set("Content-Type", ct);
};
res.format = function(obj) {
  var req2 = this.req;
  var next = req2.next;
  var keys2 = Object.keys(obj).filter(function(v) {
    return v !== "default";
  });
  var key = keys2.length > 0 ? req2.accepts(keys2) : false;
  this.vary("Accept");
  if (key) {
    this.set("Content-Type", normalizeType(key).value);
    obj[key](req2, this, next);
  } else if (obj.default) {
    obj.default(req2, this, next);
  } else {
    next(createError(406, {
      types: normalizeTypes(keys2).map(function(o) {
        return o.value;
      })
    }));
  }
  return this;
};
res.attachment = function attachment(filename) {
  if (filename) {
    this.type(extname(filename));
  }
  this.set("Content-Disposition", contentDisposition(filename));
  return this;
};
res.append = function append2(field, val) {
  var prev = this.get(field);
  var value2 = val;
  if (prev) {
    value2 = Array.isArray(prev) ? prev.concat(val) : Array.isArray(val) ? [prev].concat(val) : [prev, val];
  }
  return this.set(field, value2);
};
res.set = res.header = function header2(field, val) {
  if (arguments.length === 2) {
    var value2 = Array.isArray(val) ? val.map(String) : String(val);
    if (field.toLowerCase() === "content-type") {
      if (Array.isArray(value2)) {
        throw new TypeError("Content-Type cannot be set to an Array");
      }
      if (!charsetRegExp.test(value2)) {
        var charset3 = mime$1.charsets.lookup(value2.split(";")[0]);
        if (charset3) value2 += "; charset=" + charset3.toLowerCase();
      }
    }
    this.setHeader(field, value2);
  } else {
    for (var key in field) {
      this.set(key, field[key]);
    }
  }
  return this;
};
res.get = function(field) {
  return this.getHeader(field);
};
res.clearCookie = function clearCookie(name2, options) {
  var opts = merge$1({ expires: /* @__PURE__ */ new Date(1), path: "/" }, options);
  return this.cookie(name2, "", opts);
};
res.cookie = function(name2, value2, options) {
  var opts = merge$1({}, options);
  var secret = this.req.secret;
  var signed = opts.signed;
  if (signed && !secret) {
    throw new Error('cookieParser("secret") required for signed cookies');
  }
  var val = typeof value2 === "object" ? "j:" + JSON.stringify(value2) : String(value2);
  if (signed) {
    val = "s:" + sign$2(val, secret);
  }
  if (opts.maxAge != null) {
    var maxAge2 = opts.maxAge - 0;
    if (!isNaN(maxAge2)) {
      opts.expires = new Date(Date.now() + maxAge2);
      opts.maxAge = Math.floor(maxAge2 / 1e3);
    }
  }
  if (opts.path == null) {
    opts.path = "/";
  }
  this.append("Set-Cookie", cookie.serialize(name2, String(val), opts));
  return this;
};
res.location = function location(url2) {
  var loc;
  if (url2 === "back") {
    loc = this.req.get("Referrer") || "/";
  } else {
    loc = String(url2);
  }
  var m2 = schemaAndHostRegExp.exec(loc);
  var pos = m2 ? m2[0].length + 1 : 0;
  loc = loc.slice(0, pos) + encodeUrl(loc.slice(pos));
  return this.set("Location", loc);
};
res.redirect = function redirect2(url2) {
  var address = url2;
  var body;
  var status3 = 302;
  if (arguments.length === 2) {
    if (typeof arguments[0] === "number") {
      status3 = arguments[0];
      address = arguments[1];
    } else {
      deprecate("res.redirect(url, status): Use res.redirect(status, url) instead");
      status3 = arguments[1];
    }
  }
  address = this.location(address).get("Location");
  this.format({
    text: function() {
      body = statuses.message[status3] + ". Redirecting to " + address;
    },
    html: function() {
      var u2 = escapeHtml(address);
      body = "<p>" + statuses.message[status3] + '. Redirecting to <a href="' + u2 + '">' + u2 + "</a></p>";
    },
    default: function() {
      body = "";
    }
  });
  this.statusCode = status3;
  this.set("Content-Length", Buffer$1.byteLength(body));
  if (this.req.method === "HEAD") {
    this.end();
  } else {
    this.end(body);
  }
};
res.vary = function(field) {
  if (!field || Array.isArray(field) && !field.length) {
    deprecate("res.vary(): Provide a field name");
    return this;
  }
  vary(this, field);
  return this;
};
res.render = function render2(view2, options, callback) {
  var app2 = this.req.app;
  var done = callback;
  var opts = options || {};
  var req2 = this.req;
  var self3 = this;
  if (typeof options === "function") {
    done = options;
    opts = {};
  }
  opts._locals = self3.locals;
  done = done || function(err, str2) {
    if (err) return req2.next(err);
    self3.send(str2);
  };
  app2.render(view2, opts, done);
};
function sendfile(res2, file2, options, callback) {
  var done = false;
  var streaming;
  function onaborted() {
    if (done) return;
    done = true;
    var err = new Error("Request aborted");
    err.code = "ECONNABORTED";
    callback(err);
  }
  function ondirectory() {
    if (done) return;
    done = true;
    var err = new Error("EISDIR, read");
    err.code = "EISDIR";
    callback(err);
  }
  function onerror(err) {
    if (done) return;
    done = true;
    callback(err);
  }
  function onend() {
    if (done) return;
    done = true;
    callback();
  }
  function onfile() {
    streaming = false;
  }
  function onfinish(err) {
    if (err && err.code === "ECONNRESET") return onaborted();
    if (err) return onerror(err);
    if (done) return;
    setImmediate(function() {
      if (streaming !== false && !done) {
        onaborted();
        return;
      }
      if (done) return;
      done = true;
      callback();
    });
  }
  function onstream() {
    streaming = true;
  }
  file2.on("directory", ondirectory);
  file2.on("end", onend);
  file2.on("error", onerror);
  file2.on("file", onfile);
  file2.on("stream", onstream);
  onFinished(res2, onfinish);
  if (options.headers) {
    file2.on("headers", function headers(res3) {
      var obj = options.headers;
      var keys2 = Object.keys(obj);
      for (var i = 0; i < keys2.length; i++) {
        var k = keys2[i];
        res3.setHeader(k, obj[k]);
      }
    });
  }
  file2.pipe(res2);
}
function stringify$4(value2, replacer, spaces, escape2) {
  var json3 = replacer || spaces ? JSON.stringify(value2, replacer, spaces) : JSON.stringify(value2);
  if (escape2 && typeof json3 === "string") {
    json3 = json3.replace(/[<>&]/g, function(c) {
      switch (c.charCodeAt(0)) {
        case 60:
          return "\\u003c";
        case 62:
          return "\\u003e";
        case 38:
          return "\\u0026";
        default:
          return c;
      }
    });
  }
  return json3;
}
var serveStatic = { exports: {} };
/*!
 * serve-static
 * Copyright(c) 2010 Sencha Inc.
 * Copyright(c) 2011 TJ Holowaychuk
 * Copyright(c) 2014-2016 Douglas Christopher Wilson
 * MIT Licensed
 */
var hasRequiredServeStatic;
function requireServeStatic() {
  if (hasRequiredServeStatic) return serveStatic.exports;
  hasRequiredServeStatic = 1;
  var encodeUrl2 = encodeurl;
  var escapeHtml2 = escapeHtml_1;
  var parseUrl2 = parseurlExports;
  var resolve3 = require$$1$2.resolve;
  var send4 = sendExports;
  var url2 = require$$5$2;
  serveStatic.exports = serveStatic$1;
  serveStatic.exports.mime = send4.mime;
  function serveStatic$1(root2, options) {
    if (!root2) {
      throw new TypeError("root path required");
    }
    if (typeof root2 !== "string") {
      throw new TypeError("root path must be a string");
    }
    var opts = Object.create(options || null);
    var fallthrough = opts.fallthrough !== false;
    var redirect3 = opts.redirect !== false;
    var setHeaders2 = opts.setHeaders;
    if (setHeaders2 && typeof setHeaders2 !== "function") {
      throw new TypeError("option setHeaders must be function");
    }
    opts.maxage = opts.maxage || opts.maxAge || 0;
    opts.root = resolve3(root2);
    var onDirectory = redirect3 ? createRedirectDirectoryListener() : createNotFoundDirectoryListener();
    return function serveStatic2(req2, res2, next) {
      if (req2.method !== "GET" && req2.method !== "HEAD") {
        if (fallthrough) {
          return next();
        }
        res2.statusCode = 405;
        res2.setHeader("Allow", "GET, HEAD");
        res2.setHeader("Content-Length", "0");
        res2.end();
        return;
      }
      var forwardError = !fallthrough;
      var originalUrl = parseUrl2.original(req2);
      var path3 = parseUrl2(req2).pathname;
      if (path3 === "/" && originalUrl.pathname.substr(-1) !== "/") {
        path3 = "";
      }
      var stream3 = send4(req2, path3, opts);
      stream3.on("directory", onDirectory);
      if (setHeaders2) {
        stream3.on("headers", setHeaders2);
      }
      if (fallthrough) {
        stream3.on("file", function onFile2() {
          forwardError = true;
        });
      }
      stream3.on("error", function error2(err) {
        if (forwardError || !(err.statusCode < 500)) {
          next(err);
          return;
        }
        next();
      });
      stream3.pipe(res2);
    };
  }
  function collapseLeadingSlashes2(str2) {
    for (var i = 0; i < str2.length; i++) {
      if (str2.charCodeAt(i) !== 47) {
        break;
      }
    }
    return i > 1 ? "/" + str2.substr(i) : str2;
  }
  function createHtmlDocument2(title, body) {
    return '<!DOCTYPE html>\n<html lang="en">\n<head>\n<meta charset="utf-8">\n<title>' + title + "</title>\n</head>\n<body>\n<pre>" + body + "</pre>\n</body>\n</html>\n";
  }
  function createNotFoundDirectoryListener() {
    return function notFound() {
      this.error(404);
    };
  }
  function createRedirectDirectoryListener() {
    return function redirect3(res2) {
      if (this.hasTrailingSlash()) {
        this.error(404);
        return;
      }
      var originalUrl = parseUrl2.original(this.req);
      originalUrl.path = null;
      originalUrl.pathname = collapseLeadingSlashes2(originalUrl.pathname + "/");
      var loc = encodeUrl2(url2.format(originalUrl));
      var doc = createHtmlDocument2("Redirecting", 'Redirecting to <a href="' + escapeHtml2(loc) + '">' + escapeHtml2(loc) + "</a>");
      res2.statusCode = 301;
      res2.setHeader("Content-Type", "text/html; charset=UTF-8");
      res2.setHeader("Content-Length", Buffer.byteLength(doc));
      res2.setHeader("Content-Security-Policy", "default-src 'none'");
      res2.setHeader("X-Content-Type-Options", "nosniff");
      res2.setHeader("Location", loc);
      res2.end(doc);
    };
  }
  return serveStatic.exports;
}
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
(function(module2, exports) {
  var bodyParser2 = bodyParserExports;
  var EventEmitter2 = require$$0$8.EventEmitter;
  var mixin2 = mergeDescriptors;
  var proto2 = applicationExports;
  var Route2 = route;
  var Router = routerExports;
  var req2 = request$2;
  var res2 = response;
  exports = module2.exports = createApplication;
  function createApplication() {
    var app2 = function(req3, res3, next) {
      app2.handle(req3, res3, next);
    };
    mixin2(app2, EventEmitter2.prototype, false);
    mixin2(app2, proto2, false);
    app2.request = Object.create(req2, {
      app: { configurable: true, enumerable: true, writable: true, value: app2 }
    });
    app2.response = Object.create(res2, {
      app: { configurable: true, enumerable: true, writable: true, value: app2 }
    });
    app2.init();
    return app2;
  }
  exports.application = proto2;
  exports.request = req2;
  exports.response = res2;
  exports.Route = Route2;
  exports.Router = Router;
  exports.json = bodyParser2.json;
  exports.query = requireQuery();
  exports.raw = bodyParser2.raw;
  exports.static = requireServeStatic();
  exports.text = bodyParser2.text;
  exports.urlencoded = bodyParser2.urlencoded;
  var removedMiddlewares = [
    "bodyParser",
    "compress",
    "cookieSession",
    "session",
    "logger",
    "cookieParser",
    "favicon",
    "responseTime",
    "errorHandler",
    "timeout",
    "methodOverride",
    "vhost",
    "csrf",
    "directory",
    "limit",
    "multipart",
    "staticCache"
  ];
  removedMiddlewares.forEach(function(name2) {
    Object.defineProperty(exports, name2, {
      get: function() {
        throw new Error("Most middleware (like " + name2 + ") is no longer bundled with Express and must be installed separately. Please see https://github.com/senchalabs/connect#middleware.");
      },
      configurable: true
    });
  });
})(express$2, express$2.exports);
var expressExports = express$2.exports;
/*!
 * express
 * Copyright(c) 2009-2013 TJ Holowaychuk
 * Copyright(c) 2013 Roman Shtylman
 * Copyright(c) 2014-2015 Douglas Christopher Wilson
 * MIT Licensed
 */
var express$1 = expressExports;
var cryptoJs = { exports: {} };
var core$1 = { exports: {} };
var hasRequiredCore$1;
function requireCore$1() {
  if (hasRequiredCore$1) return core$1.exports;
  hasRequiredCore$1 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory();
      }
    })(commonjsGlobal, function() {
      var CryptoJS2 = CryptoJS2 || function(Math2, undefined$1) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof commonjsGlobal !== "undefined" && commonjsGlobal.crypto) {
          crypto2 = commonjsGlobal.crypto;
        }
        if (!crypto2 && typeof commonjsRequire === "function") {
          try {
            crypto2 = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create2 = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create2(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance = this.extend();
              instance.init.apply(instance, arguments);
              return instance;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j2 = 0; j2 < thatSigBytes; j2 += 4) {
                thisWords[thisSigBytes + j2 >>> 2] = thatWords[j2 >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2.words = this.words.slice(0);
            return clone2;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data2) {
            if (typeof data2 == "string") {
              data2 = Utf8.parse(data2);
            }
            this._data.concat(data2);
            this._nDataBytes += data2.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data2 = this._data;
            var dataWords = data2.words;
            var dataSigBytes = data2.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                this._doProcessBlock(dataWords, offset);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data2.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            clone2._data = this._data.clone();
            return clone2;
          },
          _minBufferSize: 0
        });
        C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash2 = this._doFinalize();
            return hash2;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS2;
    });
  })(core$1);
  return core$1.exports;
}
var x64Core = { exports: {} };
var hasRequiredX64Core;
function requireX64Core() {
  if (hasRequiredX64Core) return x64Core.exports;
  hasRequiredX64Core = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var X32WordArray = C_lib.WordArray;
        var C_x64 = C.x64 = {};
        C_x64.Word = Base.extend({
          /**
           * Initializes a newly created 64-bit word.
           *
           * @param {number} high The high 32 bits.
           * @param {number} low The low 32 bits.
           *
           * @example
           *
           *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
           */
          init: function(high, low) {
            this.high = high;
            this.low = low;
          }
          /**
           * Bitwise NOTs this word.
           *
           * @return {X64Word} A new x64-Word object after negating.
           *
           * @example
           *
           *     var negated = x64Word.not();
           */
          // not: function () {
          // var high = ~this.high;
          // var low = ~this.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ANDs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to AND with this word.
           *
           * @return {X64Word} A new x64-Word object after ANDing.
           *
           * @example
           *
           *     var anded = x64Word.and(anotherX64Word);
           */
          // and: function (word) {
          // var high = this.high & word.high;
          // var low = this.low & word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise ORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to OR with this word.
           *
           * @return {X64Word} A new x64-Word object after ORing.
           *
           * @example
           *
           *     var ored = x64Word.or(anotherX64Word);
           */
          // or: function (word) {
          // var high = this.high | word.high;
          // var low = this.low | word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Bitwise XORs this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to XOR with this word.
           *
           * @return {X64Word} A new x64-Word object after XORing.
           *
           * @example
           *
           *     var xored = x64Word.xor(anotherX64Word);
           */
          // xor: function (word) {
          // var high = this.high ^ word.high;
          // var low = this.low ^ word.low;
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the left.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftL(25);
           */
          // shiftL: function (n) {
          // if (n < 32) {
          // var high = (this.high << n) | (this.low >>> (32 - n));
          // var low = this.low << n;
          // } else {
          // var high = this.low << (n - 32);
          // var low = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Shifts this word n bits to the right.
           *
           * @param {number} n The number of bits to shift.
           *
           * @return {X64Word} A new x64-Word object after shifting.
           *
           * @example
           *
           *     var shifted = x64Word.shiftR(7);
           */
          // shiftR: function (n) {
          // if (n < 32) {
          // var low = (this.low >>> n) | (this.high << (32 - n));
          // var high = this.high >>> n;
          // } else {
          // var low = this.high >>> (n - 32);
          // var high = 0;
          // }
          // return X64Word.create(high, low);
          // },
          /**
           * Rotates this word n bits to the left.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotL(25);
           */
          // rotL: function (n) {
          // return this.shiftL(n).or(this.shiftR(64 - n));
          // },
          /**
           * Rotates this word n bits to the right.
           *
           * @param {number} n The number of bits to rotate.
           *
           * @return {X64Word} A new x64-Word object after rotating.
           *
           * @example
           *
           *     var rotated = x64Word.rotR(7);
           */
          // rotR: function (n) {
          // return this.shiftR(n).or(this.shiftL(64 - n));
          // },
          /**
           * Adds this word with the passed word.
           *
           * @param {X64Word} word The x64-Word to add with this word.
           *
           * @return {X64Word} A new x64-Word object after adding.
           *
           * @example
           *
           *     var added = x64Word.add(anotherX64Word);
           */
          // add: function (word) {
          // var low = (this.low + word.low) | 0;
          // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
          // var high = (this.high + word.high + carry) | 0;
          // return X64Word.create(high, low);
          // }
        });
        C_x64.WordArray = Base.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.x64.WordArray.create();
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ]);
           *
           *     var wordArray = CryptoJS.x64.WordArray.create([
           *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
           *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
           *     ], 10);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined$1) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 8;
            }
          },
          /**
           * Converts this 64-bit word array to a 32-bit word array.
           *
           * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
           *
           * @example
           *
           *     var x32WordArray = x64WordArray.toX32();
           */
          toX32: function() {
            var x64Words = this.words;
            var x64WordsLength = x64Words.length;
            var x32Words = [];
            for (var i = 0; i < x64WordsLength; i++) {
              var x64Word = x64Words[i];
              x32Words.push(x64Word.high);
              x32Words.push(x64Word.low);
            }
            return X32WordArray.create(x32Words, this.sigBytes);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {X64WordArray} The clone.
           *
           * @example
           *
           *     var clone = x64WordArray.clone();
           */
          clone: function() {
            var clone2 = Base.clone.call(this);
            var words = clone2.words = this.words.slice(0);
            var wordsLength = words.length;
            for (var i = 0; i < wordsLength; i++) {
              words[i] = words[i].clone();
            }
            return clone2;
          }
        });
      })();
      return CryptoJS2;
    });
  })(x64Core);
  return x64Core.exports;
}
var libTypedarrays = { exports: {} };
var hasRequiredLibTypedarrays;
function requireLibTypedarrays() {
  if (hasRequiredLibTypedarrays) return libTypedarrays.exports;
  hasRequiredLibTypedarrays = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        if (typeof ArrayBuffer != "function") {
          return;
        }
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var superInit = WordArray.init;
        var subInit = WordArray.init = function(typedArray) {
          if (typedArray instanceof ArrayBuffer) {
            typedArray = new Uint8Array(typedArray);
          }
          if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
          }
          if (typedArray instanceof Uint8Array) {
            var typedArrayByteLength = typedArray.byteLength;
            var words = [];
            for (var i = 0; i < typedArrayByteLength; i++) {
              words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
            }
            superInit.call(this, words, typedArrayByteLength);
          } else {
            superInit.apply(this, arguments);
          }
        };
        subInit.prototype = WordArray;
      })();
      return CryptoJS2.lib.WordArray;
    });
  })(libTypedarrays);
  return libTypedarrays.exports;
}
var encUtf16 = { exports: {} };
var hasRequiredEncUtf16;
function requireEncUtf16() {
  if (hasRequiredEncUtf16) return encUtf16.exports;
  hasRequiredEncUtf16 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Utf16 = C_enc.Utf16BE = {
          /**
           * Converts a word array to a UTF-16 BE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 BE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 65535;
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 BE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 BE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        C_enc.Utf16LE = {
          /**
           * Converts a word array to a UTF-16 LE string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-16 LE string.
           *
           * @static
           *
           * @example
           *
           *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var utf16Chars = [];
            for (var i = 0; i < sigBytes; i += 2) {
              var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 65535);
              utf16Chars.push(String.fromCharCode(codePoint));
            }
            return utf16Chars.join("");
          },
          /**
           * Converts a UTF-16 LE string to a word array.
           *
           * @param {string} utf16Str The UTF-16 LE string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
           */
          parse: function(utf16Str) {
            var utf16StrLength = utf16Str.length;
            var words = [];
            for (var i = 0; i < utf16StrLength; i++) {
              words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
            }
            return WordArray.create(words, utf16StrLength * 2);
          }
        };
        function swapEndian(word) {
          return word << 8 & 4278255360 | word >>> 8 & 16711935;
        }
      })();
      return CryptoJS2.enc.Utf16;
    });
  })(encUtf16);
  return encUtf16.exports;
}
var encBase64 = { exports: {} };
var hasRequiredEncBase64;
function requireEncBase64() {
  if (hasRequiredEncBase64) return encBase64.exports;
  hasRequiredEncBase64 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64 = {
          /**
           * Converts a word array to a Base64 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Base64 string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64 string to a word array.
           *
           * @param {string} base64Str The Base64 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
           */
          parse: function(base64Str) {
            var base64StrLength = base64Str.length;
            var map2 = this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map2.length; j2++) {
                reverseMap[map2.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64;
    });
  })(encBase64);
  return encBase64.exports;
}
var encBase64url = { exports: {} };
var hasRequiredEncBase64url;
function requireEncBase64url() {
  if (hasRequiredEncBase64url) return encBase64url.exports;
  hasRequiredEncBase64url = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_enc = C.enc;
        C_enc.Base64url = {
          /**
           * Converts a word array to a Base64url string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {string} The Base64url string.
           *
           * @static
           *
           * @example
           *
           *     var base64String = CryptoJS.enc.Base64url.stringify(wordArray);
           */
          stringify: function(wordArray, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var map2 = urlSafe ? this._safe_map : this._map;
            wordArray.clamp();
            var base64Chars = [];
            for (var i = 0; i < sigBytes; i += 3) {
              var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 255;
              var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 255;
              var triplet = byte1 << 16 | byte2 << 8 | byte3;
              for (var j2 = 0; j2 < 4 && i + j2 * 0.75 < sigBytes; j2++) {
                base64Chars.push(map2.charAt(triplet >>> 6 * (3 - j2) & 63));
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              while (base64Chars.length % 4) {
                base64Chars.push(paddingChar);
              }
            }
            return base64Chars.join("");
          },
          /**
           * Converts a Base64url string to a word array.
           *
           * @param {string} base64Str The Base64url string.
           *
           * @param {boolean} urlSafe Whether to use url safe
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Base64url.parse(base64String);
           */
          parse: function(base64Str, urlSafe) {
            if (urlSafe === void 0) {
              urlSafe = true;
            }
            var base64StrLength = base64Str.length;
            var map2 = urlSafe ? this._safe_map : this._map;
            var reverseMap = this._reverseMap;
            if (!reverseMap) {
              reverseMap = this._reverseMap = [];
              for (var j2 = 0; j2 < map2.length; j2++) {
                reverseMap[map2.charCodeAt(j2)] = j2;
              }
            }
            var paddingChar = map2.charAt(64);
            if (paddingChar) {
              var paddingIndex = base64Str.indexOf(paddingChar);
              if (paddingIndex !== -1) {
                base64StrLength = paddingIndex;
              }
            }
            return parseLoop(base64Str, base64StrLength, reverseMap);
          },
          _map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
          _safe_map: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"
        };
        function parseLoop(base64Str, base64StrLength, reverseMap) {
          var words = [];
          var nBytes = 0;
          for (var i = 0; i < base64StrLength; i++) {
            if (i % 4) {
              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
              var bitsCombined = bits1 | bits2;
              words[nBytes >>> 2] |= bitsCombined << 24 - nBytes % 4 * 8;
              nBytes++;
            }
          }
          return WordArray.create(words, nBytes);
        }
      })();
      return CryptoJS2.enc.Base64url;
    });
  })(encBase64url);
  return encBase64url.exports;
}
var md5$1 = { exports: {} };
var hasRequiredMd5;
function requireMd5() {
  if (hasRequiredMd5) return md5$1.exports;
  hasRequiredMd5 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var T = [];
        (function() {
          for (var i = 0; i < 64; i++) {
            T[i] = Math2.abs(Math2.sin(i + 1)) * 4294967296 | 0;
          }
        })();
        var MD5 = C_algo.MD5 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var M_offset_0 = M2[offset + 0];
            var M_offset_1 = M2[offset + 1];
            var M_offset_2 = M2[offset + 2];
            var M_offset_3 = M2[offset + 3];
            var M_offset_4 = M2[offset + 4];
            var M_offset_5 = M2[offset + 5];
            var M_offset_6 = M2[offset + 6];
            var M_offset_7 = M2[offset + 7];
            var M_offset_8 = M2[offset + 8];
            var M_offset_9 = M2[offset + 9];
            var M_offset_10 = M2[offset + 10];
            var M_offset_11 = M2[offset + 11];
            var M_offset_12 = M2[offset + 12];
            var M_offset_13 = M2[offset + 13];
            var M_offset_14 = M2[offset + 14];
            var M_offset_15 = M2[offset + 15];
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d2 = H[3];
            a = FF(a, b, c, d2, M_offset_0, 7, T[0]);
            d2 = FF(d2, a, b, c, M_offset_1, 12, T[1]);
            c = FF(c, d2, a, b, M_offset_2, 17, T[2]);
            b = FF(b, c, d2, a, M_offset_3, 22, T[3]);
            a = FF(a, b, c, d2, M_offset_4, 7, T[4]);
            d2 = FF(d2, a, b, c, M_offset_5, 12, T[5]);
            c = FF(c, d2, a, b, M_offset_6, 17, T[6]);
            b = FF(b, c, d2, a, M_offset_7, 22, T[7]);
            a = FF(a, b, c, d2, M_offset_8, 7, T[8]);
            d2 = FF(d2, a, b, c, M_offset_9, 12, T[9]);
            c = FF(c, d2, a, b, M_offset_10, 17, T[10]);
            b = FF(b, c, d2, a, M_offset_11, 22, T[11]);
            a = FF(a, b, c, d2, M_offset_12, 7, T[12]);
            d2 = FF(d2, a, b, c, M_offset_13, 12, T[13]);
            c = FF(c, d2, a, b, M_offset_14, 17, T[14]);
            b = FF(b, c, d2, a, M_offset_15, 22, T[15]);
            a = GG(a, b, c, d2, M_offset_1, 5, T[16]);
            d2 = GG(d2, a, b, c, M_offset_6, 9, T[17]);
            c = GG(c, d2, a, b, M_offset_11, 14, T[18]);
            b = GG(b, c, d2, a, M_offset_0, 20, T[19]);
            a = GG(a, b, c, d2, M_offset_5, 5, T[20]);
            d2 = GG(d2, a, b, c, M_offset_10, 9, T[21]);
            c = GG(c, d2, a, b, M_offset_15, 14, T[22]);
            b = GG(b, c, d2, a, M_offset_4, 20, T[23]);
            a = GG(a, b, c, d2, M_offset_9, 5, T[24]);
            d2 = GG(d2, a, b, c, M_offset_14, 9, T[25]);
            c = GG(c, d2, a, b, M_offset_3, 14, T[26]);
            b = GG(b, c, d2, a, M_offset_8, 20, T[27]);
            a = GG(a, b, c, d2, M_offset_13, 5, T[28]);
            d2 = GG(d2, a, b, c, M_offset_2, 9, T[29]);
            c = GG(c, d2, a, b, M_offset_7, 14, T[30]);
            b = GG(b, c, d2, a, M_offset_12, 20, T[31]);
            a = HH(a, b, c, d2, M_offset_5, 4, T[32]);
            d2 = HH(d2, a, b, c, M_offset_8, 11, T[33]);
            c = HH(c, d2, a, b, M_offset_11, 16, T[34]);
            b = HH(b, c, d2, a, M_offset_14, 23, T[35]);
            a = HH(a, b, c, d2, M_offset_1, 4, T[36]);
            d2 = HH(d2, a, b, c, M_offset_4, 11, T[37]);
            c = HH(c, d2, a, b, M_offset_7, 16, T[38]);
            b = HH(b, c, d2, a, M_offset_10, 23, T[39]);
            a = HH(a, b, c, d2, M_offset_13, 4, T[40]);
            d2 = HH(d2, a, b, c, M_offset_0, 11, T[41]);
            c = HH(c, d2, a, b, M_offset_3, 16, T[42]);
            b = HH(b, c, d2, a, M_offset_6, 23, T[43]);
            a = HH(a, b, c, d2, M_offset_9, 4, T[44]);
            d2 = HH(d2, a, b, c, M_offset_12, 11, T[45]);
            c = HH(c, d2, a, b, M_offset_15, 16, T[46]);
            b = HH(b, c, d2, a, M_offset_2, 23, T[47]);
            a = II(a, b, c, d2, M_offset_0, 6, T[48]);
            d2 = II(d2, a, b, c, M_offset_7, 10, T[49]);
            c = II(c, d2, a, b, M_offset_14, 15, T[50]);
            b = II(b, c, d2, a, M_offset_5, 21, T[51]);
            a = II(a, b, c, d2, M_offset_12, 6, T[52]);
            d2 = II(d2, a, b, c, M_offset_3, 10, T[53]);
            c = II(c, d2, a, b, M_offset_10, 15, T[54]);
            b = II(b, c, d2, a, M_offset_1, 21, T[55]);
            a = II(a, b, c, d2, M_offset_8, 6, T[56]);
            d2 = II(d2, a, b, c, M_offset_15, 10, T[57]);
            c = II(c, d2, a, b, M_offset_6, 15, T[58]);
            b = II(b, c, d2, a, M_offset_13, 21, T[59]);
            a = II(a, b, c, d2, M_offset_4, 6, T[60]);
            d2 = II(d2, a, b, c, M_offset_11, 10, T[61]);
            c = II(c, d2, a, b, M_offset_2, 15, T[62]);
            b = II(b, c, d2, a, M_offset_9, 21, T[63]);
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            var nBitsTotalH = Math2.floor(nBitsTotal / 4294967296);
            var nBitsTotalL = nBitsTotal;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 16711935 | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 4278255360;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 16711935 | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H = hash2.words;
            for (var i = 0; i < 4; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function FF(a, b, c, d2, x, s2, t2) {
          var n = a + (b & c | ~b & d2) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function GG(a, b, c, d2, x, s2, t2) {
          var n = a + (b & d2 | c & ~d2) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function HH(a, b, c, d2, x, s2, t2) {
          var n = a + (b ^ c ^ d2) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        function II(a, b, c, d2, x, s2, t2) {
          var n = a + (c ^ (b | ~d2)) + x + t2;
          return (n << s2 | n >>> 32 - s2) + b;
        }
        C.MD5 = Hasher._createHelper(MD5);
        C.HmacMD5 = Hasher._createHmacHelper(MD5);
      })(Math);
      return CryptoJS2.MD5;
    });
  })(md5$1);
  return md5$1.exports;
}
var sha1$1 = { exports: {} };
var hasRequiredSha1;
function requireSha1() {
  if (hasRequiredSha1) return sha1$1.exports;
  hasRequiredSha1 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var W = [];
        var SHA1 = C_algo.SHA1 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              1732584193,
              4023233417,
              2562383102,
              271733878,
              3285377520
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H = this._hash.words;
            var a = H[0];
            var b = H[1];
            var c = H[2];
            var d2 = H[3];
            var e = H[4];
            for (var i = 0; i < 80; i++) {
              if (i < 16) {
                W[i] = M2[offset + i] | 0;
              } else {
                var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                W[i] = n << 1 | n >>> 31;
              }
              var t2 = (a << 5 | a >>> 27) + e + W[i];
              if (i < 20) {
                t2 += (b & c | ~b & d2) + 1518500249;
              } else if (i < 40) {
                t2 += (b ^ c ^ d2) + 1859775393;
              } else if (i < 60) {
                t2 += (b & c | b & d2 | c & d2) - 1894007588;
              } else {
                t2 += (b ^ c ^ d2) - 899497514;
              }
              e = d2;
              d2 = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = t2;
            }
            H[0] = H[0] + a | 0;
            H[1] = H[1] + b | 0;
            H[2] = H[2] + c | 0;
            H[3] = H[3] + d2 | 0;
            H[4] = H[4] + e | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C.SHA1 = Hasher._createHelper(SHA1);
        C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
      })();
      return CryptoJS2.SHA1;
    });
  })(sha1$1);
  return sha1$1.exports;
}
var sha256$1 = { exports: {} };
var hasRequiredSha256;
function requireSha256() {
  if (hasRequiredSha256) return sha256$1.exports;
  hasRequiredSha256 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M2, offset) {
            var H10 = this._hash.words;
            var a = H10[0];
            var b = H10[1];
            var c = H10[2];
            var d2 = H10[3];
            var e = H10[4];
            var f = H10[5];
            var g = H10[6];
            var h2 = H10[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M2[offset + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h2 + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h2 = g;
              g = f;
              f = e;
              e = d2 + t1 | 0;
              d2 = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H10[0] = H10[0] + a | 0;
            H10[1] = H10[1] + b | 0;
            H10[2] = H10[2] + c | 0;
            H10[3] = H10[3] + d2 | 0;
            H10[4] = H10[4] + e | 0;
            H10[5] = H10[5] + f | 0;
            H10[6] = H10[6] + g | 0;
            H10[7] = H10[7] + h2 | 0;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS2.SHA256;
    });
  })(sha256$1);
  return sha256$1.exports;
}
var sha224 = { exports: {} };
var hasRequiredSha224;
function requireSha224() {
  if (hasRequiredSha224) return sha224.exports;
  hasRequiredSha224 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireSha256());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var SHA224 = C_algo.SHA224 = SHA256.extend({
          _doReset: function() {
            this._hash = new WordArray.init([
              3238371032,
              914150663,
              812702999,
              4144912697,
              4290775857,
              1750603025,
              1694076839,
              3204075428
            ]);
          },
          _doFinalize: function() {
            var hash2 = SHA256._doFinalize.call(this);
            hash2.sigBytes -= 4;
            return hash2;
          }
        });
        C.SHA224 = SHA256._createHelper(SHA224);
        C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
      })();
      return CryptoJS2.SHA224;
    });
  })(sha224);
  return sha224.exports;
}
var sha512$2 = { exports: {} };
var hasRequiredSha512;
function requireSha512() {
  if (hasRequiredSha512) return sha512$2.exports;
  hasRequiredSha512 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        function X64Word_create() {
          return X64Word.create.apply(X64Word, arguments);
        }
        var K = [
          X64Word_create(1116352408, 3609767458),
          X64Word_create(1899447441, 602891725),
          X64Word_create(3049323471, 3964484399),
          X64Word_create(3921009573, 2173295548),
          X64Word_create(961987163, 4081628472),
          X64Word_create(1508970993, 3053834265),
          X64Word_create(2453635748, 2937671579),
          X64Word_create(2870763221, 3664609560),
          X64Word_create(3624381080, 2734883394),
          X64Word_create(310598401, 1164996542),
          X64Word_create(607225278, 1323610764),
          X64Word_create(1426881987, 3590304994),
          X64Word_create(1925078388, 4068182383),
          X64Word_create(2162078206, 991336113),
          X64Word_create(2614888103, 633803317),
          X64Word_create(3248222580, 3479774868),
          X64Word_create(3835390401, 2666613458),
          X64Word_create(4022224774, 944711139),
          X64Word_create(264347078, 2341262773),
          X64Word_create(604807628, 2007800933),
          X64Word_create(770255983, 1495990901),
          X64Word_create(1249150122, 1856431235),
          X64Word_create(1555081692, 3175218132),
          X64Word_create(1996064986, 2198950837),
          X64Word_create(2554220882, 3999719339),
          X64Word_create(2821834349, 766784016),
          X64Word_create(2952996808, 2566594879),
          X64Word_create(3210313671, 3203337956),
          X64Word_create(3336571891, 1034457026),
          X64Word_create(3584528711, 2466948901),
          X64Word_create(113926993, 3758326383),
          X64Word_create(338241895, 168717936),
          X64Word_create(666307205, 1188179964),
          X64Word_create(773529912, 1546045734),
          X64Word_create(1294757372, 1522805485),
          X64Word_create(1396182291, 2643833823),
          X64Word_create(1695183700, 2343527390),
          X64Word_create(1986661051, 1014477480),
          X64Word_create(2177026350, 1206759142),
          X64Word_create(2456956037, 344077627),
          X64Word_create(2730485921, 1290863460),
          X64Word_create(2820302411, 3158454273),
          X64Word_create(3259730800, 3505952657),
          X64Word_create(3345764771, 106217008),
          X64Word_create(3516065817, 3606008344),
          X64Word_create(3600352804, 1432725776),
          X64Word_create(4094571909, 1467031594),
          X64Word_create(275423344, 851169720),
          X64Word_create(430227734, 3100823752),
          X64Word_create(506948616, 1363258195),
          X64Word_create(659060556, 3750685593),
          X64Word_create(883997877, 3785050280),
          X64Word_create(958139571, 3318307427),
          X64Word_create(1322822218, 3812723403),
          X64Word_create(1537002063, 2003034995),
          X64Word_create(1747873779, 3602036899),
          X64Word_create(1955562222, 1575990012),
          X64Word_create(2024104815, 1125592928),
          X64Word_create(2227730452, 2716904306),
          X64Word_create(2361852424, 442776044),
          X64Word_create(2428436474, 593698344),
          X64Word_create(2756734187, 3733110249),
          X64Word_create(3204031479, 2999351573),
          X64Word_create(3329325298, 3815920427),
          X64Word_create(3391569614, 3928383900),
          X64Word_create(3515267271, 566280711),
          X64Word_create(3940187606, 3454069534),
          X64Word_create(4118630271, 4000239992),
          X64Word_create(116418474, 1914138554),
          X64Word_create(174292421, 2731055270),
          X64Word_create(289380356, 3203993006),
          X64Word_create(460393269, 320620315),
          X64Word_create(685471733, 587496836),
          X64Word_create(852142971, 1086792851),
          X64Word_create(1017036298, 365543100),
          X64Word_create(1126000580, 2618297676),
          X64Word_create(1288033470, 3409855158),
          X64Word_create(1501505948, 4234509866),
          X64Word_create(1607167915, 987167468),
          X64Word_create(1816402316, 1246189591)
        ];
        var W = [];
        (function() {
          for (var i = 0; i < 80; i++) {
            W[i] = X64Word_create();
          }
        })();
        var SHA512 = C_algo.SHA512 = Hasher.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(1779033703, 4089235720),
              new X64Word.init(3144134277, 2227873595),
              new X64Word.init(1013904242, 4271175723),
              new X64Word.init(2773480762, 1595750129),
              new X64Word.init(1359893119, 2917565137),
              new X64Word.init(2600822924, 725511199),
              new X64Word.init(528734635, 4215389547),
              new X64Word.init(1541459225, 327033209)
            ]);
          },
          _doProcessBlock: function(M2, offset) {
            var H = this._hash.words;
            var H02 = H[0];
            var H12 = H[1];
            var H22 = H[2];
            var H32 = H[3];
            var H42 = H[4];
            var H52 = H[5];
            var H62 = H[6];
            var H72 = H[7];
            var H0h = H02.high;
            var H0l = H02.low;
            var H1h = H12.high;
            var H1l = H12.low;
            var H2h = H22.high;
            var H2l = H22.low;
            var H3h = H32.high;
            var H3l = H32.low;
            var H4h = H42.high;
            var H4l = H42.low;
            var H5h = H52.high;
            var H5l = H52.low;
            var H6h = H62.high;
            var H6l = H62.low;
            var H7h = H72.high;
            var H7l = H72.low;
            var ah = H0h;
            var al = H0l;
            var bh = H1h;
            var bl = H1l;
            var ch = H2h;
            var cl = H2l;
            var dh = H3h;
            var dl = H3l;
            var eh = H4h;
            var el = H4l;
            var fh = H5h;
            var fl = H5l;
            var gh = H6h;
            var gl = H6l;
            var hh = H7h;
            var hl = H7l;
            for (var i = 0; i < 80; i++) {
              var Wil;
              var Wih;
              var Wi = W[i];
              if (i < 16) {
                Wih = Wi.high = M2[offset + i * 2] | 0;
                Wil = Wi.low = M2[offset + i * 2 + 1] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0xh = gamma0x.high;
                var gamma0xl = gamma0x.low;
                var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);
                var gamma1x = W[i - 2];
                var gamma1xh = gamma1x.high;
                var gamma1xl = gamma1x.low;
                var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);
                var Wi7 = W[i - 7];
                var Wi7h = Wi7.high;
                var Wi7l = Wi7.low;
                var Wi16 = W[i - 16];
                var Wi16h = Wi16.high;
                var Wi16l = Wi16.low;
                Wil = gamma0l + Wi7l;
                Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                Wil = Wil + gamma1l;
                Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                Wil = Wil + Wi16l;
                Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                Wi.high = Wih;
                Wi.low = Wil;
              }
              var chh = eh & fh ^ ~eh & gh;
              var chl = el & fl ^ ~el & gl;
              var majh = ah & bh ^ ah & ch ^ bh & ch;
              var majl = al & bl ^ al & cl ^ bl & cl;
              var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
              var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
              var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
              var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);
              var Ki = K[i];
              var Kih = Ki.high;
              var Kil = Ki.low;
              var t1l = hl + sigma1l;
              var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
              var t1l = t1l + chl;
              var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
              var t1l = t1l + Kil;
              var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
              var t1l = t1l + Wil;
              var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);
              var t2l = sigma0l + majl;
              var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);
              hh = gh;
              hl = gl;
              gh = fh;
              gl = fl;
              fh = eh;
              fl = el;
              el = dl + t1l | 0;
              eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
              dh = ch;
              dl = cl;
              ch = bh;
              cl = bl;
              bh = ah;
              bl = al;
              al = t1l + t2l | 0;
              ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
            }
            H0l = H02.low = H0l + al;
            H02.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
            H1l = H12.low = H1l + bl;
            H12.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
            H2l = H22.low = H2l + cl;
            H22.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
            H3l = H32.low = H3l + dl;
            H32.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
            H4l = H42.low = H4l + el;
            H42.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
            H5l = H52.low = H5l + fl;
            H52.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
            H6l = H62.low = H6l + gl;
            H62.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
            H7l = H72.low = H7l + hl;
            H72.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var hash2 = this._hash.toX32();
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          },
          blockSize: 1024 / 32
        });
        C.SHA512 = Hasher._createHelper(SHA512);
        C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
      })();
      return CryptoJS2.SHA512;
    });
  })(sha512$2);
  return sha512$2.exports;
}
var sha384$1 = { exports: {} };
var hasRequiredSha384;
function requireSha384() {
  if (hasRequiredSha384) return sha384$1.exports;
  hasRequiredSha384 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireX64Core(), requireSha512());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var X64WordArray = C_x64.WordArray;
        var C_algo = C.algo;
        var SHA512 = C_algo.SHA512;
        var SHA384 = C_algo.SHA384 = SHA512.extend({
          _doReset: function() {
            this._hash = new X64WordArray.init([
              new X64Word.init(3418070365, 3238371032),
              new X64Word.init(1654270250, 914150663),
              new X64Word.init(2438529370, 812702999),
              new X64Word.init(355462360, 4144912697),
              new X64Word.init(1731405415, 4290775857),
              new X64Word.init(2394180231, 1750603025),
              new X64Word.init(3675008525, 1694076839),
              new X64Word.init(1203062813, 3204075428)
            ]);
          },
          _doFinalize: function() {
            var hash2 = SHA512._doFinalize.call(this);
            hash2.sigBytes -= 16;
            return hash2;
          }
        });
        C.SHA384 = SHA512._createHelper(SHA384);
        C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
      })();
      return CryptoJS2.SHA384;
    });
  })(sha384$1);
  return sha384$1.exports;
}
var sha3 = { exports: {} };
var hasRequiredSha3;
function requireSha3() {
  if (hasRequiredSha3) return sha3.exports;
  hasRequiredSha3 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireX64Core());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_x64 = C.x64;
        var X64Word = C_x64.Word;
        var C_algo = C.algo;
        var RHO_OFFSETS = [];
        var PI_INDEXES = [];
        var ROUND_CONSTANTS = [];
        (function() {
          var x = 1, y2 = 0;
          for (var t2 = 0; t2 < 24; t2++) {
            RHO_OFFSETS[x + 5 * y2] = (t2 + 1) * (t2 + 2) / 2 % 64;
            var newX = y2 % 5;
            var newY = (2 * x + 3 * y2) % 5;
            x = newX;
            y2 = newY;
          }
          for (var x = 0; x < 5; x++) {
            for (var y2 = 0; y2 < 5; y2++) {
              PI_INDEXES[x + 5 * y2] = y2 + (2 * x + 3 * y2) % 5 * 5;
            }
          }
          var LFSR = 1;
          for (var i = 0; i < 24; i++) {
            var roundConstantMsw = 0;
            var roundConstantLsw = 0;
            for (var j2 = 0; j2 < 7; j2++) {
              if (LFSR & 1) {
                var bitPosition = (1 << j2) - 1;
                if (bitPosition < 32) {
                  roundConstantLsw ^= 1 << bitPosition;
                } else {
                  roundConstantMsw ^= 1 << bitPosition - 32;
                }
              }
              if (LFSR & 128) {
                LFSR = LFSR << 1 ^ 113;
              } else {
                LFSR <<= 1;
              }
            }
            ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
          }
        })();
        var T = [];
        (function() {
          for (var i = 0; i < 25; i++) {
            T[i] = X64Word.create();
          }
        })();
        var SHA3 = C_algo.SHA3 = Hasher.extend({
          /**
           * Configuration options.
           *
           * @property {number} outputLength
           *   The desired number of bits in the output hash.
           *   Only values permitted are: 224, 256, 384, 512.
           *   Default: 512
           */
          cfg: Hasher.cfg.extend({
            outputLength: 512
          }),
          _doReset: function() {
            var state2 = this._state = [];
            for (var i = 0; i < 25; i++) {
              state2[i] = new X64Word.init();
            }
            this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
          },
          _doProcessBlock: function(M2, offset) {
            var state2 = this._state;
            var nBlockSizeLanes = this.blockSize / 2;
            for (var i = 0; i < nBlockSizeLanes; i++) {
              var M2i = M2[offset + 2 * i];
              var M2i1 = M2[offset + 2 * i + 1];
              M2i = (M2i << 8 | M2i >>> 24) & 16711935 | (M2i << 24 | M2i >>> 8) & 4278255360;
              M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 16711935 | (M2i1 << 24 | M2i1 >>> 8) & 4278255360;
              var lane = state2[i];
              lane.high ^= M2i1;
              lane.low ^= M2i;
            }
            for (var round = 0; round < 24; round++) {
              for (var x = 0; x < 5; x++) {
                var tMsw = 0, tLsw = 0;
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x + 5 * y2];
                  tMsw ^= lane.high;
                  tLsw ^= lane.low;
                }
                var Tx = T[x];
                Tx.high = tMsw;
                Tx.low = tLsw;
              }
              for (var x = 0; x < 5; x++) {
                var Tx4 = T[(x + 4) % 5];
                var Tx1 = T[(x + 1) % 5];
                var Tx1Msw = Tx1.high;
                var Tx1Lsw = Tx1.low;
                var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                for (var y2 = 0; y2 < 5; y2++) {
                  var lane = state2[x + 5 * y2];
                  lane.high ^= tMsw;
                  lane.low ^= tLsw;
                }
              }
              for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                var tMsw;
                var tLsw;
                var lane = state2[laneIndex];
                var laneMsw = lane.high;
                var laneLsw = lane.low;
                var rhoOffset = RHO_OFFSETS[laneIndex];
                if (rhoOffset < 32) {
                  tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                  tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                } else {
                  tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                  tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                }
                var TPiLane = T[PI_INDEXES[laneIndex]];
                TPiLane.high = tMsw;
                TPiLane.low = tLsw;
              }
              var T0 = T[0];
              var state0 = state2[0];
              T0.high = state0.high;
              T0.low = state0.low;
              for (var x = 0; x < 5; x++) {
                for (var y2 = 0; y2 < 5; y2++) {
                  var laneIndex = x + 5 * y2;
                  var lane = state2[laneIndex];
                  var TLane = T[laneIndex];
                  var Tx1Lane = T[(x + 1) % 5 + 5 * y2];
                  var Tx2Lane = T[(x + 2) % 5 + 5 * y2];
                  lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                  lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                }
              }
              var lane = state2[0];
              var roundConstant = ROUND_CONSTANTS[round];
              lane.high ^= roundConstant.high;
              lane.low ^= roundConstant.low;
            }
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            var blockSizeBits = this.blockSize * 32;
            dataWords[nBitsLeft >>> 5] |= 1 << 24 - nBitsLeft % 32;
            dataWords[(Math2.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 128;
            data2.sigBytes = dataWords.length * 4;
            this._process();
            var state2 = this._state;
            var outputLengthBytes = this.cfg.outputLength / 8;
            var outputLengthLanes = outputLengthBytes / 8;
            var hashWords = [];
            for (var i = 0; i < outputLengthLanes; i++) {
              var lane = state2[i];
              var laneMsw = lane.high;
              var laneLsw = lane.low;
              laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 16711935 | (laneMsw << 24 | laneMsw >>> 8) & 4278255360;
              laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 16711935 | (laneLsw << 24 | laneLsw >>> 8) & 4278255360;
              hashWords.push(laneLsw);
              hashWords.push(laneMsw);
            }
            return new WordArray.init(hashWords, outputLengthBytes);
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            var state2 = clone2._state = this._state.slice(0);
            for (var i = 0; i < 25; i++) {
              state2[i] = state2[i].clone();
            }
            return clone2;
          }
        });
        C.SHA3 = Hasher._createHelper(SHA3);
        C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
      })(Math);
      return CryptoJS2.SHA3;
    });
  })(sha3);
  return sha3.exports;
}
var ripemd160 = { exports: {} };
var hasRequiredRipemd160;
function requireRipemd160() {
  if (hasRequiredRipemd160) return ripemd160.exports;
  hasRequiredRipemd160 = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      /** @preserve
      			(c) 2012 by CÃ©dric Mesnil. All rights reserved.
      
      			Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
      			    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      			    - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
      			THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      			*/
      (function(Math2) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var _zl = WordArray.create([
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          7,
          4,
          13,
          1,
          10,
          6,
          15,
          3,
          12,
          0,
          9,
          5,
          2,
          14,
          11,
          8,
          3,
          10,
          14,
          4,
          9,
          15,
          8,
          1,
          2,
          7,
          0,
          6,
          13,
          11,
          5,
          12,
          1,
          9,
          11,
          10,
          0,
          8,
          12,
          4,
          13,
          3,
          7,
          15,
          14,
          5,
          6,
          2,
          4,
          0,
          5,
          9,
          7,
          12,
          2,
          10,
          14,
          1,
          3,
          8,
          11,
          6,
          15,
          13
        ]);
        var _zr = WordArray.create([
          5,
          14,
          7,
          0,
          9,
          2,
          11,
          4,
          13,
          6,
          15,
          8,
          1,
          10,
          3,
          12,
          6,
          11,
          3,
          7,
          0,
          13,
          5,
          10,
          14,
          15,
          8,
          12,
          4,
          9,
          1,
          2,
          15,
          5,
          1,
          3,
          7,
          14,
          6,
          9,
          11,
          8,
          12,
          2,
          10,
          0,
          4,
          13,
          8,
          6,
          4,
          1,
          3,
          11,
          15,
          0,
          5,
          12,
          2,
          13,
          9,
          7,
          10,
          14,
          12,
          15,
          10,
          4,
          1,
          5,
          8,
          7,
          6,
          2,
          13,
          14,
          0,
          3,
          9,
          11
        ]);
        var _sl = WordArray.create([
          11,
          14,
          15,
          12,
          5,
          8,
          7,
          9,
          11,
          13,
          14,
          15,
          6,
          7,
          9,
          8,
          7,
          6,
          8,
          13,
          11,
          9,
          7,
          15,
          7,
          12,
          15,
          9,
          11,
          7,
          13,
          12,
          11,
          13,
          6,
          7,
          14,
          9,
          13,
          15,
          14,
          8,
          13,
          6,
          5,
          12,
          7,
          5,
          11,
          12,
          14,
          15,
          14,
          15,
          9,
          8,
          9,
          14,
          5,
          6,
          8,
          6,
          5,
          12,
          9,
          15,
          5,
          11,
          6,
          8,
          13,
          12,
          5,
          12,
          13,
          14,
          11,
          8,
          5,
          6
        ]);
        var _sr = WordArray.create([
          8,
          9,
          9,
          11,
          13,
          15,
          15,
          5,
          7,
          7,
          8,
          11,
          14,
          14,
          12,
          6,
          9,
          13,
          15,
          7,
          12,
          8,
          9,
          11,
          7,
          7,
          12,
          7,
          6,
          15,
          13,
          11,
          9,
          7,
          15,
          11,
          8,
          6,
          6,
          14,
          12,
          13,
          5,
          14,
          13,
          13,
          7,
          5,
          15,
          5,
          8,
          11,
          14,
          14,
          6,
          14,
          6,
          9,
          12,
          9,
          12,
          5,
          15,
          8,
          8,
          5,
          12,
          9,
          12,
          5,
          14,
          6,
          8,
          13,
          6,
          5,
          15,
          13,
          11,
          11
        ]);
        var _hl = WordArray.create([0, 1518500249, 1859775393, 2400959708, 2840853838]);
        var _hr = WordArray.create([1352829926, 1548603684, 1836072691, 2053994217, 0]);
        var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
          _doReset: function() {
            this._hash = WordArray.create([1732584193, 4023233417, 2562383102, 271733878, 3285377520]);
          },
          _doProcessBlock: function(M2, offset) {
            for (var i = 0; i < 16; i++) {
              var offset_i = offset + i;
              var M_offset_i = M2[offset_i];
              M2[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 16711935 | (M_offset_i << 24 | M_offset_i >>> 8) & 4278255360;
            }
            var H = this._hash.words;
            var hl = _hl.words;
            var hr = _hr.words;
            var zl = _zl.words;
            var zr = _zr.words;
            var sl = _sl.words;
            var sr = _sr.words;
            var al, bl, cl, dl, el;
            var ar, br, cr, dr, er;
            ar = al = H[0];
            br = bl = H[1];
            cr = cl = H[2];
            dr = dl = H[3];
            er = el = H[4];
            var t2;
            for (var i = 0; i < 80; i += 1) {
              t2 = al + M2[offset + zl[i]] | 0;
              if (i < 16) {
                t2 += f1(bl, cl, dl) + hl[0];
              } else if (i < 32) {
                t2 += f2(bl, cl, dl) + hl[1];
              } else if (i < 48) {
                t2 += f3(bl, cl, dl) + hl[2];
              } else if (i < 64) {
                t2 += f4(bl, cl, dl) + hl[3];
              } else {
                t2 += f5(bl, cl, dl) + hl[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sl[i]);
              t2 = t2 + el | 0;
              al = el;
              el = dl;
              dl = rotl(cl, 10);
              cl = bl;
              bl = t2;
              t2 = ar + M2[offset + zr[i]] | 0;
              if (i < 16) {
                t2 += f5(br, cr, dr) + hr[0];
              } else if (i < 32) {
                t2 += f4(br, cr, dr) + hr[1];
              } else if (i < 48) {
                t2 += f3(br, cr, dr) + hr[2];
              } else if (i < 64) {
                t2 += f2(br, cr, dr) + hr[3];
              } else {
                t2 += f1(br, cr, dr) + hr[4];
              }
              t2 = t2 | 0;
              t2 = rotl(t2, sr[i]);
              t2 = t2 + er | 0;
              ar = er;
              er = dr;
              dr = rotl(cr, 10);
              cr = br;
              br = t2;
            }
            t2 = H[1] + cl + dr | 0;
            H[1] = H[2] + dl + er | 0;
            H[2] = H[3] + el + ar | 0;
            H[3] = H[4] + al + br | 0;
            H[4] = H[0] + bl + cr | 0;
            H[0] = t2;
          },
          _doFinalize: function() {
            var data2 = this._data;
            var dataWords = data2.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data2.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 16711935 | (nBitsTotal << 24 | nBitsTotal >>> 8) & 4278255360;
            data2.sigBytes = (dataWords.length + 1) * 4;
            this._process();
            var hash2 = this._hash;
            var H = hash2.words;
            for (var i = 0; i < 5; i++) {
              var H_i = H[i];
              H[i] = (H_i << 8 | H_i >>> 24) & 16711935 | (H_i << 24 | H_i >>> 8) & 4278255360;
            }
            return hash2;
          },
          clone: function() {
            var clone2 = Hasher.clone.call(this);
            clone2._hash = this._hash.clone();
            return clone2;
          }
        });
        function f1(x, y2, z) {
          return x ^ y2 ^ z;
        }
        function f2(x, y2, z) {
          return x & y2 | ~x & z;
        }
        function f3(x, y2, z) {
          return (x | ~y2) ^ z;
        }
        function f4(x, y2, z) {
          return x & z | y2 & ~z;
        }
        function f5(x, y2, z) {
          return x ^ (y2 | ~z);
        }
        function rotl(x, n) {
          return x << n | x >>> 32 - n;
        }
        C.RIPEMD160 = Hasher._createHelper(RIPEMD160);
        C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
      })();
      return CryptoJS2.RIPEMD160;
    });
  })(ripemd160);
  return ripemd160.exports;
}
var hmac$1 = { exports: {} };
var hasRequiredHmac;
function requireHmac() {
  if (hasRequiredHmac) return hmac$1.exports;
  hasRequiredHmac = 1;
  (function(module2, exports) {
    (function(root2, factory) {
      {
        module2.exports = factory(requireCore$1());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var C_enc = C.enc;
        var Utf8 = C_enc.Utf8;
        var C_algo = C.algo;
        C_algo.HMAC = Base.extend({
          /**
           * Initializes a newly created HMAC.
           *
           * @param {Hasher} hasher The hash algorithm to use.
           * @param {WordArray|string} key The secret key.
           *
           * @example
           *
           *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
           */
          init: function(hasher, key) {
            hasher = this._hasher = new hasher.init();
            if (typeof key == "string") {
              key = Utf8.parse(key);
            }
            var hasherBlockSize = hasher.blockSize;
            var hasherBlockSizeBytes = hasherBlockSize * 4;
            if (key.sigBytes > hasherBlockSizeBytes) {
              key = hasher.finalize(key);
            }
            key.clamp();
            var oKey = this._oKey = key.clone();
            var iKey = this._iKey = key.clone();
            var oKeyWords = oKey.words;
            var iKeyWords = iKey.words;
            for (var i = 0; i < hasherBlockSize; i++) {
              oKeyWords[i] ^= 1549556828;
              iKeyWords[i] ^= 909522486;
            }
            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;
            this.reset();
          },
          /**
           * Resets this HMAC to its initial state.
           *
           * @example
           *
           *     hmacHasher.reset();
           */
          reset: function() {
            var hasher = this._hasher;
            hasher.reset();
            hasher.update(this._iKey);
          },
          /**
           * Updates this HMAC with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {HMAC} This HMAC instance.
           *
           * @example
           *
           *     hmacHasher.update('message');
           *     hmacHasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._hasher.update(messageUpdate);
            return this;
          },
          /**
           * Finalizes the HMAC computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The HMAC.
           *
           * @example
           *
           *     var hmac = hmacHasher.finalize();
           *     var hmac = hmacHasher.finalize('message');
           *     var hmac = hmacHasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            var hasher = this._hasher;
            var innerHash = hasher.finalize(messageUpdate);
            hasher.reset();
            var hmac2 = hasher.finalize(this._oKey.clone().concat(innerHash));
            return hmac2;
          }
        });
      })();
    });
  })(hmac$1);
  return hmac$1.exports;
}
var pbkdf2 = { exports: {} };
var hasRequiredPbkdf2;
function requirePbkdf2() {
  if (hasRequiredPbkdf2) return pbkdf2.exports;
  hasRequiredPbkdf2 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireSha256(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var SHA256 = C_algo.SHA256;
        var HMAC = C_algo.HMAC;
        var PBKDF2 = C_algo.PBKDF2 = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hasher to use. Default: SHA256
           * @property {number} iterations The number of iterations to perform. Default: 250000
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: SHA256,
            iterations: 25e4
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.PBKDF2.create();
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Computes the Password-Based Key Derivation Function 2.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var cfg = this.cfg;
            var hmac2 = HMAC.create(cfg.hasher, password);
            var derivedKey = WordArray.create();
            var blockIndex = WordArray.create([1]);
            var derivedKeyWords = derivedKey.words;
            var blockIndexWords = blockIndex.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              var block = hmac2.update(salt).finalize(blockIndex);
              hmac2.reset();
              var blockWords = block.words;
              var blockWordsLength = blockWords.length;
              var intermediate = block;
              for (var i = 1; i < iterations; i++) {
                intermediate = hmac2.finalize(intermediate);
                hmac2.reset();
                var intermediateWords = intermediate.words;
                for (var j2 = 0; j2 < blockWordsLength; j2++) {
                  blockWords[j2] ^= intermediateWords[j2];
                }
              }
              derivedKey.concat(block);
              blockIndexWords[0]++;
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.PBKDF2 = function(password, salt, cfg) {
          return PBKDF2.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.PBKDF2;
    });
  })(pbkdf2);
  return pbkdf2.exports;
}
var evpkdf = { exports: {} };
var hasRequiredEvpkdf;
function requireEvpkdf() {
  if (hasRequiredEvpkdf) return evpkdf.exports;
  hasRequiredEvpkdf = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireSha1(), requireHmac());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var C_algo = C.algo;
        var MD5 = C_algo.MD5;
        var EvpKDF = C_algo.EvpKDF = Base.extend({
          /**
           * Configuration options.
           *
           * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
           * @property {Hasher} hasher The hash algorithm to use. Default: MD5
           * @property {number} iterations The number of iterations to perform. Default: 1
           */
          cfg: Base.extend({
            keySize: 128 / 32,
            hasher: MD5,
            iterations: 1
          }),
          /**
           * Initializes a newly created key derivation function.
           *
           * @param {Object} cfg (Optional) The configuration options to use for the derivation.
           *
           * @example
           *
           *     var kdf = CryptoJS.algo.EvpKDF.create();
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
           *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
          },
          /**
           * Derives a key from a password.
           *
           * @param {WordArray|string} password The password.
           * @param {WordArray|string} salt A salt.
           *
           * @return {WordArray} The derived key.
           *
           * @example
           *
           *     var key = kdf.compute(password, salt);
           */
          compute: function(password, salt) {
            var block;
            var cfg = this.cfg;
            var hasher = cfg.hasher.create();
            var derivedKey = WordArray.create();
            var derivedKeyWords = derivedKey.words;
            var keySize = cfg.keySize;
            var iterations = cfg.iterations;
            while (derivedKeyWords.length < keySize) {
              if (block) {
                hasher.update(block);
              }
              block = hasher.update(password).finalize(salt);
              hasher.reset();
              for (var i = 1; i < iterations; i++) {
                block = hasher.finalize(block);
                hasher.reset();
              }
              derivedKey.concat(block);
            }
            derivedKey.sigBytes = keySize * 4;
            return derivedKey;
          }
        });
        C.EvpKDF = function(password, salt, cfg) {
          return EvpKDF.create(cfg).compute(password, salt);
        };
      })();
      return CryptoJS2.EvpKDF;
    });
  })(evpkdf);
  return evpkdf.exports;
}
var cipherCore = { exports: {} };
var hasRequiredCipherCore;
function requireCipherCore() {
  if (hasRequiredCipherCore) return cipherCore.exports;
  hasRequiredCipherCore = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEvpkdf());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.lib.Cipher || function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var Base = C_lib.Base;
        var WordArray = C_lib.WordArray;
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
        var C_enc = C.enc;
        C_enc.Utf8;
        var Base64 = C_enc.Base64;
        var C_algo = C.algo;
        var EvpKDF = C_algo.EvpKDF;
        var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           *
           * @property {WordArray} iv The IV to use for this operation.
           */
          cfg: Base.extend(),
          /**
           * Creates this cipher in encryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
           */
          createEncryptor: function(key, cfg) {
            return this.create(this._ENC_XFORM_MODE, key, cfg);
          },
          /**
           * Creates this cipher in decryption mode.
           *
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {Cipher} A cipher instance.
           *
           * @static
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
           */
          createDecryptor: function(key, cfg) {
            return this.create(this._DEC_XFORM_MODE, key, cfg);
          },
          /**
           * Initializes a newly created cipher.
           *
           * @param {number} xformMode Either the encryption or decryption transormation mode constant.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @example
           *
           *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
           */
          init: function(xformMode, key, cfg) {
            this.cfg = this.cfg.extend(cfg);
            this._xformMode = xformMode;
            this._key = key;
            this.reset();
          },
          /**
           * Resets this cipher to its initial state.
           *
           * @example
           *
           *     cipher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Adds data to be encrypted or decrypted.
           *
           * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
           *
           * @return {WordArray} The data after processing.
           *
           * @example
           *
           *     var encrypted = cipher.process('data');
           *     var encrypted = cipher.process(wordArray);
           */
          process: function(dataUpdate) {
            this._append(dataUpdate);
            return this._process();
          },
          /**
           * Finalizes the encryption or decryption process.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
           *
           * @return {WordArray} The data after final processing.
           *
           * @example
           *
           *     var encrypted = cipher.finalize();
           *     var encrypted = cipher.finalize('data');
           *     var encrypted = cipher.finalize(wordArray);
           */
          finalize: function(dataUpdate) {
            if (dataUpdate) {
              this._append(dataUpdate);
            }
            var finalProcessedData = this._doFinalize();
            return finalProcessedData;
          },
          keySize: 128 / 32,
          ivSize: 128 / 32,
          _ENC_XFORM_MODE: 1,
          _DEC_XFORM_MODE: 2,
          /**
           * Creates shortcut functions to a cipher's object interface.
           *
           * @param {Cipher} cipher The cipher to create a helper for.
           *
           * @return {Object} An object with encrypt and decrypt shortcut functions.
           *
           * @static
           *
           * @example
           *
           *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
           */
          _createHelper: /* @__PURE__ */ function() {
            function selectCipherStrategy(key) {
              if (typeof key == "string") {
                return PasswordBasedCipher;
              } else {
                return SerializableCipher;
              }
            }
            return function(cipher) {
              return {
                encrypt: function(message, key, cfg) {
                  return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                },
                decrypt: function(ciphertext, key, cfg) {
                  return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                }
              };
            };
          }()
        });
        C_lib.StreamCipher = Cipher.extend({
          _doFinalize: function() {
            var finalProcessedBlocks = this._process(true);
            return finalProcessedBlocks;
          },
          blockSize: 1
        });
        var C_mode = C.mode = {};
        var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
          /**
           * Creates this mode for encryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
           */
          createEncryptor: function(cipher, iv2) {
            return this.Encryptor.create(cipher, iv2);
          },
          /**
           * Creates this mode for decryption.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @static
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
           */
          createDecryptor: function(cipher, iv2) {
            return this.Decryptor.create(cipher, iv2);
          },
          /**
           * Initializes a newly created mode.
           *
           * @param {Cipher} cipher A block cipher instance.
           * @param {Array} iv The IV words.
           *
           * @example
           *
           *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
           */
          init: function(cipher, iv2) {
            this._cipher = cipher;
            this._iv = iv2;
          }
        });
        var CBC = C_mode.CBC = function() {
          var CBC2 = BlockCipherMode.extend();
          CBC2.Encryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              xorBlock.call(this, words, offset, blockSize);
              cipher.encryptBlock(words, offset);
              this._prevBlock = words.slice(offset, offset + blockSize);
            }
          });
          CBC2.Decryptor = CBC2.extend({
            /**
             * Processes the data block at offset.
             *
             * @param {Array} words The data words to operate on.
             * @param {number} offset The offset where the block starts.
             *
             * @example
             *
             *     mode.processBlock(data.words, offset);
             */
            processBlock: function(words, offset) {
              var cipher = this._cipher;
              var blockSize = cipher.blockSize;
              var thisBlock = words.slice(offset, offset + blockSize);
              cipher.decryptBlock(words, offset);
              xorBlock.call(this, words, offset, blockSize);
              this._prevBlock = thisBlock;
            }
          });
          function xorBlock(words, offset, blockSize) {
            var block;
            var iv2 = this._iv;
            if (iv2) {
              block = iv2;
              this._iv = undefined$1;
            } else {
              block = this._prevBlock;
            }
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= block[i];
            }
          }
          return CBC2;
        }();
        var C_pad = C.pad = {};
        var Pkcs7 = C_pad.Pkcs7 = {
          /**
           * Pads data using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to pad.
           * @param {number} blockSize The multiple that the data should be padded to.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
           */
          pad: function(data2, blockSize) {
            var blockSizeBytes = blockSize * 4;
            var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
            var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;
            var paddingWords = [];
            for (var i = 0; i < nPaddingBytes; i += 4) {
              paddingWords.push(paddingWord);
            }
            var padding = WordArray.create(paddingWords, nPaddingBytes);
            data2.concat(padding);
          },
          /**
           * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
           *
           * @param {WordArray} data The data to unpad.
           *
           * @static
           *
           * @example
           *
           *     CryptoJS.pad.Pkcs7.unpad(wordArray);
           */
          unpad: function(data2) {
            var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
            data2.sigBytes -= nPaddingBytes;
          }
        };
        C_lib.BlockCipher = Cipher.extend({
          /**
           * Configuration options.
           *
           * @property {Mode} mode The block mode to use. Default: CBC
           * @property {Padding} padding The padding strategy to use. Default: Pkcs7
           */
          cfg: Cipher.cfg.extend({
            mode: CBC,
            padding: Pkcs7
          }),
          reset: function() {
            var modeCreator;
            Cipher.reset.call(this);
            var cfg = this.cfg;
            var iv2 = cfg.iv;
            var mode = cfg.mode;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              modeCreator = mode.createEncryptor;
            } else {
              modeCreator = mode.createDecryptor;
              this._minBufferSize = 1;
            }
            if (this._mode && this._mode.__creator == modeCreator) {
              this._mode.init(this, iv2 && iv2.words);
            } else {
              this._mode = modeCreator.call(mode, this, iv2 && iv2.words);
              this._mode.__creator = modeCreator;
            }
          },
          _doProcessBlock: function(words, offset) {
            this._mode.processBlock(words, offset);
          },
          _doFinalize: function() {
            var finalProcessedBlocks;
            var padding = this.cfg.padding;
            if (this._xformMode == this._ENC_XFORM_MODE) {
              padding.pad(this._data, this.blockSize);
              finalProcessedBlocks = this._process(true);
            } else {
              finalProcessedBlocks = this._process(true);
              padding.unpad(finalProcessedBlocks);
            }
            return finalProcessedBlocks;
          },
          blockSize: 128 / 32
        });
        var CipherParams = C_lib.CipherParams = Base.extend({
          /**
           * Initializes a newly created cipher params object.
           *
           * @param {Object} cipherParams An object with any of the possible cipher parameters.
           *
           * @example
           *
           *     var cipherParams = CryptoJS.lib.CipherParams.create({
           *         ciphertext: ciphertextWordArray,
           *         key: keyWordArray,
           *         iv: ivWordArray,
           *         salt: saltWordArray,
           *         algorithm: CryptoJS.algo.AES,
           *         mode: CryptoJS.mode.CBC,
           *         padding: CryptoJS.pad.PKCS7,
           *         blockSize: 4,
           *         formatter: CryptoJS.format.OpenSSL
           *     });
           */
          init: function(cipherParams) {
            this.mixIn(cipherParams);
          },
          /**
           * Converts this cipher params object to a string.
           *
           * @param {Format} formatter (Optional) The formatting strategy to use.
           *
           * @return {string} The stringified cipher params.
           *
           * @throws Error If neither the formatter nor the default formatter is set.
           *
           * @example
           *
           *     var string = cipherParams + '';
           *     var string = cipherParams.toString();
           *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
           */
          toString: function(formatter) {
            return (formatter || this.formatter).stringify(this);
          }
        });
        var C_format = C.format = {};
        var OpenSSLFormatter = C_format.OpenSSL = {
          /**
           * Converts a cipher params object to an OpenSSL-compatible string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The OpenSSL-compatible string.
           *
           * @static
           *
           * @example
           *
           *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            var wordArray;
            var ciphertext = cipherParams.ciphertext;
            var salt = cipherParams.salt;
            if (salt) {
              wordArray = WordArray.create([1398893684, 1701076831]).concat(salt).concat(ciphertext);
            } else {
              wordArray = ciphertext;
            }
            return wordArray.toString(Base64);
          },
          /**
           * Converts an OpenSSL-compatible string to a cipher params object.
           *
           * @param {string} openSSLStr The OpenSSL-compatible string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
           */
          parse: function(openSSLStr) {
            var salt;
            var ciphertext = Base64.parse(openSSLStr);
            var ciphertextWords = ciphertext.words;
            if (ciphertextWords[0] == 1398893684 && ciphertextWords[1] == 1701076831) {
              salt = WordArray.create(ciphertextWords.slice(2, 4));
              ciphertextWords.splice(0, 4);
              ciphertext.sigBytes -= 16;
            }
            return CipherParams.create({ ciphertext, salt });
          }
        };
        var SerializableCipher = C_lib.SerializableCipher = Base.extend({
          /**
           * Configuration options.
           *
           * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
           */
          cfg: Base.extend({
            format: OpenSSLFormatter
          }),
          /**
           * Encrypts a message.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, key, cfg) {
            cfg = this.cfg.extend(cfg);
            var encryptor = cipher.createEncryptor(key, cfg);
            var ciphertext = encryptor.finalize(message);
            var cipherCfg = encryptor.cfg;
            return CipherParams.create({
              ciphertext,
              key,
              iv: cipherCfg.iv,
              algorithm: cipher,
              mode: cipherCfg.mode,
              padding: cipherCfg.padding,
              blockSize: cipher.blockSize,
              formatter: cfg.format
            });
          },
          /**
           * Decrypts serialized ciphertext.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {WordArray} key The key.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, key, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
            return plaintext;
          },
          /**
           * Converts serialized ciphertext to CipherParams,
           * else assumed CipherParams already and returns ciphertext unchanged.
           *
           * @param {CipherParams|string} ciphertext The ciphertext.
           * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
           *
           * @return {CipherParams} The unserialized ciphertext.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
           */
          _parse: function(ciphertext, format2) {
            if (typeof ciphertext == "string") {
              return format2.parse(ciphertext, this);
            } else {
              return ciphertext;
            }
          }
        });
        var C_kdf = C.kdf = {};
        var OpenSSLKdf = C_kdf.OpenSSL = {
          /**
           * Derives a key and IV from a password.
           *
           * @param {string} password The password to derive from.
           * @param {number} keySize The size in words of the key to generate.
           * @param {number} ivSize The size in words of the IV to generate.
           * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
           *
           * @return {CipherParams} A cipher params object with the key, IV, and salt.
           *
           * @static
           *
           * @example
           *
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
           *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
           */
          execute: function(password, keySize, ivSize, salt, hasher) {
            if (!salt) {
              salt = WordArray.random(64 / 8);
            }
            if (!hasher) {
              var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);
            } else {
              var key = EvpKDF.create({ keySize: keySize + ivSize, hasher }).compute(password, salt);
            }
            var iv2 = WordArray.create(key.words.slice(keySize), ivSize * 4);
            key.sigBytes = keySize * 4;
            return CipherParams.create({ key, iv: iv2, salt });
          }
        };
        var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
          /**
           * Configuration options.
           *
           * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
           */
          cfg: SerializableCipher.cfg.extend({
            kdf: OpenSSLKdf
          }),
          /**
           * Encrypts a message using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {WordArray|string} message The message to encrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {CipherParams} A cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
           *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
           */
          encrypt: function(cipher, message, password, cfg) {
            cfg = this.cfg.extend(cfg);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, cfg.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);
            ciphertext.mixIn(derivedParams);
            return ciphertext;
          },
          /**
           * Decrypts serialized ciphertext using a password.
           *
           * @param {Cipher} cipher The cipher algorithm to use.
           * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
           * @param {string} password The password.
           * @param {Object} cfg (Optional) The configuration options to use for this operation.
           *
           * @return {WordArray} The plaintext.
           *
           * @static
           *
           * @example
           *
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
           *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
           */
          decrypt: function(cipher, ciphertext, password, cfg) {
            cfg = this.cfg.extend(cfg);
            ciphertext = this._parse(ciphertext, cfg.format);
            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt, cfg.hasher);
            cfg.iv = derivedParams.iv;
            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
            return plaintext;
          }
        });
      }();
    });
  })(cipherCore);
  return cipherCore.exports;
}
var modeCfb = { exports: {} };
var hasRequiredModeCfb;
function requireModeCfb() {
  if (hasRequiredModeCfb) return modeCfb.exports;
  hasRequiredModeCfb = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.CFB = function() {
        var CFB = CryptoJS2.lib.BlockCipherMode.extend();
        CFB.Encryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = words.slice(offset, offset + blockSize);
          }
        });
        CFB.Decryptor = CFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var thisBlock = words.slice(offset, offset + blockSize);
            generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);
            this._prevBlock = thisBlock;
          }
        });
        function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
          var keystream;
          var iv2 = this._iv;
          if (iv2) {
            keystream = iv2.slice(0);
            this._iv = void 0;
          } else {
            keystream = this._prevBlock;
          }
          cipher.encryptBlock(keystream, 0);
          for (var i = 0; i < blockSize; i++) {
            words[offset + i] ^= keystream[i];
          }
        }
        return CFB;
      }();
      return CryptoJS2.mode.CFB;
    });
  })(modeCfb);
  return modeCfb.exports;
}
var modeCtr = { exports: {} };
var hasRequiredModeCtr;
function requireModeCtr() {
  if (hasRequiredModeCtr) return modeCtr.exports;
  hasRequiredModeCtr = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.CTR = function() {
        var CTR = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = CTR.Encryptor = CTR.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv2 = this._iv;
            var counter = this._counter;
            if (iv2) {
              counter = this._counter = iv2.slice(0);
              this._iv = void 0;
            }
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTR.Decryptor = Encryptor;
        return CTR;
      }();
      return CryptoJS2.mode.CTR;
    });
  })(modeCtr);
  return modeCtr.exports;
}
var modeCtrGladman = { exports: {} };
var hasRequiredModeCtrGladman;
function requireModeCtrGladman() {
  if (hasRequiredModeCtrGladman) return modeCtrGladman.exports;
  hasRequiredModeCtrGladman = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      /** @preserve
       * Counter block mode compatible with  Dr Brian Gladman fileenc.c
       * derived from CryptoJS.mode.CTR
       * Jan Hruby jhruby.web@gmail.com
       */
      CryptoJS2.mode.CTRGladman = function() {
        var CTRGladman = CryptoJS2.lib.BlockCipherMode.extend();
        function incWord(word) {
          if ((word >> 24 & 255) === 255) {
            var b1 = word >> 16 & 255;
            var b2 = word >> 8 & 255;
            var b3 = word & 255;
            if (b1 === 255) {
              b1 = 0;
              if (b2 === 255) {
                b2 = 0;
                if (b3 === 255) {
                  b3 = 0;
                } else {
                  ++b3;
                }
              } else {
                ++b2;
              }
            } else {
              ++b1;
            }
            word = 0;
            word += b1 << 16;
            word += b2 << 8;
            word += b3;
          } else {
            word += 1 << 24;
          }
          return word;
        }
        function incCounter(counter) {
          if ((counter[0] = incWord(counter[0])) === 0) {
            counter[1] = incWord(counter[1]);
          }
          return counter;
        }
        var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv2 = this._iv;
            var counter = this._counter;
            if (iv2) {
              counter = this._counter = iv2.slice(0);
              this._iv = void 0;
            }
            incCounter(counter);
            var keystream = counter.slice(0);
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        CTRGladman.Decryptor = Encryptor;
        return CTRGladman;
      }();
      return CryptoJS2.mode.CTRGladman;
    });
  })(modeCtrGladman);
  return modeCtrGladman.exports;
}
var modeOfb = { exports: {} };
var hasRequiredModeOfb;
function requireModeOfb() {
  if (hasRequiredModeOfb) return modeOfb.exports;
  hasRequiredModeOfb = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.OFB = function() {
        var OFB = CryptoJS2.lib.BlockCipherMode.extend();
        var Encryptor = OFB.Encryptor = OFB.extend({
          processBlock: function(words, offset) {
            var cipher = this._cipher;
            var blockSize = cipher.blockSize;
            var iv2 = this._iv;
            var keystream = this._keystream;
            if (iv2) {
              keystream = this._keystream = iv2.slice(0);
              this._iv = void 0;
            }
            cipher.encryptBlock(keystream, 0);
            for (var i = 0; i < blockSize; i++) {
              words[offset + i] ^= keystream[i];
            }
          }
        });
        OFB.Decryptor = Encryptor;
        return OFB;
      }();
      return CryptoJS2.mode.OFB;
    });
  })(modeOfb);
  return modeOfb.exports;
}
var modeEcb = { exports: {} };
var hasRequiredModeEcb;
function requireModeEcb() {
  if (hasRequiredModeEcb) return modeEcb.exports;
  hasRequiredModeEcb = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.mode.ECB = function() {
        var ECB = CryptoJS2.lib.BlockCipherMode.extend();
        ECB.Encryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.encryptBlock(words, offset);
          }
        });
        ECB.Decryptor = ECB.extend({
          processBlock: function(words, offset) {
            this._cipher.decryptBlock(words, offset);
          }
        });
        return ECB;
      }();
      return CryptoJS2.mode.ECB;
    });
  })(modeEcb);
  return modeEcb.exports;
}
var padAnsix923 = { exports: {} };
var hasRequiredPadAnsix923;
function requirePadAnsix923() {
  if (hasRequiredPadAnsix923) return padAnsix923.exports;
  hasRequiredPadAnsix923 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.AnsiX923 = {
        pad: function(data2, blockSize) {
          var dataSigBytes = data2.sigBytes;
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;
          var lastBytePos = dataSigBytes + nPaddingBytes - 1;
          data2.clamp();
          data2.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
          data2.sigBytes += nPaddingBytes;
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Ansix923;
    });
  })(padAnsix923);
  return padAnsix923.exports;
}
var padIso10126 = { exports: {} };
var hasRequiredPadIso10126;
function requirePadIso10126() {
  if (hasRequiredPadIso10126) return padIso10126.exports;
  hasRequiredPadIso10126 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.Iso10126 = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          var nPaddingBytes = blockSizeBytes - data2.sigBytes % blockSizeBytes;
          data2.concat(CryptoJS2.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS2.lib.WordArray.create([nPaddingBytes << 24], 1));
        },
        unpad: function(data2) {
          var nPaddingBytes = data2.words[data2.sigBytes - 1 >>> 2] & 255;
          data2.sigBytes -= nPaddingBytes;
        }
      };
      return CryptoJS2.pad.Iso10126;
    });
  })(padIso10126);
  return padIso10126.exports;
}
var padIso97971 = { exports: {} };
var hasRequiredPadIso97971;
function requirePadIso97971() {
  if (hasRequiredPadIso97971) return padIso97971.exports;
  hasRequiredPadIso97971 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.Iso97971 = {
        pad: function(data2, blockSize) {
          data2.concat(CryptoJS2.lib.WordArray.create([2147483648], 1));
          CryptoJS2.pad.ZeroPadding.pad(data2, blockSize);
        },
        unpad: function(data2) {
          CryptoJS2.pad.ZeroPadding.unpad(data2);
          data2.sigBytes--;
        }
      };
      return CryptoJS2.pad.Iso97971;
    });
  })(padIso97971);
  return padIso97971.exports;
}
var padZeropadding = { exports: {} };
var hasRequiredPadZeropadding;
function requirePadZeropadding() {
  if (hasRequiredPadZeropadding) return padZeropadding.exports;
  hasRequiredPadZeropadding = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.ZeroPadding = {
        pad: function(data2, blockSize) {
          var blockSizeBytes = blockSize * 4;
          data2.clamp();
          data2.sigBytes += blockSizeBytes - (data2.sigBytes % blockSizeBytes || blockSizeBytes);
        },
        unpad: function(data2) {
          var dataWords = data2.words;
          var i = data2.sigBytes - 1;
          for (var i = data2.sigBytes - 1; i >= 0; i--) {
            if (dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 255) {
              data2.sigBytes = i + 1;
              break;
            }
          }
        }
      };
      return CryptoJS2.pad.ZeroPadding;
    });
  })(padZeropadding);
  return padZeropadding.exports;
}
var padNopadding = { exports: {} };
var hasRequiredPadNopadding;
function requirePadNopadding() {
  if (hasRequiredPadNopadding) return padNopadding.exports;
  hasRequiredPadNopadding = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      CryptoJS2.pad.NoPadding = {
        pad: function() {
        },
        unpad: function() {
        }
      };
      return CryptoJS2.pad.NoPadding;
    });
  })(padNopadding);
  return padNopadding.exports;
}
var formatHex = { exports: {} };
var hasRequiredFormatHex;
function requireFormatHex() {
  if (hasRequiredFormatHex) return formatHex.exports;
  hasRequiredFormatHex = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function(undefined$1) {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var CipherParams = C_lib.CipherParams;
        var C_enc = C.enc;
        var Hex = C_enc.Hex;
        var C_format = C.format;
        C_format.Hex = {
          /**
           * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
           *
           * @param {CipherParams} cipherParams The cipher params object.
           *
           * @return {string} The hexadecimally encoded string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
           */
          stringify: function(cipherParams) {
            return cipherParams.ciphertext.toString(Hex);
          },
          /**
           * Converts a hexadecimally encoded ciphertext string to a cipher params object.
           *
           * @param {string} input The hexadecimally encoded string.
           *
           * @return {CipherParams} The cipher params object.
           *
           * @static
           *
           * @example
           *
           *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
           */
          parse: function(input) {
            var ciphertext = Hex.parse(input);
            return CipherParams.create({ ciphertext });
          }
        };
      })();
      return CryptoJS2.format.Hex;
    });
  })(formatHex);
  return formatHex.exports;
}
var aes = { exports: {} };
var hasRequiredAes;
function requireAes() {
  if (hasRequiredAes) return aes.exports;
  hasRequiredAes = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher2 = C_lib.BlockCipher;
        var C_algo = C.algo;
        var SBOX = [];
        var INV_SBOX = [];
        var SUB_MIX_0 = [];
        var SUB_MIX_1 = [];
        var SUB_MIX_2 = [];
        var SUB_MIX_3 = [];
        var INV_SUB_MIX_0 = [];
        var INV_SUB_MIX_1 = [];
        var INV_SUB_MIX_2 = [];
        var INV_SUB_MIX_3 = [];
        (function() {
          var d2 = [];
          for (var i = 0; i < 256; i++) {
            if (i < 128) {
              d2[i] = i << 1;
            } else {
              d2[i] = i << 1 ^ 283;
            }
          }
          var x = 0;
          var xi = 0;
          for (var i = 0; i < 256; i++) {
            var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
            sx = sx >>> 8 ^ sx & 255 ^ 99;
            SBOX[x] = sx;
            INV_SBOX[sx] = x;
            var x2 = d2[x];
            var x4 = d2[x2];
            var x8 = d2[x4];
            var t2 = d2[sx] * 257 ^ sx * 16843008;
            SUB_MIX_0[x] = t2 << 24 | t2 >>> 8;
            SUB_MIX_1[x] = t2 << 16 | t2 >>> 16;
            SUB_MIX_2[x] = t2 << 8 | t2 >>> 24;
            SUB_MIX_3[x] = t2;
            var t2 = x8 * 16843009 ^ x4 * 65537 ^ x2 * 257 ^ x * 16843008;
            INV_SUB_MIX_0[sx] = t2 << 24 | t2 >>> 8;
            INV_SUB_MIX_1[sx] = t2 << 16 | t2 >>> 16;
            INV_SUB_MIX_2[sx] = t2 << 8 | t2 >>> 24;
            INV_SUB_MIX_3[sx] = t2;
            if (!x) {
              x = xi = 1;
            } else {
              x = x2 ^ d2[d2[d2[x8 ^ x2]]];
              xi ^= d2[d2[xi]];
            }
          }
        })();
        var RCON = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
        var AES = C_algo.AES = BlockCipher2.extend({
          _doReset: function() {
            var t2;
            if (this._nRounds && this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            var nRounds = this._nRounds = keySize + 6;
            var ksRows = (nRounds + 1) * 4;
            var keySchedule = this._keySchedule = [];
            for (var ksRow = 0; ksRow < ksRows; ksRow++) {
              if (ksRow < keySize) {
                keySchedule[ksRow] = keyWords[ksRow];
              } else {
                t2 = keySchedule[ksRow - 1];
                if (!(ksRow % keySize)) {
                  t2 = t2 << 8 | t2 >>> 24;
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                  t2 ^= RCON[ksRow / keySize | 0] << 24;
                } else if (keySize > 6 && ksRow % keySize == 4) {
                  t2 = SBOX[t2 >>> 24] << 24 | SBOX[t2 >>> 16 & 255] << 16 | SBOX[t2 >>> 8 & 255] << 8 | SBOX[t2 & 255];
                }
                keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t2;
              }
            }
            var invKeySchedule = this._invKeySchedule = [];
            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
              var ksRow = ksRows - invKsRow;
              if (invKsRow % 4) {
                var t2 = keySchedule[ksRow];
              } else {
                var t2 = keySchedule[ksRow - 4];
              }
              if (invKsRow < 4 || ksRow <= 4) {
                invKeySchedule[invKsRow] = t2;
              } else {
                invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t2 >>> 24]] ^ INV_SUB_MIX_1[SBOX[t2 >>> 16 & 255]] ^ INV_SUB_MIX_2[SBOX[t2 >>> 8 & 255]] ^ INV_SUB_MIX_3[SBOX[t2 & 255]];
              }
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
          },
          decryptBlock: function(M2, offset) {
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
            this._doCryptBlock(M2, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);
            var t2 = M2[offset + 1];
            M2[offset + 1] = M2[offset + 3];
            M2[offset + 3] = t2;
          },
          _doCryptBlock: function(M2, offset, keySchedule, SUB_MIX_02, SUB_MIX_12, SUB_MIX_22, SUB_MIX_32, SBOX2) {
            var nRounds = this._nRounds;
            var s0 = M2[offset] ^ keySchedule[0];
            var s1 = M2[offset + 1] ^ keySchedule[1];
            var s2 = M2[offset + 2] ^ keySchedule[2];
            var s3 = M2[offset + 3] ^ keySchedule[3];
            var ksRow = 4;
            for (var round = 1; round < nRounds; round++) {
              var t0 = SUB_MIX_02[s0 >>> 24] ^ SUB_MIX_12[s1 >>> 16 & 255] ^ SUB_MIX_22[s2 >>> 8 & 255] ^ SUB_MIX_32[s3 & 255] ^ keySchedule[ksRow++];
              var t1 = SUB_MIX_02[s1 >>> 24] ^ SUB_MIX_12[s2 >>> 16 & 255] ^ SUB_MIX_22[s3 >>> 8 & 255] ^ SUB_MIX_32[s0 & 255] ^ keySchedule[ksRow++];
              var t2 = SUB_MIX_02[s2 >>> 24] ^ SUB_MIX_12[s3 >>> 16 & 255] ^ SUB_MIX_22[s0 >>> 8 & 255] ^ SUB_MIX_32[s1 & 255] ^ keySchedule[ksRow++];
              var t3 = SUB_MIX_02[s3 >>> 24] ^ SUB_MIX_12[s0 >>> 16 & 255] ^ SUB_MIX_22[s1 >>> 8 & 255] ^ SUB_MIX_32[s2 & 255] ^ keySchedule[ksRow++];
              s0 = t0;
              s1 = t1;
              s2 = t2;
              s3 = t3;
            }
            var t0 = (SBOX2[s0 >>> 24] << 24 | SBOX2[s1 >>> 16 & 255] << 16 | SBOX2[s2 >>> 8 & 255] << 8 | SBOX2[s3 & 255]) ^ keySchedule[ksRow++];
            var t1 = (SBOX2[s1 >>> 24] << 24 | SBOX2[s2 >>> 16 & 255] << 16 | SBOX2[s3 >>> 8 & 255] << 8 | SBOX2[s0 & 255]) ^ keySchedule[ksRow++];
            var t2 = (SBOX2[s2 >>> 24] << 24 | SBOX2[s3 >>> 16 & 255] << 16 | SBOX2[s0 >>> 8 & 255] << 8 | SBOX2[s1 & 255]) ^ keySchedule[ksRow++];
            var t3 = (SBOX2[s3 >>> 24] << 24 | SBOX2[s0 >>> 16 & 255] << 16 | SBOX2[s1 >>> 8 & 255] << 8 | SBOX2[s2 & 255]) ^ keySchedule[ksRow++];
            M2[offset] = t0;
            M2[offset + 1] = t1;
            M2[offset + 2] = t2;
            M2[offset + 3] = t3;
          },
          keySize: 256 / 32
        });
        C.AES = BlockCipher2._createHelper(AES);
      })();
      return CryptoJS2.AES;
    });
  })(aes);
  return aes.exports;
}
var tripledes = { exports: {} };
var hasRequiredTripledes;
function requireTripledes() {
  if (hasRequiredTripledes) return tripledes.exports;
  hasRequiredTripledes = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var BlockCipher2 = C_lib.BlockCipher;
        var C_algo = C.algo;
        var PC1 = [
          57,
          49,
          41,
          33,
          25,
          17,
          9,
          1,
          58,
          50,
          42,
          34,
          26,
          18,
          10,
          2,
          59,
          51,
          43,
          35,
          27,
          19,
          11,
          3,
          60,
          52,
          44,
          36,
          63,
          55,
          47,
          39,
          31,
          23,
          15,
          7,
          62,
          54,
          46,
          38,
          30,
          22,
          14,
          6,
          61,
          53,
          45,
          37,
          29,
          21,
          13,
          5,
          28,
          20,
          12,
          4
        ];
        var PC2 = [
          14,
          17,
          11,
          24,
          1,
          5,
          3,
          28,
          15,
          6,
          21,
          10,
          23,
          19,
          12,
          4,
          26,
          8,
          16,
          7,
          27,
          20,
          13,
          2,
          41,
          52,
          31,
          37,
          47,
          55,
          30,
          40,
          51,
          45,
          33,
          48,
          44,
          49,
          39,
          56,
          34,
          53,
          46,
          42,
          50,
          36,
          29,
          32
        ];
        var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];
        var SBOX_P = [
          {
            0: 8421888,
            268435456: 32768,
            536870912: 8421378,
            805306368: 2,
            1073741824: 512,
            1342177280: 8421890,
            1610612736: 8389122,
            1879048192: 8388608,
            2147483648: 514,
            2415919104: 8389120,
            2684354560: 33280,
            2952790016: 8421376,
            3221225472: 32770,
            3489660928: 8388610,
            3758096384: 0,
            4026531840: 33282,
            134217728: 0,
            402653184: 8421890,
            671088640: 33282,
            939524096: 32768,
            1207959552: 8421888,
            1476395008: 512,
            1744830464: 8421378,
            2013265920: 2,
            2281701376: 8389120,
            2550136832: 33280,
            2818572288: 8421376,
            3087007744: 8389122,
            3355443200: 8388610,
            3623878656: 32770,
            3892314112: 514,
            4160749568: 8388608,
            1: 32768,
            268435457: 2,
            536870913: 8421888,
            805306369: 8388608,
            1073741825: 8421378,
            1342177281: 33280,
            1610612737: 512,
            1879048193: 8389122,
            2147483649: 8421890,
            2415919105: 8421376,
            2684354561: 8388610,
            2952790017: 33282,
            3221225473: 514,
            3489660929: 8389120,
            3758096385: 32770,
            4026531841: 0,
            134217729: 8421890,
            402653185: 8421376,
            671088641: 8388608,
            939524097: 512,
            1207959553: 32768,
            1476395009: 8388610,
            1744830465: 2,
            2013265921: 33282,
            2281701377: 32770,
            2550136833: 8389122,
            2818572289: 514,
            3087007745: 8421888,
            3355443201: 8389120,
            3623878657: 0,
            3892314113: 33280,
            4160749569: 8421378
          },
          {
            0: 1074282512,
            16777216: 16384,
            33554432: 524288,
            50331648: 1074266128,
            67108864: 1073741840,
            83886080: 1074282496,
            100663296: 1073758208,
            117440512: 16,
            134217728: 540672,
            150994944: 1073758224,
            167772160: 1073741824,
            184549376: 540688,
            201326592: 524304,
            218103808: 0,
            234881024: 16400,
            251658240: 1074266112,
            8388608: 1073758208,
            25165824: 540688,
            41943040: 16,
            58720256: 1073758224,
            75497472: 1074282512,
            92274688: 1073741824,
            109051904: 524288,
            125829120: 1074266128,
            142606336: 524304,
            159383552: 0,
            176160768: 16384,
            192937984: 1074266112,
            209715200: 1073741840,
            226492416: 540672,
            243269632: 1074282496,
            260046848: 16400,
            268435456: 0,
            285212672: 1074266128,
            301989888: 1073758224,
            318767104: 1074282496,
            335544320: 1074266112,
            352321536: 16,
            369098752: 540688,
            385875968: 16384,
            402653184: 16400,
            419430400: 524288,
            436207616: 524304,
            452984832: 1073741840,
            469762048: 540672,
            486539264: 1073758208,
            503316480: 1073741824,
            520093696: 1074282512,
            276824064: 540688,
            293601280: 524288,
            310378496: 1074266112,
            327155712: 16384,
            343932928: 1073758208,
            360710144: 1074282512,
            377487360: 16,
            394264576: 1073741824,
            411041792: 1074282496,
            427819008: 1073741840,
            444596224: 1073758224,
            461373440: 524304,
            478150656: 0,
            494927872: 16400,
            511705088: 1074266128,
            528482304: 540672
          },
          {
            0: 260,
            1048576: 0,
            2097152: 67109120,
            3145728: 65796,
            4194304: 65540,
            5242880: 67108868,
            6291456: 67174660,
            7340032: 67174400,
            8388608: 67108864,
            9437184: 67174656,
            10485760: 65792,
            11534336: 67174404,
            12582912: 67109124,
            13631488: 65536,
            14680064: 4,
            15728640: 256,
            524288: 67174656,
            1572864: 67174404,
            2621440: 0,
            3670016: 67109120,
            4718592: 67108868,
            5767168: 65536,
            6815744: 65540,
            7864320: 260,
            8912896: 4,
            9961472: 256,
            11010048: 67174400,
            12058624: 65796,
            13107200: 65792,
            14155776: 67109124,
            15204352: 67174660,
            16252928: 67108864,
            16777216: 67174656,
            17825792: 65540,
            18874368: 65536,
            19922944: 67109120,
            20971520: 256,
            22020096: 67174660,
            23068672: 67108868,
            24117248: 0,
            25165824: 67109124,
            26214400: 67108864,
            27262976: 4,
            28311552: 65792,
            29360128: 67174400,
            30408704: 260,
            31457280: 65796,
            32505856: 67174404,
            17301504: 67108864,
            18350080: 260,
            19398656: 67174656,
            20447232: 0,
            21495808: 65540,
            22544384: 67109120,
            23592960: 256,
            24641536: 67174404,
            25690112: 65536,
            26738688: 67174660,
            27787264: 65796,
            28835840: 67108868,
            29884416: 67109124,
            30932992: 67174400,
            31981568: 4,
            33030144: 65792
          },
          {
            0: 2151682048,
            65536: 2147487808,
            131072: 4198464,
            196608: 2151677952,
            262144: 0,
            327680: 4198400,
            393216: 2147483712,
            458752: 4194368,
            524288: 2147483648,
            589824: 4194304,
            655360: 64,
            720896: 2147487744,
            786432: 2151678016,
            851968: 4160,
            917504: 4096,
            983040: 2151682112,
            32768: 2147487808,
            98304: 64,
            163840: 2151678016,
            229376: 2147487744,
            294912: 4198400,
            360448: 2151682112,
            425984: 0,
            491520: 2151677952,
            557056: 4096,
            622592: 2151682048,
            688128: 4194304,
            753664: 4160,
            819200: 2147483648,
            884736: 4194368,
            950272: 4198464,
            1015808: 2147483712,
            1048576: 4194368,
            1114112: 4198400,
            1179648: 2147483712,
            1245184: 0,
            1310720: 4160,
            1376256: 2151678016,
            1441792: 2151682048,
            1507328: 2147487808,
            1572864: 2151682112,
            1638400: 2147483648,
            1703936: 2151677952,
            1769472: 4198464,
            1835008: 2147487744,
            1900544: 4194304,
            1966080: 64,
            2031616: 4096,
            1081344: 2151677952,
            1146880: 2151682112,
            1212416: 0,
            1277952: 4198400,
            1343488: 4194368,
            1409024: 2147483648,
            1474560: 2147487808,
            1540096: 64,
            1605632: 2147483712,
            1671168: 4096,
            1736704: 2147487744,
            1802240: 2151678016,
            1867776: 4160,
            1933312: 2151682048,
            1998848: 4194304,
            2064384: 4198464
          },
          {
            0: 128,
            4096: 17039360,
            8192: 262144,
            12288: 536870912,
            16384: 537133184,
            20480: 16777344,
            24576: 553648256,
            28672: 262272,
            32768: 16777216,
            36864: 537133056,
            40960: 536871040,
            45056: 553910400,
            49152: 553910272,
            53248: 0,
            57344: 17039488,
            61440: 553648128,
            2048: 17039488,
            6144: 553648256,
            10240: 128,
            14336: 17039360,
            18432: 262144,
            22528: 537133184,
            26624: 553910272,
            30720: 536870912,
            34816: 537133056,
            38912: 0,
            43008: 553910400,
            47104: 16777344,
            51200: 536871040,
            55296: 553648128,
            59392: 16777216,
            63488: 262272,
            65536: 262144,
            69632: 128,
            73728: 536870912,
            77824: 553648256,
            81920: 16777344,
            86016: 553910272,
            90112: 537133184,
            94208: 16777216,
            98304: 553910400,
            102400: 553648128,
            106496: 17039360,
            110592: 537133056,
            114688: 262272,
            118784: 536871040,
            122880: 0,
            126976: 17039488,
            67584: 553648256,
            71680: 16777216,
            75776: 17039360,
            79872: 537133184,
            83968: 536870912,
            88064: 17039488,
            92160: 128,
            96256: 553910272,
            100352: 262272,
            104448: 553910400,
            108544: 0,
            112640: 553648128,
            116736: 16777344,
            120832: 262144,
            124928: 537133056,
            129024: 536871040
          },
          {
            0: 268435464,
            256: 8192,
            512: 270532608,
            768: 270540808,
            1024: 268443648,
            1280: 2097152,
            1536: 2097160,
            1792: 268435456,
            2048: 0,
            2304: 268443656,
            2560: 2105344,
            2816: 8,
            3072: 270532616,
            3328: 2105352,
            3584: 8200,
            3840: 270540800,
            128: 270532608,
            384: 270540808,
            640: 8,
            896: 2097152,
            1152: 2105352,
            1408: 268435464,
            1664: 268443648,
            1920: 8200,
            2176: 2097160,
            2432: 8192,
            2688: 268443656,
            2944: 270532616,
            3200: 0,
            3456: 270540800,
            3712: 2105344,
            3968: 268435456,
            4096: 268443648,
            4352: 270532616,
            4608: 270540808,
            4864: 8200,
            5120: 2097152,
            5376: 268435456,
            5632: 268435464,
            5888: 2105344,
            6144: 2105352,
            6400: 0,
            6656: 8,
            6912: 270532608,
            7168: 8192,
            7424: 268443656,
            7680: 270540800,
            7936: 2097160,
            4224: 8,
            4480: 2105344,
            4736: 2097152,
            4992: 268435464,
            5248: 268443648,
            5504: 8200,
            5760: 270540808,
            6016: 270532608,
            6272: 270540800,
            6528: 270532616,
            6784: 8192,
            7040: 2105352,
            7296: 2097160,
            7552: 0,
            7808: 268435456,
            8064: 268443656
          },
          {
            0: 1048576,
            16: 33555457,
            32: 1024,
            48: 1049601,
            64: 34604033,
            80: 0,
            96: 1,
            112: 34603009,
            128: 33555456,
            144: 1048577,
            160: 33554433,
            176: 34604032,
            192: 34603008,
            208: 1025,
            224: 1049600,
            240: 33554432,
            8: 34603009,
            24: 0,
            40: 33555457,
            56: 34604032,
            72: 1048576,
            88: 33554433,
            104: 33554432,
            120: 1025,
            136: 1049601,
            152: 33555456,
            168: 34603008,
            184: 1048577,
            200: 1024,
            216: 34604033,
            232: 1,
            248: 1049600,
            256: 33554432,
            272: 1048576,
            288: 33555457,
            304: 34603009,
            320: 1048577,
            336: 33555456,
            352: 34604032,
            368: 1049601,
            384: 1025,
            400: 34604033,
            416: 1049600,
            432: 1,
            448: 0,
            464: 34603008,
            480: 33554433,
            496: 1024,
            264: 1049600,
            280: 33555457,
            296: 34603009,
            312: 1,
            328: 33554432,
            344: 1048576,
            360: 1025,
            376: 34604032,
            392: 33554433,
            408: 34603008,
            424: 0,
            440: 34604033,
            456: 1049601,
            472: 1024,
            488: 33555456,
            504: 1048577
          },
          {
            0: 134219808,
            1: 131072,
            2: 134217728,
            3: 32,
            4: 131104,
            5: 134350880,
            6: 134350848,
            7: 2048,
            8: 134348800,
            9: 134219776,
            10: 133120,
            11: 134348832,
            12: 2080,
            13: 0,
            14: 134217760,
            15: 133152,
            2147483648: 2048,
            2147483649: 134350880,
            2147483650: 134219808,
            2147483651: 134217728,
            2147483652: 134348800,
            2147483653: 133120,
            2147483654: 133152,
            2147483655: 32,
            2147483656: 134217760,
            2147483657: 2080,
            2147483658: 131104,
            2147483659: 134350848,
            2147483660: 0,
            2147483661: 134348832,
            2147483662: 134219776,
            2147483663: 131072,
            16: 133152,
            17: 134350848,
            18: 32,
            19: 2048,
            20: 134219776,
            21: 134217760,
            22: 134348832,
            23: 131072,
            24: 0,
            25: 131104,
            26: 134348800,
            27: 134219808,
            28: 134350880,
            29: 133120,
            30: 2080,
            31: 134217728,
            2147483664: 131072,
            2147483665: 2048,
            2147483666: 134348832,
            2147483667: 133152,
            2147483668: 32,
            2147483669: 134348800,
            2147483670: 134217728,
            2147483671: 134219808,
            2147483672: 134350880,
            2147483673: 134217760,
            2147483674: 134219776,
            2147483675: 0,
            2147483676: 133120,
            2147483677: 2080,
            2147483678: 131104,
            2147483679: 134350848
          }
        ];
        var SBOX_MASK = [
          4160749569,
          528482304,
          33030144,
          2064384,
          129024,
          8064,
          504,
          2147483679
        ];
        var DES = C_algo.DES = BlockCipher2.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keyBits = [];
            for (var i = 0; i < 56; i++) {
              var keyBitPos = PC1[i] - 1;
              keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
            }
            var subKeys = this._subKeys = [];
            for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
              var subKey = subKeys[nSubKey] = [];
              var bitShift = BIT_SHIFTS[nSubKey];
              for (var i = 0; i < 24; i++) {
                subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;
                subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
              }
              subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
              for (var i = 1; i < 7; i++) {
                subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
              }
              subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
            }
            var invSubKeys = this._invSubKeys = [];
            for (var i = 0; i < 16; i++) {
              invSubKeys[i] = subKeys[15 - i];
            }
          },
          encryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._subKeys);
          },
          decryptBlock: function(M2, offset) {
            this._doCryptBlock(M2, offset, this._invSubKeys);
          },
          _doCryptBlock: function(M2, offset, subKeys) {
            this._lBlock = M2[offset];
            this._rBlock = M2[offset + 1];
            exchangeLR.call(this, 4, 252645135);
            exchangeLR.call(this, 16, 65535);
            exchangeRL.call(this, 2, 858993459);
            exchangeRL.call(this, 8, 16711935);
            exchangeLR.call(this, 1, 1431655765);
            for (var round = 0; round < 16; round++) {
              var subKey = subKeys[round];
              var lBlock = this._lBlock;
              var rBlock = this._rBlock;
              var f = 0;
              for (var i = 0; i < 8; i++) {
                f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
              }
              this._lBlock = rBlock;
              this._rBlock = lBlock ^ f;
            }
            var t2 = this._lBlock;
            this._lBlock = this._rBlock;
            this._rBlock = t2;
            exchangeLR.call(this, 1, 1431655765);
            exchangeRL.call(this, 8, 16711935);
            exchangeRL.call(this, 2, 858993459);
            exchangeLR.call(this, 16, 65535);
            exchangeLR.call(this, 4, 252645135);
            M2[offset] = this._lBlock;
            M2[offset + 1] = this._rBlock;
          },
          keySize: 64 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        function exchangeLR(offset, mask) {
          var t2 = (this._lBlock >>> offset ^ this._rBlock) & mask;
          this._rBlock ^= t2;
          this._lBlock ^= t2 << offset;
        }
        function exchangeRL(offset, mask) {
          var t2 = (this._rBlock >>> offset ^ this._lBlock) & mask;
          this._lBlock ^= t2;
          this._rBlock ^= t2 << offset;
        }
        C.DES = BlockCipher2._createHelper(DES);
        var TripleDES = C_algo.TripleDES = BlockCipher2.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            if (keyWords.length !== 2 && keyWords.length !== 4 && keyWords.length < 6) {
              throw new Error("Invalid key length - 3DES requires the key length to be 64, 128, 192 or >192.");
            }
            var key1 = keyWords.slice(0, 2);
            var key2 = keyWords.length < 4 ? keyWords.slice(0, 2) : keyWords.slice(2, 4);
            var key3 = keyWords.length < 6 ? keyWords.slice(0, 2) : keyWords.slice(4, 6);
            this._des1 = DES.createEncryptor(WordArray.create(key1));
            this._des2 = DES.createEncryptor(WordArray.create(key2));
            this._des3 = DES.createEncryptor(WordArray.create(key3));
          },
          encryptBlock: function(M2, offset) {
            this._des1.encryptBlock(M2, offset);
            this._des2.decryptBlock(M2, offset);
            this._des3.encryptBlock(M2, offset);
          },
          decryptBlock: function(M2, offset) {
            this._des3.decryptBlock(M2, offset);
            this._des2.encryptBlock(M2, offset);
            this._des1.decryptBlock(M2, offset);
          },
          keySize: 192 / 32,
          ivSize: 64 / 32,
          blockSize: 64 / 32
        });
        C.TripleDES = BlockCipher2._createHelper(TripleDES);
      })();
      return CryptoJS2.TripleDES;
    });
  })(tripledes);
  return tripledes.exports;
}
var rc4 = { exports: {} };
var hasRequiredRc4;
function requireRc4() {
  if (hasRequiredRc4) return rc4.exports;
  hasRequiredRc4 = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var RC4 = C_algo.RC4 = StreamCipher.extend({
          _doReset: function() {
            var key = this._key;
            var keyWords = key.words;
            var keySigBytes = key.sigBytes;
            var S2 = this._S = [];
            for (var i = 0; i < 256; i++) {
              S2[i] = i;
            }
            for (var i = 0, j2 = 0; i < 256; i++) {
              var keyByteIndex = i % keySigBytes;
              var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 255;
              j2 = (j2 + S2[i] + keyByte) % 256;
              var t2 = S2[i];
              S2[i] = S2[j2];
              S2[j2] = t2;
            }
            this._i = this._j = 0;
          },
          _doProcessBlock: function(M2, offset) {
            M2[offset] ^= generateKeystreamWord.call(this);
          },
          keySize: 256 / 32,
          ivSize: 0
        });
        function generateKeystreamWord() {
          var S2 = this._S;
          var i = this._i;
          var j2 = this._j;
          var keystreamWord = 0;
          for (var n = 0; n < 4; n++) {
            i = (i + 1) % 256;
            j2 = (j2 + S2[i]) % 256;
            var t2 = S2[i];
            S2[i] = S2[j2];
            S2[j2] = t2;
            keystreamWord |= S2[(S2[i] + S2[j2]) % 256] << 24 - n * 8;
          }
          this._i = i;
          this._j = j2;
          return keystreamWord;
        }
        C.RC4 = StreamCipher._createHelper(RC4);
        var RC4Drop = C_algo.RC4Drop = RC4.extend({
          /**
           * Configuration options.
           *
           * @property {number} drop The number of keystream words to drop. Default 192
           */
          cfg: RC4.cfg.extend({
            drop: 192
          }),
          _doReset: function() {
            RC4._doReset.call(this);
            for (var i = this.cfg.drop; i > 0; i--) {
              generateKeystreamWord.call(this);
            }
          }
        });
        C.RC4Drop = StreamCipher._createHelper(RC4Drop);
      })();
      return CryptoJS2.RC4;
    });
  })(rc4);
  return rc4.exports;
}
var rabbit = { exports: {} };
var hasRequiredRabbit;
function requireRabbit() {
  if (hasRequiredRabbit) return rabbit.exports;
  hasRequiredRabbit = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G = [];
        var Rabbit = C_algo.Rabbit = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv2 = this.cfg.iv;
            for (var i = 0; i < 4; i++) {
              K[i] = (K[i] << 8 | K[i] >>> 24) & 16711935 | (K[i] << 24 | K[i] >>> 8) & 4278255360;
            }
            var X2 = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X2[i + 4 & 7];
            }
            if (iv2) {
              var IV = iv2.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i = 0; i < 4; i++) {
              S2[i] = (S2[i] << 8 | S2[i] >>> 24) & 16711935 | (S2[i] << 24 | S2[i] >>> 8) & 4278255360;
              M2[offset + i] ^= S2[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X2[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X2[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X2[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X2[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X2[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X2[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X2[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X2[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X2[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.Rabbit = StreamCipher._createHelper(Rabbit);
      })();
      return CryptoJS2.Rabbit;
    });
  })(rabbit);
  return rabbit.exports;
}
var rabbitLegacy = { exports: {} };
var hasRequiredRabbitLegacy;
function requireRabbitLegacy() {
  if (hasRequiredRabbitLegacy) return rabbitLegacy.exports;
  hasRequiredRabbitLegacy = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var StreamCipher = C_lib.StreamCipher;
        var C_algo = C.algo;
        var S2 = [];
        var C_ = [];
        var G = [];
        var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
          _doReset: function() {
            var K = this._key.words;
            var iv2 = this.cfg.iv;
            var X2 = this._X = [
              K[0],
              K[3] << 16 | K[2] >>> 16,
              K[1],
              K[0] << 16 | K[3] >>> 16,
              K[2],
              K[1] << 16 | K[0] >>> 16,
              K[3],
              K[2] << 16 | K[1] >>> 16
            ];
            var C2 = this._C = [
              K[2] << 16 | K[2] >>> 16,
              K[0] & 4294901760 | K[1] & 65535,
              K[3] << 16 | K[3] >>> 16,
              K[1] & 4294901760 | K[2] & 65535,
              K[0] << 16 | K[0] >>> 16,
              K[2] & 4294901760 | K[3] & 65535,
              K[1] << 16 | K[1] >>> 16,
              K[3] & 4294901760 | K[0] & 65535
            ];
            this._b = 0;
            for (var i = 0; i < 4; i++) {
              nextState.call(this);
            }
            for (var i = 0; i < 8; i++) {
              C2[i] ^= X2[i + 4 & 7];
            }
            if (iv2) {
              var IV = iv2.words;
              var IV_0 = IV[0];
              var IV_1 = IV[1];
              var i0 = (IV_0 << 8 | IV_0 >>> 24) & 16711935 | (IV_0 << 24 | IV_0 >>> 8) & 4278255360;
              var i2 = (IV_1 << 8 | IV_1 >>> 24) & 16711935 | (IV_1 << 24 | IV_1 >>> 8) & 4278255360;
              var i1 = i0 >>> 16 | i2 & 4294901760;
              var i3 = i2 << 16 | i0 & 65535;
              C2[0] ^= i0;
              C2[1] ^= i1;
              C2[2] ^= i2;
              C2[3] ^= i3;
              C2[4] ^= i0;
              C2[5] ^= i1;
              C2[6] ^= i2;
              C2[7] ^= i3;
              for (var i = 0; i < 4; i++) {
                nextState.call(this);
              }
            }
          },
          _doProcessBlock: function(M2, offset) {
            var X2 = this._X;
            nextState.call(this);
            S2[0] = X2[0] ^ X2[5] >>> 16 ^ X2[3] << 16;
            S2[1] = X2[2] ^ X2[7] >>> 16 ^ X2[5] << 16;
            S2[2] = X2[4] ^ X2[1] >>> 16 ^ X2[7] << 16;
            S2[3] = X2[6] ^ X2[3] >>> 16 ^ X2[1] << 16;
            for (var i = 0; i < 4; i++) {
              S2[i] = (S2[i] << 8 | S2[i] >>> 24) & 16711935 | (S2[i] << 24 | S2[i] >>> 8) & 4278255360;
              M2[offset + i] ^= S2[i];
            }
          },
          blockSize: 128 / 32,
          ivSize: 64 / 32
        });
        function nextState() {
          var X2 = this._X;
          var C2 = this._C;
          for (var i = 0; i < 8; i++) {
            C_[i] = C2[i];
          }
          C2[0] = C2[0] + 1295307597 + this._b | 0;
          C2[1] = C2[1] + 3545052371 + (C2[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
          C2[2] = C2[2] + 886263092 + (C2[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
          C2[3] = C2[3] + 1295307597 + (C2[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
          C2[4] = C2[4] + 3545052371 + (C2[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
          C2[5] = C2[5] + 886263092 + (C2[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
          C2[6] = C2[6] + 1295307597 + (C2[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
          C2[7] = C2[7] + 3545052371 + (C2[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
          this._b = C2[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;
          for (var i = 0; i < 8; i++) {
            var gx = X2[i] + C2[i];
            var ga = gx & 65535;
            var gb = gx >>> 16;
            var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
            var gl = ((gx & 4294901760) * gx | 0) + ((gx & 65535) * gx | 0);
            G[i] = gh ^ gl;
          }
          X2[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
          X2[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
          X2[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
          X2[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
          X2[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
          X2[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
          X2[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
          X2[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
        }
        C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
      })();
      return CryptoJS2.RabbitLegacy;
    });
  })(rabbitLegacy);
  return rabbitLegacy.exports;
}
var blowfish = { exports: {} };
var hasRequiredBlowfish;
function requireBlowfish() {
  if (hasRequiredBlowfish) return blowfish.exports;
  hasRequiredBlowfish = 1;
  (function(module2, exports) {
    (function(root2, factory, undef) {
      {
        module2.exports = factory(requireCore$1(), requireEncBase64(), requireMd5(), requireEvpkdf(), requireCipherCore());
      }
    })(commonjsGlobal, function(CryptoJS2) {
      (function() {
        var C = CryptoJS2;
        var C_lib = C.lib;
        var BlockCipher2 = C_lib.BlockCipher;
        var C_algo = C.algo;
        const N = 16;
        const ORIG_P = [
          608135816,
          2242054355,
          320440878,
          57701188,
          2752067618,
          698298832,
          137296536,
          3964562569,
          1160258022,
          953160567,
          3193202383,
          887688300,
          3232508343,
          3380367581,
          1065670069,
          3041331479,
          2450970073,
          2306472731
        ];
        const ORIG_S = [
          [
            3509652390,
            2564797868,
            805139163,
            3491422135,
            3101798381,
            1780907670,
            3128725573,
            4046225305,
            614570311,
            3012652279,
            134345442,
            2240740374,
            1667834072,
            1901547113,
            2757295779,
            4103290238,
            227898511,
            1921955416,
            1904987480,
            2182433518,
            2069144605,
            3260701109,
            2620446009,
            720527379,
            3318853667,
            677414384,
            3393288472,
            3101374703,
            2390351024,
            1614419982,
            1822297739,
            2954791486,
            3608508353,
            3174124327,
            2024746970,
            1432378464,
            3864339955,
            2857741204,
            1464375394,
            1676153920,
            1439316330,
            715854006,
            3033291828,
            289532110,
            2706671279,
            2087905683,
            3018724369,
            1668267050,
            732546397,
            1947742710,
            3462151702,
            2609353502,
            2950085171,
            1814351708,
            2050118529,
            680887927,
            999245976,
            1800124847,
            3300911131,
            1713906067,
            1641548236,
            4213287313,
            1216130144,
            1575780402,
            4018429277,
            3917837745,
            3693486850,
            3949271944,
            596196993,
            3549867205,
            258830323,
            2213823033,
            772490370,
            2760122372,
            1774776394,
            2652871518,
            566650946,
            4142492826,
            1728879713,
            2882767088,
            1783734482,
            3629395816,
            2517608232,
            2874225571,
            1861159788,
            326777828,
            3124490320,
            2130389656,
            2716951837,
            967770486,
            1724537150,
            2185432712,
            2364442137,
            1164943284,
            2105845187,
            998989502,
            3765401048,
            2244026483,
            1075463327,
            1455516326,
            1322494562,
            910128902,
            469688178,
            1117454909,
            936433444,
            3490320968,
            3675253459,
            1240580251,
            122909385,
            2157517691,
            634681816,
            4142456567,
            3825094682,
            3061402683,
            2540495037,
            79693498,
            3249098678,
            1084186820,
            1583128258,
            426386531,
            1761308591,
            1047286709,
            322548459,
            995290223,
            1845252383,
            2603652396,
            3431023940,
            2942221577,
            3202600964,
            3727903485,
            1712269319,
            422464435,
            3234572375,
            1170764815,
            3523960633,
            3117677531,
            1434042557,
            442511882,
            3600875718,
            1076654713,
            1738483198,
            4213154764,
            2393238008,
            3677496056,
            1014306527,
            4251020053,
            793779912,
            2902807211,
            842905082,
            4246964064,
            1395751752,
            1040244610,
            2656851899,
            3396308128,
            445077038,
            3742853595,
            3577915638,
            679411651,
            2892444358,
            2354009459,
            1767581616,
            3150600392,
            3791627101,
            3102740896,
            284835224,
            4246832056,
            1258075500,
            768725851,
            2589189241,
            3069724005,
            3532540348,
            1274779536,
            3789419226,
            2764799539,
            1660621633,
            3471099624,
            4011903706,
            913787905,
            3497959166,
            737222580,
            2514213453,
            2928710040,
            3937242737,
            1804850592,
            3499020752,
            2949064160,
            2386320175,
            2390070455,
            2415321851,
            4061277028,
            2290661394,
            2416832540,
            1336762016,
            1754252060,
            3520065937,
            3014181293,
            791618072,
            3188594551,
            3933548030,
            2332172193,
            3852520463,
            3043980520,
            413987798,
            3465142937,
            3030929376,
            4245938359,
            2093235073,
            3534596313,
            375366246,
            2157278981,
            2479649556,
            555357303,
            3870105701,
            2008414854,
            3344188149,
            4221384143,
            3956125452,
            2067696032,
            3594591187,
            2921233993,
            2428461,
            544322398,
            577241275,
            1471733935,
            610547355,
            4027169054,
            1432588573,
            1507829418,
            2025931657,
            3646575487,
            545086370,
            48609733,
            2200306550,
            1653985193,
            298326376,
            1316178497,
            3007786442,
            2064951626,
            458293330,
            2589141269,
            3591329599,
            3164325604,
            727753846,
            2179363840,
            146436021,
            1461446943,
            4069977195,
            705550613,
            3059967265,
            3887724982,
            4281599278,
            3313849956,
            1404054877,
            2845806497,
            146425753,
            1854211946
          ],
          [
            1266315497,
            3048417604,
            3681880366,
            3289982499,
            290971e4,
            1235738493,
            2632868024,
            2414719590,
            3970600049,
            1771706367,
            1449415276,
            3266420449,
            422970021,
            1963543593,
            2690192192,
            3826793022,
            1062508698,
            1531092325,
            1804592342,
            2583117782,
            2714934279,
            4024971509,
            1294809318,
            4028980673,
            1289560198,
            2221992742,
            1669523910,
            35572830,
            157838143,
            1052438473,
            1016535060,
            1802137761,
            1753167236,
            1386275462,
            3080475397,
            2857371447,
            1040679964,
            2145300060,
            2390574316,
            1461121720,
            2956646967,
            4031777805,
            4028374788,
            33600511,
            2920084762,
            1018524850,
            629373528,
            3691585981,
            3515945977,
            2091462646,
            2486323059,
            586499841,
            988145025,
            935516892,
            3367335476,
            2599673255,
            2839830854,
            265290510,
            3972581182,
            2759138881,
            3795373465,
            1005194799,
            847297441,
            406762289,
            1314163512,
            1332590856,
            1866599683,
            4127851711,
            750260880,
            613907577,
            1450815602,
            3165620655,
            3734664991,
            3650291728,
            3012275730,
            3704569646,
            1427272223,
            778793252,
            1343938022,
            2676280711,
            2052605720,
            1946737175,
            3164576444,
            3914038668,
            3967478842,
            3682934266,
            1661551462,
            3294938066,
            4011595847,
            840292616,
            3712170807,
            616741398,
            312560963,
            711312465,
            1351876610,
            322626781,
            1910503582,
            271666773,
            2175563734,
            1594956187,
            70604529,
            3617834859,
            1007753275,
            1495573769,
            4069517037,
            2549218298,
            2663038764,
            504708206,
            2263041392,
            3941167025,
            2249088522,
            1514023603,
            1998579484,
            1312622330,
            694541497,
            2582060303,
            2151582166,
            1382467621,
            776784248,
            2618340202,
            3323268794,
            2497899128,
            2784771155,
            503983604,
            4076293799,
            907881277,
            423175695,
            432175456,
            1378068232,
            4145222326,
            3954048622,
            3938656102,
            3820766613,
            2793130115,
            2977904593,
            26017576,
            3274890735,
            3194772133,
            1700274565,
            1756076034,
            4006520079,
            3677328699,
            720338349,
            1533947780,
            354530856,
            688349552,
            3973924725,
            1637815568,
            332179504,
            3949051286,
            53804574,
            2852348879,
            3044236432,
            1282449977,
            3583942155,
            3416972820,
            4006381244,
            1617046695,
            2628476075,
            3002303598,
            1686838959,
            431878346,
            2686675385,
            1700445008,
            1080580658,
            1009431731,
            832498133,
            3223435511,
            2605976345,
            2271191193,
            2516031870,
            1648197032,
            4164389018,
            2548247927,
            300782431,
            375919233,
            238389289,
            3353747414,
            2531188641,
            2019080857,
            1475708069,
            455242339,
            2609103871,
            448939670,
            3451063019,
            1395535956,
            2413381860,
            1841049896,
            1491858159,
            885456874,
            4264095073,
            4001119347,
            1565136089,
            3898914787,
            1108368660,
            540939232,
            1173283510,
            2745871338,
            3681308437,
            4207628240,
            3343053890,
            4016749493,
            1699691293,
            1103962373,
            3625875870,
            2256883143,
            3830138730,
            1031889488,
            3479347698,
            1535977030,
            4236805024,
            3251091107,
            2132092099,
            1774941330,
            1199868427,
            1452454533,
            157007616,
            2904115357,
            342012276,
            595725824,
            1480756522,
            206960106,
            497939518,
            591360097,
            863170706,
            2375253569,
            3596610801,
            1814182875,
            2094937945,
            3421402208,
            1082520231,
            3463918190,
            2785509508,
            435703966,
            3908032597,
            1641649973,
            2842273706,
            3305899714,
            1510255612,
            2148256476,
            2655287854,
            3276092548,
            4258621189,
            236887753,
            3681803219,
            274041037,
            1734335097,
            3815195456,
            3317970021,
            1899903192,
            1026095262,
            4050517792,
            356393447,
            2410691914,
            3873677099,
            3682840055
          ],
          [
            3913112168,
            2491498743,
            4132185628,
            2489919796,
            1091903735,
            1979897079,
            3170134830,
            3567386728,
            3557303409,
            857797738,
            1136121015,
            1342202287,
            507115054,
            2535736646,
            337727348,
            3213592640,
            1301675037,
            2528481711,
            1895095763,
            1721773893,
            3216771564,
            62756741,
            2142006736,
            835421444,
            2531993523,
            1442658625,
            3659876326,
            2882144922,
            676362277,
            1392781812,
            170690266,
            3921047035,
            1759253602,
            3611846912,
            1745797284,
            664899054,
            1329594018,
            3901205900,
            3045908486,
            2062866102,
            2865634940,
            3543621612,
            3464012697,
            1080764994,
            553557557,
            3656615353,
            3996768171,
            991055499,
            499776247,
            1265440854,
            648242737,
            3940784050,
            980351604,
            3713745714,
            1749149687,
            3396870395,
            4211799374,
            3640570775,
            1161844396,
            3125318951,
            1431517754,
            545492359,
            4268468663,
            3499529547,
            1437099964,
            2702547544,
            3433638243,
            2581715763,
            2787789398,
            1060185593,
            1593081372,
            2418618748,
            4260947970,
            69676912,
            2159744348,
            86519011,
            2512459080,
            3838209314,
            1220612927,
            3339683548,
            133810670,
            1090789135,
            1078426020,
            1569222167,
            845107691,
            3583754449,
            4072456591,
            1091646820,
            628848692,
            1613405280,
            3757631651,
            526609435,
            236106946,
            48312990,
            2942717905,
            3402727701,
            1797494240,
            859738849,
            992217954,
            4005476642,
            2243076622,
            3870952857,
            3732016268,
            765654824,
            3490871365,
            2511836413,
            1685915746,
            3888969200,
            1414112111,
            2273134842,
            3281911079,
            4080962846,
            172450625,
            2569994100,
            980381355,
            4109958455,
            2819808352,
            2716589560,
            2568741196,
            3681446669,
            3329971472,
            1835478071,
            660984891,
            3704678404,
            4045999559,
            3422617507,
            3040415634,
            1762651403,
            1719377915,
            3470491036,
            2693910283,
            3642056355,
            3138596744,
            1364962596,
            2073328063,
            1983633131,
            926494387,
            3423689081,
            2150032023,
            4096667949,
            1749200295,
            3328846651,
            309677260,
            2016342300,
            1779581495,
            3079819751,
            111262694,
            1274766160,
            443224088,
            298511866,
            1025883608,
            3806446537,
            1145181785,
            168956806,
            3641502830,
            3584813610,
            1689216846,
            3666258015,
            3200248200,
            1692713982,
            2646376535,
            4042768518,
            1618508792,
            1610833997,
            3523052358,
            4130873264,
            2001055236,
            3610705100,
            2202168115,
            4028541809,
            2961195399,
            1006657119,
            2006996926,
            3186142756,
            1430667929,
            3210227297,
            1314452623,
            4074634658,
            4101304120,
            2273951170,
            1399257539,
            3367210612,
            3027628629,
            1190975929,
            2062231137,
            2333990788,
            2221543033,
            2438960610,
            1181637006,
            548689776,
            2362791313,
            3372408396,
            3104550113,
            3145860560,
            296247880,
            1970579870,
            3078560182,
            3769228297,
            1714227617,
            3291629107,
            3898220290,
            166772364,
            1251581989,
            493813264,
            448347421,
            195405023,
            2709975567,
            677966185,
            3703036547,
            1463355134,
            2715995803,
            1338867538,
            1343315457,
            2802222074,
            2684532164,
            233230375,
            2599980071,
            2000651841,
            3277868038,
            1638401717,
            4028070440,
            3237316320,
            6314154,
            819756386,
            300326615,
            590932579,
            1405279636,
            3267499572,
            3150704214,
            2428286686,
            3959192993,
            3461946742,
            1862657033,
            1266418056,
            963775037,
            2089974820,
            2263052895,
            1917689273,
            448879540,
            3550394620,
            3981727096,
            150775221,
            3627908307,
            1303187396,
            508620638,
            2975983352,
            2726630617,
            1817252668,
            1876281319,
            1457606340,
            908771278,
            3720792119,
            3617206836,
            2455994898,
            1729034894,
            1080033504
          ],
          [
            976866871,
            3556439503,
            2881648439,
            1522871579,
            1555064734,
            1336096578,
            3548522304,
            2579274686,
            3574697629,
            3205460757,
            3593280638,
            3338716283,
            3079412587,
            564236357,
            2993598910,
            1781952180,
            1464380207,
            3163844217,
            3332601554,
            1699332808,
            1393555694,
            1183702653,
            3581086237,
            1288719814,
            691649499,
            2847557200,
            2895455976,
            3193889540,
            2717570544,
            1781354906,
            1676643554,
            2592534050,
            3230253752,
            1126444790,
            2770207658,
            2633158820,
            2210423226,
            2615765581,
            2414155088,
            3127139286,
            673620729,
            2805611233,
            1269405062,
            4015350505,
            3341807571,
            4149409754,
            1057255273,
            2012875353,
            2162469141,
            2276492801,
            2601117357,
            993977747,
            3918593370,
            2654263191,
            753973209,
            36408145,
            2530585658,
            25011837,
            3520020182,
            2088578344,
            530523599,
            2918365339,
            1524020338,
            1518925132,
            3760827505,
            3759777254,
            1202760957,
            3985898139,
            3906192525,
            674977740,
            4174734889,
            2031300136,
            2019492241,
            3983892565,
            4153806404,
            3822280332,
            352677332,
            2297720250,
            60907813,
            90501309,
            3286998549,
            1016092578,
            2535922412,
            2839152426,
            457141659,
            509813237,
            4120667899,
            652014361,
            1966332200,
            2975202805,
            55981186,
            2327461051,
            676427537,
            3255491064,
            2882294119,
            3433927263,
            1307055953,
            942726286,
            933058658,
            2468411793,
            3933900994,
            4215176142,
            1361170020,
            2001714738,
            2830558078,
            3274259782,
            1222529897,
            1679025792,
            2729314320,
            3714953764,
            1770335741,
            151462246,
            3013232138,
            1682292957,
            1483529935,
            471910574,
            1539241949,
            458788160,
            3436315007,
            1807016891,
            3718408830,
            978976581,
            1043663428,
            3165965781,
            1927990952,
            4200891579,
            2372276910,
            3208408903,
            3533431907,
            1412390302,
            2931980059,
            4132332400,
            1947078029,
            3881505623,
            4168226417,
            2941484381,
            1077988104,
            1320477388,
            886195818,
            18198404,
            3786409e3,
            2509781533,
            112762804,
            3463356488,
            1866414978,
            891333506,
            18488651,
            661792760,
            1628790961,
            3885187036,
            3141171499,
            876946877,
            2693282273,
            1372485963,
            791857591,
            2686433993,
            3759982718,
            3167212022,
            3472953795,
            2716379847,
            445679433,
            3561995674,
            3504004811,
            3574258232,
            54117162,
            3331405415,
            2381918588,
            3769707343,
            4154350007,
            1140177722,
            4074052095,
            668550556,
            3214352940,
            367459370,
            261225585,
            2610173221,
            4209349473,
            3468074219,
            3265815641,
            314222801,
            3066103646,
            3808782860,
            282218597,
            3406013506,
            3773591054,
            379116347,
            1285071038,
            846784868,
            2669647154,
            3771962079,
            3550491691,
            2305946142,
            453669953,
            1268987020,
            3317592352,
            3279303384,
            3744833421,
            2610507566,
            3859509063,
            266596637,
            3847019092,
            517658769,
            3462560207,
            3443424879,
            370717030,
            4247526661,
            2224018117,
            4143653529,
            4112773975,
            2788324899,
            2477274417,
            1456262402,
            2901442914,
            1517677493,
            1846949527,
            2295493580,
            3734397586,
            2176403920,
            1280348187,
            1908823572,
            3871786941,
            846861322,
            1172426758,
            3287448474,
            3383383037,
            1655181056,
            3139813346,
            901632758,
            1897031941,
            2986607138,
            3066810236,
            3447102507,
            1393639104,
            373351379,
            950779232,
            625454576,
            3124240540,
            4148612726,
            2007998917,
            544563296,
            2244738638,
            2330496472,
            2058025392,
            1291430526,
            424198748,
            50039436,
            29584100,
            3605783033,
            2429876329,
            2791104160,
            1057563949,
            3255363231,
            3075367218,
            3463963227,
            1469046755,
            985887462
          ]
        ];
        var BLOWFISH_CTX = {
          pbox: [],
          sbox: []
        };
        function F(ctx, x) {
          let a = x >> 24 & 255;
          let b = x >> 16 & 255;
          let c = x >> 8 & 255;
          let d2 = x & 255;
          let y2 = ctx.sbox[0][a] + ctx.sbox[1][b];
          y2 = y2 ^ ctx.sbox[2][c];
          y2 = y2 + ctx.sbox[3][d2];
          return y2;
        }
        function BlowFish_Encrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = 0; i < N; ++i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[N];
          Xl = Xl ^ ctx.pbox[N + 1];
          return { left: Xl, right: Xr };
        }
        function BlowFish_Decrypt(ctx, left, right) {
          let Xl = left;
          let Xr = right;
          let temp;
          for (let i = N + 1; i > 1; --i) {
            Xl = Xl ^ ctx.pbox[i];
            Xr = F(ctx, Xl) ^ Xr;
            temp = Xl;
            Xl = Xr;
            Xr = temp;
          }
          temp = Xl;
          Xl = Xr;
          Xr = temp;
          Xr = Xr ^ ctx.pbox[1];
          Xl = Xl ^ ctx.pbox[0];
          return { left: Xl, right: Xr };
        }
        function BlowFishInit(ctx, key, keysize) {
          for (let Row = 0; Row < 4; Row++) {
            ctx.sbox[Row] = [];
            for (let Col = 0; Col < 256; Col++) {
              ctx.sbox[Row][Col] = ORIG_S[Row][Col];
            }
          }
          let keyIndex = 0;
          for (let index2 = 0; index2 < N + 2; index2++) {
            ctx.pbox[index2] = ORIG_P[index2] ^ key[keyIndex];
            keyIndex++;
            if (keyIndex >= keysize) {
              keyIndex = 0;
            }
          }
          let Data1 = 0;
          let Data2 = 0;
          let res2 = 0;
          for (let i = 0; i < N + 2; i += 2) {
            res2 = BlowFish_Encrypt(ctx, Data1, Data2);
            Data1 = res2.left;
            Data2 = res2.right;
            ctx.pbox[i] = Data1;
            ctx.pbox[i + 1] = Data2;
          }
          for (let i = 0; i < 4; i++) {
            for (let j2 = 0; j2 < 256; j2 += 2) {
              res2 = BlowFish_Encrypt(ctx, Data1, Data2);
              Data1 = res2.left;
              Data2 = res2.right;
              ctx.sbox[i][j2] = Data1;
              ctx.sbox[i][j2 + 1] = Data2;
            }
          }
          return true;
        }
        var Blowfish = C_algo.Blowfish = BlockCipher2.extend({
          _doReset: function() {
            if (this._keyPriorReset === this._key) {
              return;
            }
            var key = this._keyPriorReset = this._key;
            var keyWords = key.words;
            var keySize = key.sigBytes / 4;
            BlowFishInit(BLOWFISH_CTX, keyWords, keySize);
          },
          encryptBlock: function(M2, offset) {
            var res2 = BlowFish_Encrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
            M2[offset] = res2.left;
            M2[offset + 1] = res2.right;
          },
          decryptBlock: function(M2, offset) {
            var res2 = BlowFish_Decrypt(BLOWFISH_CTX, M2[offset], M2[offset + 1]);
            M2[offset] = res2.left;
            M2[offset + 1] = res2.right;
          },
          blockSize: 64 / 32,
          keySize: 128 / 32,
          ivSize: 64 / 32
        });
        C.Blowfish = BlockCipher2._createHelper(Blowfish);
      })();
      return CryptoJS2.Blowfish;
    });
  })(blowfish);
  return blowfish.exports;
}
(function(module2, exports) {
  (function(root2, factory, undef) {
    {
      module2.exports = factory(requireCore$1(), requireX64Core(), requireLibTypedarrays(), requireEncUtf16(), requireEncBase64(), requireEncBase64url(), requireMd5(), requireSha1(), requireSha256(), requireSha224(), requireSha512(), requireSha384(), requireSha3(), requireRipemd160(), requireHmac(), requirePbkdf2(), requireEvpkdf(), requireCipherCore(), requireModeCfb(), requireModeCtr(), requireModeCtrGladman(), requireModeOfb(), requireModeEcb(), requirePadAnsix923(), requirePadIso10126(), requirePadIso97971(), requirePadZeropadding(), requirePadNopadding(), requireFormatHex(), requireAes(), requireTripledes(), requireRc4(), requireRabbit(), requireRabbitLegacy(), requireBlowfish());
    }
  })(commonjsGlobal, function(CryptoJS2) {
    return CryptoJS2;
  });
})(cryptoJs);
var cryptoJsExports = cryptoJs.exports;
var forge$D = {
  // default options
  options: {
    usePureJavaScript: false
  }
};
var api = {};
var baseN$1 = api;
var _reverseAlphabets = {};
api.encode = function(input, alphabet, maxline) {
  if (typeof alphabet !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  if (maxline !== void 0 && typeof maxline !== "number") {
    throw new TypeError('"maxline" must be a number.');
  }
  var output = "";
  if (!(input instanceof Uint8Array)) {
    output = _encodeWithByteBuffer(input, alphabet);
  } else {
    var i = 0;
    var base = alphabet.length;
    var first2 = alphabet.charAt(0);
    var digits = [0];
    for (i = 0; i < input.length; ++i) {
      for (var j2 = 0, carry = input[i]; j2 < digits.length; ++j2) {
        carry += digits[j2] << 8;
        digits[j2] = carry % base;
        carry = carry / base | 0;
      }
      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    }
    for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
      output += first2;
    }
    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
  }
  if (maxline) {
    var regex = new RegExp(".{1," + maxline + "}", "g");
    output = output.match(regex).join("\r\n");
  }
  return output;
};
api.decode = function(input, alphabet) {
  if (typeof input !== "string") {
    throw new TypeError('"input" must be a string.');
  }
  if (typeof alphabet !== "string") {
    throw new TypeError('"alphabet" must be a string.');
  }
  var table = _reverseAlphabets[alphabet];
  if (!table) {
    table = _reverseAlphabets[alphabet] = [];
    for (var i = 0; i < alphabet.length; ++i) {
      table[alphabet.charCodeAt(i)] = i;
    }
  }
  input = input.replace(/\s/g, "");
  var base = alphabet.length;
  var first2 = alphabet.charAt(0);
  var bytes2 = [0];
  for (var i = 0; i < input.length; i++) {
    var value2 = table[input.charCodeAt(i)];
    if (value2 === void 0) {
      return;
    }
    for (var j2 = 0, carry = value2; j2 < bytes2.length; ++j2) {
      carry += bytes2[j2] * base;
      bytes2[j2] = carry & 255;
      carry >>= 8;
    }
    while (carry > 0) {
      bytes2.push(carry & 255);
      carry >>= 8;
    }
  }
  for (var k = 0; input[k] === first2 && k < input.length - 1; ++k) {
    bytes2.push(0);
  }
  if (typeof Buffer !== "undefined") {
    return Buffer.from(bytes2.reverse());
  }
  return new Uint8Array(bytes2.reverse());
};
function _encodeWithByteBuffer(input, alphabet) {
  var i = 0;
  var base = alphabet.length;
  var first2 = alphabet.charAt(0);
  var digits = [0];
  for (i = 0; i < input.length(); ++i) {
    for (var j2 = 0, carry = input.at(i); j2 < digits.length; ++j2) {
      carry += digits[j2] << 8;
      digits[j2] = carry % base;
      carry = carry / base | 0;
    }
    while (carry > 0) {
      digits.push(carry % base);
      carry = carry / base | 0;
    }
  }
  var output = "";
  for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
    output += first2;
  }
  for (i = digits.length - 1; i >= 0; --i) {
    output += alphabet[digits[i]];
  }
  return output;
}
var forge$C = forge$D;
var baseN = baseN$1;
var util$b = forge$C.util = forge$C.util || {};
(function() {
  if (typeof process !== "undefined" && process.nextTick && !process.browser) {
    util$b.nextTick = process.nextTick;
    if (typeof setImmediate === "function") {
      util$b.setImmediate = setImmediate;
    } else {
      util$b.setImmediate = util$b.nextTick;
    }
    return;
  }
  if (typeof setImmediate === "function") {
    util$b.setImmediate = function() {
      return setImmediate.apply(void 0, arguments);
    };
    util$b.nextTick = function(callback) {
      return setImmediate(callback);
    };
    return;
  }
  util$b.setImmediate = function(callback) {
    setTimeout(callback, 0);
  };
  if (typeof window !== "undefined" && typeof window.postMessage === "function") {
    let handler = function(event) {
      if (event.source === window && event.data === msg) {
        event.stopPropagation();
        var copy2 = callbacks.slice();
        callbacks.length = 0;
        copy2.forEach(function(callback) {
          callback();
        });
      }
    };
    var msg = "forge.setImmediate";
    var callbacks = [];
    util$b.setImmediate = function(callback) {
      callbacks.push(callback);
      if (callbacks.length === 1) {
        window.postMessage(msg, "*");
      }
    };
    window.addEventListener("message", handler, true);
  }
  if (typeof MutationObserver !== "undefined") {
    var now = Date.now();
    var attr = true;
    var div = document.createElement("div");
    var callbacks = [];
    new MutationObserver(function() {
      var copy2 = callbacks.slice();
      callbacks.length = 0;
      copy2.forEach(function(callback) {
        callback();
      });
    }).observe(div, { attributes: true });
    var oldSetImmediate = util$b.setImmediate;
    util$b.setImmediate = function(callback) {
      if (Date.now() - now > 15) {
        now = Date.now();
        oldSetImmediate(callback);
      } else {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          div.setAttribute("a", attr = !attr);
        }
      }
    };
  }
  util$b.nextTick = util$b.setImmediate;
})();
util$b.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
util$b.globalScope = function() {
  if (util$b.isNodejs) {
    return commonjsGlobal;
  }
  return typeof self === "undefined" ? window : self;
}();
util$b.isArray = Array.isArray || function(x) {
  return Object.prototype.toString.call(x) === "[object Array]";
};
util$b.isArrayBuffer = function(x) {
  return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
};
util$b.isArrayBufferView = function(x) {
  return x && util$b.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
};
function _checkBitsParam(n) {
  if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
    throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
  }
}
util$b.ByteBuffer = ByteStringBuffer;
function ByteStringBuffer(b) {
  this.data = "";
  this.read = 0;
  if (typeof b === "string") {
    this.data = b;
  } else if (util$b.isArrayBuffer(b) || util$b.isArrayBufferView(b)) {
    if (typeof Buffer !== "undefined" && b instanceof Buffer) {
      this.data = b.toString("binary");
    } else {
      var arr = new Uint8Array(b);
      try {
        this.data = String.fromCharCode.apply(null, arr);
      } catch (e) {
        for (var i = 0; i < arr.length; ++i) {
          this.putByte(arr[i]);
        }
      }
    }
  } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
    this.data = b.data;
    this.read = b.read;
  }
  this._constructedStringLength = 0;
}
util$b.ByteStringBuffer = ByteStringBuffer;
var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
util$b.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
  this._constructedStringLength += x;
  if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
    this.data.substr(0, 1);
    this._constructedStringLength = 0;
  }
};
util$b.ByteStringBuffer.prototype.length = function() {
  return this.data.length - this.read;
};
util$b.ByteStringBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$b.ByteStringBuffer.prototype.putByte = function(b) {
  return this.putBytes(String.fromCharCode(b));
};
util$b.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
  b = String.fromCharCode(b);
  var d2 = this.data;
  while (n > 0) {
    if (n & 1) {
      d2 += b;
    }
    n >>>= 1;
    if (n > 0) {
      b += b;
    }
  }
  this.data = d2;
  this._optimizeConstructedString(n);
  return this;
};
util$b.ByteStringBuffer.prototype.putBytes = function(bytes2) {
  this.data += bytes2;
  this._optimizeConstructedString(bytes2.length);
  return this;
};
util$b.ByteStringBuffer.prototype.putString = function(str2) {
  return this.putBytes(util$b.encodeUtf8(str2));
};
util$b.ByteStringBuffer.prototype.putInt16 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt24 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt32 = function(i) {
  return this.putBytes(
    String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt16Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt24Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt32Le = function(i) {
  return this.putBytes(
    String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255)
  );
};
util$b.ByteStringBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  var bytes2 = "";
  do {
    n -= 8;
    bytes2 += String.fromCharCode(i >> n & 255);
  } while (n > 0);
  return this.putBytes(bytes2);
};
util$b.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
  if (i < 0) {
    i += 2 << n - 1;
  }
  return this.putInt(i, n);
};
util$b.ByteStringBuffer.prototype.putBuffer = function(buffer) {
  return this.putBytes(buffer.getBytes());
};
util$b.ByteStringBuffer.prototype.getByte = function() {
  return this.data.charCodeAt(this.read++);
};
util$b.ByteStringBuffer.prototype.getInt16 = function() {
  var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
  this.read += 2;
  return rval;
};
util$b.ByteStringBuffer.prototype.getInt24 = function() {
  var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
  this.read += 3;
  return rval;
};
util$b.ByteStringBuffer.prototype.getInt32 = function() {
  var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
  this.read += 4;
  return rval;
};
util$b.ByteStringBuffer.prototype.getInt16Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
  this.read += 2;
  return rval;
};
util$b.ByteStringBuffer.prototype.getInt24Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
  this.read += 3;
  return rval;
};
util$b.ByteStringBuffer.prototype.getInt32Le = function() {
  var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
  this.read += 4;
  return rval;
};
util$b.ByteStringBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.charCodeAt(this.read++);
    n -= 8;
  } while (n > 0);
  return rval;
};
util$b.ByteStringBuffer.prototype.getSignedInt = function(n) {
  var x = this.getInt(n);
  var max2 = 2 << n - 2;
  if (x >= max2) {
    x -= max2 << 1;
  }
  return x;
};
util$b.ByteStringBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$b.ByteStringBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$b.ByteStringBuffer.prototype.at = function(i) {
  return this.data.charCodeAt(this.read + i);
};
util$b.ByteStringBuffer.prototype.setAt = function(i, b) {
  this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
  return this;
};
util$b.ByteStringBuffer.prototype.last = function() {
  return this.data.charCodeAt(this.data.length - 1);
};
util$b.ByteStringBuffer.prototype.copy = function() {
  var c = util$b.createBuffer(this.data);
  c.read = this.read;
  return c;
};
util$b.ByteStringBuffer.prototype.compact = function() {
  if (this.read > 0) {
    this.data = this.data.slice(this.read);
    this.read = 0;
  }
  return this;
};
util$b.ByteStringBuffer.prototype.clear = function() {
  this.data = "";
  this.read = 0;
  return this;
};
util$b.ByteStringBuffer.prototype.truncate = function(count) {
  var len = Math.max(0, this.length() - count);
  this.data = this.data.substr(this.read, len);
  this.read = 0;
  return this;
};
util$b.ByteStringBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i = this.read; i < this.data.length; ++i) {
    var b = this.data.charCodeAt(i);
    if (b < 16) {
      rval += "0";
    }
    rval += b.toString(16);
  }
  return rval;
};
util$b.ByteStringBuffer.prototype.toString = function() {
  return util$b.decodeUtf8(this.bytes());
};
function DataBuffer(b, options) {
  options = options || {};
  this.read = options.readOffset || 0;
  this.growSize = options.growSize || 1024;
  var isArrayBuffer2 = util$b.isArrayBuffer(b);
  var isArrayBufferView2 = util$b.isArrayBufferView(b);
  if (isArrayBuffer2 || isArrayBufferView2) {
    if (isArrayBuffer2) {
      this.data = new DataView(b);
    } else {
      this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
    }
    this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
    return;
  }
  this.data = new DataView(new ArrayBuffer(0));
  this.write = 0;
  if (b !== null && b !== void 0) {
    this.putBytes(b);
  }
  if ("writeOffset" in options) {
    this.write = options.writeOffset;
  }
}
util$b.DataBuffer = DataBuffer;
util$b.DataBuffer.prototype.length = function() {
  return this.write - this.read;
};
util$b.DataBuffer.prototype.isEmpty = function() {
  return this.length() <= 0;
};
util$b.DataBuffer.prototype.accommodate = function(amount, growSize) {
  if (this.length() >= amount) {
    return this;
  }
  growSize = Math.max(growSize || this.growSize, amount);
  var src2 = new Uint8Array(
    this.data.buffer,
    this.data.byteOffset,
    this.data.byteLength
  );
  var dst = new Uint8Array(this.length() + growSize);
  dst.set(src2);
  this.data = new DataView(dst.buffer);
  return this;
};
util$b.DataBuffer.prototype.putByte = function(b) {
  this.accommodate(1);
  this.data.setUint8(this.write++, b);
  return this;
};
util$b.DataBuffer.prototype.fillWithByte = function(b, n) {
  this.accommodate(n);
  for (var i = 0; i < n; ++i) {
    this.data.setUint8(b);
  }
  return this;
};
util$b.DataBuffer.prototype.putBytes = function(bytes2, encoding3) {
  if (util$b.isArrayBufferView(bytes2)) {
    var src2 = new Uint8Array(bytes2.buffer, bytes2.byteOffset, bytes2.byteLength);
    var len = src2.byteLength - src2.byteOffset;
    this.accommodate(len);
    var dst = new Uint8Array(this.data.buffer, this.write);
    dst.set(src2);
    this.write += len;
    return this;
  }
  if (util$b.isArrayBuffer(bytes2)) {
    var src2 = new Uint8Array(bytes2);
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(this.data.buffer);
    dst.set(src2, this.write);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes2 instanceof util$b.DataBuffer || typeof bytes2 === "object" && typeof bytes2.read === "number" && typeof bytes2.write === "number" && util$b.isArrayBufferView(bytes2.data)) {
    var src2 = new Uint8Array(bytes2.data.byteLength, bytes2.read, bytes2.length());
    this.accommodate(src2.byteLength);
    var dst = new Uint8Array(bytes2.data.byteLength, this.write);
    dst.set(src2);
    this.write += src2.byteLength;
    return this;
  }
  if (bytes2 instanceof util$b.ByteStringBuffer) {
    bytes2 = bytes2.data;
    encoding3 = "binary";
  }
  encoding3 = encoding3 || "binary";
  if (typeof bytes2 === "string") {
    var view2;
    if (encoding3 === "hex") {
      this.accommodate(Math.ceil(bytes2.length / 2));
      view2 = new Uint8Array(this.data.buffer, this.write);
      this.write += util$b.binary.hex.decode(bytes2, view2, this.write);
      return this;
    }
    if (encoding3 === "base64") {
      this.accommodate(Math.ceil(bytes2.length / 4) * 3);
      view2 = new Uint8Array(this.data.buffer, this.write);
      this.write += util$b.binary.base64.decode(bytes2, view2, this.write);
      return this;
    }
    if (encoding3 === "utf8") {
      bytes2 = util$b.encodeUtf8(bytes2);
      encoding3 = "binary";
    }
    if (encoding3 === "binary" || encoding3 === "raw") {
      this.accommodate(bytes2.length);
      view2 = new Uint8Array(this.data.buffer, this.write);
      this.write += util$b.binary.raw.decode(view2);
      return this;
    }
    if (encoding3 === "utf16") {
      this.accommodate(bytes2.length * 2);
      view2 = new Uint16Array(this.data.buffer, this.write);
      this.write += util$b.text.utf16.encode(view2);
      return this;
    }
    throw new Error("Invalid encoding: " + encoding3);
  }
  throw Error("Invalid parameter: " + bytes2);
};
util$b.DataBuffer.prototype.putBuffer = function(buffer) {
  this.putBytes(buffer);
  buffer.clear();
  return this;
};
util$b.DataBuffer.prototype.putString = function(str2) {
  return this.putBytes(str2, "utf16");
};
util$b.DataBuffer.prototype.putInt16 = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i);
  this.write += 2;
  return this;
};
util$b.DataBuffer.prototype.putInt24 = function(i) {
  this.accommodate(3);
  this.data.setInt16(this.write, i >> 8 & 65535);
  this.data.setInt8(this.write, i >> 16 & 255);
  this.write += 3;
  return this;
};
util$b.DataBuffer.prototype.putInt32 = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i);
  this.write += 4;
  return this;
};
util$b.DataBuffer.prototype.putInt16Le = function(i) {
  this.accommodate(2);
  this.data.setInt16(this.write, i, true);
  this.write += 2;
  return this;
};
util$b.DataBuffer.prototype.putInt24Le = function(i) {
  this.accommodate(3);
  this.data.setInt8(this.write, i >> 16 & 255);
  this.data.setInt16(this.write, i >> 8 & 65535, true);
  this.write += 3;
  return this;
};
util$b.DataBuffer.prototype.putInt32Le = function(i) {
  this.accommodate(4);
  this.data.setInt32(this.write, i, true);
  this.write += 4;
  return this;
};
util$b.DataBuffer.prototype.putInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  do {
    n -= 8;
    this.data.setInt8(this.write++, i >> n & 255);
  } while (n > 0);
  return this;
};
util$b.DataBuffer.prototype.putSignedInt = function(i, n) {
  _checkBitsParam(n);
  this.accommodate(n / 8);
  if (i < 0) {
    i += 2 << n - 1;
  }
  return this.putInt(i, n);
};
util$b.DataBuffer.prototype.getByte = function() {
  return this.data.getInt8(this.read++);
};
util$b.DataBuffer.prototype.getInt16 = function() {
  var rval = this.data.getInt16(this.read);
  this.read += 2;
  return rval;
};
util$b.DataBuffer.prototype.getInt24 = function() {
  var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
  this.read += 3;
  return rval;
};
util$b.DataBuffer.prototype.getInt32 = function() {
  var rval = this.data.getInt32(this.read);
  this.read += 4;
  return rval;
};
util$b.DataBuffer.prototype.getInt16Le = function() {
  var rval = this.data.getInt16(this.read, true);
  this.read += 2;
  return rval;
};
util$b.DataBuffer.prototype.getInt24Le = function() {
  var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
  this.read += 3;
  return rval;
};
util$b.DataBuffer.prototype.getInt32Le = function() {
  var rval = this.data.getInt32(this.read, true);
  this.read += 4;
  return rval;
};
util$b.DataBuffer.prototype.getInt = function(n) {
  _checkBitsParam(n);
  var rval = 0;
  do {
    rval = (rval << 8) + this.data.getInt8(this.read++);
    n -= 8;
  } while (n > 0);
  return rval;
};
util$b.DataBuffer.prototype.getSignedInt = function(n) {
  var x = this.getInt(n);
  var max2 = 2 << n - 2;
  if (x >= max2) {
    x -= max2 << 1;
  }
  return x;
};
util$b.DataBuffer.prototype.getBytes = function(count) {
  var rval;
  if (count) {
    count = Math.min(this.length(), count);
    rval = this.data.slice(this.read, this.read + count);
    this.read += count;
  } else if (count === 0) {
    rval = "";
  } else {
    rval = this.read === 0 ? this.data : this.data.slice(this.read);
    this.clear();
  }
  return rval;
};
util$b.DataBuffer.prototype.bytes = function(count) {
  return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
};
util$b.DataBuffer.prototype.at = function(i) {
  return this.data.getUint8(this.read + i);
};
util$b.DataBuffer.prototype.setAt = function(i, b) {
  this.data.setUint8(i, b);
  return this;
};
util$b.DataBuffer.prototype.last = function() {
  return this.data.getUint8(this.write - 1);
};
util$b.DataBuffer.prototype.copy = function() {
  return new util$b.DataBuffer(this);
};
util$b.DataBuffer.prototype.compact = function() {
  if (this.read > 0) {
    var src2 = new Uint8Array(this.data.buffer, this.read);
    var dst = new Uint8Array(src2.byteLength);
    dst.set(src2);
    this.data = new DataView(dst);
    this.write -= this.read;
    this.read = 0;
  }
  return this;
};
util$b.DataBuffer.prototype.clear = function() {
  this.data = new DataView(new ArrayBuffer(0));
  this.read = this.write = 0;
  return this;
};
util$b.DataBuffer.prototype.truncate = function(count) {
  this.write = Math.max(0, this.length() - count);
  this.read = Math.min(this.read, this.write);
  return this;
};
util$b.DataBuffer.prototype.toHex = function() {
  var rval = "";
  for (var i = this.read; i < this.data.byteLength; ++i) {
    var b = this.data.getUint8(i);
    if (b < 16) {
      rval += "0";
    }
    rval += b.toString(16);
  }
  return rval;
};
util$b.DataBuffer.prototype.toString = function(encoding3) {
  var view2 = new Uint8Array(this.data, this.read, this.length());
  encoding3 = encoding3 || "utf8";
  if (encoding3 === "binary" || encoding3 === "raw") {
    return util$b.binary.raw.encode(view2);
  }
  if (encoding3 === "hex") {
    return util$b.binary.hex.encode(view2);
  }
  if (encoding3 === "base64") {
    return util$b.binary.base64.encode(view2);
  }
  if (encoding3 === "utf8") {
    return util$b.text.utf8.decode(view2);
  }
  if (encoding3 === "utf16") {
    return util$b.text.utf16.decode(view2);
  }
  throw new Error("Invalid encoding: " + encoding3);
};
util$b.createBuffer = function(input, encoding3) {
  encoding3 = encoding3 || "raw";
  if (input !== void 0 && encoding3 === "utf8") {
    input = util$b.encodeUtf8(input);
  }
  return new util$b.ByteBuffer(input);
};
util$b.fillString = function(c, n) {
  var s2 = "";
  while (n > 0) {
    if (n & 1) {
      s2 += c;
    }
    n >>>= 1;
    if (n > 0) {
      c += c;
    }
  }
  return s2;
};
util$b.xorBytes = function(s1, s2, n) {
  var s3 = "";
  var b = "";
  var t2 = "";
  var i = 0;
  var c = 0;
  for (; n > 0; --n, ++i) {
    b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
    if (c >= 10) {
      s3 += t2;
      t2 = "";
      c = 0;
    }
    t2 += String.fromCharCode(b);
    ++c;
  }
  s3 += t2;
  return s3;
};
util$b.hexToBytes = function(hex) {
  var rval = "";
  var i = 0;
  if (hex.length & true) {
    i = 1;
    rval += String.fromCharCode(parseInt(hex[0], 16));
  }
  for (; i < hex.length; i += 2) {
    rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  }
  return rval;
};
util$b.bytesToHex = function(bytes2) {
  return util$b.createBuffer(bytes2).toHex();
};
util$b.int32ToBytes = function(i) {
  return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
};
var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var _base64Idx = [
  /*43 -43 = 0*/
  /*'+',  1,  2,  3,'/' */
  62,
  -1,
  -1,
  -1,
  63,
  /*'0','1','2','3','4','5','6','7','8','9' */
  52,
  53,
  54,
  55,
  56,
  57,
  58,
  59,
  60,
  61,
  /*15, 16, 17,'=', 19, 20, 21 */
  -1,
  -1,
  -1,
  64,
  -1,
  -1,
  -1,
  /*65 - 43 = 22*/
  /*'A','B','C','D','E','F','G','H','I','J','K','L','M', */
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  /*'N','O','P','Q','R','S','T','U','V','W','X','Y','Z' */
  13,
  14,
  15,
  16,
  17,
  18,
  19,
  20,
  21,
  22,
  23,
  24,
  25,
  /*91 - 43 = 48 */
  /*48, 49, 50, 51, 52, 53 */
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  /*97 - 43 = 54*/
  /*'a','b','c','d','e','f','g','h','i','j','k','l','m' */
  26,
  27,
  28,
  29,
  30,
  31,
  32,
  33,
  34,
  35,
  36,
  37,
  38,
  /*'n','o','p','q','r','s','t','u','v','w','x','y','z' */
  39,
  40,
  41,
  42,
  43,
  44,
  45,
  46,
  47,
  48,
  49,
  50,
  51
];
var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
util$b.encode64 = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i = 0;
  while (i < input.length) {
    chr1 = input.charCodeAt(i++);
    chr2 = input.charCodeAt(i++);
    chr3 = input.charCodeAt(i++);
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$b.decode64 = function(input) {
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  var output = "";
  var enc1, enc2, enc3, enc4;
  var i = 0;
  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
    if (enc3 !== 64) {
      output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
      if (enc4 !== 64) {
        output += String.fromCharCode((enc3 & 3) << 6 | enc4);
      }
    }
  }
  return output;
};
util$b.encodeUtf8 = function(str2) {
  return unescape(encodeURIComponent(str2));
};
util$b.decodeUtf8 = function(str2) {
  return decodeURIComponent(escape(str2));
};
util$b.binary = {
  raw: {},
  hex: {},
  base64: {},
  base58: {},
  baseN: {
    encode: baseN.encode,
    decode: baseN.decode
  }
};
util$b.binary.raw.encode = function(bytes2) {
  return String.fromCharCode.apply(null, bytes2);
};
util$b.binary.raw.decode = function(str2, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str2.length);
  }
  offset = offset || 0;
  var j2 = offset;
  for (var i = 0; i < str2.length; ++i) {
    out[j2++] = str2.charCodeAt(i);
  }
  return output ? j2 - offset : out;
};
util$b.binary.hex.encode = util$b.bytesToHex;
util$b.binary.hex.decode = function(hex, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(hex.length / 2));
  }
  offset = offset || 0;
  var i = 0, j2 = offset;
  if (hex.length & 1) {
    i = 1;
    out[j2++] = parseInt(hex[0], 16);
  }
  for (; i < hex.length; i += 2) {
    out[j2++] = parseInt(hex.substr(i, 2), 16);
  }
  return output ? j2 - offset : out;
};
util$b.binary.base64.encode = function(input, maxline) {
  var line = "";
  var output = "";
  var chr1, chr2, chr3;
  var i = 0;
  while (i < input.byteLength) {
    chr1 = input[i++];
    chr2 = input[i++];
    chr3 = input[i++];
    line += _base64.charAt(chr1 >> 2);
    line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
    if (isNaN(chr2)) {
      line += "==";
    } else {
      line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
      line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
    }
    if (maxline && line.length > maxline) {
      output += line.substr(0, maxline) + "\r\n";
      line = line.substr(maxline);
    }
  }
  output += line;
  return output;
};
util$b.binary.base64.decode = function(input, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(Math.ceil(input.length / 4) * 3);
  }
  input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
  offset = offset || 0;
  var enc1, enc2, enc3, enc4;
  var i = 0, j2 = offset;
  while (i < input.length) {
    enc1 = _base64Idx[input.charCodeAt(i++) - 43];
    enc2 = _base64Idx[input.charCodeAt(i++) - 43];
    enc3 = _base64Idx[input.charCodeAt(i++) - 43];
    enc4 = _base64Idx[input.charCodeAt(i++) - 43];
    out[j2++] = enc1 << 2 | enc2 >> 4;
    if (enc3 !== 64) {
      out[j2++] = (enc2 & 15) << 4 | enc3 >> 2;
      if (enc4 !== 64) {
        out[j2++] = (enc3 & 3) << 6 | enc4;
      }
    }
  }
  return output ? j2 - offset : out.subarray(0, j2);
};
util$b.binary.base58.encode = function(input, maxline) {
  return util$b.binary.baseN.encode(input, _base58, maxline);
};
util$b.binary.base58.decode = function(input, maxline) {
  return util$b.binary.baseN.decode(input, _base58, maxline);
};
util$b.text = {
  utf8: {},
  utf16: {}
};
util$b.text.utf8.encode = function(str2, output, offset) {
  str2 = util$b.encodeUtf8(str2);
  var out = output;
  if (!out) {
    out = new Uint8Array(str2.length);
  }
  offset = offset || 0;
  var j2 = offset;
  for (var i = 0; i < str2.length; ++i) {
    out[j2++] = str2.charCodeAt(i);
  }
  return output ? j2 - offset : out;
};
util$b.text.utf8.decode = function(bytes2) {
  return util$b.decodeUtf8(String.fromCharCode.apply(null, bytes2));
};
util$b.text.utf16.encode = function(str2, output, offset) {
  var out = output;
  if (!out) {
    out = new Uint8Array(str2.length * 2);
  }
  var view2 = new Uint16Array(out.buffer);
  offset = offset || 0;
  var j2 = offset;
  var k = offset;
  for (var i = 0; i < str2.length; ++i) {
    view2[k++] = str2.charCodeAt(i);
    j2 += 2;
  }
  return output ? j2 - offset : out;
};
util$b.text.utf16.decode = function(bytes2) {
  return String.fromCharCode.apply(null, new Uint16Array(bytes2.buffer));
};
util$b.deflate = function(api2, bytes2, raw) {
  bytes2 = util$b.decode64(api2.deflate(util$b.encode64(bytes2)).rval);
  if (raw) {
    var start = 2;
    var flg = bytes2.charCodeAt(1);
    if (flg & 32) {
      start = 6;
    }
    bytes2 = bytes2.substring(start, bytes2.length - 4);
  }
  return bytes2;
};
util$b.inflate = function(api2, bytes2, raw) {
  var rval = api2.inflate(util$b.encode64(bytes2)).rval;
  return rval === null ? null : util$b.decode64(rval);
};
var _setStorageObject = function(api2, id, obj) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval;
  if (obj === null) {
    rval = api2.removeItem(id);
  } else {
    obj = util$b.encode64(JSON.stringify(obj));
    rval = api2.setItem(id, obj);
  }
  if (typeof rval !== "undefined" && rval.rval !== true) {
    var error2 = new Error(rval.error.message);
    error2.id = rval.error.id;
    error2.name = rval.error.name;
    throw error2;
  }
};
var _getStorageObject = function(api2, id) {
  if (!api2) {
    throw new Error("WebStorage not available.");
  }
  var rval = api2.getItem(id);
  if (api2.init) {
    if (rval.rval === null) {
      if (rval.error) {
        var error2 = new Error(rval.error.message);
        error2.id = rval.error.id;
        error2.name = rval.error.name;
        throw error2;
      }
      rval = null;
    } else {
      rval = rval.rval;
    }
  }
  if (rval !== null) {
    rval = JSON.parse(util$b.decode64(rval));
  }
  return rval;
};
var _setItem = function(api2, id, key, data2) {
  var obj = _getStorageObject(api2, id);
  if (obj === null) {
    obj = {};
  }
  obj[key] = data2;
  _setStorageObject(api2, id, obj);
};
var _getItem = function(api2, id, key) {
  var rval = _getStorageObject(api2, id);
  if (rval !== null) {
    rval = key in rval ? rval[key] : null;
  }
  return rval;
};
var _removeItem = function(api2, id, key) {
  var obj = _getStorageObject(api2, id);
  if (obj !== null && key in obj) {
    delete obj[key];
    var empty2 = true;
    for (var prop in obj) {
      empty2 = false;
      break;
    }
    if (empty2) {
      obj = null;
    }
    _setStorageObject(api2, id, obj);
  }
};
var _clearItems = function(api2, id) {
  _setStorageObject(api2, id, null);
};
var _callStorageFunction = function(func, args, location2) {
  var rval = null;
  if (typeof location2 === "undefined") {
    location2 = ["web", "flash"];
  }
  var type3;
  var done = false;
  var exception = null;
  for (var idx in location2) {
    type3 = location2[idx];
    try {
      if (type3 === "flash" || type3 === "both") {
        if (args[0] === null) {
          throw new Error("Flash local storage not available.");
        }
        rval = func.apply(this, args);
        done = type3 === "flash";
      }
      if (type3 === "web" || type3 === "both") {
        args[0] = localStorage;
        rval = func.apply(this, args);
        done = true;
      }
    } catch (ex) {
      exception = ex;
    }
    if (done) {
      break;
    }
  }
  if (!done) {
    throw exception;
  }
  return rval;
};
util$b.setItem = function(api2, id, key, data2, location2) {
  _callStorageFunction(_setItem, arguments, location2);
};
util$b.getItem = function(api2, id, key, location2) {
  return _callStorageFunction(_getItem, arguments, location2);
};
util$b.removeItem = function(api2, id, key, location2) {
  _callStorageFunction(_removeItem, arguments, location2);
};
util$b.clearItems = function(api2, id, location2) {
  _callStorageFunction(_clearItems, arguments, location2);
};
util$b.isEmpty = function(obj) {
  for (var prop in obj) {
    if (obj.hasOwnProperty(prop)) {
      return false;
    }
  }
  return true;
};
util$b.format = function(format2) {
  var re = /%./g;
  var match2;
  var part;
  var argi = 0;
  var parts = [];
  var last = 0;
  while (match2 = re.exec(format2)) {
    part = format2.substring(last, re.lastIndex - 2);
    if (part.length > 0) {
      parts.push(part);
    }
    last = re.lastIndex;
    var code2 = match2[0][1];
    switch (code2) {
      case "s":
      case "o":
        if (argi < arguments.length) {
          parts.push(arguments[argi++ + 1]);
        } else {
          parts.push("<?>");
        }
        break;
      case "%":
        parts.push("%");
        break;
      default:
        parts.push("<%" + code2 + "?>");
    }
  }
  parts.push(format2.substring(last));
  return parts.join("");
};
util$b.formatNumber = function(number, decimals, dec_point, thousands_sep) {
  var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
  var d2 = dec_point === void 0 ? "," : dec_point;
  var t2 = thousands_sep === void 0 ? "." : thousands_sep, s2 = n < 0 ? "-" : "";
  var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
  var j2 = i.length > 3 ? i.length % 3 : 0;
  return s2 + (j2 ? i.substr(0, j2) + t2 : "") + i.substr(j2).replace(/(\d{3})(?=\d)/g, "$1" + t2) + (c ? d2 + Math.abs(n - i).toFixed(c).slice(2) : "");
};
util$b.formatSize = function(size) {
  if (size >= 1073741824) {
    size = util$b.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
  } else if (size >= 1048576) {
    size = util$b.formatNumber(size / 1048576, 2, ".", "") + " MiB";
  } else if (size >= 1024) {
    size = util$b.formatNumber(size / 1024, 0) + " KiB";
  } else {
    size = util$b.formatNumber(size, 0) + " bytes";
  }
  return size;
};
util$b.bytesFromIP = function(ip3) {
  if (ip3.indexOf(".") !== -1) {
    return util$b.bytesFromIPv4(ip3);
  }
  if (ip3.indexOf(":") !== -1) {
    return util$b.bytesFromIPv6(ip3);
  }
  return null;
};
util$b.bytesFromIPv4 = function(ip3) {
  ip3 = ip3.split(".");
  if (ip3.length !== 4) {
    return null;
  }
  var b = util$b.createBuffer();
  for (var i = 0; i < ip3.length; ++i) {
    var num = parseInt(ip3[i], 10);
    if (isNaN(num)) {
      return null;
    }
    b.putByte(num);
  }
  return b.getBytes();
};
util$b.bytesFromIPv6 = function(ip3) {
  var blanks = 0;
  ip3 = ip3.split(":").filter(function(e) {
    if (e.length === 0) ++blanks;
    return true;
  });
  var zeros = (8 - ip3.length + blanks) * 2;
  var b = util$b.createBuffer();
  for (var i = 0; i < 8; ++i) {
    if (!ip3[i] || ip3[i].length === 0) {
      b.fillWithByte(0, zeros);
      zeros = 0;
      continue;
    }
    var bytes2 = util$b.hexToBytes(ip3[i]);
    if (bytes2.length < 2) {
      b.putByte(0);
    }
    b.putBytes(bytes2);
  }
  return b.getBytes();
};
util$b.bytesToIP = function(bytes2) {
  if (bytes2.length === 4) {
    return util$b.bytesToIPv4(bytes2);
  }
  if (bytes2.length === 16) {
    return util$b.bytesToIPv6(bytes2);
  }
  return null;
};
util$b.bytesToIPv4 = function(bytes2) {
  if (bytes2.length !== 4) {
    return null;
  }
  var ip3 = [];
  for (var i = 0; i < bytes2.length; ++i) {
    ip3.push(bytes2.charCodeAt(i));
  }
  return ip3.join(".");
};
util$b.bytesToIPv6 = function(bytes2) {
  if (bytes2.length !== 16) {
    return null;
  }
  var ip3 = [];
  var zeroGroups = [];
  var zeroMaxGroup = 0;
  for (var i = 0; i < bytes2.length; i += 2) {
    var hex = util$b.bytesToHex(bytes2[i] + bytes2[i + 1]);
    while (hex[0] === "0" && hex !== "0") {
      hex = hex.substr(1);
    }
    if (hex === "0") {
      var last = zeroGroups[zeroGroups.length - 1];
      var idx = ip3.length;
      if (!last || idx !== last.end + 1) {
        zeroGroups.push({ start: idx, end: idx });
      } else {
        last.end = idx;
        if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
          zeroMaxGroup = zeroGroups.length - 1;
        }
      }
    }
    ip3.push(hex);
  }
  if (zeroGroups.length > 0) {
    var group = zeroGroups[zeroMaxGroup];
    if (group.end - group.start > 0) {
      ip3.splice(group.start, group.end - group.start + 1, "");
      if (group.start === 0) {
        ip3.unshift("");
      }
      if (group.end === 7) {
        ip3.push("");
      }
    }
  }
  return ip3.join(":");
};
util$b.estimateCores = function(options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  if ("cores" in util$b && !options.update) {
    return callback(null, util$b.cores);
  }
  if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
    util$b.cores = navigator.hardwareConcurrency;
    return callback(null, util$b.cores);
  }
  if (typeof Worker === "undefined") {
    util$b.cores = 1;
    return callback(null, util$b.cores);
  }
  if (typeof Blob === "undefined") {
    util$b.cores = 2;
    return callback(null, util$b.cores);
  }
  var blobUrl = URL.createObjectURL(new Blob([
    "(",
    (function() {
      self.addEventListener("message", function(e) {
        var st = Date.now();
        var et = st + 4;
        self.postMessage({ st, et });
      });
    }).toString(),
    ")()"
  ], { type: "application/javascript" }));
  sample([], 5, 16);
  function sample(max2, samples, numWorkers) {
    if (samples === 0) {
      var avg = Math.floor(max2.reduce(function(avg2, x) {
        return avg2 + x;
      }, 0) / max2.length);
      util$b.cores = Math.max(1, avg);
      URL.revokeObjectURL(blobUrl);
      return callback(null, util$b.cores);
    }
    map2(numWorkers, function(err, results) {
      max2.push(reduce2(numWorkers, results));
      sample(max2, samples - 1, numWorkers);
    });
  }
  function map2(numWorkers, callback2) {
    var workers = [];
    var results = [];
    for (var i = 0; i < numWorkers; ++i) {
      var worker = new Worker(blobUrl);
      worker.addEventListener("message", function(e) {
        results.push(e.data);
        if (results.length === numWorkers) {
          for (var i2 = 0; i2 < numWorkers; ++i2) {
            workers[i2].terminate();
          }
          callback2(null, results);
        }
      });
      workers.push(worker);
    }
    for (var i = 0; i < numWorkers; ++i) {
      workers[i].postMessage(i);
    }
  }
  function reduce2(numWorkers, results) {
    var overlaps = [];
    for (var n = 0; n < numWorkers; ++n) {
      var r1 = results[n];
      var overlap = overlaps[n] = [];
      for (var i = 0; i < numWorkers; ++i) {
        if (n === i) {
          continue;
        }
        var r2 = results[i];
        if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
          overlap.push(i);
        }
      }
    }
    return overlaps.reduce(function(max2, overlap2) {
      return Math.max(max2, overlap2.length);
    }, 0);
  }
};
var forge$B = forge$D;
forge$B.cipher = forge$B.cipher || {};
forge$B.cipher.algorithms = forge$B.cipher.algorithms || {};
forge$B.cipher.createCipher = function(algorithm, key) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$B.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$B.cipher.BlockCipher({
    algorithm: api2,
    key,
    decrypt: false
  });
};
forge$B.cipher.createDecipher = function(algorithm, key) {
  var api2 = algorithm;
  if (typeof api2 === "string") {
    api2 = forge$B.cipher.getAlgorithm(api2);
    if (api2) {
      api2 = api2();
    }
  }
  if (!api2) {
    throw new Error("Unsupported algorithm: " + algorithm);
  }
  return new forge$B.cipher.BlockCipher({
    algorithm: api2,
    key,
    decrypt: true
  });
};
forge$B.cipher.registerAlgorithm = function(name2, algorithm) {
  name2 = name2.toUpperCase();
  forge$B.cipher.algorithms[name2] = algorithm;
};
forge$B.cipher.getAlgorithm = function(name2) {
  name2 = name2.toUpperCase();
  if (name2 in forge$B.cipher.algorithms) {
    return forge$B.cipher.algorithms[name2];
  }
  return null;
};
var BlockCipher = forge$B.cipher.BlockCipher = function(options) {
  this.algorithm = options.algorithm;
  this.mode = this.algorithm.mode;
  this.blockSize = this.mode.blockSize;
  this._finish = false;
  this._input = null;
  this.output = null;
  this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
  this._decrypt = options.decrypt;
  this.algorithm.initialize(options);
};
BlockCipher.prototype.start = function(options) {
  options = options || {};
  var opts = {};
  for (var key in options) {
    opts[key] = options[key];
  }
  opts.decrypt = this._decrypt;
  this._finish = false;
  this._input = forge$B.util.createBuffer();
  this.output = options.output || forge$B.util.createBuffer();
  this.mode.start(opts);
};
BlockCipher.prototype.update = function(input) {
  if (input) {
    this._input.putBuffer(input);
  }
  while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
  }
  this._input.compact();
};
BlockCipher.prototype.finish = function(pad) {
  if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
    this.mode.pad = function(input) {
      return pad(this.blockSize, input, false);
    };
    this.mode.unpad = function(output) {
      return pad(this.blockSize, output, true);
    };
  }
  var options = {};
  options.decrypt = this._decrypt;
  options.overflow = this._input.length() % this.blockSize;
  if (!this._decrypt && this.mode.pad) {
    if (!this.mode.pad(this._input, options)) {
      return false;
    }
  }
  this._finish = true;
  this.update();
  if (this._decrypt && this.mode.unpad) {
    if (!this.mode.unpad(this.output, options)) {
      return false;
    }
  }
  if (this.mode.afterFinish) {
    if (!this.mode.afterFinish(this.output, options)) {
      return false;
    }
  }
  return true;
};
var forge$A = forge$D;
forge$A.cipher = forge$A.cipher || {};
var modes = forge$A.cipher.modes = forge$A.cipher.modes || {};
modes.ecb = function(options) {
  options = options || {};
  this.name = "ECB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.ecb.prototype.start = function(options) {
};
modes.ecb.prototype.encrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};
modes.ecb.prototype.decrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
};
modes.ecb.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.ecb.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len = output.length();
  var count = output.at(len - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cbc = function(options) {
  options = options || {};
  this.name = "CBC";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
};
modes.cbc.prototype.start = function(options) {
  if (options.iv === null) {
    if (!this._prev) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = this._prev.slice(0);
  } else if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  } else {
    this._iv = transformIV(options.iv, this.blockSize);
    this._prev = this._iv.slice(0);
  }
};
modes.cbc.prototype.encrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = this._prev[i] ^ input.getInt32();
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i]);
  }
  this._prev = this._outBlock;
};
modes.cbc.prototype.decrypt = function(input, output, finish) {
  if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
    return true;
  }
  for (var i = 0; i < this._ints; ++i) {
    this._inBlock[i] = input.getInt32();
  }
  this.cipher.decrypt(this._inBlock, this._outBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._prev[i] ^ this._outBlock[i]);
  }
  this._prev = this._inBlock.slice(0);
};
modes.cbc.prototype.pad = function(input, options) {
  var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
  input.fillWithByte(padding, padding);
  return true;
};
modes.cbc.prototype.unpad = function(output, options) {
  if (options.overflow > 0) {
    return false;
  }
  var len = output.length();
  var count = output.at(len - 1);
  if (count > this.blockSize << 2) {
    return false;
  }
  output.truncate(count);
  return true;
};
modes.cfb = function(options) {
  options = options || {};
  this.name = "CFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialBlock = new Array(this._ints);
  this._partialOutput = forge$A.util.createBuffer();
  this._partialBytes = 0;
};
modes.cfb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.cfb.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
      output.putInt32(this._inBlock[i]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
    this._partialOutput.putInt32(this._partialBlock[i]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.cfb.prototype.decrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
      output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i) {
    this._partialBlock[i] = input.getInt32();
    this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._partialBlock[i];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.ofb = function(options) {
  options = options || {};
  this.name = "OFB";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$A.util.createBuffer();
  this._partialBytes = 0;
};
modes.ofb.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ofb.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (input.length() === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
      this._inBlock[i] = this._outBlock[i];
    }
    return;
  }
  var partialBytes = (this.blockSize - inputLength) % this.blockSize;
  if (partialBytes > 0) {
    partialBytes = this.blockSize - partialBytes;
  }
  this._partialOutput.clear();
  for (var i = 0; i < this._ints; ++i) {
    this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
  }
  if (partialBytes > 0) {
    input.read -= this.blockSize;
  } else {
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._outBlock[i];
    }
  }
  if (this._partialBytes > 0) {
    this._partialOutput.getBytes(this._partialBytes);
  }
  if (partialBytes > 0 && !finish) {
    output.putBytes(this._partialOutput.getBytes(
      partialBytes - this._partialBytes
    ));
    this._partialBytes = partialBytes;
    return true;
  }
  output.putBytes(this._partialOutput.getBytes(
    inputLength - this._partialBytes
  ));
  this._partialBytes = 0;
};
modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
modes.ctr = function(options) {
  options = options || {};
  this.name = "CTR";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = null;
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$A.util.createBuffer();
  this._partialBytes = 0;
};
modes.ctr.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  this._iv = transformIV(options.iv, this.blockSize);
  this._inBlock = this._iv.slice(0);
  this._partialBytes = 0;
};
modes.ctr.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes
      ));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes
    ));
    this._partialBytes = 0;
  }
  inc32(this._inBlock);
};
modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
modes.gcm = function(options) {
  options = options || {};
  this.name = "GCM";
  this.cipher = options.cipher;
  this.blockSize = options.blockSize || 16;
  this._ints = this.blockSize / 4;
  this._inBlock = new Array(this._ints);
  this._outBlock = new Array(this._ints);
  this._partialOutput = forge$A.util.createBuffer();
  this._partialBytes = 0;
  this._R = 3774873600;
};
modes.gcm.prototype.start = function(options) {
  if (!("iv" in options)) {
    throw new Error("Invalid IV parameter.");
  }
  var iv2 = forge$A.util.createBuffer(options.iv);
  this._cipherLength = 0;
  var additionalData;
  if ("additionalData" in options) {
    additionalData = forge$A.util.createBuffer(options.additionalData);
  } else {
    additionalData = forge$A.util.createBuffer();
  }
  if ("tagLength" in options) {
    this._tagLength = options.tagLength;
  } else {
    this._tagLength = 128;
  }
  this._tag = null;
  if (options.decrypt) {
    this._tag = forge$A.util.createBuffer(options.tag).getBytes();
    if (this._tag.length !== this._tagLength / 8) {
      throw new Error("Authentication tag does not match tag length.");
    }
  }
  this._hashBlock = new Array(this._ints);
  this.tag = null;
  this._hashSubkey = new Array(this._ints);
  this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
  this.componentBits = 4;
  this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
  var ivLength = iv2.length();
  if (ivLength === 12) {
    this._j0 = [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), 1];
  } else {
    this._j0 = [0, 0, 0, 0];
    while (iv2.length() > 0) {
      this._j0 = this.ghash(
        this._hashSubkey,
        this._j0,
        [iv2.getInt32(), iv2.getInt32(), iv2.getInt32(), iv2.getInt32()]
      );
    }
    this._j0 = this.ghash(
      this._hashSubkey,
      this._j0,
      [0, 0].concat(from64To32(ivLength * 8))
    );
  }
  this._inBlock = this._j0.slice(0);
  inc32(this._inBlock);
  this._partialBytes = 0;
  additionalData = forge$A.util.createBuffer(additionalData);
  this._aDataLength = from64To32(additionalData.length() * 8);
  var overflow = additionalData.length() % this.blockSize;
  if (overflow) {
    additionalData.fillWithByte(0, this.blockSize - overflow);
  }
  this._s = [0, 0, 0, 0];
  while (additionalData.length() > 0) {
    this._s = this.ghash(this._hashSubkey, this._s, [
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32(),
      additionalData.getInt32()
    ]);
  }
};
modes.gcm.prototype.encrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength === 0) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  if (this._partialBytes === 0 && inputLength >= this.blockSize) {
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^= input.getInt32());
    }
    this._cipherLength += this.blockSize;
  } else {
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes <= 0 || finish) {
      if (finish) {
        var overflow = inputLength % this.blockSize;
        this._cipherLength += overflow;
        this._partialOutput.truncate(this.blockSize - overflow);
      } else {
        this._cipherLength += this.blockSize;
      }
      for (var i = 0; i < this._ints; ++i) {
        this._outBlock[i] = this._partialOutput.getInt32();
      }
      this._partialOutput.read -= this.blockSize;
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      input.read -= this.blockSize;
      output.putBytes(this._partialOutput.getBytes(
        partialBytes - this._partialBytes
      ));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(
      inputLength - this._partialBytes
    ));
    this._partialBytes = 0;
  }
  this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
  inc32(this._inBlock);
};
modes.gcm.prototype.decrypt = function(input, output, finish) {
  var inputLength = input.length();
  if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
    return true;
  }
  this.cipher.encrypt(this._inBlock, this._outBlock);
  inc32(this._inBlock);
  this._hashBlock[0] = input.getInt32();
  this._hashBlock[1] = input.getInt32();
  this._hashBlock[2] = input.getInt32();
  this._hashBlock[3] = input.getInt32();
  this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
  for (var i = 0; i < this._ints; ++i) {
    output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
  }
  if (inputLength < this.blockSize) {
    this._cipherLength += inputLength % this.blockSize;
  } else {
    this._cipherLength += this.blockSize;
  }
};
modes.gcm.prototype.afterFinish = function(output, options) {
  var rval = true;
  if (options.decrypt && options.overflow) {
    output.truncate(this.blockSize - options.overflow);
  }
  this.tag = forge$A.util.createBuffer();
  var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
  this._s = this.ghash(this._hashSubkey, this._s, lengths);
  var tag = [];
  this.cipher.encrypt(this._j0, tag);
  for (var i = 0; i < this._ints; ++i) {
    this.tag.putInt32(this._s[i] ^ tag[i]);
  }
  this.tag.truncate(this.tag.length() % (this._tagLength / 8));
  if (options.decrypt && this.tag.bytes() !== this._tag) {
    rval = false;
  }
  return rval;
};
modes.gcm.prototype.multiply = function(x, y2) {
  var z_i = [0, 0, 0, 0];
  var v_i = y2.slice(0);
  for (var i = 0; i < 128; ++i) {
    var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
    if (x_i) {
      z_i[0] ^= v_i[0];
      z_i[1] ^= v_i[1];
      z_i[2] ^= v_i[2];
      z_i[3] ^= v_i[3];
    }
    this.pow(v_i, v_i);
  }
  return z_i;
};
modes.gcm.prototype.pow = function(x, out) {
  var lsb = x[3] & 1;
  for (var i = 3; i > 0; --i) {
    out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
  }
  out[0] = x[0] >>> 1;
  if (lsb) {
    out[0] ^= this._R;
  }
};
modes.gcm.prototype.tableMultiply = function(x) {
  var z = [0, 0, 0, 0];
  for (var i = 0; i < 32; ++i) {
    var idx = i / 8 | 0;
    var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
    var ah = this._m[i][x_i];
    z[0] ^= ah[0];
    z[1] ^= ah[1];
    z[2] ^= ah[2];
    z[3] ^= ah[3];
  }
  return z;
};
modes.gcm.prototype.ghash = function(h2, y2, x) {
  y2[0] ^= x[0];
  y2[1] ^= x[1];
  y2[2] ^= x[2];
  y2[3] ^= x[3];
  return this.tableMultiply(y2);
};
modes.gcm.prototype.generateHashTable = function(h2, bits) {
  var multiplier = 8 / bits;
  var perInt = 4 * multiplier;
  var size = 16 * multiplier;
  var m2 = new Array(size);
  for (var i = 0; i < size; ++i) {
    var tmp = [0, 0, 0, 0];
    var idx = i / perInt | 0;
    var shft = (perInt - 1 - i % perInt) * bits;
    tmp[idx] = 1 << bits - 1 << shft;
    m2[i] = this.generateSubHashTable(this.multiply(tmp, h2), bits);
  }
  return m2;
};
modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
  var size = 1 << bits;
  var half = size >>> 1;
  var m2 = new Array(size);
  m2[half] = mid.slice(0);
  var i = half >>> 1;
  while (i > 0) {
    this.pow(m2[2 * i], m2[i] = []);
    i >>= 1;
  }
  i = 2;
  while (i < half) {
    for (var j2 = 1; j2 < i; ++j2) {
      var m_i = m2[i];
      var m_j = m2[j2];
      m2[i + j2] = [
        m_i[0] ^ m_j[0],
        m_i[1] ^ m_j[1],
        m_i[2] ^ m_j[2],
        m_i[3] ^ m_j[3]
      ];
    }
    i *= 2;
  }
  m2[0] = [0, 0, 0, 0];
  for (i = half + 1; i < size; ++i) {
    var c = m2[i ^ half];
    m2[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
  }
  return m2;
};
function transformIV(iv2, blockSize) {
  if (typeof iv2 === "string") {
    iv2 = forge$A.util.createBuffer(iv2);
  }
  if (forge$A.util.isArray(iv2) && iv2.length > 4) {
    var tmp = iv2;
    iv2 = forge$A.util.createBuffer();
    for (var i = 0; i < tmp.length; ++i) {
      iv2.putByte(tmp[i]);
    }
  }
  if (iv2.length() < blockSize) {
    throw new Error(
      "Invalid IV length; got " + iv2.length() + " bytes and expected " + blockSize + " bytes."
    );
  }
  if (!forge$A.util.isArray(iv2)) {
    var ints = [];
    var blocks = blockSize / 4;
    for (var i = 0; i < blocks; ++i) {
      ints.push(iv2.getInt32());
    }
    iv2 = ints;
  }
  return iv2;
}
function inc32(block) {
  block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
}
function from64To32(num) {
  return [num / 4294967296 | 0, num & 4294967295];
}
var forge$z = forge$D;
forge$z.aes = forge$z.aes || {};
forge$z.aes.startEncrypting = function(key, iv2, output, mode) {
  var cipher = _createCipher$1({
    key,
    output,
    decrypt: false,
    mode
  });
  cipher.start(iv2);
  return cipher;
};
forge$z.aes.createEncryptionCipher = function(key, mode) {
  return _createCipher$1({
    key,
    output: null,
    decrypt: false,
    mode
  });
};
forge$z.aes.startDecrypting = function(key, iv2, output, mode) {
  var cipher = _createCipher$1({
    key,
    output,
    decrypt: true,
    mode
  });
  cipher.start(iv2);
  return cipher;
};
forge$z.aes.createDecryptionCipher = function(key, mode) {
  return _createCipher$1({
    key,
    output: null,
    decrypt: true,
    mode
  });
};
forge$z.aes.Algorithm = function(name2, mode) {
  if (!init) {
    initialize();
  }
  var self3 = this;
  self3.name = name2;
  self3.mode = new mode({
    blockSize: 16,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock$1(self3._w, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock$1(self3._w, inBlock, outBlock, true);
      }
    }
  });
  self3._init = false;
};
forge$z.aes.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key = options.key;
  var tmp;
  if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
    key = forge$z.util.createBuffer(key);
  } else if (forge$z.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
    tmp = key;
    key = forge$z.util.createBuffer();
    for (var i = 0; i < tmp.length; ++i) {
      key.putByte(tmp[i]);
    }
  }
  if (!forge$z.util.isArray(key)) {
    tmp = key;
    key = [];
    var len = tmp.length();
    if (len === 16 || len === 24 || len === 32) {
      len = len >>> 2;
      for (var i = 0; i < len; ++i) {
        key.push(tmp.getInt32());
      }
    }
  }
  if (!forge$z.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
    throw new Error("Invalid key parameter.");
  }
  var mode = this.mode.name;
  var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
  this._w = _expandKey(key, options.decrypt && !encryptOp);
  this._init = true;
};
forge$z.aes._expandKey = function(key, decrypt2) {
  if (!init) {
    initialize();
  }
  return _expandKey(key, decrypt2);
};
forge$z.aes._updateBlock = _updateBlock$1;
registerAlgorithm$1("AES-ECB", forge$z.cipher.modes.ecb);
registerAlgorithm$1("AES-CBC", forge$z.cipher.modes.cbc);
registerAlgorithm$1("AES-CFB", forge$z.cipher.modes.cfb);
registerAlgorithm$1("AES-OFB", forge$z.cipher.modes.ofb);
registerAlgorithm$1("AES-CTR", forge$z.cipher.modes.ctr);
registerAlgorithm$1("AES-GCM", forge$z.cipher.modes.gcm);
function registerAlgorithm$1(name2, mode) {
  var factory = function() {
    return new forge$z.aes.Algorithm(name2, mode);
  };
  forge$z.cipher.registerAlgorithm(name2, factory);
}
var init = false;
var Nb = 4;
var sbox;
var isbox;
var rcon;
var mix;
var imix;
function initialize() {
  init = true;
  rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
  var xtime = new Array(256);
  for (var i = 0; i < 128; ++i) {
    xtime[i] = i << 1;
    xtime[i + 128] = i + 128 << 1 ^ 283;
  }
  sbox = new Array(256);
  isbox = new Array(256);
  mix = new Array(4);
  imix = new Array(4);
  for (var i = 0; i < 4; ++i) {
    mix[i] = new Array(256);
    imix[i] = new Array(256);
  }
  var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
  for (var i = 0; i < 256; ++i) {
    sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
    sx = sx >> 8 ^ sx & 255 ^ 99;
    sbox[e] = sx;
    isbox[sx] = e;
    sx2 = xtime[sx];
    e2 = xtime[e];
    e4 = xtime[e2];
    e8 = xtime[e4];
    me = sx2 << 24 ^ // 2
    sx << 16 ^ // 1
    sx << 8 ^ // 1
    (sx ^ sx2);
    ime = (e2 ^ e4 ^ e8) << 24 ^ // E (14)
    (e ^ e8) << 16 ^ // 9
    (e ^ e4 ^ e8) << 8 ^ // D (13)
    (e ^ e2 ^ e8);
    for (var n = 0; n < 4; ++n) {
      mix[n][e] = me;
      imix[n][sx] = ime;
      me = me << 24 | me >>> 8;
      ime = ime << 24 | ime >>> 8;
    }
    if (e === 0) {
      e = ei = 1;
    } else {
      e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
      ei ^= xtime[xtime[ei]];
    }
  }
}
function _expandKey(key, decrypt2) {
  var w2 = key.slice(0);
  var temp, iNk = 1;
  var Nk = w2.length;
  var Nr1 = Nk + 6 + 1;
  var end = Nb * Nr1;
  for (var i = Nk; i < end; ++i) {
    temp = w2[i - 1];
    if (i % Nk === 0) {
      temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
      iNk++;
    } else if (Nk > 6 && i % Nk === 4) {
      temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
    }
    w2[i] = w2[i - Nk] ^ temp;
  }
  if (decrypt2) {
    var tmp;
    var m0 = imix[0];
    var m1 = imix[1];
    var m2 = imix[2];
    var m3 = imix[3];
    var wnew = w2.slice(0);
    end = w2.length;
    for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
      if (i === 0 || i === end - Nb) {
        wnew[i] = w2[wi];
        wnew[i + 1] = w2[wi + 3];
        wnew[i + 2] = w2[wi + 2];
        wnew[i + 3] = w2[wi + 1];
      } else {
        for (var n = 0; n < Nb; ++n) {
          tmp = w2[wi + n];
          wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
        }
      }
    }
    w2 = wnew;
  }
  return w2;
}
function _updateBlock$1(w2, input, output, decrypt2) {
  var Nr = w2.length / 4 - 1;
  var m0, m1, m2, m3, sub;
  if (decrypt2) {
    m0 = imix[0];
    m1 = imix[1];
    m2 = imix[2];
    m3 = imix[3];
    sub = isbox;
  } else {
    m0 = mix[0];
    m1 = mix[1];
    m2 = mix[2];
    m3 = mix[3];
    sub = sbox;
  }
  var a, b, c, d2, a2, b2, c2;
  a = input[0] ^ w2[0];
  b = input[decrypt2 ? 3 : 1] ^ w2[1];
  c = input[2] ^ w2[2];
  d2 = input[decrypt2 ? 1 : 3] ^ w2[3];
  var i = 3;
  for (var round = 1; round < Nr; ++round) {
    a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d2 & 255] ^ w2[++i];
    b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d2 >>> 8 & 255] ^ m3[a & 255] ^ w2[++i];
    c2 = m0[c >>> 24] ^ m1[d2 >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w2[++i];
    d2 = m0[d2 >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w2[++i];
    a = a2;
    b = b2;
    c = c2;
  }
  output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d2 & 255] ^ w2[++i];
  output[decrypt2 ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d2 >>> 8 & 255] << 8 ^ sub[a & 255] ^ w2[++i];
  output[2] = sub[c >>> 24] << 24 ^ sub[d2 >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w2[++i];
  output[decrypt2 ? 1 : 3] = sub[d2 >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w2[++i];
}
function _createCipher$1(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "AES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$z.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$z.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv2, options2) {
    var output = null;
    if (options2 instanceof forge$z.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv2;
    start.call(cipher, options2);
  };
  return cipher;
}
var forge$y = forge$D;
forge$y.pki = forge$y.pki || {};
var oids$2 = forge$y.pki.oids = forge$y.oids = forge$y.oids || {};
function _IN(id, name2) {
  oids$2[id] = name2;
  oids$2[name2] = id;
}
function _I_(id, name2) {
  oids$2[id] = name2;
}
_IN("1.2.840.113549.1.1.1", "rsaEncryption");
_IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
_IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
_IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
_IN("1.2.840.113549.1.1.8", "mgf1");
_IN("1.2.840.113549.1.1.9", "pSpecified");
_IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
_IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
_IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
_IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
_IN("1.3.101.112", "EdDSA25519");
_IN("1.2.840.10040.4.3", "dsa-with-sha1");
_IN("1.3.14.3.2.7", "desCBC");
_IN("1.3.14.3.2.26", "sha1");
_IN("1.3.14.3.2.29", "sha1WithRSASignature");
_IN("2.16.840.1.101.3.4.2.1", "sha256");
_IN("2.16.840.1.101.3.4.2.2", "sha384");
_IN("2.16.840.1.101.3.4.2.3", "sha512");
_IN("2.16.840.1.101.3.4.2.4", "sha224");
_IN("2.16.840.1.101.3.4.2.5", "sha512-224");
_IN("2.16.840.1.101.3.4.2.6", "sha512-256");
_IN("1.2.840.113549.2.2", "md2");
_IN("1.2.840.113549.2.5", "md5");
_IN("1.2.840.113549.1.7.1", "data");
_IN("1.2.840.113549.1.7.2", "signedData");
_IN("1.2.840.113549.1.7.3", "envelopedData");
_IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
_IN("1.2.840.113549.1.7.5", "digestedData");
_IN("1.2.840.113549.1.7.6", "encryptedData");
_IN("1.2.840.113549.1.9.1", "emailAddress");
_IN("1.2.840.113549.1.9.2", "unstructuredName");
_IN("1.2.840.113549.1.9.3", "contentType");
_IN("1.2.840.113549.1.9.4", "messageDigest");
_IN("1.2.840.113549.1.9.5", "signingTime");
_IN("1.2.840.113549.1.9.6", "counterSignature");
_IN("1.2.840.113549.1.9.7", "challengePassword");
_IN("1.2.840.113549.1.9.8", "unstructuredAddress");
_IN("1.2.840.113549.1.9.14", "extensionRequest");
_IN("1.2.840.113549.1.9.20", "friendlyName");
_IN("1.2.840.113549.1.9.21", "localKeyId");
_IN("1.2.840.113549.1.9.22.1", "x509Certificate");
_IN("1.2.840.113549.1.12.10.1.1", "keyBag");
_IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
_IN("1.2.840.113549.1.12.10.1.3", "certBag");
_IN("1.2.840.113549.1.12.10.1.4", "crlBag");
_IN("1.2.840.113549.1.12.10.1.5", "secretBag");
_IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
_IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
_IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
_IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
_IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
_IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
_IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
_IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
_IN("1.2.840.113549.2.7", "hmacWithSHA1");
_IN("1.2.840.113549.2.8", "hmacWithSHA224");
_IN("1.2.840.113549.2.9", "hmacWithSHA256");
_IN("1.2.840.113549.2.10", "hmacWithSHA384");
_IN("1.2.840.113549.2.11", "hmacWithSHA512");
_IN("1.2.840.113549.3.7", "des-EDE3-CBC");
_IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
_IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
_IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
_IN("2.5.4.3", "commonName");
_IN("2.5.4.4", "surname");
_IN("2.5.4.5", "serialNumber");
_IN("2.5.4.6", "countryName");
_IN("2.5.4.7", "localityName");
_IN("2.5.4.8", "stateOrProvinceName");
_IN("2.5.4.9", "streetAddress");
_IN("2.5.4.10", "organizationName");
_IN("2.5.4.11", "organizationalUnitName");
_IN("2.5.4.12", "title");
_IN("2.5.4.13", "description");
_IN("2.5.4.15", "businessCategory");
_IN("2.5.4.17", "postalCode");
_IN("2.5.4.42", "givenName");
_IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
_IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
_IN("2.16.840.1.113730.1.1", "nsCertType");
_IN("2.16.840.1.113730.1.13", "nsComment");
_I_("2.5.29.1", "authorityKeyIdentifier");
_I_("2.5.29.2", "keyAttributes");
_I_("2.5.29.3", "certificatePolicies");
_I_("2.5.29.4", "keyUsageRestriction");
_I_("2.5.29.5", "policyMapping");
_I_("2.5.29.6", "subtreesConstraint");
_I_("2.5.29.7", "subjectAltName");
_I_("2.5.29.8", "issuerAltName");
_I_("2.5.29.9", "subjectDirectoryAttributes");
_I_("2.5.29.10", "basicConstraints");
_I_("2.5.29.11", "nameConstraints");
_I_("2.5.29.12", "policyConstraints");
_I_("2.5.29.13", "basicConstraints");
_IN("2.5.29.14", "subjectKeyIdentifier");
_IN("2.5.29.15", "keyUsage");
_I_("2.5.29.16", "privateKeyUsagePeriod");
_IN("2.5.29.17", "subjectAltName");
_IN("2.5.29.18", "issuerAltName");
_IN("2.5.29.19", "basicConstraints");
_I_("2.5.29.20", "cRLNumber");
_I_("2.5.29.21", "cRLReason");
_I_("2.5.29.22", "expirationDate");
_I_("2.5.29.23", "instructionCode");
_I_("2.5.29.24", "invalidityDate");
_I_("2.5.29.25", "cRLDistributionPoints");
_I_("2.5.29.26", "issuingDistributionPoint");
_I_("2.5.29.27", "deltaCRLIndicator");
_I_("2.5.29.28", "issuingDistributionPoint");
_I_("2.5.29.29", "certificateIssuer");
_I_("2.5.29.30", "nameConstraints");
_IN("2.5.29.31", "cRLDistributionPoints");
_IN("2.5.29.32", "certificatePolicies");
_I_("2.5.29.33", "policyMappings");
_I_("2.5.29.34", "policyConstraints");
_IN("2.5.29.35", "authorityKeyIdentifier");
_I_("2.5.29.36", "policyConstraints");
_IN("2.5.29.37", "extKeyUsage");
_I_("2.5.29.46", "freshestCRL");
_I_("2.5.29.54", "inhibitAnyPolicy");
_IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
_IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
_IN("1.3.6.1.5.5.7.3.1", "serverAuth");
_IN("1.3.6.1.5.5.7.3.2", "clientAuth");
_IN("1.3.6.1.5.5.7.3.3", "codeSigning");
_IN("1.3.6.1.5.5.7.3.4", "emailProtection");
_IN("1.3.6.1.5.5.7.3.8", "timeStamping");
var forge$x = forge$D;
var asn1$8 = forge$x.asn1 = forge$x.asn1 || {};
asn1$8.Class = {
  UNIVERSAL: 0,
  APPLICATION: 64,
  CONTEXT_SPECIFIC: 128,
  PRIVATE: 192
};
asn1$8.Type = {
  NONE: 0,
  BOOLEAN: 1,
  INTEGER: 2,
  BITSTRING: 3,
  OCTETSTRING: 4,
  NULL: 5,
  OID: 6,
  ODESC: 7,
  EXTERNAL: 8,
  REAL: 9,
  ENUMERATED: 10,
  EMBEDDED: 11,
  UTF8: 12,
  ROID: 13,
  SEQUENCE: 16,
  SET: 17,
  PRINTABLESTRING: 19,
  IA5STRING: 22,
  UTCTIME: 23,
  GENERALIZEDTIME: 24,
  BMPSTRING: 30
};
asn1$8.create = function(tagClass, type3, constructed, value2, options) {
  if (forge$x.util.isArray(value2)) {
    var tmp = [];
    for (var i = 0; i < value2.length; ++i) {
      if (value2[i] !== void 0) {
        tmp.push(value2[i]);
      }
    }
    value2 = tmp;
  }
  var obj = {
    tagClass,
    type: type3,
    constructed,
    composed: constructed || forge$x.util.isArray(value2),
    value: value2
  };
  if (options && "bitStringContents" in options) {
    obj.bitStringContents = options.bitStringContents;
    obj.original = asn1$8.copy(obj);
  }
  return obj;
};
asn1$8.copy = function(obj, options) {
  var copy2;
  if (forge$x.util.isArray(obj)) {
    copy2 = [];
    for (var i = 0; i < obj.length; ++i) {
      copy2.push(asn1$8.copy(obj[i], options));
    }
    return copy2;
  }
  if (typeof obj === "string") {
    return obj;
  }
  copy2 = {
    tagClass: obj.tagClass,
    type: obj.type,
    constructed: obj.constructed,
    composed: obj.composed,
    value: asn1$8.copy(obj.value, options)
  };
  if (options && !options.excludeBitStringContents) {
    copy2.bitStringContents = obj.bitStringContents;
  }
  return copy2;
};
asn1$8.equals = function(obj1, obj2, options) {
  if (forge$x.util.isArray(obj1)) {
    if (!forge$x.util.isArray(obj2)) {
      return false;
    }
    if (obj1.length !== obj2.length) {
      return false;
    }
    for (var i = 0; i < obj1.length; ++i) {
      if (!asn1$8.equals(obj1[i], obj2[i])) {
        return false;
      }
    }
    return true;
  }
  if (typeof obj1 !== typeof obj2) {
    return false;
  }
  if (typeof obj1 === "string") {
    return obj1 === obj2;
  }
  var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1$8.equals(obj1.value, obj2.value);
  if (options && options.includeBitStringContents) {
    equal = equal && obj1.bitStringContents === obj2.bitStringContents;
  }
  return equal;
};
asn1$8.getBerValueLength = function(b) {
  var b2 = b.getByte();
  if (b2 === 128) {
    return void 0;
  }
  var length;
  var longForm = b2 & 128;
  if (!longForm) {
    length = b2;
  } else {
    length = b.getInt((b2 & 127) << 3);
  }
  return length;
};
function _checkBufferLength(bytes2, remaining, n) {
  if (n > remaining) {
    var error2 = new Error("Too few bytes to parse DER.");
    error2.available = bytes2.length();
    error2.remaining = remaining;
    error2.requested = n;
    throw error2;
  }
}
var _getValueLength = function(bytes2, remaining) {
  var b2 = bytes2.getByte();
  remaining--;
  if (b2 === 128) {
    return void 0;
  }
  var length;
  var longForm = b2 & 128;
  if (!longForm) {
    length = b2;
  } else {
    var longFormBytes = b2 & 127;
    _checkBufferLength(bytes2, remaining, longFormBytes);
    length = bytes2.getInt(longFormBytes << 3);
  }
  if (length < 0) {
    throw new Error("Negative length: " + length);
  }
  return length;
};
asn1$8.fromDer = function(bytes2, options) {
  if (options === void 0) {
    options = {
      strict: true,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if (typeof options === "boolean") {
    options = {
      strict: options,
      parseAllBytes: true,
      decodeBitStrings: true
    };
  }
  if (!("strict" in options)) {
    options.strict = true;
  }
  if (!("parseAllBytes" in options)) {
    options.parseAllBytes = true;
  }
  if (!("decodeBitStrings" in options)) {
    options.decodeBitStrings = true;
  }
  if (typeof bytes2 === "string") {
    bytes2 = forge$x.util.createBuffer(bytes2);
  }
  var byteCount = bytes2.length();
  var value2 = _fromDer(bytes2, bytes2.length(), 0, options);
  if (options.parseAllBytes && bytes2.length() !== 0) {
    var error2 = new Error("Unparsed DER bytes remain after ASN.1 parsing.");
    error2.byteCount = byteCount;
    error2.remaining = bytes2.length();
    throw error2;
  }
  return value2;
};
function _fromDer(bytes2, remaining, depth, options) {
  var start;
  _checkBufferLength(bytes2, remaining, 2);
  var b1 = bytes2.getByte();
  remaining--;
  var tagClass = b1 & 192;
  var type3 = b1 & 31;
  start = bytes2.length();
  var length = _getValueLength(bytes2, remaining);
  remaining -= start - bytes2.length();
  if (length !== void 0 && length > remaining) {
    if (options.strict) {
      var error2 = new Error("Too few bytes to read ASN.1 value.");
      error2.available = bytes2.length();
      error2.remaining = remaining;
      error2.requested = length;
      throw error2;
    }
    length = remaining;
  }
  var value2;
  var bitStringContents;
  var constructed = (b1 & 32) === 32;
  if (constructed) {
    value2 = [];
    if (length === void 0) {
      for (; ; ) {
        _checkBufferLength(bytes2, remaining, 2);
        if (bytes2.bytes(2) === String.fromCharCode(0, 0)) {
          bytes2.getBytes(2);
          remaining -= 2;
          break;
        }
        start = bytes2.length();
        value2.push(_fromDer(bytes2, remaining, depth + 1, options));
        remaining -= start - bytes2.length();
      }
    } else {
      while (length > 0) {
        start = bytes2.length();
        value2.push(_fromDer(bytes2, length, depth + 1, options));
        remaining -= start - bytes2.length();
        length -= start - bytes2.length();
      }
    }
  }
  if (value2 === void 0 && tagClass === asn1$8.Class.UNIVERSAL && type3 === asn1$8.Type.BITSTRING) {
    bitStringContents = bytes2.bytes(length);
  }
  if (value2 === void 0 && options.decodeBitStrings && tagClass === asn1$8.Class.UNIVERSAL && // FIXME: OCTET STRINGs not yet supported here
  // .. other parts of forge expect to decode OCTET STRINGs manually
  type3 === asn1$8.Type.BITSTRING && length > 1) {
    var savedRead = bytes2.read;
    var savedRemaining = remaining;
    var unused = 0;
    if (type3 === asn1$8.Type.BITSTRING) {
      _checkBufferLength(bytes2, remaining, 1);
      unused = bytes2.getByte();
      remaining--;
    }
    if (unused === 0) {
      try {
        start = bytes2.length();
        var subOptions = {
          // enforce strict mode to avoid parsing ASN.1 from plain data
          strict: true,
          decodeBitStrings: true
        };
        var composed = _fromDer(bytes2, remaining, depth + 1, subOptions);
        var used = start - bytes2.length();
        remaining -= used;
        if (type3 == asn1$8.Type.BITSTRING) {
          used++;
        }
        var tc = composed.tagClass;
        if (used === length && (tc === asn1$8.Class.UNIVERSAL || tc === asn1$8.Class.CONTEXT_SPECIFIC)) {
          value2 = [composed];
        }
      } catch (ex) {
      }
    }
    if (value2 === void 0) {
      bytes2.read = savedRead;
      remaining = savedRemaining;
    }
  }
  if (value2 === void 0) {
    if (length === void 0) {
      if (options.strict) {
        throw new Error("Non-constructed ASN.1 object of indefinite length.");
      }
      length = remaining;
    }
    if (type3 === asn1$8.Type.BMPSTRING) {
      value2 = "";
      for (; length > 0; length -= 2) {
        _checkBufferLength(bytes2, remaining, 2);
        value2 += String.fromCharCode(bytes2.getInt16());
        remaining -= 2;
      }
    } else {
      value2 = bytes2.getBytes(length);
      remaining -= length;
    }
  }
  var asn1Options = bitStringContents === void 0 ? null : {
    bitStringContents
  };
  return asn1$8.create(tagClass, type3, constructed, value2, asn1Options);
}
asn1$8.toDer = function(obj) {
  var bytes2 = forge$x.util.createBuffer();
  var b1 = obj.tagClass | obj.type;
  var value2 = forge$x.util.createBuffer();
  var useBitStringContents = false;
  if ("bitStringContents" in obj) {
    useBitStringContents = true;
    if (obj.original) {
      useBitStringContents = asn1$8.equals(obj, obj.original);
    }
  }
  if (useBitStringContents) {
    value2.putBytes(obj.bitStringContents);
  } else if (obj.composed) {
    if (obj.constructed) {
      b1 |= 32;
    } else {
      value2.putByte(0);
    }
    for (var i = 0; i < obj.value.length; ++i) {
      if (obj.value[i] !== void 0) {
        value2.putBuffer(asn1$8.toDer(obj.value[i]));
      }
    }
  } else {
    if (obj.type === asn1$8.Type.BMPSTRING) {
      for (var i = 0; i < obj.value.length; ++i) {
        value2.putInt16(obj.value.charCodeAt(i));
      }
    } else {
      if (obj.type === asn1$8.Type.INTEGER && obj.value.length > 1 && // leading 0x00 for positive integer
      (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
      obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
        value2.putBytes(obj.value.substr(1));
      } else {
        value2.putBytes(obj.value);
      }
    }
  }
  bytes2.putByte(b1);
  if (value2.length() <= 127) {
    bytes2.putByte(value2.length() & 127);
  } else {
    var len = value2.length();
    var lenBytes = "";
    do {
      lenBytes += String.fromCharCode(len & 255);
      len = len >>> 8;
    } while (len > 0);
    bytes2.putByte(lenBytes.length | 128);
    for (var i = lenBytes.length - 1; i >= 0; --i) {
      bytes2.putByte(lenBytes.charCodeAt(i));
    }
  }
  bytes2.putBuffer(value2);
  return bytes2;
};
asn1$8.oidToDer = function(oid) {
  var values = oid.split(".");
  var bytes2 = forge$x.util.createBuffer();
  bytes2.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
  var last, valueBytes, value2, b;
  for (var i = 2; i < values.length; ++i) {
    last = true;
    valueBytes = [];
    value2 = parseInt(values[i], 10);
    do {
      b = value2 & 127;
      value2 = value2 >>> 7;
      if (!last) {
        b |= 128;
      }
      valueBytes.push(b);
      last = false;
    } while (value2 > 0);
    for (var n = valueBytes.length - 1; n >= 0; --n) {
      bytes2.putByte(valueBytes[n]);
    }
  }
  return bytes2;
};
asn1$8.derToOid = function(bytes2) {
  var oid;
  if (typeof bytes2 === "string") {
    bytes2 = forge$x.util.createBuffer(bytes2);
  }
  var b = bytes2.getByte();
  oid = Math.floor(b / 40) + "." + b % 40;
  var value2 = 0;
  while (bytes2.length() > 0) {
    b = bytes2.getByte();
    value2 = value2 << 7;
    if (b & 128) {
      value2 += b & 127;
    } else {
      oid += "." + (value2 + b);
      value2 = 0;
    }
  }
  return oid;
};
asn1$8.utcTimeToDate = function(utc) {
  var date = /* @__PURE__ */ new Date();
  var year = parseInt(utc.substr(0, 2), 10);
  year = year >= 50 ? 1900 + year : 2e3 + year;
  var MM = parseInt(utc.substr(2, 2), 10) - 1;
  var DD = parseInt(utc.substr(4, 2), 10);
  var hh = parseInt(utc.substr(6, 2), 10);
  var mm = parseInt(utc.substr(8, 2), 10);
  var ss = 0;
  if (utc.length > 11) {
    var c = utc.charAt(10);
    var end = 10;
    if (c !== "+" && c !== "-") {
      ss = parseInt(utc.substr(10, 2), 10);
      end += 2;
    }
  }
  date.setUTCFullYear(year, MM, DD);
  date.setUTCHours(hh, mm, ss, 0);
  if (end) {
    c = utc.charAt(end);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
      var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
      var offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c === "+") {
        date.setTime(+date - offset);
      } else {
        date.setTime(+date + offset);
      }
    }
  }
  return date;
};
asn1$8.generalizedTimeToDate = function(gentime) {
  var date = /* @__PURE__ */ new Date();
  var YYYY = parseInt(gentime.substr(0, 4), 10);
  var MM = parseInt(gentime.substr(4, 2), 10) - 1;
  var DD = parseInt(gentime.substr(6, 2), 10);
  var hh = parseInt(gentime.substr(8, 2), 10);
  var mm = parseInt(gentime.substr(10, 2), 10);
  var ss = parseInt(gentime.substr(12, 2), 10);
  var fff = 0;
  var offset = 0;
  var isUTC = false;
  if (gentime.charAt(gentime.length - 1) === "Z") {
    isUTC = true;
  }
  var end = gentime.length - 5, c = gentime.charAt(end);
  if (c === "+" || c === "-") {
    var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
    var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
    offset = hhoffset * 60 + mmoffset;
    offset *= 6e4;
    if (c === "+") {
      offset *= -1;
    }
    isUTC = true;
  }
  if (gentime.charAt(14) === ".") {
    fff = parseFloat(gentime.substr(14), 10) * 1e3;
  }
  if (isUTC) {
    date.setUTCFullYear(YYYY, MM, DD);
    date.setUTCHours(hh, mm, ss, fff);
    date.setTime(+date + offset);
  } else {
    date.setFullYear(YYYY, MM, DD);
    date.setHours(hh, mm, ss, fff);
  }
  return date;
};
asn1$8.dateToUtcTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format2 = [];
  format2.push(("" + date.getUTCFullYear()).substr(2));
  format2.push("" + (date.getUTCMonth() + 1));
  format2.push("" + date.getUTCDate());
  format2.push("" + date.getUTCHours());
  format2.push("" + date.getUTCMinutes());
  format2.push("" + date.getUTCSeconds());
  for (var i = 0; i < format2.length; ++i) {
    if (format2[i].length < 2) {
      rval += "0";
    }
    rval += format2[i];
  }
  rval += "Z";
  return rval;
};
asn1$8.dateToGeneralizedTime = function(date) {
  if (typeof date === "string") {
    return date;
  }
  var rval = "";
  var format2 = [];
  format2.push("" + date.getUTCFullYear());
  format2.push("" + (date.getUTCMonth() + 1));
  format2.push("" + date.getUTCDate());
  format2.push("" + date.getUTCHours());
  format2.push("" + date.getUTCMinutes());
  format2.push("" + date.getUTCSeconds());
  for (var i = 0; i < format2.length; ++i) {
    if (format2[i].length < 2) {
      rval += "0";
    }
    rval += format2[i];
  }
  rval += "Z";
  return rval;
};
asn1$8.integerToDer = function(x) {
  var rval = forge$x.util.createBuffer();
  if (x >= -128 && x < 128) {
    return rval.putSignedInt(x, 8);
  }
  if (x >= -32768 && x < 32768) {
    return rval.putSignedInt(x, 16);
  }
  if (x >= -8388608 && x < 8388608) {
    return rval.putSignedInt(x, 24);
  }
  if (x >= -2147483648 && x < 2147483648) {
    return rval.putSignedInt(x, 32);
  }
  var error2 = new Error("Integer too large; max is 32-bits.");
  error2.integer = x;
  throw error2;
};
asn1$8.derToInteger = function(bytes2) {
  if (typeof bytes2 === "string") {
    bytes2 = forge$x.util.createBuffer(bytes2);
  }
  var n = bytes2.length() * 8;
  if (n > 32) {
    throw new Error("Integer too large; max is 32-bits.");
  }
  return bytes2.getSignedInt(n);
};
asn1$8.validate = function(obj, v, capture, errors2) {
  var rval = false;
  if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
    if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
      rval = true;
      if (v.value && forge$x.util.isArray(v.value)) {
        var j2 = 0;
        for (var i = 0; rval && i < v.value.length; ++i) {
          rval = v.value[i].optional || false;
          if (obj.value[j2]) {
            rval = asn1$8.validate(obj.value[j2], v.value[i], capture, errors2);
            if (rval) {
              ++j2;
            } else if (v.value[i].optional) {
              rval = true;
            }
          }
          if (!rval && errors2) {
            errors2.push(
              "[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"'
            );
          }
        }
      }
      if (rval && capture) {
        if (v.capture) {
          capture[v.capture] = obj.value;
        }
        if (v.captureAsn1) {
          capture[v.captureAsn1] = obj;
        }
        if (v.captureBitStringContents && "bitStringContents" in obj) {
          capture[v.captureBitStringContents] = obj.bitStringContents;
        }
        if (v.captureBitStringValue && "bitStringContents" in obj) {
          if (obj.bitStringContents.length < 2) {
            capture[v.captureBitStringValue] = "";
          } else {
            var unused = obj.bitStringContents.charCodeAt(0);
            if (unused !== 0) {
              throw new Error(
                "captureBitStringValue only supported for zero unused bits"
              );
            }
            capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
          }
        }
      }
    } else if (errors2) {
      errors2.push(
        "[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"'
      );
    }
  } else if (errors2) {
    if (obj.tagClass !== v.tagClass) {
      errors2.push(
        "[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"'
      );
    }
    if (obj.type !== v.type) {
      errors2.push(
        "[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"'
      );
    }
  }
  return rval;
};
var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
asn1$8.prettyPrint = function(obj, level, indentation) {
  var rval = "";
  level = level || 0;
  indentation = indentation || 2;
  if (level > 0) {
    rval += "\n";
  }
  var indent = "";
  for (var i = 0; i < level * indentation; ++i) {
    indent += " ";
  }
  rval += indent + "Tag: ";
  switch (obj.tagClass) {
    case asn1$8.Class.UNIVERSAL:
      rval += "Universal:";
      break;
    case asn1$8.Class.APPLICATION:
      rval += "Application:";
      break;
    case asn1$8.Class.CONTEXT_SPECIFIC:
      rval += "Context-Specific:";
      break;
    case asn1$8.Class.PRIVATE:
      rval += "Private:";
      break;
  }
  if (obj.tagClass === asn1$8.Class.UNIVERSAL) {
    rval += obj.type;
    switch (obj.type) {
      case asn1$8.Type.NONE:
        rval += " (None)";
        break;
      case asn1$8.Type.BOOLEAN:
        rval += " (Boolean)";
        break;
      case asn1$8.Type.INTEGER:
        rval += " (Integer)";
        break;
      case asn1$8.Type.BITSTRING:
        rval += " (Bit string)";
        break;
      case asn1$8.Type.OCTETSTRING:
        rval += " (Octet string)";
        break;
      case asn1$8.Type.NULL:
        rval += " (Null)";
        break;
      case asn1$8.Type.OID:
        rval += " (Object Identifier)";
        break;
      case asn1$8.Type.ODESC:
        rval += " (Object Descriptor)";
        break;
      case asn1$8.Type.EXTERNAL:
        rval += " (External or Instance of)";
        break;
      case asn1$8.Type.REAL:
        rval += " (Real)";
        break;
      case asn1$8.Type.ENUMERATED:
        rval += " (Enumerated)";
        break;
      case asn1$8.Type.EMBEDDED:
        rval += " (Embedded PDV)";
        break;
      case asn1$8.Type.UTF8:
        rval += " (UTF8)";
        break;
      case asn1$8.Type.ROID:
        rval += " (Relative Object Identifier)";
        break;
      case asn1$8.Type.SEQUENCE:
        rval += " (Sequence)";
        break;
      case asn1$8.Type.SET:
        rval += " (Set)";
        break;
      case asn1$8.Type.PRINTABLESTRING:
        rval += " (Printable String)";
        break;
      case asn1$8.Type.IA5String:
        rval += " (IA5String (ASCII))";
        break;
      case asn1$8.Type.UTCTIME:
        rval += " (UTC time)";
        break;
      case asn1$8.Type.GENERALIZEDTIME:
        rval += " (Generalized time)";
        break;
      case asn1$8.Type.BMPSTRING:
        rval += " (BMP String)";
        break;
    }
  } else {
    rval += obj.type;
  }
  rval += "\n";
  rval += indent + "Constructed: " + obj.constructed + "\n";
  if (obj.composed) {
    var subvalues = 0;
    var sub = "";
    for (var i = 0; i < obj.value.length; ++i) {
      if (obj.value[i] !== void 0) {
        subvalues += 1;
        sub += asn1$8.prettyPrint(obj.value[i], level + 1, indentation);
        if (i + 1 < obj.value.length) {
          sub += ",";
        }
      }
    }
    rval += indent + "Sub values: " + subvalues + sub;
  } else {
    rval += indent + "Value: ";
    if (obj.type === asn1$8.Type.OID) {
      var oid = asn1$8.derToOid(obj.value);
      rval += oid;
      if (forge$x.pki && forge$x.pki.oids) {
        if (oid in forge$x.pki.oids) {
          rval += " (" + forge$x.pki.oids[oid] + ") ";
        }
      }
    }
    if (obj.type === asn1$8.Type.INTEGER) {
      try {
        rval += asn1$8.derToInteger(obj.value);
      } catch (ex) {
        rval += "0x" + forge$x.util.bytesToHex(obj.value);
      }
    } else if (obj.type === asn1$8.Type.BITSTRING) {
      if (obj.value.length > 1) {
        rval += "0x" + forge$x.util.bytesToHex(obj.value.slice(1));
      } else {
        rval += "(none)";
      }
      if (obj.value.length > 0) {
        var unused = obj.value.charCodeAt(0);
        if (unused == 1) {
          rval += " (1 unused bit shown)";
        } else if (unused > 1) {
          rval += " (" + unused + " unused bits shown)";
        }
      }
    } else if (obj.type === asn1$8.Type.OCTETSTRING) {
      if (!_nonLatinRegex.test(obj.value)) {
        rval += "(" + obj.value + ") ";
      }
      rval += "0x" + forge$x.util.bytesToHex(obj.value);
    } else if (obj.type === asn1$8.Type.UTF8) {
      try {
        rval += forge$x.util.decodeUtf8(obj.value);
      } catch (e) {
        if (e.message === "URI malformed") {
          rval += "0x" + forge$x.util.bytesToHex(obj.value) + " (malformed UTF8)";
        } else {
          throw e;
        }
      }
    } else if (obj.type === asn1$8.Type.PRINTABLESTRING || obj.type === asn1$8.Type.IA5String) {
      rval += obj.value;
    } else if (_nonLatinRegex.test(obj.value)) {
      rval += "0x" + forge$x.util.bytesToHex(obj.value);
    } else if (obj.value.length === 0) {
      rval += "[null]";
    } else {
      rval += obj.value;
    }
  }
  return rval;
};
var forge$w = forge$D;
forge$w.md = forge$w.md || {};
forge$w.md.algorithms = forge$w.md.algorithms || {};
var forge$v = forge$D;
var hmac = forge$v.hmac = forge$v.hmac || {};
hmac.create = function() {
  var _key = null;
  var _md = null;
  var _ipadding = null;
  var _opadding = null;
  var ctx = {};
  ctx.start = function(md, key) {
    if (md !== null) {
      if (typeof md === "string") {
        md = md.toLowerCase();
        if (md in forge$v.md.algorithms) {
          _md = forge$v.md.algorithms[md].create();
        } else {
          throw new Error('Unknown hash algorithm "' + md + '"');
        }
      } else {
        _md = md;
      }
    }
    if (key === null) {
      key = _key;
    } else {
      if (typeof key === "string") {
        key = forge$v.util.createBuffer(key);
      } else if (forge$v.util.isArray(key)) {
        var tmp = key;
        key = forge$v.util.createBuffer();
        for (var i = 0; i < tmp.length; ++i) {
          key.putByte(tmp[i]);
        }
      }
      var keylen = key.length();
      if (keylen > _md.blockLength) {
        _md.start();
        _md.update(key.bytes());
        key = _md.digest();
      }
      _ipadding = forge$v.util.createBuffer();
      _opadding = forge$v.util.createBuffer();
      keylen = key.length();
      for (var i = 0; i < keylen; ++i) {
        var tmp = key.at(i);
        _ipadding.putByte(54 ^ tmp);
        _opadding.putByte(92 ^ tmp);
      }
      if (keylen < _md.blockLength) {
        var tmp = _md.blockLength - keylen;
        for (var i = 0; i < tmp; ++i) {
          _ipadding.putByte(54);
          _opadding.putByte(92);
        }
      }
      _key = key;
      _ipadding = _ipadding.bytes();
      _opadding = _opadding.bytes();
    }
    _md.start();
    _md.update(_ipadding);
  };
  ctx.update = function(bytes2) {
    _md.update(bytes2);
  };
  ctx.getMac = function() {
    var inner = _md.digest().bytes();
    _md.start();
    _md.update(_opadding);
    _md.update(inner);
    return _md.digest();
  };
  ctx.digest = ctx.getMac;
  return ctx;
};
var forge$u = forge$D;
var md5 = forge$u.md5 = forge$u.md5 || {};
forge$u.md.md5 = forge$u.md.algorithms.md5 = md5;
md5.create = function() {
  if (!_initialized$3) {
    _init$3();
  }
  var _state = null;
  var _input = forge$u.util.createBuffer();
  var _w = new Array(16);
  var md = {
    algorithm: "md5",
    blockLength: 64,
    digestLength: 16,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$u.util.createBuffer();
    _state = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$u.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$3(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$u.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$3.substr(0, md.blockLength - overflow));
    var bits, carry = 0;
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      bits = md.fullMessageLength[i] * 8 + carry;
      carry = bits / 4294967296 >>> 0;
      finalBlock.putInt32Le(bits >>> 0);
    }
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3
    };
    _update$3(s2, _w, finalBlock);
    var rval = forge$u.util.createBuffer();
    rval.putInt32Le(s2.h0);
    rval.putInt32Le(s2.h1);
    rval.putInt32Le(s2.h2);
    rval.putInt32Le(s2.h3);
    return rval;
  };
  return md;
};
var _padding$3 = null;
var _g = null;
var _r = null;
var _k$2 = null;
var _initialized$3 = false;
function _init$3() {
  _padding$3 = String.fromCharCode(128);
  _padding$3 += forge$u.util.fillString(String.fromCharCode(0), 64);
  _g = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    1,
    6,
    11,
    0,
    5,
    10,
    15,
    4,
    9,
    14,
    3,
    8,
    13,
    2,
    7,
    12,
    5,
    8,
    11,
    14,
    1,
    4,
    7,
    10,
    13,
    0,
    3,
    6,
    9,
    12,
    15,
    2,
    0,
    7,
    14,
    5,
    12,
    3,
    10,
    1,
    8,
    15,
    6,
    13,
    4,
    11,
    2,
    9
  ];
  _r = [
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    7,
    12,
    17,
    22,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    5,
    9,
    14,
    20,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    4,
    11,
    16,
    23,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21,
    6,
    10,
    15,
    21
  ];
  _k$2 = new Array(64);
  for (var i = 0; i < 64; ++i) {
    _k$2[i] = Math.floor(Math.abs(Math.sin(i + 1)) * 4294967296);
  }
  _initialized$3 = true;
}
function _update$3(s2, w2, bytes2) {
  var t2, a, b, c, d2, f, r, i;
  var len = bytes2.length();
  while (len >= 64) {
    a = s2.h0;
    b = s2.h1;
    c = s2.h2;
    d2 = s2.h3;
    for (i = 0; i < 16; ++i) {
      w2[i] = bytes2.getInt32Le();
      f = d2 ^ b & (c ^ d2);
      t2 = a + f + _k$2[i] + w2[i];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    for (; i < 32; ++i) {
      f = c ^ d2 & (b ^ c);
      t2 = a + f + _k$2[i] + w2[_g[i]];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    for (; i < 48; ++i) {
      f = b ^ c ^ d2;
      t2 = a + f + _k$2[i] + w2[_g[i]];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    for (; i < 64; ++i) {
      f = c ^ (b | ~d2);
      t2 = a + f + _k$2[i] + w2[_g[i]];
      r = _r[i];
      a = d2;
      d2 = c;
      c = b;
      b += t2 << r | t2 >>> 32 - r;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d2 | 0;
    len -= 64;
  }
}
var forge$t = forge$D;
var pem = forge$t.pem = forge$t.pem || {};
pem.encode = function(msg, options) {
  options = options || {};
  var rval = "-----BEGIN " + msg.type + "-----\r\n";
  var header3;
  if (msg.procType) {
    header3 = {
      name: "Proc-Type",
      values: [String(msg.procType.version), msg.procType.type]
    };
    rval += foldHeader(header3);
  }
  if (msg.contentDomain) {
    header3 = { name: "Content-Domain", values: [msg.contentDomain] };
    rval += foldHeader(header3);
  }
  if (msg.dekInfo) {
    header3 = { name: "DEK-Info", values: [msg.dekInfo.algorithm] };
    if (msg.dekInfo.parameters) {
      header3.values.push(msg.dekInfo.parameters);
    }
    rval += foldHeader(header3);
  }
  if (msg.headers) {
    for (var i = 0; i < msg.headers.length; ++i) {
      rval += foldHeader(msg.headers[i]);
    }
  }
  if (msg.procType) {
    rval += "\r\n";
  }
  rval += forge$t.util.encode64(msg.body, options.maxline || 64) + "\r\n";
  rval += "-----END " + msg.type + "-----\r\n";
  return rval;
};
pem.decode = function(str2) {
  var rval = [];
  var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
  var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
  var rCRLF = /\r?\n/;
  var match2;
  while (true) {
    match2 = rMessage.exec(str2);
    if (!match2) {
      break;
    }
    var type3 = match2[1];
    if (type3 === "NEW CERTIFICATE REQUEST") {
      type3 = "CERTIFICATE REQUEST";
    }
    var msg = {
      type: type3,
      procType: null,
      contentDomain: null,
      dekInfo: null,
      headers: [],
      body: forge$t.util.decode64(match2[3])
    };
    rval.push(msg);
    if (!match2[2]) {
      continue;
    }
    var lines = match2[2].split(rCRLF);
    var li = 0;
    while (match2 && li < lines.length) {
      var line = lines[li].replace(/\s+$/, "");
      for (var nl = li + 1; nl < lines.length; ++nl) {
        var next = lines[nl];
        if (!/\s/.test(next[0])) {
          break;
        }
        line += next;
        li = nl;
      }
      match2 = line.match(rHeader);
      if (match2) {
        var header3 = { name: match2[1], values: [] };
        var values = match2[2].split(",");
        for (var vi = 0; vi < values.length; ++vi) {
          header3.values.push(ltrim(values[vi]));
        }
        if (!msg.procType) {
          if (header3.name !== "Proc-Type") {
            throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
          } else if (header3.values.length !== 2) {
            throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
          }
          msg.procType = { version: values[0], type: values[1] };
        } else if (!msg.contentDomain && header3.name === "Content-Domain") {
          msg.contentDomain = values[0] || "";
        } else if (!msg.dekInfo && header3.name === "DEK-Info") {
          if (header3.values.length === 0) {
            throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
          }
          msg.dekInfo = { algorithm: values[0], parameters: values[1] || null };
        } else {
          msg.headers.push(header3);
        }
      }
      ++li;
    }
    if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
      throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
    }
  }
  if (rval.length === 0) {
    throw new Error("Invalid PEM formatted message.");
  }
  return rval;
};
function foldHeader(header3) {
  var rval = header3.name + ": ";
  var values = [];
  var insertSpace = function(match2, $1) {
    return " " + $1;
  };
  for (var i = 0; i < header3.values.length; ++i) {
    values.push(header3.values[i].replace(/^(\S+\r\n)/, insertSpace));
  }
  rval += values.join(",") + "\r\n";
  var length = 0;
  var candidate = -1;
  for (var i = 0; i < rval.length; ++i, ++length) {
    if (length > 65 && candidate !== -1) {
      var insert = rval[candidate];
      if (insert === ",") {
        ++candidate;
        rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
      } else {
        rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
      }
      length = i - candidate - 1;
      candidate = -1;
      ++i;
    } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
      candidate = i;
    }
  }
  return rval;
}
function ltrim(str2) {
  return str2.replace(/^\s+/, "");
}
var forge$s = forge$D;
forge$s.des = forge$s.des || {};
forge$s.des.startEncrypting = function(key, iv2, output, mode) {
  var cipher = _createCipher({
    key,
    output,
    decrypt: false,
    mode: mode || (iv2 === null ? "ECB" : "CBC")
  });
  cipher.start(iv2);
  return cipher;
};
forge$s.des.createEncryptionCipher = function(key, mode) {
  return _createCipher({
    key,
    output: null,
    decrypt: false,
    mode
  });
};
forge$s.des.startDecrypting = function(key, iv2, output, mode) {
  var cipher = _createCipher({
    key,
    output,
    decrypt: true,
    mode: mode || (iv2 === null ? "ECB" : "CBC")
  });
  cipher.start(iv2);
  return cipher;
};
forge$s.des.createDecryptionCipher = function(key, mode) {
  return _createCipher({
    key,
    output: null,
    decrypt: true,
    mode
  });
};
forge$s.des.Algorithm = function(name2, mode) {
  var self3 = this;
  self3.name = name2;
  self3.mode = new mode({
    blockSize: 8,
    cipher: {
      encrypt: function(inBlock, outBlock) {
        return _updateBlock(self3._keys, inBlock, outBlock, false);
      },
      decrypt: function(inBlock, outBlock) {
        return _updateBlock(self3._keys, inBlock, outBlock, true);
      }
    }
  });
  self3._init = false;
};
forge$s.des.Algorithm.prototype.initialize = function(options) {
  if (this._init) {
    return;
  }
  var key = forge$s.util.createBuffer(options.key);
  if (this.name.indexOf("3DES") === 0) {
    if (key.length() !== 24) {
      throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
    }
  }
  this._keys = _createKeys(key);
  this._init = true;
};
registerAlgorithm("DES-ECB", forge$s.cipher.modes.ecb);
registerAlgorithm("DES-CBC", forge$s.cipher.modes.cbc);
registerAlgorithm("DES-CFB", forge$s.cipher.modes.cfb);
registerAlgorithm("DES-OFB", forge$s.cipher.modes.ofb);
registerAlgorithm("DES-CTR", forge$s.cipher.modes.ctr);
registerAlgorithm("3DES-ECB", forge$s.cipher.modes.ecb);
registerAlgorithm("3DES-CBC", forge$s.cipher.modes.cbc);
registerAlgorithm("3DES-CFB", forge$s.cipher.modes.cfb);
registerAlgorithm("3DES-OFB", forge$s.cipher.modes.ofb);
registerAlgorithm("3DES-CTR", forge$s.cipher.modes.ctr);
function registerAlgorithm(name2, mode) {
  var factory = function() {
    return new forge$s.des.Algorithm(name2, mode);
  };
  forge$s.cipher.registerAlgorithm(name2, factory);
}
var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
function _createKeys(key) {
  var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
  var iterations = key.length() > 8 ? 3 : 1;
  var keys2 = [];
  var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
  var n = 0, tmp;
  for (var j2 = 0; j2 < iterations; j2++) {
    var left = key.getInt32();
    var right = key.getInt32();
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 2 ^ right) & 858993459;
    right ^= tmp;
    left ^= tmp << 2;
    tmp = (right >>> -16 ^ left) & 65535;
    left ^= tmp;
    right ^= tmp << -16;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = left << 8 | right >>> 20 & 240;
    left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
    right = tmp;
    for (var i = 0; i < shifts.length; ++i) {
      if (shifts[i]) {
        left = left << 2 | left >>> 26;
        right = right << 2 | right >>> 26;
      } else {
        left = left << 1 | left >>> 27;
        right = right << 1 | right >>> 27;
      }
      left &= -15;
      right &= -15;
      var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
      var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
      tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
      keys2[n++] = lefttmp ^ tmp;
      keys2[n++] = righttmp ^ tmp << 16;
    }
  }
  return keys2;
}
function _updateBlock(keys2, input, output, decrypt2) {
  var iterations = keys2.length === 32 ? 3 : 9;
  var looping;
  if (iterations === 3) {
    looping = decrypt2 ? [30, -2, -2] : [0, 32, 2];
  } else {
    looping = decrypt2 ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
  }
  var tmp;
  var left = input[0];
  var right = input[1];
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  left = left << 1 | left >>> 31;
  right = right << 1 | right >>> 31;
  for (var j2 = 0; j2 < iterations; j2 += 3) {
    var endloop = looping[j2 + 1];
    var loopinc = looping[j2 + 2];
    for (var i = looping[j2]; i != endloop; i += loopinc) {
      var right1 = right ^ keys2[i];
      var right2 = (right >>> 4 | right << 28) ^ keys2[i + 1];
      tmp = left;
      left = right;
      right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
    }
    tmp = left;
    left = right;
    right = tmp;
  }
  left = left >>> 1 | left << 31;
  right = right >>> 1 | right << 31;
  tmp = (left >>> 1 ^ right) & 1431655765;
  right ^= tmp;
  left ^= tmp << 1;
  tmp = (right >>> 8 ^ left) & 16711935;
  left ^= tmp;
  right ^= tmp << 8;
  tmp = (right >>> 2 ^ left) & 858993459;
  left ^= tmp;
  right ^= tmp << 2;
  tmp = (left >>> 16 ^ right) & 65535;
  right ^= tmp;
  left ^= tmp << 16;
  tmp = (left >>> 4 ^ right) & 252645135;
  right ^= tmp;
  left ^= tmp << 4;
  output[0] = left;
  output[1] = right;
}
function _createCipher(options) {
  options = options || {};
  var mode = (options.mode || "CBC").toUpperCase();
  var algorithm = "DES-" + mode;
  var cipher;
  if (options.decrypt) {
    cipher = forge$s.cipher.createDecipher(algorithm, options.key);
  } else {
    cipher = forge$s.cipher.createCipher(algorithm, options.key);
  }
  var start = cipher.start;
  cipher.start = function(iv2, options2) {
    var output = null;
    if (options2 instanceof forge$s.util.ByteBuffer) {
      output = options2;
      options2 = {};
    }
    options2 = options2 || {};
    options2.output = output;
    options2.iv = iv2;
    start.call(cipher, options2);
  };
  return cipher;
}
var forge$r = forge$D;
var pkcs5 = forge$r.pkcs5 = forge$r.pkcs5 || {};
var crypto$5;
if (forge$r.util.isNodejs && !forge$r.options.usePureJavaScript) {
  crypto$5 = require$$2$3;
}
forge$r.pbkdf2 = pkcs5.pbkdf2 = function(p, s2, c, dkLen, md, callback) {
  if (typeof md === "function") {
    callback = md;
    md = null;
  }
  if (forge$r.util.isNodejs && !forge$r.options.usePureJavaScript && crypto$5.pbkdf2 && (md === null || typeof md !== "object") && (crypto$5.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
    if (typeof md !== "string") {
      md = "sha1";
    }
    p = Buffer.from(p, "binary");
    s2 = Buffer.from(s2, "binary");
    if (!callback) {
      if (crypto$5.pbkdf2Sync.length === 4) {
        return crypto$5.pbkdf2Sync(p, s2, c, dkLen).toString("binary");
      }
      return crypto$5.pbkdf2Sync(p, s2, c, dkLen, md).toString("binary");
    }
    if (crypto$5.pbkdf2Sync.length === 4) {
      return crypto$5.pbkdf2(p, s2, c, dkLen, function(err2, key) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key.toString("binary"));
      });
    }
    return crypto$5.pbkdf2(p, s2, c, dkLen, md, function(err2, key) {
      if (err2) {
        return callback(err2);
      }
      callback(null, key.toString("binary"));
    });
  }
  if (typeof md === "undefined" || md === null) {
    md = "sha1";
  }
  if (typeof md === "string") {
    if (!(md in forge$r.md.algorithms)) {
      throw new Error("Unknown hash algorithm: " + md);
    }
    md = forge$r.md[md].create();
  }
  var hLen = md.digestLength;
  if (dkLen > 4294967295 * hLen) {
    var err = new Error("Derived key is too long.");
    if (callback) {
      return callback(err);
    }
    throw err;
  }
  var len = Math.ceil(dkLen / hLen);
  var r = dkLen - (len - 1) * hLen;
  var prf = forge$r.hmac.create();
  prf.start(md, p);
  var dk = "";
  var xor, u_c, u_c1;
  if (!callback) {
    for (var i = 1; i <= len; ++i) {
      prf.start(null, null);
      prf.update(s2);
      prf.update(forge$r.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();
      for (var j2 = 2; j2 <= c; ++j2) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge$r.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
      }
      dk += i < len ? xor : xor.substr(0, r);
    }
    return dk;
  }
  var i = 1, j2;
  function outer() {
    if (i > len) {
      return callback(null, dk);
    }
    prf.start(null, null);
    prf.update(s2);
    prf.update(forge$r.util.int32ToBytes(i));
    xor = u_c1 = prf.digest().getBytes();
    j2 = 2;
    inner();
  }
  function inner() {
    if (j2 <= c) {
      prf.start(null, null);
      prf.update(u_c1);
      u_c = prf.digest().getBytes();
      xor = forge$r.util.xorBytes(xor, u_c, hLen);
      u_c1 = u_c;
      ++j2;
      return forge$r.util.setImmediate(inner);
    }
    dk += i < len ? xor : xor.substr(0, r);
    ++i;
    outer();
  }
  outer();
};
var forge$q = forge$D;
var sha256 = forge$q.sha256 = forge$q.sha256 || {};
forge$q.md.sha256 = forge$q.md.algorithms.sha256 = sha256;
sha256.create = function() {
  if (!_initialized$2) {
    _init$2();
  }
  var _state = null;
  var _input = forge$q.util.createBuffer();
  var _w = new Array(64);
  var md = {
    algorithm: "sha256",
    blockLength: 64,
    digestLength: 32,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$q.util.createBuffer();
    _state = {
      h0: 1779033703,
      h1: 3144134277,
      h2: 1013904242,
      h3: 2773480762,
      h4: 1359893119,
      h5: 2600822924,
      h6: 528734635,
      h7: 1541459225
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$q.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$2(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$q.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$2.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4,
      h5: _state.h5,
      h6: _state.h6,
      h7: _state.h7
    };
    _update$2(s2, _w, finalBlock);
    var rval = forge$q.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    rval.putInt32(s2.h5);
    rval.putInt32(s2.h6);
    rval.putInt32(s2.h7);
    return rval;
  };
  return md;
};
var _padding$2 = null;
var _initialized$2 = false;
var _k$1 = null;
function _init$2() {
  _padding$2 = String.fromCharCode(128);
  _padding$2 += forge$q.util.fillString(String.fromCharCode(0), 64);
  _k$1 = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  _initialized$2 = true;
}
function _update$2(s2, w2, bytes2) {
  var t1, t2, s0, s1, ch, maj, i, a, b, c, d2, e, f, g, h2;
  var len = bytes2.length();
  while (len >= 64) {
    for (i = 0; i < 16; ++i) {
      w2[i] = bytes2.getInt32();
    }
    for (; i < 64; ++i) {
      t1 = w2[i - 2];
      t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
      t2 = w2[i - 15];
      t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
      w2[i] = t1 + w2[i - 7] + t2 + w2[i - 16] | 0;
    }
    a = s2.h0;
    b = s2.h1;
    c = s2.h2;
    d2 = s2.h3;
    e = s2.h4;
    f = s2.h5;
    g = s2.h6;
    h2 = s2.h7;
    for (i = 0; i < 64; ++i) {
      s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
      ch = g ^ e & (f ^ g);
      s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
      maj = a & b | c & (a ^ b);
      t1 = h2 + s1 + ch + _k$1[i] + w2[i];
      t2 = s0 + maj;
      h2 = g;
      g = f;
      f = e;
      e = d2 + t1 >>> 0;
      d2 = c;
      c = b;
      b = a;
      a = t1 + t2 >>> 0;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e | 0;
    s2.h5 = s2.h5 + f | 0;
    s2.h6 = s2.h6 + g | 0;
    s2.h7 = s2.h7 + h2 | 0;
    len -= 64;
  }
}
var forge$p = forge$D;
var _crypto$1 = null;
if (forge$p.util.isNodejs && !forge$p.options.usePureJavaScript && !process.versions["node-webkit"]) {
  _crypto$1 = require$$2$3;
}
var prng = forge$p.prng = forge$p.prng || {};
prng.create = function(plugin) {
  var ctx = {
    plugin,
    key: null,
    seed: null,
    time: null,
    // number of reseeds so far
    reseeds: 0,
    // amount of data generated so far
    generated: 0,
    // no initial key bytes
    keyBytes: ""
  };
  var md = plugin.md;
  var pools = new Array(32);
  for (var i = 0; i < 32; ++i) {
    pools[i] = md.create();
  }
  ctx.pools = pools;
  ctx.pool = 0;
  ctx.generate = function(count, callback) {
    if (!callback) {
      return ctx.generateSync(count);
    }
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    var b = forge$p.util.createBuffer();
    ctx.key = null;
    generate2();
    function generate2(err) {
      if (err) {
        return callback(err);
      }
      if (b.length() >= count) {
        return callback(null, b.getBytes(count));
      }
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        return forge$p.util.nextTick(function() {
          _reseed(generate2);
        });
      }
      var bytes2 = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes2.length;
      b.putBytes(bytes2);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      forge$p.util.setImmediate(generate2);
    }
  };
  ctx.generateSync = function(count) {
    var cipher = ctx.plugin.cipher;
    var increment = ctx.plugin.increment;
    var formatKey = ctx.plugin.formatKey;
    var formatSeed = ctx.plugin.formatSeed;
    ctx.key = null;
    var b = forge$p.util.createBuffer();
    while (b.length() < count) {
      if (ctx.generated > 1048575) {
        ctx.key = null;
      }
      if (ctx.key === null) {
        _reseedSync();
      }
      var bytes2 = cipher(ctx.key, ctx.seed);
      ctx.generated += bytes2.length;
      b.putBytes(bytes2);
      ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
      ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
    }
    return b.getBytes(count);
  };
  function _reseed(callback) {
    if (ctx.pools[0].messageLength >= 32) {
      _seed();
      return callback();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.seedFile(needed, function(err, bytes2) {
      if (err) {
        return callback(err);
      }
      ctx.collect(bytes2);
      _seed();
      callback();
    });
  }
  function _reseedSync() {
    if (ctx.pools[0].messageLength >= 32) {
      return _seed();
    }
    var needed = 32 - ctx.pools[0].messageLength << 5;
    ctx.collect(ctx.seedFileSync(needed));
    _seed();
  }
  function _seed() {
    ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
    var md2 = ctx.plugin.md.create();
    md2.update(ctx.keyBytes);
    var _2powK = 1;
    for (var k = 0; k < 32; ++k) {
      if (ctx.reseeds % _2powK === 0) {
        md2.update(ctx.pools[k].digest().getBytes());
        ctx.pools[k].start();
      }
      _2powK = _2powK << 1;
    }
    ctx.keyBytes = md2.digest().getBytes();
    md2.start();
    md2.update(ctx.keyBytes);
    var seedBytes = md2.digest().getBytes();
    ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
    ctx.seed = ctx.plugin.formatSeed(seedBytes);
    ctx.generated = 0;
  }
  function defaultSeedFile(needed) {
    var getRandomValues = null;
    var globalScope = forge$p.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    var b = forge$p.util.createBuffer();
    if (getRandomValues) {
      while (b.length() < needed) {
        var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
        var entropy = new Uint32Array(Math.floor(count));
        try {
          getRandomValues(entropy);
          for (var i2 = 0; i2 < entropy.length; ++i2) {
            b.putInt32(entropy[i2]);
          }
        } catch (e) {
          if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
            throw e;
          }
        }
      }
    }
    if (b.length() < needed) {
      var hi, lo, next;
      var seed = Math.floor(Math.random() * 65536);
      while (b.length() < needed) {
        lo = 16807 * (seed & 65535);
        hi = 16807 * (seed >> 16);
        lo += (hi & 32767) << 16;
        lo += hi >> 15;
        lo = (lo & 2147483647) + (lo >> 31);
        seed = lo & 4294967295;
        for (var i2 = 0; i2 < 3; ++i2) {
          next = seed >>> (i2 << 3);
          next ^= Math.floor(Math.random() * 256);
          b.putByte(next & 255);
        }
      }
    }
    return b.getBytes(needed);
  }
  if (_crypto$1) {
    ctx.seedFile = function(needed, callback) {
      _crypto$1.randomBytes(needed, function(err, bytes2) {
        if (err) {
          return callback(err);
        }
        callback(null, bytes2.toString());
      });
    };
    ctx.seedFileSync = function(needed) {
      return _crypto$1.randomBytes(needed).toString();
    };
  } else {
    ctx.seedFile = function(needed, callback) {
      try {
        callback(null, defaultSeedFile(needed));
      } catch (e) {
        callback(e);
      }
    };
    ctx.seedFileSync = defaultSeedFile;
  }
  ctx.collect = function(bytes2) {
    var count = bytes2.length;
    for (var i2 = 0; i2 < count; ++i2) {
      ctx.pools[ctx.pool].update(bytes2.substr(i2, 1));
      ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
    }
  };
  ctx.collectInt = function(i2, n) {
    var bytes2 = "";
    for (var x = 0; x < n; x += 8) {
      bytes2 += String.fromCharCode(i2 >> x & 255);
    }
    ctx.collect(bytes2);
  };
  ctx.registerWorker = function(worker) {
    if (worker === self) {
      ctx.seedFile = function(needed, callback) {
        function listener3(e) {
          var data2 = e.data;
          if (data2.forge && data2.forge.prng) {
            self.removeEventListener("message", listener3);
            callback(data2.forge.prng.err, data2.forge.prng.bytes);
          }
        }
        self.addEventListener("message", listener3);
        self.postMessage({ forge: { prng: { needed } } });
      };
    } else {
      var listener2 = function(e) {
        var data2 = e.data;
        if (data2.forge && data2.forge.prng) {
          ctx.seedFile(data2.forge.prng.needed, function(err, bytes2) {
            worker.postMessage({ forge: { prng: { err, bytes: bytes2 } } });
          });
        }
      };
      worker.addEventListener("message", listener2);
    }
  };
  return ctx;
};
var forge$o = forge$D;
(function() {
  if (forge$o.random && forge$o.random.getBytes) {
    forge$o.random;
    return;
  }
  (function(jQuery2) {
    var prng_aes = {};
    var _prng_aes_output = new Array(4);
    var _prng_aes_buffer = forge$o.util.createBuffer();
    prng_aes.formatKey = function(key2) {
      var tmp = forge$o.util.createBuffer(key2);
      key2 = new Array(4);
      key2[0] = tmp.getInt32();
      key2[1] = tmp.getInt32();
      key2[2] = tmp.getInt32();
      key2[3] = tmp.getInt32();
      return forge$o.aes._expandKey(key2, false);
    };
    prng_aes.formatSeed = function(seed) {
      var tmp = forge$o.util.createBuffer(seed);
      seed = new Array(4);
      seed[0] = tmp.getInt32();
      seed[1] = tmp.getInt32();
      seed[2] = tmp.getInt32();
      seed[3] = tmp.getInt32();
      return seed;
    };
    prng_aes.cipher = function(key2, seed) {
      forge$o.aes._updateBlock(key2, seed, _prng_aes_output, false);
      _prng_aes_buffer.putInt32(_prng_aes_output[0]);
      _prng_aes_buffer.putInt32(_prng_aes_output[1]);
      _prng_aes_buffer.putInt32(_prng_aes_output[2]);
      _prng_aes_buffer.putInt32(_prng_aes_output[3]);
      return _prng_aes_buffer.getBytes();
    };
    prng_aes.increment = function(seed) {
      ++seed[3];
      return seed;
    };
    prng_aes.md = forge$o.md.sha256;
    function spawnPrng() {
      var ctx = forge$o.prng.create(prng_aes);
      ctx.getBytes = function(count, callback) {
        return ctx.generate(count, callback);
      };
      ctx.getBytesSync = function(count) {
        return ctx.generate(count);
      };
      return ctx;
    }
    var _ctx = spawnPrng();
    var getRandomValues = null;
    var globalScope = forge$o.util.globalScope;
    var _crypto2 = globalScope.crypto || globalScope.msCrypto;
    if (_crypto2 && _crypto2.getRandomValues) {
      getRandomValues = function(arr) {
        return _crypto2.getRandomValues(arr);
      };
    }
    if (forge$o.options.usePureJavaScript || !forge$o.util.isNodejs && !getRandomValues) {
      _ctx.collectInt(+/* @__PURE__ */ new Date(), 32);
      if (typeof navigator !== "undefined") {
        var _navBytes = "";
        for (var key in navigator) {
          try {
            if (typeof navigator[key] == "string") {
              _navBytes += navigator[key];
            }
          } catch (e) {
          }
        }
        _ctx.collect(_navBytes);
        _navBytes = null;
      }
      if (jQuery2) {
        jQuery2().mousemove(function(e) {
          _ctx.collectInt(e.clientX, 16);
          _ctx.collectInt(e.clientY, 16);
        });
        jQuery2().keypress(function(e) {
          _ctx.collectInt(e.charCode, 8);
        });
      }
    }
    if (!forge$o.random) {
      forge$o.random = _ctx;
    } else {
      for (var key in _ctx) {
        forge$o.random[key] = _ctx[key];
      }
    }
    forge$o.random.createInstance = spawnPrng;
    forge$o.random;
  })(typeof jQuery !== "undefined" ? jQuery : null);
})();
var forge$n = forge$D;
var piTable = [
  217,
  120,
  249,
  196,
  25,
  221,
  181,
  237,
  40,
  233,
  253,
  121,
  74,
  160,
  216,
  157,
  198,
  126,
  55,
  131,
  43,
  118,
  83,
  142,
  98,
  76,
  100,
  136,
  68,
  139,
  251,
  162,
  23,
  154,
  89,
  245,
  135,
  179,
  79,
  19,
  97,
  69,
  109,
  141,
  9,
  129,
  125,
  50,
  189,
  143,
  64,
  235,
  134,
  183,
  123,
  11,
  240,
  149,
  33,
  34,
  92,
  107,
  78,
  130,
  84,
  214,
  101,
  147,
  206,
  96,
  178,
  28,
  115,
  86,
  192,
  20,
  167,
  140,
  241,
  220,
  18,
  117,
  202,
  31,
  59,
  190,
  228,
  209,
  66,
  61,
  212,
  48,
  163,
  60,
  182,
  38,
  111,
  191,
  14,
  218,
  70,
  105,
  7,
  87,
  39,
  242,
  29,
  155,
  188,
  148,
  67,
  3,
  248,
  17,
  199,
  246,
  144,
  239,
  62,
  231,
  6,
  195,
  213,
  47,
  200,
  102,
  30,
  215,
  8,
  232,
  234,
  222,
  128,
  82,
  238,
  247,
  132,
  170,
  114,
  172,
  53,
  77,
  106,
  42,
  150,
  26,
  210,
  113,
  90,
  21,
  73,
  116,
  75,
  159,
  208,
  94,
  4,
  24,
  164,
  236,
  194,
  224,
  65,
  110,
  15,
  81,
  203,
  204,
  36,
  145,
  175,
  80,
  161,
  244,
  112,
  57,
  153,
  124,
  58,
  133,
  35,
  184,
  180,
  122,
  252,
  2,
  54,
  91,
  37,
  85,
  151,
  49,
  45,
  93,
  250,
  152,
  227,
  138,
  146,
  174,
  5,
  223,
  41,
  16,
  103,
  108,
  186,
  201,
  211,
  0,
  230,
  207,
  225,
  158,
  168,
  44,
  99,
  22,
  1,
  63,
  88,
  226,
  137,
  169,
  13,
  56,
  52,
  27,
  171,
  51,
  255,
  176,
  187,
  72,
  12,
  95,
  185,
  177,
  205,
  46,
  197,
  243,
  219,
  71,
  229,
  165,
  156,
  119,
  10,
  166,
  32,
  104,
  254,
  127,
  193,
  173
];
var s = [1, 2, 3, 5];
var rol = function(word, bits) {
  return word << bits & 65535 | (word & 65535) >> 16 - bits;
};
var ror = function(word, bits) {
  return (word & 65535) >> bits | word << 16 - bits & 65535;
};
forge$n.rc2 = forge$n.rc2 || {};
forge$n.rc2.expandKey = function(key, effKeyBits) {
  if (typeof key === "string") {
    key = forge$n.util.createBuffer(key);
  }
  effKeyBits = effKeyBits || 128;
  var L2 = key;
  var T = key.length();
  var T1 = effKeyBits;
  var T8 = Math.ceil(T1 / 8);
  var TM = 255 >> (T1 & 7);
  var i;
  for (i = T; i < 128; i++) {
    L2.putByte(piTable[L2.at(i - 1) + L2.at(i - T) & 255]);
  }
  L2.setAt(128 - T8, piTable[L2.at(128 - T8) & TM]);
  for (i = 127 - T8; i >= 0; i--) {
    L2.setAt(i, piTable[L2.at(i + 1) ^ L2.at(i + T8)]);
  }
  return L2;
};
var createCipher = function(key, bits, encrypt2) {
  var _finish = false, _input = null, _output = null, _iv = null;
  var mixRound, mashRound;
  var i, j2, K = [];
  key = forge$n.rc2.expandKey(key, bits);
  for (i = 0; i < 64; i++) {
    K.push(key.getInt16Le());
  }
  if (encrypt2) {
    mixRound = function(R) {
      for (i = 0; i < 4; i++) {
        R[i] += K[j2] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
        R[i] = rol(R[i], s[i]);
        j2++;
      }
    };
    mashRound = function(R) {
      for (i = 0; i < 4; i++) {
        R[i] += K[R[(i + 3) % 4] & 63];
      }
    };
  } else {
    mixRound = function(R) {
      for (i = 3; i >= 0; i--) {
        R[i] = ror(R[i], s[i]);
        R[i] -= K[j2] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
        j2--;
      }
    };
    mashRound = function(R) {
      for (i = 3; i >= 0; i--) {
        R[i] -= K[R[(i + 3) % 4] & 63];
      }
    };
  }
  var runPlan = function(plan) {
    var R = [];
    for (i = 0; i < 4; i++) {
      var val = _input.getInt16Le();
      if (_iv !== null) {
        if (encrypt2) {
          val ^= _iv.getInt16Le();
        } else {
          _iv.putInt16Le(val);
        }
      }
      R.push(val & 65535);
    }
    j2 = encrypt2 ? 0 : 63;
    for (var ptr = 0; ptr < plan.length; ptr++) {
      for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
        plan[ptr][1](R);
      }
    }
    for (i = 0; i < 4; i++) {
      if (_iv !== null) {
        if (encrypt2) {
          _iv.putInt16Le(R[i]);
        } else {
          R[i] ^= _iv.getInt16Le();
        }
      }
      _output.putInt16Le(R[i]);
    }
  };
  var cipher = null;
  cipher = {
    /**
     * Starts or restarts the encryption or decryption process, whichever
     * was previously configured.
     *
     * To use the cipher in CBC mode, iv may be given either as a string
     * of bytes, or as a byte buffer.  For ECB mode, give null as iv.
     *
     * @param iv the initialization vector to use, null for ECB mode.
     * @param output the output the buffer to write to, null to create one.
     */
    start: function(iv2, output) {
      if (iv2) {
        if (typeof iv2 === "string") {
          iv2 = forge$n.util.createBuffer(iv2);
        }
      }
      _finish = false;
      _input = forge$n.util.createBuffer();
      _output = output || new forge$n.util.createBuffer();
      _iv = iv2;
      cipher.output = _output;
    },
    /**
     * Updates the next block.
     *
     * @param input the buffer to read from.
     */
    update: function(input) {
      if (!_finish) {
        _input.putBuffer(input);
      }
      while (_input.length() >= 8) {
        runPlan([
          [5, mixRound],
          [1, mashRound],
          [6, mixRound],
          [1, mashRound],
          [5, mixRound]
        ]);
      }
    },
    /**
     * Finishes encrypting or decrypting.
     *
     * @param pad a padding function to use, null for PKCS#7 padding,
     *           signature(blockSize, buffer, decrypt).
     *
     * @return true if successful, false on error.
     */
    finish: function(pad) {
      var rval = true;
      if (encrypt2) {
        if (pad) {
          rval = pad(8, _input, !encrypt2);
        } else {
          var padding = _input.length() === 8 ? 8 : 8 - _input.length();
          _input.fillWithByte(padding, padding);
        }
      }
      if (rval) {
        _finish = true;
        cipher.update();
      }
      if (!encrypt2) {
        rval = _input.length() === 0;
        if (rval) {
          if (pad) {
            rval = pad(8, _output, !encrypt2);
          } else {
            var len = _output.length();
            var count = _output.at(len - 1);
            if (count > len) {
              rval = false;
            } else {
              _output.truncate(count);
            }
          }
        }
      }
      return rval;
    }
  };
  return cipher;
};
forge$n.rc2.startEncrypting = function(key, iv2, output) {
  var cipher = forge$n.rc2.createEncryptionCipher(key, 128);
  cipher.start(iv2, output);
  return cipher;
};
forge$n.rc2.createEncryptionCipher = function(key, bits) {
  return createCipher(key, bits, true);
};
forge$n.rc2.startDecrypting = function(key, iv2, output) {
  var cipher = forge$n.rc2.createDecryptionCipher(key, 128);
  cipher.start(iv2, output);
  return cipher;
};
forge$n.rc2.createDecryptionCipher = function(key, bits) {
  return createCipher(key, bits, false);
};
var forge$m = forge$D;
forge$m.jsbn = forge$m.jsbn || {};
var dbits;
function BigInteger$4(a, b, c) {
  this.data = [];
  if (a != null)
    if ("number" == typeof a) this.fromNumber(a, b, c);
    else if (b == null && "string" != typeof a) this.fromString(a, 256);
    else this.fromString(a, b);
}
forge$m.jsbn.BigInteger = BigInteger$4;
function nbi() {
  return new BigInteger$4(null);
}
function am1(i, x, w2, j2, c, n) {
  while (--n >= 0) {
    var v = x * this.data[i++] + w2.data[j2] + c;
    c = Math.floor(v / 67108864);
    w2.data[j2++] = v & 67108863;
  }
  return c;
}
function am2(i, x, w2, j2, c, n) {
  var xl = x & 32767, xh = x >> 15;
  while (--n >= 0) {
    var l = this.data[i] & 32767;
    var h2 = this.data[i++] >> 15;
    var m2 = xh * l + h2 * xl;
    l = xl * l + ((m2 & 32767) << 15) + w2.data[j2] + (c & 1073741823);
    c = (l >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
    w2.data[j2++] = l & 1073741823;
  }
  return c;
}
function am3(i, x, w2, j2, c, n) {
  var xl = x & 16383, xh = x >> 14;
  while (--n >= 0) {
    var l = this.data[i] & 16383;
    var h2 = this.data[i++] >> 14;
    var m2 = xh * l + h2 * xl;
    l = xl * l + ((m2 & 16383) << 14) + w2.data[j2] + c;
    c = (l >> 28) + (m2 >> 14) + xh * h2;
    w2.data[j2++] = l & 268435455;
  }
  return c;
}
if (typeof navigator === "undefined") {
  BigInteger$4.prototype.am = am3;
  dbits = 28;
} else if (navigator.appName == "Microsoft Internet Explorer") {
  BigInteger$4.prototype.am = am2;
  dbits = 30;
} else if (navigator.appName != "Netscape") {
  BigInteger$4.prototype.am = am1;
  dbits = 26;
} else {
  BigInteger$4.prototype.am = am3;
  dbits = 28;
}
BigInteger$4.prototype.DB = dbits;
BigInteger$4.prototype.DM = (1 << dbits) - 1;
BigInteger$4.prototype.DV = 1 << dbits;
var BI_FP = 52;
BigInteger$4.prototype.FV = Math.pow(2, BI_FP);
BigInteger$4.prototype.F1 = BI_FP - dbits;
BigInteger$4.prototype.F2 = 2 * dbits - BI_FP;
var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
var BI_RC = new Array();
var rr, vv;
rr = "0".charCodeAt(0);
for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
rr = "a".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
rr = "A".charCodeAt(0);
for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
function int2char(n) {
  return BI_RM.charAt(n);
}
function intAt(s2, i) {
  var c = BI_RC[s2.charCodeAt(i)];
  return c == null ? -1 : c;
}
function bnpCopyTo(r) {
  for (var i = this.t - 1; i >= 0; --i) r.data[i] = this.data[i];
  r.t = this.t;
  r.s = this.s;
}
function bnpFromInt(x) {
  this.t = 1;
  this.s = x < 0 ? -1 : 0;
  if (x > 0) this.data[0] = x;
  else if (x < -1) this.data[0] = x + this.DV;
  else this.t = 0;
}
function nbv(i) {
  var r = nbi();
  r.fromInt(i);
  return r;
}
function bnpFromString(s2, b) {
  var k;
  if (b == 16) k = 4;
  else if (b == 8) k = 3;
  else if (b == 256) k = 8;
  else if (b == 2) k = 1;
  else if (b == 32) k = 5;
  else if (b == 4) k = 2;
  else {
    this.fromRadix(s2, b);
    return;
  }
  this.t = 0;
  this.s = 0;
  var i = s2.length, mi = false, sh = 0;
  while (--i >= 0) {
    var x = k == 8 ? s2[i] & 255 : intAt(s2, i);
    if (x < 0) {
      if (s2.charAt(i) == "-") mi = true;
      continue;
    }
    mi = false;
    if (sh == 0)
      this.data[this.t++] = x;
    else if (sh + k > this.DB) {
      this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
      this.data[this.t++] = x >> this.DB - sh;
    } else
      this.data[this.t - 1] |= x << sh;
    sh += k;
    if (sh >= this.DB) sh -= this.DB;
  }
  if (k == 8 && (s2[0] & 128) != 0) {
    this.s = -1;
    if (sh > 0) this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
  }
  this.clamp();
  if (mi) BigInteger$4.ZERO.subTo(this, this);
}
function bnpClamp() {
  var c = this.s & this.DM;
  while (this.t > 0 && this.data[this.t - 1] == c) --this.t;
}
function bnToString(b) {
  if (this.s < 0) return "-" + this.negate().toString(b);
  var k;
  if (b == 16) k = 4;
  else if (b == 8) k = 3;
  else if (b == 2) k = 1;
  else if (b == 32) k = 5;
  else if (b == 4) k = 2;
  else return this.toRadix(b);
  var km = (1 << k) - 1, d2, m2 = false, r = "", i = this.t;
  var p = this.DB - i * this.DB % k;
  if (i-- > 0) {
    if (p < this.DB && (d2 = this.data[i] >> p) > 0) {
      m2 = true;
      r = int2char(d2);
    }
    while (i >= 0) {
      if (p < k) {
        d2 = (this.data[i] & (1 << p) - 1) << k - p;
        d2 |= this.data[--i] >> (p += this.DB - k);
      } else {
        d2 = this.data[i] >> (p -= k) & km;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if (d2 > 0) m2 = true;
      if (m2) r += int2char(d2);
    }
  }
  return m2 ? r : "0";
}
function bnNegate() {
  var r = nbi();
  BigInteger$4.ZERO.subTo(this, r);
  return r;
}
function bnAbs() {
  return this.s < 0 ? this.negate() : this;
}
function bnCompareTo(a) {
  var r = this.s - a.s;
  if (r != 0) return r;
  var i = this.t;
  r = i - a.t;
  if (r != 0) return this.s < 0 ? -r : r;
  while (--i >= 0) if ((r = this.data[i] - a.data[i]) != 0) return r;
  return 0;
}
function nbits(x) {
  var r = 1, t2;
  if ((t2 = x >>> 16) != 0) {
    x = t2;
    r += 16;
  }
  if ((t2 = x >> 8) != 0) {
    x = t2;
    r += 8;
  }
  if ((t2 = x >> 4) != 0) {
    x = t2;
    r += 4;
  }
  if ((t2 = x >> 2) != 0) {
    x = t2;
    r += 2;
  }
  if ((t2 = x >> 1) != 0) {
    x = t2;
    r += 1;
  }
  return r;
}
function bnBitLength() {
  if (this.t <= 0) return 0;
  return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
}
function bnpDLShiftTo(n, r) {
  var i;
  for (i = this.t - 1; i >= 0; --i) r.data[i + n] = this.data[i];
  for (i = n - 1; i >= 0; --i) r.data[i] = 0;
  r.t = this.t + n;
  r.s = this.s;
}
function bnpDRShiftTo(n, r) {
  for (var i = n; i < this.t; ++i) r.data[i - n] = this.data[i];
  r.t = Math.max(this.t - n, 0);
  r.s = this.s;
}
function bnpLShiftTo(n, r) {
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << cbs) - 1;
  var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
  for (i = this.t - 1; i >= 0; --i) {
    r.data[i + ds + 1] = this.data[i] >> cbs | c;
    c = (this.data[i] & bm) << bs;
  }
  for (i = ds - 1; i >= 0; --i) r.data[i] = 0;
  r.data[ds] = c;
  r.t = this.t + ds + 1;
  r.s = this.s;
  r.clamp();
}
function bnpRShiftTo(n, r) {
  r.s = this.s;
  var ds = Math.floor(n / this.DB);
  if (ds >= this.t) {
    r.t = 0;
    return;
  }
  var bs = n % this.DB;
  var cbs = this.DB - bs;
  var bm = (1 << bs) - 1;
  r.data[0] = this.data[ds] >> bs;
  for (var i = ds + 1; i < this.t; ++i) {
    r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
    r.data[i - ds] = this.data[i] >> bs;
  }
  if (bs > 0) r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
  r.t = this.t - ds;
  r.clamp();
}
function bnpSubTo(a, r) {
  var i = 0, c = 0, m2 = Math.min(a.t, this.t);
  while (i < m2) {
    c += this.data[i] - a.data[i];
    r.data[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c -= a.s;
    while (i < this.t) {
      c += this.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c -= a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c -= a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c < -1) r.data[i++] = this.DV + c;
  else if (c > 0) r.data[i++] = c;
  r.t = i;
  r.clamp();
}
function bnpMultiplyTo(a, r) {
  var x = this.abs(), y2 = a.abs();
  var i = x.t;
  r.t = i + y2.t;
  while (--i >= 0) r.data[i] = 0;
  for (i = 0; i < y2.t; ++i) r.data[i + x.t] = x.am(0, y2.data[i], r, i, 0, x.t);
  r.s = 0;
  r.clamp();
  if (this.s != a.s) BigInteger$4.ZERO.subTo(r, r);
}
function bnpSquareTo(r) {
  var x = this.abs();
  var i = r.t = 2 * x.t;
  while (--i >= 0) r.data[i] = 0;
  for (i = 0; i < x.t - 1; ++i) {
    var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
    if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
      r.data[i + x.t] -= x.DV;
      r.data[i + x.t + 1] = 1;
    }
  }
  if (r.t > 0) r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
  r.s = 0;
  r.clamp();
}
function bnpDivRemTo(m2, q, r) {
  var pm = m2.abs();
  if (pm.t <= 0) return;
  var pt = this.abs();
  if (pt.t < pm.t) {
    if (q != null) q.fromInt(0);
    if (r != null) this.copyTo(r);
    return;
  }
  if (r == null) r = nbi();
  var y2 = nbi(), ts = this.s, ms2 = m2.s;
  var nsh = this.DB - nbits(pm.data[pm.t - 1]);
  if (nsh > 0) {
    pm.lShiftTo(nsh, y2);
    pt.lShiftTo(nsh, r);
  } else {
    pm.copyTo(y2);
    pt.copyTo(r);
  }
  var ys = y2.t;
  var y0 = y2.data[ys - 1];
  if (y0 == 0) return;
  var yt = y0 * (1 << this.F1) + (ys > 1 ? y2.data[ys - 2] >> this.F2 : 0);
  var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
  var i = r.t, j2 = i - ys, t2 = q == null ? nbi() : q;
  y2.dlShiftTo(j2, t2);
  if (r.compareTo(t2) >= 0) {
    r.data[r.t++] = 1;
    r.subTo(t2, r);
  }
  BigInteger$4.ONE.dlShiftTo(ys, t2);
  t2.subTo(y2, y2);
  while (y2.t < ys) y2.data[y2.t++] = 0;
  while (--j2 >= 0) {
    var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
    if ((r.data[i] += y2.am(0, qd, r, j2, 0, ys)) < qd) {
      y2.dlShiftTo(j2, t2);
      r.subTo(t2, r);
      while (r.data[i] < --qd) r.subTo(t2, r);
    }
  }
  if (q != null) {
    r.drShiftTo(ys, q);
    if (ts != ms2) BigInteger$4.ZERO.subTo(q, q);
  }
  r.t = ys;
  r.clamp();
  if (nsh > 0) r.rShiftTo(nsh, r);
  if (ts < 0) BigInteger$4.ZERO.subTo(r, r);
}
function bnMod(a) {
  var r = nbi();
  this.abs().divRemTo(a, null, r);
  if (this.s < 0 && r.compareTo(BigInteger$4.ZERO) > 0) a.subTo(r, r);
  return r;
}
function Classic(m2) {
  this.m = m2;
}
function cConvert(x) {
  if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
  else return x;
}
function cRevert(x) {
  return x;
}
function cReduce(x) {
  x.divRemTo(this.m, null, x);
}
function cMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
  this.reduce(r);
}
function cSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
Classic.prototype.convert = cConvert;
Classic.prototype.revert = cRevert;
Classic.prototype.reduce = cReduce;
Classic.prototype.mulTo = cMulTo;
Classic.prototype.sqrTo = cSqrTo;
function bnpInvDigit() {
  if (this.t < 1) return 0;
  var x = this.data[0];
  if ((x & 1) == 0) return 0;
  var y2 = x & 3;
  y2 = y2 * (2 - (x & 15) * y2) & 15;
  y2 = y2 * (2 - (x & 255) * y2) & 255;
  y2 = y2 * (2 - ((x & 65535) * y2 & 65535)) & 65535;
  y2 = y2 * (2 - x * y2 % this.DV) % this.DV;
  return y2 > 0 ? this.DV - y2 : -y2;
}
function Montgomery(m2) {
  this.m = m2;
  this.mp = m2.invDigit();
  this.mpl = this.mp & 32767;
  this.mph = this.mp >> 15;
  this.um = (1 << m2.DB - 15) - 1;
  this.mt2 = 2 * m2.t;
}
function montConvert(x) {
  var r = nbi();
  x.abs().dlShiftTo(this.m.t, r);
  r.divRemTo(this.m, null, r);
  if (x.s < 0 && r.compareTo(BigInteger$4.ZERO) > 0) this.m.subTo(r, r);
  return r;
}
function montRevert(x) {
  var r = nbi();
  x.copyTo(r);
  this.reduce(r);
  return r;
}
function montReduce(x) {
  while (x.t <= this.mt2)
    x.data[x.t++] = 0;
  for (var i = 0; i < this.m.t; ++i) {
    var j2 = x.data[i] & 32767;
    var u0 = j2 * this.mpl + ((j2 * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
    j2 = i + this.m.t;
    x.data[j2] += this.m.am(0, u0, x, i, 0, this.m.t);
    while (x.data[j2] >= x.DV) {
      x.data[j2] -= x.DV;
      x.data[++j2]++;
    }
  }
  x.clamp();
  x.drShiftTo(this.m.t, x);
  if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}
function montSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function montMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
  this.reduce(r);
}
Montgomery.prototype.convert = montConvert;
Montgomery.prototype.revert = montRevert;
Montgomery.prototype.reduce = montReduce;
Montgomery.prototype.mulTo = montMulTo;
Montgomery.prototype.sqrTo = montSqrTo;
function bnpIsEven() {
  return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
}
function bnpExp(e, z) {
  if (e > 4294967295 || e < 1) return BigInteger$4.ONE;
  var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
  g.copyTo(r);
  while (--i >= 0) {
    z.sqrTo(r, r2);
    if ((e & 1 << i) > 0) z.mulTo(r2, g, r);
    else {
      var t2 = r;
      r = r2;
      r2 = t2;
    }
  }
  return z.revert(r);
}
function bnModPowInt(e, m2) {
  var z;
  if (e < 256 || m2.isEven()) z = new Classic(m2);
  else z = new Montgomery(m2);
  return this.exp(e, z);
}
BigInteger$4.prototype.copyTo = bnpCopyTo;
BigInteger$4.prototype.fromInt = bnpFromInt;
BigInteger$4.prototype.fromString = bnpFromString;
BigInteger$4.prototype.clamp = bnpClamp;
BigInteger$4.prototype.dlShiftTo = bnpDLShiftTo;
BigInteger$4.prototype.drShiftTo = bnpDRShiftTo;
BigInteger$4.prototype.lShiftTo = bnpLShiftTo;
BigInteger$4.prototype.rShiftTo = bnpRShiftTo;
BigInteger$4.prototype.subTo = bnpSubTo;
BigInteger$4.prototype.multiplyTo = bnpMultiplyTo;
BigInteger$4.prototype.squareTo = bnpSquareTo;
BigInteger$4.prototype.divRemTo = bnpDivRemTo;
BigInteger$4.prototype.invDigit = bnpInvDigit;
BigInteger$4.prototype.isEven = bnpIsEven;
BigInteger$4.prototype.exp = bnpExp;
BigInteger$4.prototype.toString = bnToString;
BigInteger$4.prototype.negate = bnNegate;
BigInteger$4.prototype.abs = bnAbs;
BigInteger$4.prototype.compareTo = bnCompareTo;
BigInteger$4.prototype.bitLength = bnBitLength;
BigInteger$4.prototype.mod = bnMod;
BigInteger$4.prototype.modPowInt = bnModPowInt;
BigInteger$4.ZERO = nbv(0);
BigInteger$4.ONE = nbv(1);
function bnClone() {
  var r = nbi();
  this.copyTo(r);
  return r;
}
function bnIntValue() {
  if (this.s < 0) {
    if (this.t == 1) return this.data[0] - this.DV;
    else if (this.t == 0) return -1;
  } else if (this.t == 1) return this.data[0];
  else if (this.t == 0) return 0;
  return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
}
function bnByteValue() {
  return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
}
function bnShortValue() {
  return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
}
function bnpChunkSize(r) {
  return Math.floor(Math.LN2 * this.DB / Math.log(r));
}
function bnSigNum() {
  if (this.s < 0) return -1;
  else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0) return 0;
  else return 1;
}
function bnpToRadix(b) {
  if (b == null) b = 10;
  if (this.signum() == 0 || b < 2 || b > 36) return "0";
  var cs = this.chunkSize(b);
  var a = Math.pow(b, cs);
  var d2 = nbv(a), y2 = nbi(), z = nbi(), r = "";
  this.divRemTo(d2, y2, z);
  while (y2.signum() > 0) {
    r = (a + z.intValue()).toString(b).substr(1) + r;
    y2.divRemTo(d2, y2, z);
  }
  return z.intValue().toString(b) + r;
}
function bnpFromRadix(s2, b) {
  this.fromInt(0);
  if (b == null) b = 10;
  var cs = this.chunkSize(b);
  var d2 = Math.pow(b, cs), mi = false, j2 = 0, w2 = 0;
  for (var i = 0; i < s2.length; ++i) {
    var x = intAt(s2, i);
    if (x < 0) {
      if (s2.charAt(i) == "-" && this.signum() == 0) mi = true;
      continue;
    }
    w2 = b * w2 + x;
    if (++j2 >= cs) {
      this.dMultiply(d2);
      this.dAddOffset(w2, 0);
      j2 = 0;
      w2 = 0;
    }
  }
  if (j2 > 0) {
    this.dMultiply(Math.pow(b, j2));
    this.dAddOffset(w2, 0);
  }
  if (mi) BigInteger$4.ZERO.subTo(this, this);
}
function bnpFromNumber(a, b, c) {
  if ("number" == typeof b) {
    if (a < 2) this.fromInt(1);
    else {
      this.fromNumber(a, c);
      if (!this.testBit(a - 1))
        this.bitwiseTo(BigInteger$4.ONE.shiftLeft(a - 1), op_or, this);
      if (this.isEven()) this.dAddOffset(1, 0);
      while (!this.isProbablePrime(b)) {
        this.dAddOffset(2, 0);
        if (this.bitLength() > a) this.subTo(BigInteger$4.ONE.shiftLeft(a - 1), this);
      }
    }
  } else {
    var x = new Array(), t2 = a & 7;
    x.length = (a >> 3) + 1;
    b.nextBytes(x);
    if (t2 > 0) x[0] &= (1 << t2) - 1;
    else x[0] = 0;
    this.fromString(x, 256);
  }
}
function bnToByteArray() {
  var i = this.t, r = new Array();
  r[0] = this.s;
  var p = this.DB - i * this.DB % 8, d2, k = 0;
  if (i-- > 0) {
    if (p < this.DB && (d2 = this.data[i] >> p) != (this.s & this.DM) >> p)
      r[k++] = d2 | this.s << this.DB - p;
    while (i >= 0) {
      if (p < 8) {
        d2 = (this.data[i] & (1 << p) - 1) << 8 - p;
        d2 |= this.data[--i] >> (p += this.DB - 8);
      } else {
        d2 = this.data[i] >> (p -= 8) & 255;
        if (p <= 0) {
          p += this.DB;
          --i;
        }
      }
      if ((d2 & 128) != 0) d2 |= -256;
      if (k == 0 && (this.s & 128) != (d2 & 128)) ++k;
      if (k > 0 || d2 != this.s) r[k++] = d2;
    }
  }
  return r;
}
function bnEquals(a) {
  return this.compareTo(a) == 0;
}
function bnMin(a) {
  return this.compareTo(a) < 0 ? this : a;
}
function bnMax(a) {
  return this.compareTo(a) > 0 ? this : a;
}
function bnpBitwiseTo(a, op, r) {
  var i, f, m2 = Math.min(a.t, this.t);
  for (i = 0; i < m2; ++i) r.data[i] = op(this.data[i], a.data[i]);
  if (a.t < this.t) {
    f = a.s & this.DM;
    for (i = m2; i < this.t; ++i) r.data[i] = op(this.data[i], f);
    r.t = this.t;
  } else {
    f = this.s & this.DM;
    for (i = m2; i < a.t; ++i) r.data[i] = op(f, a.data[i]);
    r.t = a.t;
  }
  r.s = op(this.s, a.s);
  r.clamp();
}
function op_and(x, y2) {
  return x & y2;
}
function bnAnd(a) {
  var r = nbi();
  this.bitwiseTo(a, op_and, r);
  return r;
}
function op_or(x, y2) {
  return x | y2;
}
function bnOr(a) {
  var r = nbi();
  this.bitwiseTo(a, op_or, r);
  return r;
}
function op_xor(x, y2) {
  return x ^ y2;
}
function bnXor(a) {
  var r = nbi();
  this.bitwiseTo(a, op_xor, r);
  return r;
}
function op_andnot(x, y2) {
  return x & ~y2;
}
function bnAndNot(a) {
  var r = nbi();
  this.bitwiseTo(a, op_andnot, r);
  return r;
}
function bnNot() {
  var r = nbi();
  for (var i = 0; i < this.t; ++i) r.data[i] = this.DM & ~this.data[i];
  r.t = this.t;
  r.s = ~this.s;
  return r;
}
function bnShiftLeft(n) {
  var r = nbi();
  if (n < 0) this.rShiftTo(-n, r);
  else this.lShiftTo(n, r);
  return r;
}
function bnShiftRight(n) {
  var r = nbi();
  if (n < 0) this.lShiftTo(-n, r);
  else this.rShiftTo(n, r);
  return r;
}
function lbit(x) {
  if (x == 0) return -1;
  var r = 0;
  if ((x & 65535) == 0) {
    x >>= 16;
    r += 16;
  }
  if ((x & 255) == 0) {
    x >>= 8;
    r += 8;
  }
  if ((x & 15) == 0) {
    x >>= 4;
    r += 4;
  }
  if ((x & 3) == 0) {
    x >>= 2;
    r += 2;
  }
  if ((x & 1) == 0) ++r;
  return r;
}
function bnGetLowestSetBit() {
  for (var i = 0; i < this.t; ++i)
    if (this.data[i] != 0) return i * this.DB + lbit(this.data[i]);
  if (this.s < 0) return this.t * this.DB;
  return -1;
}
function cbit(x) {
  var r = 0;
  while (x != 0) {
    x &= x - 1;
    ++r;
  }
  return r;
}
function bnBitCount() {
  var r = 0, x = this.s & this.DM;
  for (var i = 0; i < this.t; ++i) r += cbit(this.data[i] ^ x);
  return r;
}
function bnTestBit(n) {
  var j2 = Math.floor(n / this.DB);
  if (j2 >= this.t) return this.s != 0;
  return (this.data[j2] & 1 << n % this.DB) != 0;
}
function bnpChangeBit(n, op) {
  var r = BigInteger$4.ONE.shiftLeft(n);
  this.bitwiseTo(r, op, r);
  return r;
}
function bnSetBit(n) {
  return this.changeBit(n, op_or);
}
function bnClearBit(n) {
  return this.changeBit(n, op_andnot);
}
function bnFlipBit(n) {
  return this.changeBit(n, op_xor);
}
function bnpAddTo(a, r) {
  var i = 0, c = 0, m2 = Math.min(a.t, this.t);
  while (i < m2) {
    c += this.data[i] + a.data[i];
    r.data[i++] = c & this.DM;
    c >>= this.DB;
  }
  if (a.t < this.t) {
    c += a.s;
    while (i < this.t) {
      c += this.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += this.s;
  } else {
    c += this.s;
    while (i < a.t) {
      c += a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    c += a.s;
  }
  r.s = c < 0 ? -1 : 0;
  if (c > 0) r.data[i++] = c;
  else if (c < -1) r.data[i++] = this.DV + c;
  r.t = i;
  r.clamp();
}
function bnAdd(a) {
  var r = nbi();
  this.addTo(a, r);
  return r;
}
function bnSubtract(a) {
  var r = nbi();
  this.subTo(a, r);
  return r;
}
function bnMultiply(a) {
  var r = nbi();
  this.multiplyTo(a, r);
  return r;
}
function bnDivide(a) {
  var r = nbi();
  this.divRemTo(a, r, null);
  return r;
}
function bnRemainder(a) {
  var r = nbi();
  this.divRemTo(a, null, r);
  return r;
}
function bnDivideAndRemainder(a) {
  var q = nbi(), r = nbi();
  this.divRemTo(a, q, r);
  return new Array(q, r);
}
function bnpDMultiply(n) {
  this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
  ++this.t;
  this.clamp();
}
function bnpDAddOffset(n, w2) {
  if (n == 0) return;
  while (this.t <= w2) this.data[this.t++] = 0;
  this.data[w2] += n;
  while (this.data[w2] >= this.DV) {
    this.data[w2] -= this.DV;
    if (++w2 >= this.t) this.data[this.t++] = 0;
    ++this.data[w2];
  }
}
function NullExp() {
}
function nNop(x) {
  return x;
}
function nMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
}
function nSqrTo(x, r) {
  x.squareTo(r);
}
NullExp.prototype.convert = nNop;
NullExp.prototype.revert = nNop;
NullExp.prototype.mulTo = nMulTo;
NullExp.prototype.sqrTo = nSqrTo;
function bnPow(e) {
  return this.exp(e, new NullExp());
}
function bnpMultiplyLowerTo(a, n, r) {
  var i = Math.min(this.t + a.t, n);
  r.s = 0;
  r.t = i;
  while (i > 0) r.data[--i] = 0;
  var j2;
  for (j2 = r.t - this.t; i < j2; ++i) r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
  for (j2 = Math.min(a.t, n); i < j2; ++i) this.am(0, a.data[i], r, i, 0, n - i);
  r.clamp();
}
function bnpMultiplyUpperTo(a, n, r) {
  --n;
  var i = r.t = this.t + a.t - n;
  r.s = 0;
  while (--i >= 0) r.data[i] = 0;
  for (i = Math.max(n - this.t, 0); i < a.t; ++i)
    r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
  r.clamp();
  r.drShiftTo(1, r);
}
function Barrett(m2) {
  this.r2 = nbi();
  this.q3 = nbi();
  BigInteger$4.ONE.dlShiftTo(2 * m2.t, this.r2);
  this.mu = this.r2.divide(m2);
  this.m = m2;
}
function barrettConvert(x) {
  if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
  else if (x.compareTo(this.m) < 0) return x;
  else {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
}
function barrettRevert(x) {
  return x;
}
function barrettReduce(x) {
  x.drShiftTo(this.m.t - 1, this.r2);
  if (x.t > this.m.t + 1) {
    x.t = this.m.t + 1;
    x.clamp();
  }
  this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
  this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
  while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
  x.subTo(this.r2, x);
  while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
}
function barrettSqrTo(x, r) {
  x.squareTo(r);
  this.reduce(r);
}
function barrettMulTo(x, y2, r) {
  x.multiplyTo(y2, r);
  this.reduce(r);
}
Barrett.prototype.convert = barrettConvert;
Barrett.prototype.revert = barrettRevert;
Barrett.prototype.reduce = barrettReduce;
Barrett.prototype.mulTo = barrettMulTo;
Barrett.prototype.sqrTo = barrettSqrTo;
function bnModPow(e, m2) {
  var i = e.bitLength(), k, r = nbv(1), z;
  if (i <= 0) return r;
  else if (i < 18) k = 1;
  else if (i < 48) k = 3;
  else if (i < 144) k = 4;
  else if (i < 768) k = 5;
  else k = 6;
  if (i < 8)
    z = new Classic(m2);
  else if (m2.isEven())
    z = new Barrett(m2);
  else
    z = new Montgomery(m2);
  var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
  g[1] = z.convert(this);
  if (k > 1) {
    var g2 = nbi();
    z.sqrTo(g[1], g2);
    while (n <= km) {
      g[n] = nbi();
      z.mulTo(g2, g[n - 2], g[n]);
      n += 2;
    }
  }
  var j2 = e.t - 1, w2, is1 = true, r2 = nbi(), t2;
  i = nbits(e.data[j2]) - 1;
  while (j2 >= 0) {
    if (i >= k1) w2 = e.data[j2] >> i - k1 & km;
    else {
      w2 = (e.data[j2] & (1 << i + 1) - 1) << k1 - i;
      if (j2 > 0) w2 |= e.data[j2 - 1] >> this.DB + i - k1;
    }
    n = k;
    while ((w2 & 1) == 0) {
      w2 >>= 1;
      --n;
    }
    if ((i -= n) < 0) {
      i += this.DB;
      --j2;
    }
    if (is1) {
      g[w2].copyTo(r);
      is1 = false;
    } else {
      while (n > 1) {
        z.sqrTo(r, r2);
        z.sqrTo(r2, r);
        n -= 2;
      }
      if (n > 0) z.sqrTo(r, r2);
      else {
        t2 = r;
        r = r2;
        r2 = t2;
      }
      z.mulTo(r2, g[w2], r);
    }
    while (j2 >= 0 && (e.data[j2] & 1 << i) == 0) {
      z.sqrTo(r, r2);
      t2 = r;
      r = r2;
      r2 = t2;
      if (--i < 0) {
        i = this.DB - 1;
        --j2;
      }
    }
  }
  return z.revert(r);
}
function bnGCD(a) {
  var x = this.s < 0 ? this.negate() : this.clone();
  var y2 = a.s < 0 ? a.negate() : a.clone();
  if (x.compareTo(y2) < 0) {
    var t2 = x;
    x = y2;
    y2 = t2;
  }
  var i = x.getLowestSetBit(), g = y2.getLowestSetBit();
  if (g < 0) return x;
  if (i < g) g = i;
  if (g > 0) {
    x.rShiftTo(g, x);
    y2.rShiftTo(g, y2);
  }
  while (x.signum() > 0) {
    if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
    if ((i = y2.getLowestSetBit()) > 0) y2.rShiftTo(i, y2);
    if (x.compareTo(y2) >= 0) {
      x.subTo(y2, x);
      x.rShiftTo(1, x);
    } else {
      y2.subTo(x, y2);
      y2.rShiftTo(1, y2);
    }
  }
  if (g > 0) y2.lShiftTo(g, y2);
  return y2;
}
function bnpModInt(n) {
  if (n <= 0) return 0;
  var d2 = this.DV % n, r = this.s < 0 ? n - 1 : 0;
  if (this.t > 0)
    if (d2 == 0) r = this.data[0] % n;
    else for (var i = this.t - 1; i >= 0; --i) r = (d2 * r + this.data[i]) % n;
  return r;
}
function bnModInverse(m2) {
  var ac = m2.isEven();
  if (this.isEven() && ac || m2.signum() == 0) return BigInteger$4.ZERO;
  var u2 = m2.clone(), v = this.clone();
  var a = nbv(1), b = nbv(0), c = nbv(0), d2 = nbv(1);
  while (u2.signum() != 0) {
    while (u2.isEven()) {
      u2.rShiftTo(1, u2);
      if (ac) {
        if (!a.isEven() || !b.isEven()) {
          a.addTo(this, a);
          b.subTo(m2, b);
        }
        a.rShiftTo(1, a);
      } else if (!b.isEven()) b.subTo(m2, b);
      b.rShiftTo(1, b);
    }
    while (v.isEven()) {
      v.rShiftTo(1, v);
      if (ac) {
        if (!c.isEven() || !d2.isEven()) {
          c.addTo(this, c);
          d2.subTo(m2, d2);
        }
        c.rShiftTo(1, c);
      } else if (!d2.isEven()) d2.subTo(m2, d2);
      d2.rShiftTo(1, d2);
    }
    if (u2.compareTo(v) >= 0) {
      u2.subTo(v, u2);
      if (ac) a.subTo(c, a);
      b.subTo(d2, b);
    } else {
      v.subTo(u2, v);
      if (ac) c.subTo(a, c);
      d2.subTo(b, d2);
    }
  }
  if (v.compareTo(BigInteger$4.ONE) != 0) return BigInteger$4.ZERO;
  if (d2.compareTo(m2) >= 0) return d2.subtract(m2);
  if (d2.signum() < 0) d2.addTo(m2, d2);
  else return d2;
  if (d2.signum() < 0) return d2.add(m2);
  else return d2;
}
var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
function bnIsProbablePrime(t2) {
  var i, x = this.abs();
  if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
    for (i = 0; i < lowprimes.length; ++i)
      if (x.data[0] == lowprimes[i]) return true;
    return false;
  }
  if (x.isEven()) return false;
  i = 1;
  while (i < lowprimes.length) {
    var m2 = lowprimes[i], j2 = i + 1;
    while (j2 < lowprimes.length && m2 < lplim) m2 *= lowprimes[j2++];
    m2 = x.modInt(m2);
    while (i < j2) if (m2 % lowprimes[i++] == 0) return false;
  }
  return x.millerRabin(t2);
}
function bnpMillerRabin(t2) {
  var n1 = this.subtract(BigInteger$4.ONE);
  var k = n1.getLowestSetBit();
  if (k <= 0) return false;
  var r = n1.shiftRight(k);
  var prng2 = bnGetPrng();
  var a;
  for (var i = 0; i < t2; ++i) {
    do {
      a = new BigInteger$4(this.bitLength(), prng2);
    } while (a.compareTo(BigInteger$4.ONE) <= 0 || a.compareTo(n1) >= 0);
    var y2 = a.modPow(r, this);
    if (y2.compareTo(BigInteger$4.ONE) != 0 && y2.compareTo(n1) != 0) {
      var j2 = 1;
      while (j2++ < k && y2.compareTo(n1) != 0) {
        y2 = y2.modPowInt(2, this);
        if (y2.compareTo(BigInteger$4.ONE) == 0) return false;
      }
      if (y2.compareTo(n1) != 0) return false;
    }
  }
  return true;
}
function bnGetPrng() {
  return {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      for (var i = 0; i < x.length; ++i) {
        x[i] = Math.floor(Math.random() * 256);
      }
    }
  };
}
BigInteger$4.prototype.chunkSize = bnpChunkSize;
BigInteger$4.prototype.toRadix = bnpToRadix;
BigInteger$4.prototype.fromRadix = bnpFromRadix;
BigInteger$4.prototype.fromNumber = bnpFromNumber;
BigInteger$4.prototype.bitwiseTo = bnpBitwiseTo;
BigInteger$4.prototype.changeBit = bnpChangeBit;
BigInteger$4.prototype.addTo = bnpAddTo;
BigInteger$4.prototype.dMultiply = bnpDMultiply;
BigInteger$4.prototype.dAddOffset = bnpDAddOffset;
BigInteger$4.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
BigInteger$4.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
BigInteger$4.prototype.modInt = bnpModInt;
BigInteger$4.prototype.millerRabin = bnpMillerRabin;
BigInteger$4.prototype.clone = bnClone;
BigInteger$4.prototype.intValue = bnIntValue;
BigInteger$4.prototype.byteValue = bnByteValue;
BigInteger$4.prototype.shortValue = bnShortValue;
BigInteger$4.prototype.signum = bnSigNum;
BigInteger$4.prototype.toByteArray = bnToByteArray;
BigInteger$4.prototype.equals = bnEquals;
BigInteger$4.prototype.min = bnMin;
BigInteger$4.prototype.max = bnMax;
BigInteger$4.prototype.and = bnAnd;
BigInteger$4.prototype.or = bnOr;
BigInteger$4.prototype.xor = bnXor;
BigInteger$4.prototype.andNot = bnAndNot;
BigInteger$4.prototype.not = bnNot;
BigInteger$4.prototype.shiftLeft = bnShiftLeft;
BigInteger$4.prototype.shiftRight = bnShiftRight;
BigInteger$4.prototype.getLowestSetBit = bnGetLowestSetBit;
BigInteger$4.prototype.bitCount = bnBitCount;
BigInteger$4.prototype.testBit = bnTestBit;
BigInteger$4.prototype.setBit = bnSetBit;
BigInteger$4.prototype.clearBit = bnClearBit;
BigInteger$4.prototype.flipBit = bnFlipBit;
BigInteger$4.prototype.add = bnAdd;
BigInteger$4.prototype.subtract = bnSubtract;
BigInteger$4.prototype.multiply = bnMultiply;
BigInteger$4.prototype.divide = bnDivide;
BigInteger$4.prototype.remainder = bnRemainder;
BigInteger$4.prototype.divideAndRemainder = bnDivideAndRemainder;
BigInteger$4.prototype.modPow = bnModPow;
BigInteger$4.prototype.modInverse = bnModInverse;
BigInteger$4.prototype.pow = bnPow;
BigInteger$4.prototype.gcd = bnGCD;
BigInteger$4.prototype.isProbablePrime = bnIsProbablePrime;
var forge$l = forge$D;
var sha1 = forge$l.sha1 = forge$l.sha1 || {};
forge$l.md.sha1 = forge$l.md.algorithms.sha1 = sha1;
sha1.create = function() {
  if (!_initialized$1) {
    _init$1();
  }
  var _state = null;
  var _input = forge$l.util.createBuffer();
  var _w = new Array(80);
  var md = {
    algorithm: "sha1",
    blockLength: 64,
    digestLength: 20,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 8
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength64 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$l.util.createBuffer();
    _state = {
      h0: 1732584193,
      h1: 4023233417,
      h2: 2562383102,
      h3: 271733878,
      h4: 3285377520
    };
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$l.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update$1(_state, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$l.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding$1.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var s2 = {
      h0: _state.h0,
      h1: _state.h1,
      h2: _state.h2,
      h3: _state.h3,
      h4: _state.h4
    };
    _update$1(s2, _w, finalBlock);
    var rval = forge$l.util.createBuffer();
    rval.putInt32(s2.h0);
    rval.putInt32(s2.h1);
    rval.putInt32(s2.h2);
    rval.putInt32(s2.h3);
    rval.putInt32(s2.h4);
    return rval;
  };
  return md;
};
var _padding$1 = null;
var _initialized$1 = false;
function _init$1() {
  _padding$1 = String.fromCharCode(128);
  _padding$1 += forge$l.util.fillString(String.fromCharCode(0), 64);
  _initialized$1 = true;
}
function _update$1(s2, w2, bytes2) {
  var t2, a, b, c, d2, e, f, i;
  var len = bytes2.length();
  while (len >= 64) {
    a = s2.h0;
    b = s2.h1;
    c = s2.h2;
    d2 = s2.h3;
    e = s2.h4;
    for (i = 0; i < 16; ++i) {
      t2 = bytes2.getInt32();
      w2[i] = t2;
      f = d2 ^ b & (c ^ d2);
      t2 = (a << 5 | a >>> 27) + f + e + 1518500249 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 20; ++i) {
      t2 = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i] = t2;
      f = d2 ^ b & (c ^ d2);
      t2 = (a << 5 | a >>> 27) + f + e + 1518500249 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 32; ++i) {
      t2 = w2[i - 3] ^ w2[i - 8] ^ w2[i - 14] ^ w2[i - 16];
      t2 = t2 << 1 | t2 >>> 31;
      w2[i] = t2;
      f = b ^ c ^ d2;
      t2 = (a << 5 | a >>> 27) + f + e + 1859775393 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 40; ++i) {
      t2 = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i] = t2;
      f = b ^ c ^ d2;
      t2 = (a << 5 | a >>> 27) + f + e + 1859775393 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 60; ++i) {
      t2 = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i] = t2;
      f = b & c | d2 & (b ^ c);
      t2 = (a << 5 | a >>> 27) + f + e + 2400959708 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    for (; i < 80; ++i) {
      t2 = w2[i - 6] ^ w2[i - 16] ^ w2[i - 28] ^ w2[i - 32];
      t2 = t2 << 2 | t2 >>> 30;
      w2[i] = t2;
      f = b ^ c ^ d2;
      t2 = (a << 5 | a >>> 27) + f + e + 3395469782 + t2;
      e = d2;
      d2 = c;
      c = (b << 30 | b >>> 2) >>> 0;
      b = a;
      a = t2;
    }
    s2.h0 = s2.h0 + a | 0;
    s2.h1 = s2.h1 + b | 0;
    s2.h2 = s2.h2 + c | 0;
    s2.h3 = s2.h3 + d2 | 0;
    s2.h4 = s2.h4 + e | 0;
    len -= 64;
  }
}
var forge$k = forge$D;
var pkcs1 = forge$k.pkcs1 = forge$k.pkcs1 || {};
pkcs1.encode_rsa_oaep = function(key, message, options) {
  var label;
  var seed;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    seed = arguments[3] || void 0;
    md = arguments[4] || void 0;
  } else if (options) {
    label = options.label || void 0;
    seed = options.seed || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  if (!md) {
    md = forge$k.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  var maxLength = keyLength - 2 * md.digestLength - 2;
  if (message.length > maxLength) {
    var error2 = new Error("RSAES-OAEP input message length is too long.");
    error2.length = message.length;
    error2.maxLength = maxLength;
    throw error2;
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest();
  var PS = "";
  var PS_length = maxLength - message.length;
  for (var i = 0; i < PS_length; i++) {
    PS += "\0";
  }
  var DB = lHash.getBytes() + PS + "" + message;
  if (!seed) {
    seed = forge$k.random.getBytes(md.digestLength);
  } else if (seed.length !== md.digestLength) {
    var error2 = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
    error2.seedLength = seed.length;
    error2.digestLength = md.digestLength;
    throw error2;
  }
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var maskedDB = forge$k.util.xorBytes(DB, dbMask, DB.length);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var maskedSeed = forge$k.util.xorBytes(seed, seedMask, seed.length);
  return "\0" + maskedSeed + maskedDB;
};
pkcs1.decode_rsa_oaep = function(key, em, options) {
  var label;
  var md;
  var mgf1Md;
  if (typeof options === "string") {
    label = options;
    md = arguments[3] || void 0;
  } else if (options) {
    label = options.label || void 0;
    md = options.md || void 0;
    if (options.mgf1 && options.mgf1.md) {
      mgf1Md = options.mgf1.md;
    }
  }
  var keyLength = Math.ceil(key.n.bitLength() / 8);
  if (em.length !== keyLength) {
    var error2 = new Error("RSAES-OAEP encoded message length is invalid.");
    error2.length = em.length;
    error2.expectedLength = keyLength;
    throw error2;
  }
  if (md === void 0) {
    md = forge$k.md.sha1.create();
  } else {
    md.start();
  }
  if (!mgf1Md) {
    mgf1Md = md;
  }
  if (keyLength < 2 * md.digestLength + 2) {
    throw new Error("RSAES-OAEP key is too short for the hash function.");
  }
  if (!label) {
    label = "";
  }
  md.update(label, "raw");
  var lHash = md.digest().getBytes();
  var y2 = em.charAt(0);
  var maskedSeed = em.substring(1, md.digestLength + 1);
  var maskedDB = em.substring(1 + md.digestLength);
  var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
  var seed = forge$k.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
  var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
  var db = forge$k.util.xorBytes(maskedDB, dbMask, maskedDB.length);
  var lHashPrime = db.substring(0, md.digestLength);
  var error2 = y2 !== "\0";
  for (var i = 0; i < md.digestLength; ++i) {
    error2 |= lHash.charAt(i) !== lHashPrime.charAt(i);
  }
  var in_ps = 1;
  var index2 = md.digestLength;
  for (var j2 = md.digestLength; j2 < db.length; j2++) {
    var code2 = db.charCodeAt(j2);
    var is_0 = code2 & 1 ^ 1;
    var error_mask = in_ps ? 65534 : 0;
    error2 |= code2 & error_mask;
    in_ps = in_ps & is_0;
    index2 += in_ps;
  }
  if (error2 || db.charCodeAt(index2) !== 1) {
    throw new Error("Invalid RSAES-OAEP padding.");
  }
  return db.substring(index2 + 1);
};
function rsa_mgf1(seed, maskLength, hash2) {
  if (!hash2) {
    hash2 = forge$k.md.sha1.create();
  }
  var t2 = "";
  var count = Math.ceil(maskLength / hash2.digestLength);
  for (var i = 0; i < count; ++i) {
    var c = String.fromCharCode(
      i >> 24 & 255,
      i >> 16 & 255,
      i >> 8 & 255,
      i & 255
    );
    hash2.start();
    hash2.update(seed + c);
    t2 += hash2.digest().getBytes();
  }
  return t2.substring(0, maskLength);
}
var forge$j = forge$D;
(function() {
  if (forge$j.prime) {
    forge$j.prime;
    return;
  }
  var prime = forge$j.prime = forge$j.prime || {};
  var BigInteger2 = forge$j.jsbn.BigInteger;
  var GCD_30_DELTA2 = [6, 4, 2, 4, 2, 4, 6, 2];
  var THIRTY = new BigInteger2(null);
  THIRTY.fromInt(30);
  var op_or2 = function(x, y2) {
    return x | y2;
  };
  prime.generateProbablePrime = function(bits, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var algorithm = options.algorithm || "PRIMEINC";
    if (typeof algorithm === "string") {
      algorithm = { name: algorithm };
    }
    algorithm.options = algorithm.options || {};
    var prng2 = options.prng || forge$j.random;
    var rng = {
      // x is an array to fill with bytes
      nextBytes: function(x) {
        var b = prng2.getBytesSync(x.length);
        for (var i = 0; i < x.length; ++i) {
          x[i] = b.charCodeAt(i);
        }
      }
    };
    if (algorithm.name === "PRIMEINC") {
      return primeincFindPrime(bits, rng, algorithm.options, callback);
    }
    throw new Error("Invalid prime generation algorithm: " + algorithm.name);
  };
  function primeincFindPrime(bits, rng, options, callback) {
    if ("workers" in options) {
      return primeincFindPrimeWithWorkers(bits, rng, options, callback);
    }
    return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
  }
  function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
    var num = generateRandom(bits, rng);
    var deltaIdx = 0;
    var mrTests = getMillerRabinTests(num.bitLength());
    if ("millerRabinTests" in options) {
      mrTests = options.millerRabinTests;
    }
    var maxBlockTime = 10;
    if ("maxBlockTime" in options) {
      maxBlockTime = options.maxBlockTime;
    }
    _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
  }
  function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
    var start = +/* @__PURE__ */ new Date();
    do {
      if (num.bitLength() > bits) {
        num = generateRandom(bits, rng);
      }
      if (num.isProbablePrime(mrTests)) {
        return callback(null, num);
      }
      num.dAddOffset(GCD_30_DELTA2[deltaIdx++ % 8], 0);
    } while (maxBlockTime < 0 || +/* @__PURE__ */ new Date() - start < maxBlockTime);
    forge$j.util.setImmediate(function() {
      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    });
  }
  function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
    if (typeof Worker === "undefined") {
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    var num = generateRandom(bits, rng);
    var numWorkers = options.workers;
    var workLoad = options.workLoad || 100;
    var range3 = workLoad * 30 / 8;
    var workerScript = options.workerScript || "forge/prime.worker.js";
    if (numWorkers === -1) {
      return forge$j.util.estimateCores(function(err, cores) {
        if (err) {
          cores = 2;
        }
        numWorkers = cores - 1;
        generate2();
      });
    }
    generate2();
    function generate2() {
      numWorkers = Math.max(1, numWorkers);
      var workers = [];
      for (var i = 0; i < numWorkers; ++i) {
        workers[i] = new Worker(workerScript);
      }
      for (var i = 0; i < numWorkers; ++i) {
        workers[i].addEventListener("message", workerMessage);
      }
      var found = false;
      function workerMessage(e) {
        if (found) {
          return;
        }
        var data2 = e.data;
        if (data2.found) {
          for (var i2 = 0; i2 < workers.length; ++i2) {
            workers[i2].terminate();
          }
          found = true;
          return callback(null, new BigInteger2(data2.prime, 16));
        }
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        var hex = num.toString(16);
        e.target.postMessage({
          hex,
          workLoad
        });
        num.dAddOffset(range3, 0);
      }
    }
  }
  function generateRandom(bits, rng) {
    var num = new BigInteger2(bits, rng);
    var bits1 = bits - 1;
    if (!num.testBit(bits1)) {
      num.bitwiseTo(BigInteger2.ONE.shiftLeft(bits1), op_or2, num);
    }
    num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
    return num;
  }
  function getMillerRabinTests(bits) {
    if (bits <= 100) return 27;
    if (bits <= 150) return 18;
    if (bits <= 200) return 15;
    if (bits <= 250) return 12;
    if (bits <= 300) return 9;
    if (bits <= 350) return 8;
    if (bits <= 400) return 7;
    if (bits <= 500) return 6;
    if (bits <= 600) return 5;
    if (bits <= 800) return 4;
    if (bits <= 1250) return 3;
    return 2;
  }
})();
var forge$i = forge$D;
if (typeof BigInteger$3 === "undefined") {
  var BigInteger$3 = forge$i.jsbn.BigInteger;
}
var _crypto = forge$i.util.isNodejs ? require$$2$3 : null;
var asn1$7 = forge$i.asn1;
var util$a = forge$i.util;
forge$i.pki = forge$i.pki || {};
forge$i.pki.rsa = forge$i.rsa = forge$i.rsa || {};
var pki$4 = forge$i.pki;
var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
var privateKeyValidator$1 = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: false,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
var rsaPrivateKeyValidator = {
  // RSAPrivateKey
  name: "RSAPrivateKey",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "RSAPrivateKey.version",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // modulus (n)
    name: "RSAPrivateKey.modulus",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPrivateKey.publicExponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPublicExponent"
  }, {
    // privateExponent (d)
    name: "RSAPrivateKey.privateExponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrivateExponent"
  }, {
    // prime1 (p)
    name: "RSAPrivateKey.prime1",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime1"
  }, {
    // prime2 (q)
    name: "RSAPrivateKey.prime2",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyPrime2"
  }, {
    // exponent1 (d mod (p-1))
    name: "RSAPrivateKey.exponent1",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent1"
  }, {
    // exponent2 (d mod (q-1))
    name: "RSAPrivateKey.exponent2",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyExponent2"
  }, {
    // coefficient ((inverse of q) mod p)
    name: "RSAPrivateKey.coefficient",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "privateKeyCoefficient"
  }]
};
var rsaPublicKeyValidator = {
  // RSAPublicKey
  name: "RSAPublicKey",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    // modulus (n)
    name: "RSAPublicKey.modulus",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "publicKeyModulus"
  }, {
    // publicExponent (e)
    name: "RSAPublicKey.exponent",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.INTEGER,
    constructed: false,
    capture: "publicKeyExponent"
  }]
};
var publicKeyValidator$2 = forge$i.pki.rsa.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "subjectPublicKeyInfo",
  value: [{
    name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: false,
      capture: "publicKeyOid"
    }]
  }, {
    // subjectPublicKey
    name: "SubjectPublicKeyInfo.subjectPublicKey",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.BITSTRING,
    constructed: false,
    value: [{
      // RSAPublicKey
      name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: "rsaPublicKey"
    }]
  }]
};
var digestInfoValidator = {
  name: "DigestInfo",
  tagClass: asn1$7.Class.UNIVERSAL,
  type: asn1$7.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "DigestInfo.DigestAlgorithm",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "DigestInfo.DigestAlgorithm.algorithmIdentifier",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.OID,
      constructed: false,
      capture: "algorithmIdentifier"
    }, {
      // NULL paramters
      name: "DigestInfo.DigestAlgorithm.parameters",
      tagClass: asn1$7.Class.UNIVERSAL,
      type: asn1$7.Type.NULL,
      // captured only to check existence for md2 and md5
      capture: "parameters",
      optional: true,
      constructed: false
    }]
  }, {
    // digest
    name: "DigestInfo.digest",
    tagClass: asn1$7.Class.UNIVERSAL,
    type: asn1$7.Type.OCTETSTRING,
    constructed: false,
    capture: "digest"
  }]
};
var emsaPkcs1v15encode = function(md) {
  var oid;
  if (md.algorithm in pki$4.oids) {
    oid = pki$4.oids[md.algorithm];
  } else {
    var error2 = new Error("Unknown message digest algorithm.");
    error2.algorithm = md.algorithm;
    throw error2;
  }
  var oidBytes = asn1$7.oidToDer(oid).getBytes();
  var digestInfo = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.SEQUENCE,
    true,
    []
  );
  var digestAlgorithm = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.SEQUENCE,
    true,
    []
  );
  digestAlgorithm.value.push(asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.OID,
    false,
    oidBytes
  ));
  digestAlgorithm.value.push(asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.NULL,
    false,
    ""
  ));
  var digest = asn1$7.create(
    asn1$7.Class.UNIVERSAL,
    asn1$7.Type.OCTETSTRING,
    false,
    md.digest().getBytes()
  );
  digestInfo.value.push(digestAlgorithm);
  digestInfo.value.push(digest);
  return asn1$7.toDer(digestInfo).getBytes();
};
var _modPow = function(x, key, pub) {
  if (pub) {
    return x.modPow(key.e, key.n);
  }
  if (!key.p || !key.q) {
    return x.modPow(key.d, key.n);
  }
  if (!key.dP) {
    key.dP = key.d.mod(key.p.subtract(BigInteger$3.ONE));
  }
  if (!key.dQ) {
    key.dQ = key.d.mod(key.q.subtract(BigInteger$3.ONE));
  }
  if (!key.qInv) {
    key.qInv = key.q.modInverse(key.p);
  }
  var r;
  do {
    r = new BigInteger$3(
      forge$i.util.bytesToHex(forge$i.random.getBytes(key.n.bitLength() / 8)),
      16
    );
  } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger$3.ONE));
  x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
  var xp = x.mod(key.p).modPow(key.dP, key.p);
  var xq = x.mod(key.q).modPow(key.dQ, key.q);
  while (xp.compareTo(xq) < 0) {
    xp = xp.add(key.p);
  }
  var y2 = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
  y2 = y2.multiply(r.modInverse(key.n)).mod(key.n);
  return y2;
};
pki$4.rsa.encrypt = function(m2, key, bt) {
  var pub = bt;
  var eb;
  var k = Math.ceil(key.n.bitLength() / 8);
  if (bt !== false && bt !== true) {
    pub = bt === 2;
    eb = _encodePkcs1_v1_5(m2, key, bt);
  } else {
    eb = forge$i.util.createBuffer();
    eb.putBytes(m2);
  }
  var x = new BigInteger$3(eb.toHex(), 16);
  var y2 = _modPow(x, key, pub);
  var yhex = y2.toString(16);
  var ed = forge$i.util.createBuffer();
  var zeros = k - Math.ceil(yhex.length / 2);
  while (zeros > 0) {
    ed.putByte(0);
    --zeros;
  }
  ed.putBytes(forge$i.util.hexToBytes(yhex));
  return ed.getBytes();
};
pki$4.rsa.decrypt = function(ed, key, pub, ml) {
  var k = Math.ceil(key.n.bitLength() / 8);
  if (ed.length !== k) {
    var error2 = new Error("Encrypted message length is invalid.");
    error2.length = ed.length;
    error2.expected = k;
    throw error2;
  }
  var y2 = new BigInteger$3(forge$i.util.createBuffer(ed).toHex(), 16);
  if (y2.compareTo(key.n) >= 0) {
    throw new Error("Encrypted message is invalid.");
  }
  var x = _modPow(y2, key, pub);
  var xhex = x.toString(16);
  var eb = forge$i.util.createBuffer();
  var zeros = k - Math.ceil(xhex.length / 2);
  while (zeros > 0) {
    eb.putByte(0);
    --zeros;
  }
  eb.putBytes(forge$i.util.hexToBytes(xhex));
  if (ml !== false) {
    return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
  }
  return eb.getBytes();
};
pki$4.rsa.createKeyPairGenerationState = function(bits, e, options) {
  if (typeof bits === "string") {
    bits = parseInt(bits, 10);
  }
  bits = bits || 2048;
  options = options || {};
  var prng2 = options.prng || forge$i.random;
  var rng = {
    // x is an array to fill with bytes
    nextBytes: function(x) {
      var b = prng2.getBytesSync(x.length);
      for (var i = 0; i < x.length; ++i) {
        x[i] = b.charCodeAt(i);
      }
    }
  };
  var algorithm = options.algorithm || "PRIMEINC";
  var rval;
  if (algorithm === "PRIMEINC") {
    rval = {
      algorithm,
      state: 0,
      bits,
      rng,
      eInt: e || 65537,
      e: new BigInteger$3(null),
      p: null,
      q: null,
      qBits: bits >> 1,
      pBits: bits - (bits >> 1),
      pqState: 0,
      num: null,
      keys: null
    };
    rval.e.fromInt(rval.eInt);
  } else {
    throw new Error("Invalid key generation algorithm: " + algorithm);
  }
  return rval;
};
pki$4.rsa.stepKeyPairGenerationState = function(state2, n) {
  if (!("algorithm" in state2)) {
    state2.algorithm = "PRIMEINC";
  }
  var THIRTY = new BigInteger$3(null);
  THIRTY.fromInt(30);
  var deltaIdx = 0;
  var op_or2 = function(x, y2) {
    return x | y2;
  };
  var t1 = +/* @__PURE__ */ new Date();
  var t2;
  var total = 0;
  while (state2.keys === null && (n <= 0 || total < n)) {
    if (state2.state === 0) {
      var bits = state2.p === null ? state2.pBits : state2.qBits;
      var bits1 = bits - 1;
      if (state2.pqState === 0) {
        state2.num = new BigInteger$3(bits, state2.rng);
        if (!state2.num.testBit(bits1)) {
          state2.num.bitwiseTo(
            BigInteger$3.ONE.shiftLeft(bits1),
            op_or2,
            state2.num
          );
        }
        state2.num.dAddOffset(31 - state2.num.mod(THIRTY).byteValue(), 0);
        deltaIdx = 0;
        ++state2.pqState;
      } else if (state2.pqState === 1) {
        if (state2.num.bitLength() > bits) {
          state2.pqState = 0;
        } else if (state2.num.isProbablePrime(
          _getMillerRabinTests(state2.num.bitLength())
        )) {
          ++state2.pqState;
        } else {
          state2.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
        }
      } else if (state2.pqState === 2) {
        state2.pqState = state2.num.subtract(BigInteger$3.ONE).gcd(state2.e).compareTo(BigInteger$3.ONE) === 0 ? 3 : 0;
      } else if (state2.pqState === 3) {
        state2.pqState = 0;
        if (state2.p === null) {
          state2.p = state2.num;
        } else {
          state2.q = state2.num;
        }
        if (state2.p !== null && state2.q !== null) {
          ++state2.state;
        }
        state2.num = null;
      }
    } else if (state2.state === 1) {
      if (state2.p.compareTo(state2.q) < 0) {
        state2.num = state2.p;
        state2.p = state2.q;
        state2.q = state2.num;
      }
      ++state2.state;
    } else if (state2.state === 2) {
      state2.p1 = state2.p.subtract(BigInteger$3.ONE);
      state2.q1 = state2.q.subtract(BigInteger$3.ONE);
      state2.phi = state2.p1.multiply(state2.q1);
      ++state2.state;
    } else if (state2.state === 3) {
      if (state2.phi.gcd(state2.e).compareTo(BigInteger$3.ONE) === 0) {
        ++state2.state;
      } else {
        state2.p = null;
        state2.q = null;
        state2.state = 0;
      }
    } else if (state2.state === 4) {
      state2.n = state2.p.multiply(state2.q);
      if (state2.n.bitLength() === state2.bits) {
        ++state2.state;
      } else {
        state2.q = null;
        state2.state = 0;
      }
    } else if (state2.state === 5) {
      var d2 = state2.e.modInverse(state2.phi);
      state2.keys = {
        privateKey: pki$4.rsa.setPrivateKey(
          state2.n,
          state2.e,
          d2,
          state2.p,
          state2.q,
          d2.mod(state2.p1),
          d2.mod(state2.q1),
          state2.q.modInverse(state2.p)
        ),
        publicKey: pki$4.rsa.setPublicKey(state2.n, state2.e)
      };
    }
    t2 = +/* @__PURE__ */ new Date();
    total += t2 - t1;
    t1 = t2;
  }
  return state2.keys !== null;
};
pki$4.rsa.generateKeyPair = function(bits, e, options, callback) {
  if (arguments.length === 1) {
    if (typeof bits === "object") {
      options = bits;
      bits = void 0;
    } else if (typeof bits === "function") {
      callback = bits;
      bits = void 0;
    }
  } else if (arguments.length === 2) {
    if (typeof bits === "number") {
      if (typeof e === "function") {
        callback = e;
        e = void 0;
      } else if (typeof e !== "number") {
        options = e;
        e = void 0;
      }
    } else {
      options = bits;
      callback = e;
      bits = void 0;
      e = void 0;
    }
  } else if (arguments.length === 3) {
    if (typeof e === "number") {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
    } else {
      callback = options;
      options = e;
      e = void 0;
    }
  }
  options = options || {};
  if (bits === void 0) {
    bits = options.bits || 2048;
  }
  if (e === void 0) {
    e = options.e || 65537;
  }
  if (!forge$i.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
    if (callback) {
      if (_detectNodeCrypto("generateKeyPair")) {
        return _crypto.generateKeyPair("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        }, function(err, pub, priv) {
          if (err) {
            return callback(err);
          }
          callback(null, {
            privateKey: pki$4.privateKeyFromPem(priv),
            publicKey: pki$4.publicKeyFromPem(pub)
          });
        });
      }
      if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
        return util$a.globalScope.crypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]).then(function(pair) {
          return util$a.globalScope.crypto.subtle.exportKey(
            "pkcs8",
            pair.privateKey
          );
        }).then(void 0, function(err) {
          callback(err);
        }).then(function(pkcs8) {
          if (pkcs8) {
            var privateKey = pki$4.privateKeyFromAsn1(
              asn1$7.fromDer(forge$i.util.createBuffer(pkcs8))
            );
            callback(null, {
              privateKey,
              publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          }
        });
      }
      if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
        var genOp = util$a.globalScope.msCrypto.subtle.generateKey({
          name: "RSASSA-PKCS1-v1_5",
          modulusLength: bits,
          publicExponent: _intToUint8Array(e),
          hash: { name: "SHA-256" }
        }, true, ["sign", "verify"]);
        genOp.oncomplete = function(e2) {
          var pair = e2.target.result;
          var exportOp = util$a.globalScope.msCrypto.subtle.exportKey(
            "pkcs8",
            pair.privateKey
          );
          exportOp.oncomplete = function(e3) {
            var pkcs8 = e3.target.result;
            var privateKey = pki$4.privateKeyFromAsn1(
              asn1$7.fromDer(forge$i.util.createBuffer(pkcs8))
            );
            callback(null, {
              privateKey,
              publicKey: pki$4.setRsaPublicKey(privateKey.n, privateKey.e)
            });
          };
          exportOp.onerror = function(err) {
            callback(err);
          };
        };
        genOp.onerror = function(err) {
          callback(err);
        };
        return;
      }
    } else {
      if (_detectNodeCrypto("generateKeyPairSync")) {
        var keypair = _crypto.generateKeyPairSync("rsa", {
          modulusLength: bits,
          publicExponent: e,
          publicKeyEncoding: {
            type: "spki",
            format: "pem"
          },
          privateKeyEncoding: {
            type: "pkcs8",
            format: "pem"
          }
        });
        return {
          privateKey: pki$4.privateKeyFromPem(keypair.privateKey),
          publicKey: pki$4.publicKeyFromPem(keypair.publicKey)
        };
      }
    }
  }
  var state2 = pki$4.rsa.createKeyPairGenerationState(bits, e, options);
  if (!callback) {
    pki$4.rsa.stepKeyPairGenerationState(state2, 0);
    return state2.keys;
  }
  _generateKeyPair(state2, options, callback);
};
pki$4.setRsaPublicKey = pki$4.rsa.setPublicKey = function(n, e) {
  var key = {
    n,
    e
  };
  key.encrypt = function(data2, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = {
        encode: function(m2, key2, pub) {
          return _encodePkcs1_v1_5(m2, key2, 2).getBytes();
        }
      };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = {
        encode: function(m2, key2) {
          return forge$i.pkcs1.encode_rsa_oaep(key2, m2, schemeOptions);
        }
      };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { encode: function(e3) {
        return e3;
      } };
    } else if (typeof scheme === "string") {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    var e2 = scheme.encode(data2, key, true);
    return pki$4.rsa.encrypt(e2, key, true);
  };
  key.verify = function(digest, signature, scheme, options) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSASSA-PKCS1-V1_5";
    }
    if (options === void 0) {
      options = {
        _parseAllDigestBytes: true
      };
    }
    if (!("_parseAllDigestBytes" in options)) {
      options._parseAllDigestBytes = true;
    }
    if (scheme === "RSASSA-PKCS1-V1_5") {
      scheme = {
        verify: function(digest2, d3) {
          d3 = _decodePkcs1_v1_5(d3, key, true);
          var obj = asn1$7.fromDer(d3, {
            parseAllBytes: options._parseAllDigestBytes
          });
          var capture = {};
          var errors2 = [];
          if (!asn1$7.validate(obj, digestInfoValidator, capture, errors2)) {
            var error2 = new Error(
              "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value."
            );
            error2.errors = errors2;
            throw error2;
          }
          var oid = asn1$7.derToOid(capture.algorithmIdentifier);
          if (!(oid === forge$i.oids.md2 || oid === forge$i.oids.md5 || oid === forge$i.oids.sha1 || oid === forge$i.oids.sha224 || oid === forge$i.oids.sha256 || oid === forge$i.oids.sha384 || oid === forge$i.oids.sha512 || oid === forge$i.oids["sha512-224"] || oid === forge$i.oids["sha512-256"])) {
            var error2 = new Error(
              "Unknown RSASSA-PKCS1-v1_5 DigestAlgorithm identifier."
            );
            error2.oid = oid;
            throw error2;
          }
          if (oid === forge$i.oids.md2 || oid === forge$i.oids.md5) {
            if (!("parameters" in capture)) {
              throw new Error(
                "ASN.1 object does not contain a valid RSASSA-PKCS1-v1_5 DigestInfo value. Missing algorithm identifer NULL parameters."
              );
            }
          }
          return digest2 === capture.digest;
        }
      };
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = {
        verify: function(digest2, d3) {
          d3 = _decodePkcs1_v1_5(d3, key, true);
          return digest2 === d3;
        }
      };
    }
    var d2 = pki$4.rsa.decrypt(signature, key, true, false);
    return scheme.verify(digest, d2, key.n.bitLength());
  };
  return key;
};
pki$4.setRsaPrivateKey = pki$4.rsa.setPrivateKey = function(n, e, d2, p, q, dP, dQ, qInv) {
  var key = {
    n,
    e,
    d: d2,
    p,
    q,
    dP,
    dQ,
    qInv
  };
  key.decrypt = function(data2, scheme, schemeOptions) {
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    } else if (scheme === void 0) {
      scheme = "RSAES-PKCS1-V1_5";
    }
    var d3 = pki$4.rsa.decrypt(data2, key, false, false);
    if (scheme === "RSAES-PKCS1-V1_5") {
      scheme = { decode: _decodePkcs1_v1_5 };
    } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
      scheme = {
        decode: function(d4, key2) {
          return forge$i.pkcs1.decode_rsa_oaep(key2, d4, schemeOptions);
        }
      };
    } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
      scheme = { decode: function(d4) {
        return d4;
      } };
    } else {
      throw new Error('Unsupported encryption scheme: "' + scheme + '".');
    }
    return scheme.decode(d3, key, false);
  };
  key.sign = function(md, scheme) {
    var bt = false;
    if (typeof scheme === "string") {
      scheme = scheme.toUpperCase();
    }
    if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
      scheme = { encode: emsaPkcs1v15encode };
      bt = 1;
    } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
      scheme = { encode: function() {
        return md;
      } };
      bt = 1;
    }
    var d3 = scheme.encode(md, key.n.bitLength());
    return pki$4.rsa.encrypt(d3, key, bt);
  };
  return key;
};
pki$4.wrapRsaPrivateKey = function(rsaKey) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // version (0)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      asn1$7.integerToDer(0).getBytes()
    ),
    // privateKeyAlgorithm
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
      asn1$7.create(
        asn1$7.Class.UNIVERSAL,
        asn1$7.Type.OID,
        false,
        asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()
      ),
      asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, "")
    ]),
    // PrivateKey
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.OCTETSTRING,
      false,
      asn1$7.toDer(rsaKey).getBytes()
    )
  ]);
};
pki$4.privateKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (asn1$7.validate(obj, privateKeyValidator$1, capture, errors2)) {
    obj = asn1$7.fromDer(forge$i.util.createBuffer(capture.privateKey));
  }
  capture = {};
  errors2 = [];
  if (!asn1$7.validate(obj, rsaPrivateKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
    error2.errors = errors2;
    throw error2;
  }
  var n, e, d2, p, q, dP, dQ, qInv;
  n = forge$i.util.createBuffer(capture.privateKeyModulus).toHex();
  e = forge$i.util.createBuffer(capture.privateKeyPublicExponent).toHex();
  d2 = forge$i.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
  p = forge$i.util.createBuffer(capture.privateKeyPrime1).toHex();
  q = forge$i.util.createBuffer(capture.privateKeyPrime2).toHex();
  dP = forge$i.util.createBuffer(capture.privateKeyExponent1).toHex();
  dQ = forge$i.util.createBuffer(capture.privateKeyExponent2).toHex();
  qInv = forge$i.util.createBuffer(capture.privateKeyCoefficient).toHex();
  return pki$4.setRsaPrivateKey(
    new BigInteger$3(n, 16),
    new BigInteger$3(e, 16),
    new BigInteger$3(d2, 16),
    new BigInteger$3(p, 16),
    new BigInteger$3(q, 16),
    new BigInteger$3(dP, 16),
    new BigInteger$3(dQ, 16),
    new BigInteger$3(qInv, 16)
  );
};
pki$4.privateKeyToAsn1 = pki$4.privateKeyToRSAPrivateKey = function(key) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // version (0 = only 2 primes, 1 multiple primes)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      asn1$7.integerToDer(0).getBytes()
    ),
    // modulus (n)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.n)
    ),
    // publicExponent (e)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.e)
    ),
    // privateExponent (d)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.d)
    ),
    // privateKeyPrime1 (p)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.p)
    ),
    // privateKeyPrime2 (q)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.q)
    ),
    // privateKeyExponent1 (dP)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.dP)
    ),
    // privateKeyExponent2 (dQ)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.dQ)
    ),
    // coefficient (qInv)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.qInv)
    )
  ]);
};
pki$4.publicKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (asn1$7.validate(obj, publicKeyValidator$2, capture, errors2)) {
    var oid = asn1$7.derToOid(capture.publicKeyOid);
    if (oid !== pki$4.oids.rsaEncryption) {
      var error2 = new Error("Cannot read public key. Unknown OID.");
      error2.oid = oid;
      throw error2;
    }
    obj = capture.rsaPublicKey;
  }
  errors2 = [];
  if (!asn1$7.validate(obj, rsaPublicKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
    error2.errors = errors2;
    throw error2;
  }
  var n = forge$i.util.createBuffer(capture.publicKeyModulus).toHex();
  var e = forge$i.util.createBuffer(capture.publicKeyExponent).toHex();
  return pki$4.setRsaPublicKey(
    new BigInteger$3(n, 16),
    new BigInteger$3(e, 16)
  );
};
pki$4.publicKeyToAsn1 = pki$4.publicKeyToSubjectPublicKeyInfo = function(key) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // AlgorithmIdentifier
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
      // algorithm
      asn1$7.create(
        asn1$7.Class.UNIVERSAL,
        asn1$7.Type.OID,
        false,
        asn1$7.oidToDer(pki$4.oids.rsaEncryption).getBytes()
      ),
      // parameters (null)
      asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.NULL, false, "")
    ]),
    // subjectPublicKey
    asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.BITSTRING, false, [
      pki$4.publicKeyToRSAPublicKey(key)
    ])
  ]);
};
pki$4.publicKeyToRSAPublicKey = function(key) {
  return asn1$7.create(asn1$7.Class.UNIVERSAL, asn1$7.Type.SEQUENCE, true, [
    // modulus (n)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.n)
    ),
    // publicExponent (e)
    asn1$7.create(
      asn1$7.Class.UNIVERSAL,
      asn1$7.Type.INTEGER,
      false,
      _bnToBytes(key.e)
    )
  ]);
};
function _encodePkcs1_v1_5(m2, key, bt) {
  var eb = forge$i.util.createBuffer();
  var k = Math.ceil(key.n.bitLength() / 8);
  if (m2.length > k - 11) {
    var error2 = new Error("Message is too long for PKCS#1 v1.5 padding.");
    error2.length = m2.length;
    error2.max = k - 11;
    throw error2;
  }
  eb.putByte(0);
  eb.putByte(bt);
  var padNum = k - 3 - m2.length;
  var padByte;
  if (bt === 0 || bt === 1) {
    padByte = bt === 0 ? 0 : 255;
    for (var i = 0; i < padNum; ++i) {
      eb.putByte(padByte);
    }
  } else {
    while (padNum > 0) {
      var numZeros = 0;
      var padBytes = forge$i.random.getBytes(padNum);
      for (var i = 0; i < padNum; ++i) {
        padByte = padBytes.charCodeAt(i);
        if (padByte === 0) {
          ++numZeros;
        } else {
          eb.putByte(padByte);
        }
      }
      padNum = numZeros;
    }
  }
  eb.putByte(0);
  eb.putBytes(m2);
  return eb;
}
function _decodePkcs1_v1_5(em, key, pub, ml) {
  var k = Math.ceil(key.n.bitLength() / 8);
  var eb = forge$i.util.createBuffer(em);
  var first2 = eb.getByte();
  var bt = eb.getByte();
  if (first2 !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
    throw new Error("Encryption block is invalid.");
  }
  var padNum = 0;
  if (bt === 0) {
    padNum = k - 3 - ml;
    for (var i = 0; i < padNum; ++i) {
      if (eb.getByte() !== 0) {
        throw new Error("Encryption block is invalid.");
      }
    }
  } else if (bt === 1) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() !== 255) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  } else if (bt === 2) {
    padNum = 0;
    while (eb.length() > 1) {
      if (eb.getByte() === 0) {
        --eb.read;
        break;
      }
      ++padNum;
    }
  }
  var zero = eb.getByte();
  if (zero !== 0 || padNum !== k - 3 - eb.length()) {
    throw new Error("Encryption block is invalid.");
  }
  return eb.getBytes();
}
function _generateKeyPair(state2, options, callback) {
  if (typeof options === "function") {
    callback = options;
    options = {};
  }
  options = options || {};
  var opts = {
    algorithm: {
      name: options.algorithm || "PRIMEINC",
      options: {
        workers: options.workers || 2,
        workLoad: options.workLoad || 100,
        workerScript: options.workerScript
      }
    }
  };
  if ("prng" in options) {
    opts.prng = options.prng;
  }
  generate2();
  function generate2() {
    getPrime(state2.pBits, function(err, num) {
      if (err) {
        return callback(err);
      }
      state2.p = num;
      if (state2.q !== null) {
        return finish(err, state2.q);
      }
      getPrime(state2.qBits, finish);
    });
  }
  function getPrime(bits, callback2) {
    forge$i.prime.generateProbablePrime(bits, opts, callback2);
  }
  function finish(err, num) {
    if (err) {
      return callback(err);
    }
    state2.q = num;
    if (state2.p.compareTo(state2.q) < 0) {
      var tmp = state2.p;
      state2.p = state2.q;
      state2.q = tmp;
    }
    if (state2.p.subtract(BigInteger$3.ONE).gcd(state2.e).compareTo(BigInteger$3.ONE) !== 0) {
      state2.p = null;
      generate2();
      return;
    }
    if (state2.q.subtract(BigInteger$3.ONE).gcd(state2.e).compareTo(BigInteger$3.ONE) !== 0) {
      state2.q = null;
      getPrime(state2.qBits, finish);
      return;
    }
    state2.p1 = state2.p.subtract(BigInteger$3.ONE);
    state2.q1 = state2.q.subtract(BigInteger$3.ONE);
    state2.phi = state2.p1.multiply(state2.q1);
    if (state2.phi.gcd(state2.e).compareTo(BigInteger$3.ONE) !== 0) {
      state2.p = state2.q = null;
      generate2();
      return;
    }
    state2.n = state2.p.multiply(state2.q);
    if (state2.n.bitLength() !== state2.bits) {
      state2.q = null;
      getPrime(state2.qBits, finish);
      return;
    }
    var d2 = state2.e.modInverse(state2.phi);
    state2.keys = {
      privateKey: pki$4.rsa.setPrivateKey(
        state2.n,
        state2.e,
        d2,
        state2.p,
        state2.q,
        d2.mod(state2.p1),
        d2.mod(state2.q1),
        state2.q.modInverse(state2.p)
      ),
      publicKey: pki$4.rsa.setPublicKey(state2.n, state2.e)
    };
    callback(null, state2.keys);
  }
}
function _bnToBytes(b) {
  var hex = b.toString(16);
  if (hex[0] >= "8") {
    hex = "00" + hex;
  }
  var bytes2 = forge$i.util.hexToBytes(hex);
  if (bytes2.length > 1 && // leading 0x00 for positive integer
  (bytes2.charCodeAt(0) === 0 && (bytes2.charCodeAt(1) & 128) === 0 || // leading 0xFF for negative integer
  bytes2.charCodeAt(0) === 255 && (bytes2.charCodeAt(1) & 128) === 128)) {
    return bytes2.substr(1);
  }
  return bytes2;
}
function _getMillerRabinTests(bits) {
  if (bits <= 100) return 27;
  if (bits <= 150) return 18;
  if (bits <= 200) return 15;
  if (bits <= 250) return 12;
  if (bits <= 300) return 9;
  if (bits <= 350) return 8;
  if (bits <= 400) return 7;
  if (bits <= 500) return 6;
  if (bits <= 600) return 5;
  if (bits <= 800) return 4;
  if (bits <= 1250) return 3;
  return 2;
}
function _detectNodeCrypto(fn) {
  return forge$i.util.isNodejs && typeof _crypto[fn] === "function";
}
function _detectSubtleCrypto(fn) {
  return typeof util$a.globalScope !== "undefined" && typeof util$a.globalScope.crypto === "object" && typeof util$a.globalScope.crypto.subtle === "object" && typeof util$a.globalScope.crypto.subtle[fn] === "function";
}
function _detectSubtleMsCrypto(fn) {
  return typeof util$a.globalScope !== "undefined" && typeof util$a.globalScope.msCrypto === "object" && typeof util$a.globalScope.msCrypto.subtle === "object" && typeof util$a.globalScope.msCrypto.subtle[fn] === "function";
}
function _intToUint8Array(x) {
  var bytes2 = forge$i.util.hexToBytes(x.toString(16));
  var buffer = new Uint8Array(bytes2.length);
  for (var i = 0; i < bytes2.length; ++i) {
    buffer[i] = bytes2.charCodeAt(i);
  }
  return buffer;
}
var forge$h = forge$D;
if (typeof BigInteger$2 === "undefined") {
  var BigInteger$2 = forge$h.jsbn.BigInteger;
}
var asn1$6 = forge$h.asn1;
var pki$3 = forge$h.pki = forge$h.pki || {};
pki$3.pbe = forge$h.pbe = forge$h.pbe || {};
var oids$1 = pki$3.oids;
var encryptedPrivateKeyValidator = {
  name: "EncryptedPrivateKeyInfo",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: false,
      capture: "encryptionOid"
    }, {
      name: "AlgorithmIdentifier.parameters",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "encryptionParams"
    }]
  }, {
    // encryptedData
    name: "EncryptedPrivateKeyInfo.encryptedData",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.OCTETSTRING,
    constructed: false,
    capture: "encryptedData"
  }]
};
var PBES2AlgorithmsValidator = {
  name: "PBES2Algorithms",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "PBES2Algorithms.keyDerivationFunc",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc.oid",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: false,
      capture: "kdfOid"
    }, {
      name: "PBES2Algorithms.params",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.params.salt",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.OCTETSTRING,
        constructed: false,
        capture: "kdfSalt"
      }, {
        name: "PBES2Algorithms.params.iterationCount",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: false,
        capture: "kdfIterationCount"
      }, {
        name: "PBES2Algorithms.params.keyLength",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: "keyLength"
      }, {
        // prf
        name: "PBES2Algorithms.params.prf",
        tagClass: asn1$6.Class.UNIVERSAL,
        type: asn1$6.Type.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "PBES2Algorithms.params.prf.algorithm",
          tagClass: asn1$6.Class.UNIVERSAL,
          type: asn1$6.Type.OID,
          constructed: false,
          capture: "prfOid"
        }]
      }]
    }]
  }, {
    name: "PBES2Algorithms.encryptionScheme",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.encryptionScheme.oid",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OID,
      constructed: false,
      capture: "encOid"
    }, {
      name: "PBES2Algorithms.encryptionScheme.iv",
      tagClass: asn1$6.Class.UNIVERSAL,
      type: asn1$6.Type.OCTETSTRING,
      constructed: false,
      capture: "encIv"
    }]
  }]
};
var pkcs12PbeParamsValidator = {
  name: "pkcs-12PbeParams",
  tagClass: asn1$6.Class.UNIVERSAL,
  type: asn1$6.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "pkcs-12PbeParams.salt",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.OCTETSTRING,
    constructed: false,
    capture: "salt"
  }, {
    name: "pkcs-12PbeParams.iterations",
    tagClass: asn1$6.Class.UNIVERSAL,
    type: asn1$6.Type.INTEGER,
    constructed: false,
    capture: "iterations"
  }]
};
pki$3.encryptPrivateKeyInfo = function(obj, password, options) {
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || "aes128";
  options.prfAlgorithm = options.prfAlgorithm || "sha1";
  var salt = forge$h.random.getBytesSync(options.saltSize);
  var count = options.count;
  var countBytes = asn1$6.integerToDer(count);
  var dkLen;
  var encryptionAlgorithm;
  var encryptedData;
  if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
    var ivLen, encOid, cipherFn;
    switch (options.algorithm) {
      case "aes128":
        dkLen = 16;
        ivLen = 16;
        encOid = oids$1["aes128-CBC"];
        cipherFn = forge$h.aes.createEncryptionCipher;
        break;
      case "aes192":
        dkLen = 24;
        ivLen = 16;
        encOid = oids$1["aes192-CBC"];
        cipherFn = forge$h.aes.createEncryptionCipher;
        break;
      case "aes256":
        dkLen = 32;
        ivLen = 16;
        encOid = oids$1["aes256-CBC"];
        cipherFn = forge$h.aes.createEncryptionCipher;
        break;
      case "des":
        dkLen = 8;
        ivLen = 8;
        encOid = oids$1["desCBC"];
        cipherFn = forge$h.des.createEncryptionCipher;
        break;
      default:
        var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
        error2.algorithm = options.algorithm;
        throw error2;
    }
    var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
    var md = prfAlgorithmToMessageDigest(prfAlgorithm);
    var dk = forge$h.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv2 = forge$h.random.getBytesSync(ivLen);
    var cipher = cipherFn(dk);
    cipher.start(iv2);
    cipher.update(asn1$6.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
    encryptionAlgorithm = asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.SEQUENCE,
      true,
      [
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          false,
          asn1$6.oidToDer(oids$1["pkcs5PBES2"]).getBytes()
        ),
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          // keyDerivationFunc
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OID,
              false,
              asn1$6.oidToDer(oids$1["pkcs5PBKDF2"]).getBytes()
            ),
            // PBKDF2-params
            params
          ]),
          // encryptionScheme
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OID,
              false,
              asn1$6.oidToDer(encOid).getBytes()
            ),
            // iv
            asn1$6.create(
              asn1$6.Class.UNIVERSAL,
              asn1$6.Type.OCTETSTRING,
              false,
              iv2
            )
          ])
        ])
      ]
    );
  } else if (options.algorithm === "3des") {
    dkLen = 24;
    var saltBytes = new forge$h.util.ByteBuffer(salt);
    var dk = pki$3.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
    var iv2 = pki$3.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
    var cipher = forge$h.des.createEncryptionCipher(dk);
    cipher.start(iv2);
    cipher.update(asn1$6.toDer(obj));
    cipher.finish();
    encryptedData = cipher.output.getBytes();
    encryptionAlgorithm = asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.SEQUENCE,
      true,
      [
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          false,
          asn1$6.oidToDer(oids$1["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()
        ),
        // pkcs-12PbeParams
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
          // salt
          asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.OCTETSTRING, false, salt),
          // iteration count
          asn1$6.create(
            asn1$6.Class.UNIVERSAL,
            asn1$6.Type.INTEGER,
            false,
            countBytes.getBytes()
          )
        ])
      ]
    );
  } else {
    var error2 = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
    error2.algorithm = options.algorithm;
    throw error2;
  }
  var rval = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
    // encryptionAlgorithm
    encryptionAlgorithm,
    // encryptedData
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.OCTETSTRING,
      false,
      encryptedData
    )
  ]);
  return rval;
};
pki$3.decryptPrivateKeyInfo = function(obj, password) {
  var rval = null;
  var capture = {};
  var errors2 = [];
  if (!asn1$6.validate(obj, encryptedPrivateKeyValidator, capture, errors2)) {
    var error2 = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$6.derToOid(capture.encryptionOid);
  var cipher = pki$3.pbe.getCipher(oid, capture.encryptionParams, password);
  var encrypted = forge$h.util.createBuffer(capture.encryptedData);
  cipher.update(encrypted);
  if (cipher.finish()) {
    rval = asn1$6.fromDer(cipher.output);
  }
  return rval;
};
pki$3.encryptedPrivateKeyToPem = function(epki, maxline) {
  var msg = {
    type: "ENCRYPTED PRIVATE KEY",
    body: asn1$6.toDer(epki).getBytes()
  };
  return forge$h.pem.encode(msg, { maxline });
};
pki$3.encryptedPrivateKeyFromPem = function(pem2) {
  var msg = forge$h.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY") {
    var error2 = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
  }
  return asn1$6.fromDer(msg.body);
};
pki$3.encryptRsaPrivateKey = function(rsaKey, password, options) {
  options = options || {};
  if (!options.legacy) {
    var rval = pki$3.wrapRsaPrivateKey(pki$3.privateKeyToAsn1(rsaKey));
    rval = pki$3.encryptPrivateKeyInfo(rval, password, options);
    return pki$3.encryptedPrivateKeyToPem(rval);
  }
  var algorithm;
  var iv2;
  var dkLen;
  var cipherFn;
  switch (options.algorithm) {
    case "aes128":
      algorithm = "AES-128-CBC";
      dkLen = 16;
      iv2 = forge$h.random.getBytesSync(16);
      cipherFn = forge$h.aes.createEncryptionCipher;
      break;
    case "aes192":
      algorithm = "AES-192-CBC";
      dkLen = 24;
      iv2 = forge$h.random.getBytesSync(16);
      cipherFn = forge$h.aes.createEncryptionCipher;
      break;
    case "aes256":
      algorithm = "AES-256-CBC";
      dkLen = 32;
      iv2 = forge$h.random.getBytesSync(16);
      cipherFn = forge$h.aes.createEncryptionCipher;
      break;
    case "3des":
      algorithm = "DES-EDE3-CBC";
      dkLen = 24;
      iv2 = forge$h.random.getBytesSync(8);
      cipherFn = forge$h.des.createEncryptionCipher;
      break;
    case "des":
      algorithm = "DES-CBC";
      dkLen = 8;
      iv2 = forge$h.random.getBytesSync(8);
      cipherFn = forge$h.des.createEncryptionCipher;
      break;
    default:
      var error2 = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
      error2.algorithm = options.algorithm;
      throw error2;
  }
  var dk = forge$h.pbe.opensslDeriveBytes(password, iv2.substr(0, 8), dkLen);
  var cipher = cipherFn(dk);
  cipher.start(iv2);
  cipher.update(asn1$6.toDer(pki$3.privateKeyToAsn1(rsaKey)));
  cipher.finish();
  var msg = {
    type: "RSA PRIVATE KEY",
    procType: {
      version: "4",
      type: "ENCRYPTED"
    },
    dekInfo: {
      algorithm,
      parameters: forge$h.util.bytesToHex(iv2).toUpperCase()
    },
    body: cipher.output.getBytes()
  };
  return forge$h.pem.encode(msg);
};
pki$3.decryptRsaPrivateKey = function(pem2, password) {
  var rval = null;
  var msg = forge$h.pem.decode(pem2)[0];
  if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
    var error2 = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
    error2.headerType = error2;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    var dkLen;
    var cipherFn;
    switch (msg.dekInfo.algorithm) {
      case "DES-CBC":
        dkLen = 8;
        cipherFn = forge$h.des.createDecryptionCipher;
        break;
      case "DES-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge$h.des.createDecryptionCipher;
        break;
      case "AES-128-CBC":
        dkLen = 16;
        cipherFn = forge$h.aes.createDecryptionCipher;
        break;
      case "AES-192-CBC":
        dkLen = 24;
        cipherFn = forge$h.aes.createDecryptionCipher;
        break;
      case "AES-256-CBC":
        dkLen = 32;
        cipherFn = forge$h.aes.createDecryptionCipher;
        break;
      case "RC2-40-CBC":
        dkLen = 5;
        cipherFn = function(key) {
          return forge$h.rc2.createDecryptionCipher(key, 40);
        };
        break;
      case "RC2-64-CBC":
        dkLen = 8;
        cipherFn = function(key) {
          return forge$h.rc2.createDecryptionCipher(key, 64);
        };
        break;
      case "RC2-128-CBC":
        dkLen = 16;
        cipherFn = function(key) {
          return forge$h.rc2.createDecryptionCipher(key, 128);
        };
        break;
      default:
        var error2 = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
        error2.algorithm = msg.dekInfo.algorithm;
        throw error2;
    }
    var iv2 = forge$h.util.hexToBytes(msg.dekInfo.parameters);
    var dk = forge$h.pbe.opensslDeriveBytes(password, iv2.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv2);
    cipher.update(forge$h.util.createBuffer(msg.body));
    if (cipher.finish()) {
      rval = cipher.output.getBytes();
    } else {
      return rval;
    }
  } else {
    rval = msg.body;
  }
  if (msg.type === "ENCRYPTED PRIVATE KEY") {
    rval = pki$3.decryptPrivateKeyInfo(asn1$6.fromDer(rval), password);
  } else {
    rval = asn1$6.fromDer(rval);
  }
  if (rval !== null) {
    rval = pki$3.privateKeyFromAsn1(rval);
  }
  return rval;
};
pki$3.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
  var j2, l;
  if (typeof md === "undefined" || md === null) {
    if (!("sha1" in forge$h.md)) {
      throw new Error('"sha1" hash algorithm unavailable.');
    }
    md = forge$h.md.sha1.create();
  }
  var u2 = md.digestLength;
  var v = md.blockLength;
  var result = new forge$h.util.ByteBuffer();
  var passBuf = new forge$h.util.ByteBuffer();
  if (password !== null && password !== void 0) {
    for (l = 0; l < password.length; l++) {
      passBuf.putInt16(password.charCodeAt(l));
    }
    passBuf.putInt16(0);
  }
  var p = passBuf.length();
  var s2 = salt.length();
  var D3 = new forge$h.util.ByteBuffer();
  D3.fillWithByte(id, v);
  var Slen = v * Math.ceil(s2 / v);
  var S2 = new forge$h.util.ByteBuffer();
  for (l = 0; l < Slen; l++) {
    S2.putByte(salt.at(l % s2));
  }
  var Plen = v * Math.ceil(p / v);
  var P = new forge$h.util.ByteBuffer();
  for (l = 0; l < Plen; l++) {
    P.putByte(passBuf.at(l % p));
  }
  var I2 = S2;
  I2.putBuffer(P);
  var c = Math.ceil(n / u2);
  for (var i = 1; i <= c; i++) {
    var buf = new forge$h.util.ByteBuffer();
    buf.putBytes(D3.bytes());
    buf.putBytes(I2.bytes());
    for (var round = 0; round < iter; round++) {
      md.start();
      md.update(buf.getBytes());
      buf = md.digest();
    }
    var B = new forge$h.util.ByteBuffer();
    for (l = 0; l < v; l++) {
      B.putByte(buf.at(l % u2));
    }
    var k = Math.ceil(s2 / v) + Math.ceil(p / v);
    var Inew = new forge$h.util.ByteBuffer();
    for (j2 = 0; j2 < k; j2++) {
      var chunk = new forge$h.util.ByteBuffer(I2.getBytes(v));
      var x = 511;
      for (l = B.length() - 1; l >= 0; l--) {
        x = x >> 8;
        x += B.at(l) + chunk.at(l);
        chunk.setAt(l, x & 255);
      }
      Inew.putBuffer(chunk);
    }
    I2 = Inew;
    result.putBuffer(buf);
  }
  result.truncate(result.length() - n);
  return result;
};
pki$3.pbe.getCipher = function(oid, params, password) {
  switch (oid) {
    case pki$3.oids["pkcs5PBES2"]:
      return pki$3.pbe.getCipherForPBES2(oid, params, password);
    case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
    case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
      return pki$3.pbe.getCipherForPKCS12PBE(oid, params, password);
    default:
      var error2 = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
      error2.oid = oid;
      error2.supportedOids = [
        "pkcs5PBES2",
        "pbeWithSHAAnd3-KeyTripleDES-CBC",
        "pbewithSHAAnd40BitRC2-CBC"
      ];
      throw error2;
  }
};
pki$3.pbe.getCipherForPBES2 = function(oid, params, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$6.validate(params, PBES2AlgorithmsValidator, capture, errors2)) {
    var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  oid = asn1$6.derToOid(capture.kdfOid);
  if (oid !== pki$3.oids["pkcs5PBKDF2"]) {
    var error2 = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
    error2.oid = oid;
    error2.supportedOids = ["pkcs5PBKDF2"];
    throw error2;
  }
  oid = asn1$6.derToOid(capture.encOid);
  if (oid !== pki$3.oids["aes128-CBC"] && oid !== pki$3.oids["aes192-CBC"] && oid !== pki$3.oids["aes256-CBC"] && oid !== pki$3.oids["des-EDE3-CBC"] && oid !== pki$3.oids["desCBC"]) {
    var error2 = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
    error2.oid = oid;
    error2.supportedOids = [
      "aes128-CBC",
      "aes192-CBC",
      "aes256-CBC",
      "des-EDE3-CBC",
      "desCBC"
    ];
    throw error2;
  }
  var salt = capture.kdfSalt;
  var count = forge$h.util.createBuffer(capture.kdfIterationCount);
  count = count.getInt(count.length() << 3);
  var dkLen;
  var cipherFn;
  switch (pki$3.oids[oid]) {
    case "aes128-CBC":
      dkLen = 16;
      cipherFn = forge$h.aes.createDecryptionCipher;
      break;
    case "aes192-CBC":
      dkLen = 24;
      cipherFn = forge$h.aes.createDecryptionCipher;
      break;
    case "aes256-CBC":
      dkLen = 32;
      cipherFn = forge$h.aes.createDecryptionCipher;
      break;
    case "des-EDE3-CBC":
      dkLen = 24;
      cipherFn = forge$h.des.createDecryptionCipher;
      break;
    case "desCBC":
      dkLen = 8;
      cipherFn = forge$h.des.createDecryptionCipher;
      break;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var dk = forge$h.pkcs5.pbkdf2(password, salt, count, dkLen, md);
  var iv2 = capture.encIv;
  var cipher = cipherFn(dk);
  cipher.start(iv2);
  return cipher;
};
pki$3.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$6.validate(params, pkcs12PbeParamsValidator, capture, errors2)) {
    var error2 = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var salt = forge$h.util.createBuffer(capture.salt);
  var count = forge$h.util.createBuffer(capture.iterations);
  count = count.getInt(count.length() << 3);
  var dkLen, dIvLen, cipherFn;
  switch (oid) {
    case pki$3.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      dkLen = 24;
      dIvLen = 8;
      cipherFn = forge$h.des.startDecrypting;
      break;
    case pki$3.oids["pbewithSHAAnd40BitRC2-CBC"]:
      dkLen = 5;
      dIvLen = 8;
      cipherFn = function(key2, iv3) {
        var cipher = forge$h.rc2.createDecryptionCipher(key2, 40);
        cipher.start(iv3, null);
        return cipher;
      };
      break;
    default:
      var error2 = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
      error2.oid = oid;
      throw error2;
  }
  var md = prfOidToMessageDigest(capture.prfOid);
  var key = pki$3.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
  md.start();
  var iv2 = pki$3.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
  return cipherFn(key, iv2);
};
pki$3.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
  if (typeof md === "undefined" || md === null) {
    if (!("md5" in forge$h.md)) {
      throw new Error('"md5" hash algorithm unavailable.');
    }
    md = forge$h.md.md5.create();
  }
  if (salt === null) {
    salt = "";
  }
  var digests = [hash(md, password + salt)];
  for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
    digests.push(hash(md, digests[i - 1] + password + salt));
  }
  return digests.join("").substr(0, dkLen);
};
function hash(md, bytes2) {
  return md.start().update(bytes2).digest().getBytes();
}
function prfOidToMessageDigest(prfOid) {
  var prfAlgorithm;
  if (!prfOid) {
    prfAlgorithm = "hmacWithSHA1";
  } else {
    prfAlgorithm = pki$3.oids[asn1$6.derToOid(prfOid)];
    if (!prfAlgorithm) {
      var error2 = new Error("Unsupported PRF OID.");
      error2.oid = prfOid;
      error2.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ];
      throw error2;
    }
  }
  return prfAlgorithmToMessageDigest(prfAlgorithm);
}
function prfAlgorithmToMessageDigest(prfAlgorithm) {
  var factory = forge$h.md;
  switch (prfAlgorithm) {
    case "hmacWithSHA224":
      factory = forge$h.md.sha512;
    case "hmacWithSHA1":
    case "hmacWithSHA256":
    case "hmacWithSHA384":
    case "hmacWithSHA512":
      prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
      break;
    default:
      var error2 = new Error("Unsupported PRF algorithm.");
      error2.algorithm = prfAlgorithm;
      error2.supported = [
        "hmacWithSHA1",
        "hmacWithSHA224",
        "hmacWithSHA256",
        "hmacWithSHA384",
        "hmacWithSHA512"
      ];
      throw error2;
  }
  if (!factory || !(prfAlgorithm in factory)) {
    throw new Error("Unknown hash algorithm: " + prfAlgorithm);
  }
  return factory[prfAlgorithm].create();
}
function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
  var params = asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
    // salt
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.OCTETSTRING,
      false,
      salt
    ),
    // iteration count
    asn1$6.create(
      asn1$6.Class.UNIVERSAL,
      asn1$6.Type.INTEGER,
      false,
      countBytes.getBytes()
    )
  ]);
  if (prfAlgorithm !== "hmacWithSHA1") {
    params.value.push(
      // key length
      asn1$6.create(
        asn1$6.Class.UNIVERSAL,
        asn1$6.Type.INTEGER,
        false,
        forge$h.util.hexToBytes(dkLen.toString(16))
      ),
      // AlgorithmIdentifier
      asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.SEQUENCE, true, [
        // algorithm
        asn1$6.create(
          asn1$6.Class.UNIVERSAL,
          asn1$6.Type.OID,
          false,
          asn1$6.oidToDer(pki$3.oids[prfAlgorithm]).getBytes()
        ),
        // parameters (null)
        asn1$6.create(asn1$6.Class.UNIVERSAL, asn1$6.Type.NULL, false, "")
      ])
    );
  }
  return params;
}
var forge$g = forge$D;
var asn1$5 = forge$g.asn1;
var p7v = forge$g.pkcs7asn1 = forge$g.pkcs7asn1 || {};
forge$g.pkcs7 = forge$g.pkcs7 || {};
forge$g.pkcs7.asn1 = p7v;
var contentInfoValidator$1 = {
  name: "ContentInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "ContentInfo.ContentType",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    captureAsn1: "content"
  }]
};
p7v.contentInfoValidator = contentInfoValidator$1;
var encryptedContentInfoValidator = {
  name: "EncryptedContentInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedContentInfo.contentType",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "EncryptedContentInfo.contentEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: false,
      capture: "encAlgorithm"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      captureAsn1: "encParameter"
    }]
  }, {
    name: "EncryptedContentInfo.encryptedContent",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    /* The PKCS#7 structure output by OpenSSL somewhat differs from what
     * other implementations do generate.
     *
     * OpenSSL generates a structure like this:
     * SEQUENCE {
     *    ...
     *    [0]
     *       26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *       C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *       ...
     * }
     *
     * Whereas other implementations (and this PKCS#7 module) generate:
     * SEQUENCE {
     *    ...
     *    [0] {
     *       OCTET STRING
     *          26 DA 67 D2 17 9C 45 3C B1 2A A8 59 2F 29 33 38
     *          C3 C3 DF 86 71 74 7A 19 9F 40 D0 29 BE 85 90 45
     *          ...
     *    }
     * }
     *
     * In order to support both, we just capture the context specific
     * field here.  The OCTET STRING bit is removed below.
     */
    capture: "encryptedContent",
    captureAsn1: "encryptedContentAsn1"
  }]
};
p7v.envelopedDataValidator = {
  name: "EnvelopedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EnvelopedData.Version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false,
    capture: "version"
  }, {
    name: "EnvelopedData.RecipientInfos",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SET,
    constructed: true,
    captureAsn1: "recipientInfos"
  }].concat(encryptedContentInfoValidator)
};
p7v.encryptedDataValidator = {
  name: "EncryptedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "EncryptedData.Version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false,
    capture: "version"
  }].concat(encryptedContentInfoValidator)
};
var signerValidator = {
  name: "SignerInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "SignerInfo.version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false
  }, {
    name: "SignerInfo.issuerAndSerialNumber",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.issuerAndSerialNumber.issuer",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "issuer"
    }, {
      name: "SignerInfo.issuerAndSerialNumber.serialNumber",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: false,
      capture: "serial"
    }]
  }, {
    name: "SignerInfo.digestAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.digestAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: false,
      capture: "digestAlgorithm"
    }, {
      name: "SignerInfo.digestAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: "digestParameter",
      optional: true
    }]
  }, {
    name: "SignerInfo.authenticatedAttributes",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    optional: true,
    capture: "authenticatedAttributes"
  }, {
    name: "SignerInfo.digestEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    capture: "signatureAlgorithm"
  }, {
    name: "SignerInfo.encryptedDigest",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OCTETSTRING,
    constructed: false,
    capture: "signature"
  }, {
    name: "SignerInfo.unauthenticatedAttributes",
    tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    optional: true,
    capture: "unauthenticatedAttributes"
  }]
};
p7v.signedDataValidator = {
  name: "SignedData",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [
    {
      name: "SignedData.Version",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: false,
      capture: "version"
    },
    {
      name: "SignedData.DigestAlgorithms",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SET,
      constructed: true,
      captureAsn1: "digestAlgorithms"
    },
    contentInfoValidator$1,
    {
      name: "SignedData.Certificates",
      tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
      type: 0,
      optional: true,
      captureAsn1: "certificates"
    },
    {
      name: "SignedData.CertificateRevocationLists",
      tagClass: asn1$5.Class.CONTEXT_SPECIFIC,
      type: 1,
      optional: true,
      captureAsn1: "crls"
    },
    {
      name: "SignedData.SignerInfos",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SET,
      capture: "signerInfos",
      optional: true,
      value: [signerValidator]
    }
  ]
};
p7v.recipientInfoValidator = {
  name: "RecipientInfo",
  tagClass: asn1$5.Class.UNIVERSAL,
  type: asn1$5.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "RecipientInfo.version",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.INTEGER,
    constructed: false,
    capture: "version"
  }, {
    name: "RecipientInfo.issuerAndSerial",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.issuerAndSerial.issuer",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "issuer"
    }, {
      name: "RecipientInfo.issuerAndSerial.serialNumber",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.INTEGER,
      constructed: false,
      capture: "serial"
    }]
  }, {
    name: "RecipientInfo.keyEncryptionAlgorithm",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
      tagClass: asn1$5.Class.UNIVERSAL,
      type: asn1$5.Type.OID,
      constructed: false,
      capture: "encAlgorithm"
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
      tagClass: asn1$5.Class.UNIVERSAL,
      constructed: false,
      captureAsn1: "encParameter",
      optional: true
    }]
  }, {
    name: "RecipientInfo.encryptedKey",
    tagClass: asn1$5.Class.UNIVERSAL,
    type: asn1$5.Type.OCTETSTRING,
    constructed: false,
    capture: "encKey"
  }]
};
var forge$f = forge$D;
forge$f.mgf = forge$f.mgf || {};
var mgf1 = forge$f.mgf.mgf1 = forge$f.mgf1 = forge$f.mgf1 || {};
mgf1.create = function(md) {
  var mgf = {
    /**
     * Generate mask of specified length.
     *
     * @param {String} seed The seed for mask generation.
     * @param maskLen Number of bytes to generate.
     * @return {String} The generated mask.
     */
    generate: function(seed, maskLen) {
      var t2 = new forge$f.util.ByteBuffer();
      var len = Math.ceil(maskLen / md.digestLength);
      for (var i = 0; i < len; i++) {
        var c = new forge$f.util.ByteBuffer();
        c.putInt32(i);
        md.start();
        md.update(seed + c.getBytes());
        t2.putBuffer(md.digest());
      }
      t2.truncate(t2.length() - maskLen);
      return t2.getBytes();
    }
  };
  return mgf;
};
var forge$e = forge$D;
forge$e.mgf = forge$e.mgf || {};
forge$e.mgf.mgf1 = forge$e.mgf1;
var forge$d = forge$D;
var pss = forge$d.pss = forge$d.pss || {};
pss.create = function(options) {
  if (arguments.length === 3) {
    options = {
      md: arguments[0],
      mgf: arguments[1],
      saltLength: arguments[2]
    };
  }
  var hash2 = options.md;
  var mgf = options.mgf;
  var hLen = hash2.digestLength;
  var salt_ = options.salt || null;
  if (typeof salt_ === "string") {
    salt_ = forge$d.util.createBuffer(salt_);
  }
  var sLen;
  if ("saltLength" in options) {
    sLen = options.saltLength;
  } else if (salt_ !== null) {
    sLen = salt_.length();
  } else {
    throw new Error("Salt length not specified or specific salt not given.");
  }
  if (salt_ !== null && salt_.length() !== sLen) {
    throw new Error("Given salt length does not match length of given salt.");
  }
  var prng2 = options.prng || forge$d.random;
  var pssobj = {};
  pssobj.encode = function(md, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    var mHash = md.digest().getBytes();
    if (emLen < hLen + sLen + 2) {
      throw new Error("Message is too long to encrypt.");
    }
    var salt;
    if (salt_ === null) {
      salt = prng2.getBytesSync(sLen);
    } else {
      salt = salt_.bytes();
    }
    var m_ = new forge$d.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    hash2.start();
    hash2.update(m_.getBytes());
    var h2 = hash2.digest().getBytes();
    var ps = new forge$d.util.ByteBuffer();
    ps.fillWithByte(0, emLen - sLen - hLen - 2);
    ps.putByte(1);
    ps.putBytes(salt);
    var db = ps.getBytes();
    var maskLen = emLen - hLen - 1;
    var dbMask = mgf.generate(h2, maskLen);
    var maskedDB = "";
    for (i = 0; i < maskLen; i++) {
      maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }
    var mask = 65280 >> 8 * emLen - emBits & 255;
    maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
    return maskedDB + h2 + String.fromCharCode(188);
  };
  pssobj.verify = function(mHash, em, modBits) {
    var i;
    var emBits = modBits - 1;
    var emLen = Math.ceil(emBits / 8);
    em = em.substr(-emLen);
    if (emLen < hLen + sLen + 2) {
      throw new Error("Inconsistent parameters to PSS signature verification.");
    }
    if (em.charCodeAt(emLen - 1) !== 188) {
      throw new Error("Encoded message does not end in 0xBC.");
    }
    var maskLen = emLen - hLen - 1;
    var maskedDB = em.substr(0, maskLen);
    var h2 = em.substr(maskLen, hLen);
    var mask = 65280 >> 8 * emLen - emBits & 255;
    if ((maskedDB.charCodeAt(0) & mask) !== 0) {
      throw new Error("Bits beyond keysize not zero as expected.");
    }
    var dbMask = mgf.generate(h2, maskLen);
    var db = "";
    for (i = 0; i < maskLen; i++) {
      db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
    }
    db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
    var checkLen = emLen - hLen - sLen - 2;
    for (i = 0; i < checkLen; i++) {
      if (db.charCodeAt(i) !== 0) {
        throw new Error("Leftmost octets not zero as expected");
      }
    }
    if (db.charCodeAt(checkLen) !== 1) {
      throw new Error("Inconsistent PSS signature, 0x01 marker not found");
    }
    var salt = db.substr(-sLen);
    var m_ = new forge$d.util.ByteBuffer();
    m_.fillWithByte(0, 8);
    m_.putBytes(mHash);
    m_.putBytes(salt);
    hash2.start();
    hash2.update(m_.getBytes());
    var h_ = hash2.digest().getBytes();
    return h2 === h_;
  };
  return pssobj;
};
var forge$c = forge$D;
var asn1$4 = forge$c.asn1;
var pki$2 = forge$c.pki = forge$c.pki || {};
var oids = pki$2.oids;
var _shortNames = {};
_shortNames["CN"] = oids["commonName"];
_shortNames["commonName"] = "CN";
_shortNames["C"] = oids["countryName"];
_shortNames["countryName"] = "C";
_shortNames["L"] = oids["localityName"];
_shortNames["localityName"] = "L";
_shortNames["ST"] = oids["stateOrProvinceName"];
_shortNames["stateOrProvinceName"] = "ST";
_shortNames["O"] = oids["organizationName"];
_shortNames["organizationName"] = "O";
_shortNames["OU"] = oids["organizationalUnitName"];
_shortNames["organizationalUnitName"] = "OU";
_shortNames["E"] = oids["emailAddress"];
_shortNames["emailAddress"] = "E";
var publicKeyValidator$1 = forge$c.pki.rsa.publicKeyValidator;
var x509CertificateValidator = {
  name: "Certificate",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "Certificate.TBSCertificate",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "tbsCertificate",
    value: [
      {
        name: "Certificate.TBSCertificate.version",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.version.integer",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.INTEGER,
          constructed: false,
          capture: "certVersion"
        }]
      },
      {
        name: "Certificate.TBSCertificate.serialNumber",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.INTEGER,
        constructed: false,
        capture: "certSerialNumber"
      },
      {
        name: "Certificate.TBSCertificate.signature",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "Certificate.TBSCertificate.signature.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "certinfoSignatureOid"
        }, {
          name: "Certificate.TBSCertificate.signature.parameters",
          tagClass: asn1$4.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "certinfoSignatureParams"
        }]
      },
      {
        name: "Certificate.TBSCertificate.issuer",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certIssuer"
      },
      {
        name: "Certificate.TBSCertificate.validity",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        // Note: UTC and generalized times may both appear so the capture
        // names are based on their detected order, the names used below
        // are only for the common case, which validity time really means
        // "notBefore" and which means "notAfter" will be determined by order
        value: [{
          // notBefore (Time) (UTC time case)
          name: "Certificate.TBSCertificate.validity.notBefore (utc)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.UTCTIME,
          constructed: false,
          optional: true,
          capture: "certValidity1UTCTime"
        }, {
          // notBefore (Time) (generalized time case)
          name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.GENERALIZEDTIME,
          constructed: false,
          optional: true,
          capture: "certValidity2GeneralizedTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (utc)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.UTCTIME,
          constructed: false,
          optional: true,
          capture: "certValidity3UTCTime"
        }, {
          // notAfter (Time) (only UTC time is supported)
          name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.GENERALIZEDTIME,
          constructed: false,
          optional: true,
          capture: "certValidity4GeneralizedTime"
        }]
      },
      {
        // Name (subject) (RDNSequence)
        name: "Certificate.TBSCertificate.subject",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certSubject"
      },
      // SubjectPublicKeyInfo
      publicKeyValidator$1,
      {
        // issuerUniqueID (optional)
        name: "Certificate.TBSCertificate.issuerUniqueID",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 1,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.issuerUniqueID.id",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: false,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certIssuerUniqueId"
        }]
      },
      {
        // subjectUniqueID (optional)
        name: "Certificate.TBSCertificate.subjectUniqueID",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 2,
        constructed: true,
        optional: true,
        value: [{
          name: "Certificate.TBSCertificate.subjectUniqueID.id",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.BITSTRING,
          constructed: false,
          // TODO: support arbitrary bit length ids
          captureBitStringValue: "certSubjectUniqueId"
        }]
      },
      {
        // Extensions (optional)
        name: "Certificate.TBSCertificate.extensions",
        tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
        type: 3,
        constructed: true,
        captureAsn1: "certExtensions",
        optional: true
      }
    ]
  }, {
    // AlgorithmIdentifier (signature algorithm)
    name: "Certificate.signatureAlgorithm",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.SEQUENCE,
    constructed: true,
    value: [{
      // algorithm
      name: "Certificate.signatureAlgorithm.algorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.OID,
      constructed: false,
      capture: "certSignatureOid"
    }, {
      name: "Certificate.TBSCertificate.signature.parameters",
      tagClass: asn1$4.Class.UNIVERSAL,
      optional: true,
      captureAsn1: "certSignatureParams"
    }]
  }, {
    // SignatureValue
    name: "Certificate.signatureValue",
    tagClass: asn1$4.Class.UNIVERSAL,
    type: asn1$4.Type.BITSTRING,
    constructed: false,
    captureBitStringValue: "certSignature"
  }]
};
var rsassaPssParameterValidator = {
  name: "rsapss",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "rsapss.hashAlgorithm",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 0,
    constructed: true,
    value: [{
      name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: false,
        capture: "hashOid"
        /* parameter block omitted, for SHA1 NULL anyhow. */
      }]
    }]
  }, {
    name: "rsapss.maskGenAlgorithm",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 1,
    constructed: true,
    value: [{
      name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.SEQUENCE,
      constructed: true,
      optional: true,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: false,
        capture: "maskGenOid"
      }, {
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false,
          capture: "maskGenHashOid"
          /* parameter block omitted, for SHA1 NULL anyhow. */
        }]
      }]
    }]
  }, {
    name: "rsapss.saltLength",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 2,
    optional: true,
    value: [{
      name: "rsapss.saltLength.saltLength",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.INTEGER,
      constructed: false,
      capture: "saltLength"
    }]
  }, {
    name: "rsapss.trailerField",
    tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
    type: 3,
    optional: true,
    value: [{
      name: "rsapss.trailer.trailer",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Class.INTEGER,
      constructed: false,
      capture: "trailer"
    }]
  }]
};
var certificationRequestInfoValidator = {
  name: "CertificationRequestInfo",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "certificationRequestInfo",
  value: [
    {
      name: "CertificationRequestInfo.integer",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.INTEGER,
      constructed: false,
      capture: "certificationRequestInfoVersion"
    },
    {
      // Name (subject) (RDNSequence)
      name: "CertificationRequestInfo.subject",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "certificationRequestInfoSubject"
    },
    // SubjectPublicKeyInfo
    publicKeyValidator$1,
    {
      name: "CertificationRequestInfo.attributes",
      tagClass: asn1$4.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      capture: "certificationRequestInfoAttributes",
      value: [{
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "CertificationRequestInfo.attributes.type",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.OID,
          constructed: false
        }, {
          name: "CertificationRequestInfo.attributes.value",
          tagClass: asn1$4.Class.UNIVERSAL,
          type: asn1$4.Type.SET,
          constructed: true
        }]
      }]
    }
  ]
};
var certificationRequestValidator = {
  name: "CertificationRequest",
  tagClass: asn1$4.Class.UNIVERSAL,
  type: asn1$4.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "csr",
  value: [
    certificationRequestInfoValidator,
    {
      // AlgorithmIdentifier (signature algorithm)
      name: "CertificationRequest.signatureAlgorithm",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.SEQUENCE,
      constructed: true,
      value: [{
        // algorithm
        name: "CertificationRequest.signatureAlgorithm.algorithm",
        tagClass: asn1$4.Class.UNIVERSAL,
        type: asn1$4.Type.OID,
        constructed: false,
        capture: "csrSignatureOid"
      }, {
        name: "CertificationRequest.signatureAlgorithm.parameters",
        tagClass: asn1$4.Class.UNIVERSAL,
        optional: true,
        captureAsn1: "csrSignatureParams"
      }]
    },
    {
      // signature
      name: "CertificationRequest.signature",
      tagClass: asn1$4.Class.UNIVERSAL,
      type: asn1$4.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: "csrSignature"
    }
  ]
};
pki$2.RDNAttributesAsArray = function(rdn, md) {
  var rval = [];
  var set, attr, obj;
  for (var si = 0; si < rdn.value.length; ++si) {
    set = rdn.value[si];
    for (var i = 0; i < set.value.length; ++i) {
      obj = {};
      attr = set.value[i];
      obj.type = asn1$4.derToOid(attr.value[0].value);
      obj.value = attr.value[1].value;
      obj.valueTagClass = attr.value[1].type;
      if (obj.type in oids) {
        obj.name = oids[obj.type];
        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if (md) {
        md.update(obj.type);
        md.update(obj.value);
      }
      rval.push(obj);
    }
  }
  return rval;
};
pki$2.CRIAttributesAsArray = function(attributes) {
  var rval = [];
  for (var si = 0; si < attributes.length; ++si) {
    var seq = attributes[si];
    var type3 = asn1$4.derToOid(seq.value[0].value);
    var values = seq.value[1].value;
    for (var vi = 0; vi < values.length; ++vi) {
      var obj = {};
      obj.type = type3;
      obj.value = values[vi].value;
      obj.valueTagClass = values[vi].type;
      if (obj.type in oids) {
        obj.name = oids[obj.type];
        if (obj.name in _shortNames) {
          obj.shortName = _shortNames[obj.name];
        }
      }
      if (obj.type === oids.extensionRequest) {
        obj.extensions = [];
        for (var ei = 0; ei < obj.value.length; ++ei) {
          obj.extensions.push(pki$2.certificateExtensionFromAsn1(obj.value[ei]));
        }
      }
      rval.push(obj);
    }
  }
  return rval;
};
function _getAttribute(obj, options) {
  if (typeof options === "string") {
    options = { shortName: options };
  }
  var rval = null;
  var attr;
  for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
    attr = obj.attributes[i];
    if (options.type && options.type === attr.type) {
      rval = attr;
    } else if (options.name && options.name === attr.name) {
      rval = attr;
    } else if (options.shortName && options.shortName === attr.shortName) {
      rval = attr;
    }
  }
  return rval;
}
var _readSignatureParameters = function(oid, obj, fillDefaults) {
  var params = {};
  if (oid !== oids["RSASSA-PSS"]) {
    return params;
  }
  if (fillDefaults) {
    params = {
      hash: {
        algorithmOid: oids["sha1"]
      },
      mgf: {
        algorithmOid: oids["mgf1"],
        hash: {
          algorithmOid: oids["sha1"]
        }
      },
      saltLength: 20
    };
  }
  var capture = {};
  var errors2 = [];
  if (!asn1$4.validate(obj, rsassaPssParameterValidator, capture, errors2)) {
    var error2 = new Error("Cannot read RSASSA-PSS parameter block.");
    error2.errors = errors2;
    throw error2;
  }
  if (capture.hashOid !== void 0) {
    params.hash = params.hash || {};
    params.hash.algorithmOid = asn1$4.derToOid(capture.hashOid);
  }
  if (capture.maskGenOid !== void 0) {
    params.mgf = params.mgf || {};
    params.mgf.algorithmOid = asn1$4.derToOid(capture.maskGenOid);
    params.mgf.hash = params.mgf.hash || {};
    params.mgf.hash.algorithmOid = asn1$4.derToOid(capture.maskGenHashOid);
  }
  if (capture.saltLength !== void 0) {
    params.saltLength = capture.saltLength.charCodeAt(0);
  }
  return params;
};
var _createSignatureDigest = function(options) {
  switch (oids[options.signatureOid]) {
    case "sha1WithRSAEncryption":
    case "sha1WithRSASignature":
      return forge$c.md.sha1.create();
    case "md5WithRSAEncryption":
      return forge$c.md.md5.create();
    case "sha256WithRSAEncryption":
      return forge$c.md.sha256.create();
    case "sha384WithRSAEncryption":
      return forge$c.md.sha384.create();
    case "sha512WithRSAEncryption":
      return forge$c.md.sha512.create();
    case "RSASSA-PSS":
      return forge$c.md.sha256.create();
    default:
      var error2 = new Error(
        "Could not compute " + options.type + " digest. Unknown signature OID."
      );
      error2.signatureOid = options.signatureOid;
      throw error2;
  }
};
var _verifySignature = function(options) {
  var cert = options.certificate;
  var scheme;
  switch (cert.signatureOid) {
    case oids.sha1WithRSAEncryption:
    case oids.sha1WithRSASignature:
      break;
    case oids["RSASSA-PSS"]:
      var hash2, mgf;
      hash2 = oids[cert.signatureParameters.mgf.hash.algorithmOid];
      if (hash2 === void 0 || forge$c.md[hash2] === void 0) {
        var error2 = new Error("Unsupported MGF hash function.");
        error2.oid = cert.signatureParameters.mgf.hash.algorithmOid;
        error2.name = hash2;
        throw error2;
      }
      mgf = oids[cert.signatureParameters.mgf.algorithmOid];
      if (mgf === void 0 || forge$c.mgf[mgf] === void 0) {
        var error2 = new Error("Unsupported MGF function.");
        error2.oid = cert.signatureParameters.mgf.algorithmOid;
        error2.name = mgf;
        throw error2;
      }
      mgf = forge$c.mgf[mgf].create(forge$c.md[hash2].create());
      hash2 = oids[cert.signatureParameters.hash.algorithmOid];
      if (hash2 === void 0 || forge$c.md[hash2] === void 0) {
        var error2 = new Error("Unsupported RSASSA-PSS hash function.");
        error2.oid = cert.signatureParameters.hash.algorithmOid;
        error2.name = hash2;
        throw error2;
      }
      scheme = forge$c.pss.create(
        forge$c.md[hash2].create(),
        mgf,
        cert.signatureParameters.saltLength
      );
      break;
  }
  return cert.publicKey.verify(
    options.md.digest().getBytes(),
    options.signature,
    scheme
  );
};
pki$2.certificateFromPem = function(pem2, computeHash, strict) {
  var msg = forge$c.pem.decode(pem2)[0];
  if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
    var error2 = new Error(
      'Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".'
    );
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error(
      "Could not convert certificate from PEM; PEM is encrypted."
    );
  }
  var obj = asn1$4.fromDer(msg.body, strict);
  return pki$2.certificateFromAsn1(obj, computeHash);
};
pki$2.certificateToPem = function(cert, maxline) {
  var msg = {
    type: "CERTIFICATE",
    body: asn1$4.toDer(pki$2.certificateToAsn1(cert)).getBytes()
  };
  return forge$c.pem.encode(msg, { maxline });
};
pki$2.publicKeyFromPem = function(pem2) {
  var msg = forge$c.pem.decode(pem2)[0];
  if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
    var error2 = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert public key from PEM; PEM is encrypted.");
  }
  var obj = asn1$4.fromDer(msg.body);
  return pki$2.publicKeyFromAsn1(obj);
};
pki$2.publicKeyToPem = function(key, maxline) {
  var msg = {
    type: "PUBLIC KEY",
    body: asn1$4.toDer(pki$2.publicKeyToAsn1(key)).getBytes()
  };
  return forge$c.pem.encode(msg, { maxline });
};
pki$2.publicKeyToRSAPublicKeyPem = function(key, maxline) {
  var msg = {
    type: "RSA PUBLIC KEY",
    body: asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(key)).getBytes()
  };
  return forge$c.pem.encode(msg, { maxline });
};
pki$2.getPublicKeyFingerprint = function(key, options) {
  options = options || {};
  var md = options.md || forge$c.md.sha1.create();
  var type3 = options.type || "RSAPublicKey";
  var bytes2;
  switch (type3) {
    case "RSAPublicKey":
      bytes2 = asn1$4.toDer(pki$2.publicKeyToRSAPublicKey(key)).getBytes();
      break;
    case "SubjectPublicKeyInfo":
      bytes2 = asn1$4.toDer(pki$2.publicKeyToAsn1(key)).getBytes();
      break;
    default:
      throw new Error('Unknown fingerprint type "' + options.type + '".');
  }
  md.start();
  md.update(bytes2);
  var digest = md.digest();
  if (options.encoding === "hex") {
    var hex = digest.toHex();
    if (options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if (options.encoding === "binary") {
    return digest.getBytes();
  } else if (options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
};
pki$2.certificationRequestFromPem = function(pem2, computeHash, strict) {
  var msg = forge$c.pem.decode(pem2)[0];
  if (msg.type !== "CERTIFICATE REQUEST") {
    var error2 = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
  }
  var obj = asn1$4.fromDer(msg.body, strict);
  return pki$2.certificationRequestFromAsn1(obj, computeHash);
};
pki$2.certificationRequestToPem = function(csr, maxline) {
  var msg = {
    type: "CERTIFICATE REQUEST",
    body: asn1$4.toDer(pki$2.certificationRequestToAsn1(csr)).getBytes()
  };
  return forge$c.pem.encode(msg, { maxline });
};
pki$2.createCertificate = function() {
  var cert = {};
  cert.version = 2;
  cert.serialNumber = "00";
  cert.signatureOid = null;
  cert.signature = null;
  cert.siginfo = {};
  cert.siginfo.algorithmOid = null;
  cert.validity = {};
  cert.validity.notBefore = /* @__PURE__ */ new Date();
  cert.validity.notAfter = /* @__PURE__ */ new Date();
  cert.issuer = {};
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = [];
  cert.issuer.hash = null;
  cert.subject = {};
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = [];
  cert.subject.hash = null;
  cert.extensions = [];
  cert.publicKey = null;
  cert.md = null;
  cert.setSubject = function(attrs, uniqueId) {
    _fillMissingFields(attrs);
    cert.subject.attributes = attrs;
    delete cert.subject.uniqueId;
    if (uniqueId) {
      cert.subject.uniqueId = uniqueId;
    }
    cert.subject.hash = null;
  };
  cert.setIssuer = function(attrs, uniqueId) {
    _fillMissingFields(attrs);
    cert.issuer.attributes = attrs;
    delete cert.issuer.uniqueId;
    if (uniqueId) {
      cert.issuer.uniqueId = uniqueId;
    }
    cert.issuer.hash = null;
  };
  cert.setExtensions = function(exts) {
    for (var i = 0; i < exts.length; ++i) {
      _fillMissingExtensionFields(exts[i], { cert });
    }
    cert.extensions = exts;
  };
  cert.getExtension = function(options) {
    if (typeof options === "string") {
      options = { name: options };
    }
    var rval = null;
    var ext;
    for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
      ext = cert.extensions[i];
      if (options.id && ext.id === options.id) {
        rval = ext;
      } else if (options.name && ext.name === options.name) {
        rval = ext;
      }
    }
    return rval;
  };
  cert.sign = function(key, md) {
    cert.md = md || forge$c.md.sha1.create();
    var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
    if (!algorithmOid) {
      var error2 = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
      error2.algorithm = cert.md.algorithm;
      throw error2;
    }
    cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
    cert.tbsCertificate = pki$2.getTBSCertificate(cert);
    var bytes2 = asn1$4.toDer(cert.tbsCertificate);
    cert.md.update(bytes2.getBytes());
    cert.signature = key.sign(cert.md);
  };
  cert.verify = function(child) {
    var rval = false;
    if (!cert.issued(child)) {
      var issuer = child.issuer;
      var subject = cert.subject;
      var error2 = new Error(
        "The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject."
      );
      error2.expectedIssuer = subject.attributes;
      error2.actualIssuer = issuer.attributes;
      throw error2;
    }
    var md = child.md;
    if (md === null) {
      md = _createSignatureDigest({
        signatureOid: child.signatureOid,
        type: "certificate"
      });
      var tbsCertificate = child.tbsCertificate || pki$2.getTBSCertificate(child);
      var bytes2 = asn1$4.toDer(tbsCertificate);
      md.update(bytes2.getBytes());
    }
    if (md !== null) {
      rval = _verifySignature({
        certificate: cert,
        md,
        signature: child.signature
      });
    }
    return rval;
  };
  cert.isIssuer = function(parent) {
    var rval = false;
    var i = cert.issuer;
    var s2 = parent.subject;
    if (i.hash && s2.hash) {
      rval = i.hash === s2.hash;
    } else if (i.attributes.length === s2.attributes.length) {
      rval = true;
      var iattr, sattr;
      for (var n = 0; rval && n < i.attributes.length; ++n) {
        iattr = i.attributes[n];
        sattr = s2.attributes[n];
        if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
          rval = false;
        }
      }
    }
    return rval;
  };
  cert.issued = function(child) {
    return child.isIssuer(cert);
  };
  cert.generateSubjectKeyIdentifier = function() {
    return pki$2.getPublicKeyFingerprint(cert.publicKey, { type: "RSAPublicKey" });
  };
  cert.verifySubjectKeyIdentifier = function() {
    var oid = oids["subjectKeyIdentifier"];
    for (var i = 0; i < cert.extensions.length; ++i) {
      var ext = cert.extensions[i];
      if (ext.id === oid) {
        var ski = cert.generateSubjectKeyIdentifier().getBytes();
        return forge$c.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
      }
    }
    return false;
  };
  return cert;
};
pki$2.certificateFromAsn1 = function(obj, computeHash) {
  var capture = {};
  var errors2 = [];
  if (!asn1$4.validate(obj, x509CertificateValidator, capture, errors2)) {
    var error2 = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$4.derToOid(capture.publicKeyOid);
  if (oid !== pki$2.oids.rsaEncryption) {
    throw new Error("Cannot read public key. OID is not RSA.");
  }
  var cert = pki$2.createCertificate();
  cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
  var serial2 = forge$c.util.createBuffer(capture.certSerialNumber);
  cert.serialNumber = serial2.toHex();
  cert.signatureOid = forge$c.asn1.derToOid(capture.certSignatureOid);
  cert.signatureParameters = _readSignatureParameters(
    cert.signatureOid,
    capture.certSignatureParams,
    true
  );
  cert.siginfo.algorithmOid = forge$c.asn1.derToOid(capture.certinfoSignatureOid);
  cert.siginfo.parameters = _readSignatureParameters(
    cert.siginfo.algorithmOid,
    capture.certinfoSignatureParams,
    false
  );
  cert.signature = capture.certSignature;
  var validity = [];
  if (capture.certValidity1UTCTime !== void 0) {
    validity.push(asn1$4.utcTimeToDate(capture.certValidity1UTCTime));
  }
  if (capture.certValidity2GeneralizedTime !== void 0) {
    validity.push(asn1$4.generalizedTimeToDate(
      capture.certValidity2GeneralizedTime
    ));
  }
  if (capture.certValidity3UTCTime !== void 0) {
    validity.push(asn1$4.utcTimeToDate(capture.certValidity3UTCTime));
  }
  if (capture.certValidity4GeneralizedTime !== void 0) {
    validity.push(asn1$4.generalizedTimeToDate(
      capture.certValidity4GeneralizedTime
    ));
  }
  if (validity.length > 2) {
    throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
  }
  if (validity.length < 2) {
    throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
  }
  cert.validity.notBefore = validity[0];
  cert.validity.notAfter = validity[1];
  cert.tbsCertificate = capture.tbsCertificate;
  if (computeHash) {
    cert.md = _createSignatureDigest({
      signatureOid: cert.signatureOid,
      type: "certificate"
    });
    var bytes2 = asn1$4.toDer(cert.tbsCertificate);
    cert.md.update(bytes2.getBytes());
  }
  var imd = forge$c.md.sha1.create();
  var ibytes = asn1$4.toDer(capture.certIssuer);
  imd.update(ibytes.getBytes());
  cert.issuer.getField = function(sn) {
    return _getAttribute(cert.issuer, sn);
  };
  cert.issuer.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.issuer.attributes.push(attr);
  };
  cert.issuer.attributes = pki$2.RDNAttributesAsArray(capture.certIssuer);
  if (capture.certIssuerUniqueId) {
    cert.issuer.uniqueId = capture.certIssuerUniqueId;
  }
  cert.issuer.hash = imd.digest().toHex();
  var smd = forge$c.md.sha1.create();
  var sbytes = asn1$4.toDer(capture.certSubject);
  smd.update(sbytes.getBytes());
  cert.subject.getField = function(sn) {
    return _getAttribute(cert.subject, sn);
  };
  cert.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    cert.subject.attributes.push(attr);
  };
  cert.subject.attributes = pki$2.RDNAttributesAsArray(capture.certSubject);
  if (capture.certSubjectUniqueId) {
    cert.subject.uniqueId = capture.certSubjectUniqueId;
  }
  cert.subject.hash = smd.digest().toHex();
  if (capture.certExtensions) {
    cert.extensions = pki$2.certificateExtensionsFromAsn1(capture.certExtensions);
  } else {
    cert.extensions = [];
  }
  cert.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  return cert;
};
pki$2.certificateExtensionsFromAsn1 = function(exts) {
  var rval = [];
  for (var i = 0; i < exts.value.length; ++i) {
    var extseq = exts.value[i];
    for (var ei = 0; ei < extseq.value.length; ++ei) {
      rval.push(pki$2.certificateExtensionFromAsn1(extseq.value[ei]));
    }
  }
  return rval;
};
pki$2.certificateExtensionFromAsn1 = function(ext) {
  var e = {};
  e.id = asn1$4.derToOid(ext.value[0].value);
  e.critical = false;
  if (ext.value[1].type === asn1$4.Type.BOOLEAN) {
    e.critical = ext.value[1].value.charCodeAt(0) !== 0;
    e.value = ext.value[2].value;
  } else {
    e.value = ext.value[1].value;
  }
  if (e.id in oids) {
    e.name = oids[e.id];
    if (e.name === "keyUsage") {
      var ev = asn1$4.fromDer(e.value);
      var b2 = 0;
      var b3 = 0;
      if (ev.value.length > 1) {
        b2 = ev.value.charCodeAt(1);
        b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
      }
      e.digitalSignature = (b2 & 128) === 128;
      e.nonRepudiation = (b2 & 64) === 64;
      e.keyEncipherment = (b2 & 32) === 32;
      e.dataEncipherment = (b2 & 16) === 16;
      e.keyAgreement = (b2 & 8) === 8;
      e.keyCertSign = (b2 & 4) === 4;
      e.cRLSign = (b2 & 2) === 2;
      e.encipherOnly = (b2 & 1) === 1;
      e.decipherOnly = (b3 & 128) === 128;
    } else if (e.name === "basicConstraints") {
      var ev = asn1$4.fromDer(e.value);
      if (ev.value.length > 0 && ev.value[0].type === asn1$4.Type.BOOLEAN) {
        e.cA = ev.value[0].value.charCodeAt(0) !== 0;
      } else {
        e.cA = false;
      }
      var value2 = null;
      if (ev.value.length > 0 && ev.value[0].type === asn1$4.Type.INTEGER) {
        value2 = ev.value[0].value;
      } else if (ev.value.length > 1) {
        value2 = ev.value[1].value;
      }
      if (value2 !== null) {
        e.pathLenConstraint = asn1$4.derToInteger(value2);
      }
    } else if (e.name === "extKeyUsage") {
      var ev = asn1$4.fromDer(e.value);
      for (var vi = 0; vi < ev.value.length; ++vi) {
        var oid = asn1$4.derToOid(ev.value[vi].value);
        if (oid in oids) {
          e[oids[oid]] = true;
        } else {
          e[oid] = true;
        }
      }
    } else if (e.name === "nsCertType") {
      var ev = asn1$4.fromDer(e.value);
      var b2 = 0;
      if (ev.value.length > 1) {
        b2 = ev.value.charCodeAt(1);
      }
      e.client = (b2 & 128) === 128;
      e.server = (b2 & 64) === 64;
      e.email = (b2 & 32) === 32;
      e.objsign = (b2 & 16) === 16;
      e.reserved = (b2 & 8) === 8;
      e.sslCA = (b2 & 4) === 4;
      e.emailCA = (b2 & 2) === 2;
      e.objCA = (b2 & 1) === 1;
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.altNames = [];
      var gn;
      var ev = asn1$4.fromDer(e.value);
      for (var n = 0; n < ev.value.length; ++n) {
        gn = ev.value[n];
        var altName = {
          type: gn.type,
          value: gn.value
        };
        e.altNames.push(altName);
        switch (gn.type) {
          case 1:
          case 2:
          case 6:
            break;
          case 7:
            altName.ip = forge$c.util.bytesToIP(gn.value);
            break;
          case 8:
            altName.oid = asn1$4.derToOid(gn.value);
            break;
        }
      }
    } else if (e.name === "subjectKeyIdentifier") {
      var ev = asn1$4.fromDer(e.value);
      e.subjectKeyIdentifier = forge$c.util.bytesToHex(ev.value);
    }
  }
  return e;
};
pki$2.certificationRequestFromAsn1 = function(obj, computeHash) {
  var capture = {};
  var errors2 = [];
  if (!asn1$4.validate(obj, certificationRequestValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$4.derToOid(capture.publicKeyOid);
  if (oid !== pki$2.oids.rsaEncryption) {
    throw new Error("Cannot read public key. OID is not RSA.");
  }
  var csr = pki$2.createCertificationRequest();
  csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
  csr.signatureOid = forge$c.asn1.derToOid(capture.csrSignatureOid);
  csr.signatureParameters = _readSignatureParameters(
    csr.signatureOid,
    capture.csrSignatureParams,
    true
  );
  csr.siginfo.algorithmOid = forge$c.asn1.derToOid(capture.csrSignatureOid);
  csr.siginfo.parameters = _readSignatureParameters(
    csr.siginfo.algorithmOid,
    capture.csrSignatureParams,
    false
  );
  csr.signature = capture.csrSignature;
  csr.certificationRequestInfo = capture.certificationRequestInfo;
  if (computeHash) {
    csr.md = _createSignatureDigest({
      signatureOid: csr.signatureOid,
      type: "certification request"
    });
    var bytes2 = asn1$4.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes2.getBytes());
  }
  var smd = forge$c.md.sha1.create();
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = pki$2.RDNAttributesAsArray(
    capture.certificationRequestInfoSubject,
    smd
  );
  csr.subject.hash = smd.digest().toHex();
  csr.publicKey = pki$2.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.attributes = pki$2.CRIAttributesAsArray(
    capture.certificationRequestInfoAttributes || []
  );
  return csr;
};
pki$2.createCertificationRequest = function() {
  var csr = {};
  csr.version = 0;
  csr.signatureOid = null;
  csr.signature = null;
  csr.siginfo = {};
  csr.siginfo.algorithmOid = null;
  csr.subject = {};
  csr.subject.getField = function(sn) {
    return _getAttribute(csr.subject, sn);
  };
  csr.subject.addField = function(attr) {
    _fillMissingFields([attr]);
    csr.subject.attributes.push(attr);
  };
  csr.subject.attributes = [];
  csr.subject.hash = null;
  csr.publicKey = null;
  csr.attributes = [];
  csr.getAttribute = function(sn) {
    return _getAttribute(csr, sn);
  };
  csr.addAttribute = function(attr) {
    _fillMissingFields([attr]);
    csr.attributes.push(attr);
  };
  csr.md = null;
  csr.setSubject = function(attrs) {
    _fillMissingFields(attrs);
    csr.subject.attributes = attrs;
    csr.subject.hash = null;
  };
  csr.setAttributes = function(attrs) {
    _fillMissingFields(attrs);
    csr.attributes = attrs;
  };
  csr.sign = function(key, md) {
    csr.md = md || forge$c.md.sha1.create();
    var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
    if (!algorithmOid) {
      var error2 = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
      error2.algorithm = csr.md.algorithm;
      throw error2;
    }
    csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
    csr.certificationRequestInfo = pki$2.getCertificationRequestInfo(csr);
    var bytes2 = asn1$4.toDer(csr.certificationRequestInfo);
    csr.md.update(bytes2.getBytes());
    csr.signature = key.sign(csr.md);
  };
  csr.verify = function() {
    var rval = false;
    var md = csr.md;
    if (md === null) {
      md = _createSignatureDigest({
        signatureOid: csr.signatureOid,
        type: "certification request"
      });
      var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
      var bytes2 = asn1$4.toDer(cri);
      md.update(bytes2.getBytes());
    }
    if (md !== null) {
      rval = _verifySignature({
        certificate: csr,
        md,
        signature: csr.signature
      });
    }
    return rval;
  };
  return csr;
};
function _dnToAsn1(obj) {
  var rval = asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.SEQUENCE,
    true,
    []
  );
  var attr, set;
  var attrs = obj.attributes;
  for (var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    var value2 = attr.value;
    var valueTagClass = asn1$4.Type.PRINTABLESTRING;
    if ("valueTagClass" in attr) {
      valueTagClass = attr.valueTagClass;
      if (valueTagClass === asn1$4.Type.UTF8) {
        value2 = forge$c.util.encodeUtf8(value2);
      }
    }
    set = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, true, [
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
        // AttributeType
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          false,
          asn1$4.oidToDer(attr.type).getBytes()
        ),
        // AttributeValue
        asn1$4.create(asn1$4.Class.UNIVERSAL, valueTagClass, false, value2)
      ])
    ]);
    rval.value.push(set);
  }
  return rval;
}
function _fillMissingFields(attrs) {
  var attr;
  for (var i = 0; i < attrs.length; ++i) {
    attr = attrs[i];
    if (typeof attr.name === "undefined") {
      if (attr.type && attr.type in pki$2.oids) {
        attr.name = pki$2.oids[attr.type];
      } else if (attr.shortName && attr.shortName in _shortNames) {
        attr.name = pki$2.oids[_shortNames[attr.shortName]];
      }
    }
    if (typeof attr.type === "undefined") {
      if (attr.name && attr.name in pki$2.oids) {
        attr.type = pki$2.oids[attr.name];
      } else {
        var error2 = new Error("Attribute type not specified.");
        error2.attribute = attr;
        throw error2;
      }
    }
    if (typeof attr.shortName === "undefined") {
      if (attr.name && attr.name in _shortNames) {
        attr.shortName = _shortNames[attr.name];
      }
    }
    if (attr.type === oids.extensionRequest) {
      attr.valueConstructed = true;
      attr.valueTagClass = asn1$4.Type.SEQUENCE;
      if (!attr.value && attr.extensions) {
        attr.value = [];
        for (var ei = 0; ei < attr.extensions.length; ++ei) {
          attr.value.push(pki$2.certificateExtensionToAsn1(
            _fillMissingExtensionFields(attr.extensions[ei])
          ));
        }
      }
    }
    if (typeof attr.value === "undefined") {
      var error2 = new Error("Attribute value not specified.");
      error2.attribute = attr;
      throw error2;
    }
  }
}
function _fillMissingExtensionFields(e, options) {
  options = options || {};
  if (typeof e.name === "undefined") {
    if (e.id && e.id in pki$2.oids) {
      e.name = pki$2.oids[e.id];
    }
  }
  if (typeof e.id === "undefined") {
    if (e.name && e.name in pki$2.oids) {
      e.id = pki$2.oids[e.name];
    } else {
      var error2 = new Error("Extension ID not specified.");
      error2.extension = e;
      throw error2;
    }
  }
  if (typeof e.value !== "undefined") {
    return e;
  }
  if (e.name === "keyUsage") {
    var unused = 0;
    var b2 = 0;
    var b3 = 0;
    if (e.digitalSignature) {
      b2 |= 128;
      unused = 7;
    }
    if (e.nonRepudiation) {
      b2 |= 64;
      unused = 6;
    }
    if (e.keyEncipherment) {
      b2 |= 32;
      unused = 5;
    }
    if (e.dataEncipherment) {
      b2 |= 16;
      unused = 4;
    }
    if (e.keyAgreement) {
      b2 |= 8;
      unused = 3;
    }
    if (e.keyCertSign) {
      b2 |= 4;
      unused = 2;
    }
    if (e.cRLSign) {
      b2 |= 2;
      unused = 1;
    }
    if (e.encipherOnly) {
      b2 |= 1;
      unused = 0;
    }
    if (e.decipherOnly) {
      b3 |= 128;
      unused = 7;
    }
    var value2 = String.fromCharCode(unused);
    if (b3 !== 0) {
      value2 += String.fromCharCode(b2) + String.fromCharCode(b3);
    } else if (b2 !== 0) {
      value2 += String.fromCharCode(b2);
    }
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      value2
    );
  } else if (e.name === "basicConstraints") {
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      true,
      []
    );
    if (e.cA) {
      e.value.value.push(asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.BOOLEAN,
        false,
        String.fromCharCode(255)
      ));
    }
    if ("pathLenConstraint" in e) {
      e.value.value.push(asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.INTEGER,
        false,
        asn1$4.integerToDer(e.pathLenConstraint).getBytes()
      ));
    }
  } else if (e.name === "extKeyUsage") {
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      true,
      []
    );
    var seq = e.value.value;
    for (var key in e) {
      if (e[key] !== true) {
        continue;
      }
      if (key in oids) {
        seq.push(asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          false,
          asn1$4.oidToDer(oids[key]).getBytes()
        ));
      } else if (key.indexOf(".") !== -1) {
        seq.push(asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.OID,
          false,
          asn1$4.oidToDer(key).getBytes()
        ));
      }
    }
  } else if (e.name === "nsCertType") {
    var unused = 0;
    var b2 = 0;
    if (e.client) {
      b2 |= 128;
      unused = 7;
    }
    if (e.server) {
      b2 |= 64;
      unused = 6;
    }
    if (e.email) {
      b2 |= 32;
      unused = 5;
    }
    if (e.objsign) {
      b2 |= 16;
      unused = 4;
    }
    if (e.reserved) {
      b2 |= 8;
      unused = 3;
    }
    if (e.sslCA) {
      b2 |= 4;
      unused = 2;
    }
    if (e.emailCA) {
      b2 |= 2;
      unused = 1;
    }
    if (e.objCA) {
      b2 |= 1;
      unused = 0;
    }
    var value2 = String.fromCharCode(unused);
    if (b2 !== 0) {
      value2 += String.fromCharCode(b2);
    }
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      value2
    );
  } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
    var altName;
    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value2 = altName.value;
      if (altName.type === 7 && altName.ip) {
        value2 = forge$c.util.bytesFromIP(altName.ip);
        if (value2 === null) {
          var error2 = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          error2.extension = e;
          throw error2;
        }
      } else if (altName.type === 8) {
        if (altName.oid) {
          value2 = asn1$4.oidToDer(asn1$4.oidToDer(altName.oid));
        } else {
          value2 = asn1$4.oidToDer(value2);
        }
      }
      e.value.value.push(asn1$4.create(
        asn1$4.Class.CONTEXT_SPECIFIC,
        altName.type,
        false,
        value2
      ));
    }
  } else if (e.name === "nsComment" && options.cert) {
    if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
      throw new Error('Invalid "nsComment" content.');
    }
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.IA5STRING,
      false,
      e.comment
    );
  } else if (e.name === "subjectKeyIdentifier" && options.cert) {
    var ski = options.cert.generateSubjectKeyIdentifier();
    e.subjectKeyIdentifier = ski.toHex();
    e.value = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.OCTETSTRING,
      false,
      ski.getBytes()
    );
  } else if (e.name === "authorityKeyIdentifier" && options.cert) {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    if (e.keyIdentifier) {
      var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
      seq.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier)
      );
    }
    if (e.authorityCertIssuer) {
      var authorityCertIssuer = [
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 4, true, [
          _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
        ])
      ];
      seq.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer)
      );
    }
    if (e.serialNumber) {
      var serialNumber = forge$c.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
      seq.push(
        asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, false, serialNumber)
      );
    }
  } else if (e.name === "cRLDistributionPoints") {
    e.value = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
    var seq = e.value.value;
    var subSeq = asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.SEQUENCE,
      true,
      []
    );
    var fullNameGeneralNames = asn1$4.create(
      asn1$4.Class.CONTEXT_SPECIFIC,
      0,
      true,
      []
    );
    var altName;
    for (var n = 0; n < e.altNames.length; ++n) {
      altName = e.altNames[n];
      var value2 = altName.value;
      if (altName.type === 7 && altName.ip) {
        value2 = forge$c.util.bytesFromIP(altName.ip);
        if (value2 === null) {
          var error2 = new Error(
            'Extension "ip" value is not a valid IPv4 or IPv6 address.'
          );
          error2.extension = e;
          throw error2;
        }
      } else if (altName.type === 8) {
        if (altName.oid) {
          value2 = asn1$4.oidToDer(asn1$4.oidToDer(altName.oid));
        } else {
          value2 = asn1$4.oidToDer(value2);
        }
      }
      fullNameGeneralNames.value.push(asn1$4.create(
        asn1$4.Class.CONTEXT_SPECIFIC,
        altName.type,
        false,
        value2
      ));
    }
    subSeq.value.push(asn1$4.create(
      asn1$4.Class.CONTEXT_SPECIFIC,
      0,
      true,
      [fullNameGeneralNames]
    ));
    seq.push(subSeq);
  }
  if (typeof e.value === "undefined") {
    var error2 = new Error("Extension value not specified.");
    error2.extension = e;
    throw error2;
  }
  return e;
}
function _signatureParametersToAsn1(oid, params) {
  switch (oid) {
    case oids["RSASSA-PSS"]:
      var parts = [];
      if (params.hash.algorithmOid !== void 0) {
        parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(
              asn1$4.Class.UNIVERSAL,
              asn1$4.Type.OID,
              false,
              asn1$4.oidToDer(params.hash.algorithmOid).getBytes()
            ),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
          ])
        ]));
      }
      if (params.mgf.algorithmOid !== void 0) {
        parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, [
          asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
            asn1$4.create(
              asn1$4.Class.UNIVERSAL,
              asn1$4.Type.OID,
              false,
              asn1$4.oidToDer(params.mgf.algorithmOid).getBytes()
            ),
            asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
              asn1$4.create(
                asn1$4.Class.UNIVERSAL,
                asn1$4.Type.OID,
                false,
                asn1$4.oidToDer(params.mgf.hash.algorithmOid).getBytes()
              ),
              asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "")
            ])
          ])
        ]));
      }
      if (params.saltLength !== void 0) {
        parts.push(asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, true, [
          asn1$4.create(
            asn1$4.Class.UNIVERSAL,
            asn1$4.Type.INTEGER,
            false,
            asn1$4.integerToDer(params.saltLength).getBytes()
          )
        ]));
      }
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, parts);
    default:
      return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.NULL, false, "");
  }
}
function _CRIAttributesToAsn1(csr) {
  var rval = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, []);
  if (csr.attributes.length === 0) {
    return rval;
  }
  var attrs = csr.attributes;
  for (var i = 0; i < attrs.length; ++i) {
    var attr = attrs[i];
    var value2 = attr.value;
    var valueTagClass = asn1$4.Type.UTF8;
    if ("valueTagClass" in attr) {
      valueTagClass = attr.valueTagClass;
    }
    if (valueTagClass === asn1$4.Type.UTF8) {
      value2 = forge$c.util.encodeUtf8(value2);
    }
    var valueConstructed = false;
    if ("valueConstructed" in attr) {
      valueConstructed = attr.valueConstructed;
    }
    var seq = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // AttributeType
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(attr.type).getBytes()
      ),
      asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SET, true, [
        // AttributeValue
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          valueTagClass,
          valueConstructed,
          value2
        )
      ])
    ]);
    rval.value.push(seq);
  }
  return rval;
}
var jan_1_1950 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
var jan_1_2050 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
function _dateToAsn1(date) {
  if (date >= jan_1_1950 && date < jan_1_2050) {
    return asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.UTCTIME,
      false,
      asn1$4.dateToUtcTime(date)
    );
  } else {
    return asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.GENERALIZEDTIME,
      false,
      asn1$4.dateToGeneralizedTime(date)
    );
  }
}
pki$2.getTBSCertificate = function(cert) {
  var notBefore = _dateToAsn1(cert.validity.notBefore);
  var notAfter = _dateToAsn1(cert.validity.notAfter);
  var tbs = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // version
    asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 0, true, [
      // integer
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.INTEGER,
        false,
        asn1$4.integerToDer(cert.version).getBytes()
      )
    ]),
    // serialNumber
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      forge$c.util.hexToBytes(cert.serialNumber)
    ),
    // signature
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(cert.siginfo.algorithmOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(
        cert.siginfo.algorithmOid,
        cert.siginfo.parameters
      )
    ]),
    // issuer
    _dnToAsn1(cert.issuer),
    // validity
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      notBefore,
      notAfter
    ]),
    // subject
    _dnToAsn1(cert.subject),
    // SubjectPublicKeyInfo
    pki$2.publicKeyToAsn1(cert.publicKey)
  ]);
  if (cert.issuer.uniqueId) {
    tbs.value.push(
      asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.BITSTRING,
          false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0) + cert.issuer.uniqueId
        )
      ])
    );
  }
  if (cert.subject.uniqueId) {
    tbs.value.push(
      asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1$4.create(
          asn1$4.Class.UNIVERSAL,
          asn1$4.Type.BITSTRING,
          false,
          // TODO: support arbitrary bit length ids
          String.fromCharCode(0) + cert.subject.uniqueId
        )
      ])
    );
  }
  if (cert.extensions.length > 0) {
    tbs.value.push(pki$2.certificateExtensionsToAsn1(cert.extensions));
  }
  return tbs;
};
pki$2.getCertificationRequestInfo = function(csr) {
  var cri = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // version
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.INTEGER,
      false,
      asn1$4.integerToDer(csr.version).getBytes()
    ),
    // subject
    _dnToAsn1(csr.subject),
    // SubjectPublicKeyInfo
    pki$2.publicKeyToAsn1(csr.publicKey),
    // attributes
    _CRIAttributesToAsn1(csr)
  ]);
  return cri;
};
pki$2.distinguishedNameToAsn1 = function(dn) {
  return _dnToAsn1(dn);
};
pki$2.certificateToAsn1 = function(cert) {
  var tbsCertificate = cert.tbsCertificate || pki$2.getTBSCertificate(cert);
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // TBSCertificate
    tbsCertificate,
    // AlgorithmIdentifier (signature algorithm)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(cert.signatureOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
    ]),
    // SignatureValue
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      String.fromCharCode(0) + cert.signature
    )
  ]);
};
pki$2.certificateExtensionsToAsn1 = function(exts) {
  var rval = asn1$4.create(asn1$4.Class.CONTEXT_SPECIFIC, 3, true, []);
  var seq = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
  rval.value.push(seq);
  for (var i = 0; i < exts.length; ++i) {
    seq.value.push(pki$2.certificateExtensionToAsn1(exts[i]));
  }
  return rval;
};
pki$2.certificateExtensionToAsn1 = function(ext) {
  var extseq = asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, []);
  extseq.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OID,
    false,
    asn1$4.oidToDer(ext.id).getBytes()
  ));
  if (ext.critical) {
    extseq.value.push(asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BOOLEAN,
      false,
      String.fromCharCode(255)
    ));
  }
  var value2 = ext.value;
  if (typeof ext.value !== "string") {
    value2 = asn1$4.toDer(value2).getBytes();
  }
  extseq.value.push(asn1$4.create(
    asn1$4.Class.UNIVERSAL,
    asn1$4.Type.OCTETSTRING,
    false,
    value2
  ));
  return extseq;
};
pki$2.certificationRequestToAsn1 = function(csr) {
  var cri = csr.certificationRequestInfo || pki$2.getCertificationRequestInfo(csr);
  return asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
    // CertificationRequestInfo
    cri,
    // AlgorithmIdentifier (signature algorithm)
    asn1$4.create(asn1$4.Class.UNIVERSAL, asn1$4.Type.SEQUENCE, true, [
      // algorithm
      asn1$4.create(
        asn1$4.Class.UNIVERSAL,
        asn1$4.Type.OID,
        false,
        asn1$4.oidToDer(csr.signatureOid).getBytes()
      ),
      // parameters
      _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
    ]),
    // signature
    asn1$4.create(
      asn1$4.Class.UNIVERSAL,
      asn1$4.Type.BITSTRING,
      false,
      String.fromCharCode(0) + csr.signature
    )
  ]);
};
pki$2.createCaStore = function(certs) {
  var caStore = {
    // stored certificates
    certs: {}
  };
  caStore.getIssuer = function(cert2) {
    var rval = getBySubject(cert2.issuer);
    return rval;
  };
  caStore.addCertificate = function(cert2) {
    if (typeof cert2 === "string") {
      cert2 = forge$c.pki.certificateFromPem(cert2);
    }
    ensureSubjectHasHash(cert2.subject);
    if (!caStore.hasCertificate(cert2)) {
      if (cert2.subject.hash in caStore.certs) {
        var tmp = caStore.certs[cert2.subject.hash];
        if (!forge$c.util.isArray(tmp)) {
          tmp = [tmp];
        }
        tmp.push(cert2);
        caStore.certs[cert2.subject.hash] = tmp;
      } else {
        caStore.certs[cert2.subject.hash] = cert2;
      }
    }
  };
  caStore.hasCertificate = function(cert2) {
    if (typeof cert2 === "string") {
      cert2 = forge$c.pki.certificateFromPem(cert2);
    }
    var match2 = getBySubject(cert2.subject);
    if (!match2) {
      return false;
    }
    if (!forge$c.util.isArray(match2)) {
      match2 = [match2];
    }
    var der1 = asn1$4.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
    for (var i2 = 0; i2 < match2.length; ++i2) {
      var der2 = asn1$4.toDer(pki$2.certificateToAsn1(match2[i2])).getBytes();
      if (der1 === der2) {
        return true;
      }
    }
    return false;
  };
  caStore.listAllCertificates = function() {
    var certList = [];
    for (var hash2 in caStore.certs) {
      if (caStore.certs.hasOwnProperty(hash2)) {
        var value2 = caStore.certs[hash2];
        if (!forge$c.util.isArray(value2)) {
          certList.push(value2);
        } else {
          for (var i2 = 0; i2 < value2.length; ++i2) {
            certList.push(value2[i2]);
          }
        }
      }
    }
    return certList;
  };
  caStore.removeCertificate = function(cert2) {
    var result;
    if (typeof cert2 === "string") {
      cert2 = forge$c.pki.certificateFromPem(cert2);
    }
    ensureSubjectHasHash(cert2.subject);
    if (!caStore.hasCertificate(cert2)) {
      return null;
    }
    var match2 = getBySubject(cert2.subject);
    if (!forge$c.util.isArray(match2)) {
      result = caStore.certs[cert2.subject.hash];
      delete caStore.certs[cert2.subject.hash];
      return result;
    }
    var der1 = asn1$4.toDer(pki$2.certificateToAsn1(cert2)).getBytes();
    for (var i2 = 0; i2 < match2.length; ++i2) {
      var der2 = asn1$4.toDer(pki$2.certificateToAsn1(match2[i2])).getBytes();
      if (der1 === der2) {
        result = match2[i2];
        match2.splice(i2, 1);
      }
    }
    if (match2.length === 0) {
      delete caStore.certs[cert2.subject.hash];
    }
    return result;
  };
  function getBySubject(subject) {
    ensureSubjectHasHash(subject);
    return caStore.certs[subject.hash] || null;
  }
  function ensureSubjectHasHash(subject) {
    if (!subject.hash) {
      var md = forge$c.md.sha1.create();
      subject.attributes = pki$2.RDNAttributesAsArray(_dnToAsn1(subject), md);
      subject.hash = md.digest().toHex();
    }
  }
  if (certs) {
    for (var i = 0; i < certs.length; ++i) {
      var cert = certs[i];
      caStore.addCertificate(cert);
    }
  }
  return caStore;
};
pki$2.certificateError = {
  bad_certificate: "forge.pki.BadCertificate",
  unsupported_certificate: "forge.pki.UnsupportedCertificate",
  certificate_revoked: "forge.pki.CertificateRevoked",
  certificate_expired: "forge.pki.CertificateExpired",
  certificate_unknown: "forge.pki.CertificateUnknown",
  unknown_ca: "forge.pki.UnknownCertificateAuthority"
};
pki$2.verifyCertificateChain = function(caStore, chain, options) {
  if (typeof options === "function") {
    options = { verify: options };
  }
  options = options || {};
  chain = chain.slice(0);
  var certs = chain.slice(0);
  var validityCheckDate = options.validityCheckDate;
  if (typeof validityCheckDate === "undefined") {
    validityCheckDate = /* @__PURE__ */ new Date();
  }
  var first2 = true;
  var error2 = null;
  var depth = 0;
  do {
    var cert = chain.shift();
    var parent = null;
    var selfSigned = false;
    if (validityCheckDate) {
      if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
        error2 = {
          message: "Certificate is not valid yet or has expired.",
          error: pki$2.certificateError.certificate_expired,
          notBefore: cert.validity.notBefore,
          notAfter: cert.validity.notAfter,
          // TODO: we might want to reconsider renaming 'now' to
          // 'validityCheckDate' should this API be changed in the future.
          now: validityCheckDate
        };
      }
    }
    if (error2 === null) {
      parent = chain[0] || caStore.getIssuer(cert);
      if (parent === null) {
        if (cert.isIssuer(cert)) {
          selfSigned = true;
          parent = cert;
        }
      }
      if (parent) {
        var parents = parent;
        if (!forge$c.util.isArray(parents)) {
          parents = [parents];
        }
        var verified = false;
        while (!verified && parents.length > 0) {
          parent = parents.shift();
          try {
            verified = parent.verify(cert);
          } catch (ex) {
          }
        }
        if (!verified) {
          error2 = {
            message: "Certificate signature is invalid.",
            error: pki$2.certificateError.bad_certificate
          };
        }
      }
      if (error2 === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
        error2 = {
          message: "Certificate is not trusted.",
          error: pki$2.certificateError.unknown_ca
        };
      }
    }
    if (error2 === null && parent && !cert.isIssuer(parent)) {
      error2 = {
        message: "Certificate issuer is invalid.",
        error: pki$2.certificateError.bad_certificate
      };
    }
    if (error2 === null) {
      var se = {
        keyUsage: true,
        basicConstraints: true
      };
      for (var i = 0; error2 === null && i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if (ext.critical && !(ext.name in se)) {
          error2 = {
            message: "Certificate has an unsupported critical extension.",
            error: pki$2.certificateError.unsupported_certificate
          };
        }
      }
    }
    if (error2 === null && (!first2 || chain.length === 0 && (!parent || selfSigned))) {
      var bcExt = cert.getExtension("basicConstraints");
      var keyUsageExt = cert.getExtension("keyUsage");
      if (keyUsageExt !== null) {
        if (!keyUsageExt.keyCertSign || bcExt === null) {
          error2 = {
            message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
            error: pki$2.certificateError.bad_certificate
          };
        }
      }
      if (error2 === null && bcExt !== null && !bcExt.cA) {
        error2 = {
          message: "Certificate basicConstraints indicates the certificate is not a CA.",
          error: pki$2.certificateError.bad_certificate
        };
      }
      if (error2 === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
        var pathLen = depth - 1;
        if (pathLen > bcExt.pathLenConstraint) {
          error2 = {
            message: "Certificate basicConstraints pathLenConstraint violated.",
            error: pki$2.certificateError.bad_certificate
          };
        }
      }
    }
    var vfd = error2 === null ? true : error2.error;
    var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
    if (ret === true) {
      error2 = null;
    } else {
      if (vfd === true) {
        error2 = {
          message: "The application rejected the certificate.",
          error: pki$2.certificateError.bad_certificate
        };
      }
      if (ret || ret === 0) {
        if (typeof ret === "object" && !forge$c.util.isArray(ret)) {
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.error) {
            error2.error = ret.error;
          }
        } else if (typeof ret === "string") {
          error2.error = ret;
        }
      }
      throw error2;
    }
    first2 = false;
    ++depth;
  } while (chain.length > 0);
  return true;
};
var forge$b = forge$D;
var asn1$3 = forge$b.asn1;
var pki$1 = forge$b.pki;
var p12 = forge$b.pkcs12 = forge$b.pkcs12 || {};
var contentInfoValidator = {
  name: "ContentInfo",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  // a ContentInfo
  constructed: true,
  value: [{
    name: "ContentInfo.contentType",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "contentType"
  }, {
    name: "ContentInfo.content",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: true,
    captureAsn1: "content"
  }]
};
var pfxValidator = {
  name: "PFX",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [
    {
      name: "PFX.version",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.INTEGER,
      constructed: false,
      capture: "version"
    },
    contentInfoValidator,
    {
      name: "PFX.macData",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Type.SEQUENCE,
      constructed: true,
      optional: true,
      captureAsn1: "mac",
      value: [{
        name: "PFX.macData.mac",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.SEQUENCE,
        // DigestInfo
        constructed: true,
        value: [{
          name: "PFX.macData.mac.digestAlgorithm",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.SEQUENCE,
          // DigestAlgorithmIdentifier
          constructed: true,
          value: [{
            name: "PFX.macData.mac.digestAlgorithm.algorithm",
            tagClass: asn1$3.Class.UNIVERSAL,
            type: asn1$3.Type.OID,
            constructed: false,
            capture: "macAlgorithm"
          }, {
            name: "PFX.macData.mac.digestAlgorithm.parameters",
            tagClass: asn1$3.Class.UNIVERSAL,
            captureAsn1: "macAlgorithmParameters"
          }]
        }, {
          name: "PFX.macData.mac.digest",
          tagClass: asn1$3.Class.UNIVERSAL,
          type: asn1$3.Type.OCTETSTRING,
          constructed: false,
          capture: "macDigest"
        }]
      }, {
        name: "PFX.macData.macSalt",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.OCTETSTRING,
        constructed: false,
        capture: "macSalt"
      }, {
        name: "PFX.macData.iterations",
        tagClass: asn1$3.Class.UNIVERSAL,
        type: asn1$3.Type.INTEGER,
        constructed: false,
        optional: true,
        capture: "macIterations"
      }]
    }
  ]
};
var safeBagValidator = {
  name: "SafeBag",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "SafeBag.bagId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "bagId"
  }, {
    name: "SafeBag.bagValue",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: true,
    captureAsn1: "bagValue"
  }, {
    name: "SafeBag.bagAttributes",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SET,
    constructed: true,
    optional: true,
    capture: "bagAttributes"
  }]
};
var attributeValidator = {
  name: "Attribute",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "Attribute.attrId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "oid"
  }, {
    name: "Attribute.attrValues",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.SET,
    constructed: true,
    capture: "values"
  }]
};
var certBagValidator = {
  name: "CertBag",
  tagClass: asn1$3.Class.UNIVERSAL,
  type: asn1$3.Type.SEQUENCE,
  constructed: true,
  value: [{
    name: "CertBag.certId",
    tagClass: asn1$3.Class.UNIVERSAL,
    type: asn1$3.Type.OID,
    constructed: false,
    capture: "certId"
  }, {
    name: "CertBag.certValue",
    tagClass: asn1$3.Class.CONTEXT_SPECIFIC,
    constructed: true,
    /* So far we only support X.509 certificates (which are wrapped in
       an OCTET STRING, hence hard code that here). */
    value: [{
      name: "CertBag.certValue[0]",
      tagClass: asn1$3.Class.UNIVERSAL,
      type: asn1$3.Class.OCTETSTRING,
      constructed: false,
      capture: "cert"
    }]
  }]
};
function _getBagsByAttribute(safeContents, attrName, attrValue, bagType) {
  var result = [];
  for (var i = 0; i < safeContents.length; i++) {
    for (var j2 = 0; j2 < safeContents[i].safeBags.length; j2++) {
      var bag = safeContents[i].safeBags[j2];
      if (bagType !== void 0 && bag.type !== bagType) {
        continue;
      }
      if (attrName === null) {
        result.push(bag);
        continue;
      }
      if (bag.attributes[attrName] !== void 0 && bag.attributes[attrName].indexOf(attrValue) >= 0) {
        result.push(bag);
      }
    }
  }
  return result;
}
p12.pkcs12FromAsn1 = function(obj, strict, password) {
  if (typeof strict === "string") {
    password = strict;
    strict = true;
  } else if (strict === void 0) {
    strict = true;
  }
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(obj, pfxValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#12 PFX. ASN.1 object is not an PKCS#12 PFX.");
    error2.errors = error2;
    throw error2;
  }
  var pfx = {
    version: capture.version.charCodeAt(0),
    safeContents: [],
    /**
     * Gets bags with matching attributes.
     *
     * @param filter the attributes to filter by:
     *          [localKeyId] the localKeyId to search for.
     *          [localKeyIdHex] the localKeyId in hex to search for.
     *          [friendlyName] the friendly name to search for.
     *          [bagType] bag type to narrow each attribute search by.
     *
     * @return a map of attribute type to an array of matching bags or, if no
     *           attribute was given but a bag type, the map key will be the
     *           bag type.
     */
    getBags: function(filter3) {
      var rval = {};
      var localKeyId;
      if ("localKeyId" in filter3) {
        localKeyId = filter3.localKeyId;
      } else if ("localKeyIdHex" in filter3) {
        localKeyId = forge$b.util.hexToBytes(filter3.localKeyIdHex);
      }
      if (localKeyId === void 0 && !("friendlyName" in filter3) && "bagType" in filter3) {
        rval[filter3.bagType] = _getBagsByAttribute(
          pfx.safeContents,
          null,
          null,
          filter3.bagType
        );
      }
      if (localKeyId !== void 0) {
        rval.localKeyId = _getBagsByAttribute(
          pfx.safeContents,
          "localKeyId",
          localKeyId,
          filter3.bagType
        );
      }
      if ("friendlyName" in filter3) {
        rval.friendlyName = _getBagsByAttribute(
          pfx.safeContents,
          "friendlyName",
          filter3.friendlyName,
          filter3.bagType
        );
      }
      return rval;
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching friendlyName attribute.
     *
     * @param friendlyName the friendly name to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching friendlyName attribute.
     */
    getBagsByFriendlyName: function(friendlyName, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents,
        "friendlyName",
        friendlyName,
        bagType
      );
    },
    /**
     * DEPRECATED: use getBags() instead.
     *
     * Get bags with matching localKeyId attribute.
     *
     * @param localKeyId the localKeyId to search for.
     * @param [bagType] bag type to narrow search by.
     *
     * @return an array of bags with matching localKeyId attribute.
     */
    getBagsByLocalKeyId: function(localKeyId, bagType) {
      return _getBagsByAttribute(
        pfx.safeContents,
        "localKeyId",
        localKeyId,
        bagType
      );
    }
  };
  if (capture.version.charCodeAt(0) !== 3) {
    var error2 = new Error("PKCS#12 PFX of version other than 3 not supported.");
    error2.version = capture.version.charCodeAt(0);
    throw error2;
  }
  if (asn1$3.derToOid(capture.contentType) !== pki$1.oids.data) {
    var error2 = new Error("Only PKCS#12 PFX in password integrity mode supported.");
    error2.oid = asn1$3.derToOid(capture.contentType);
    throw error2;
  }
  var data2 = capture.content.value[0];
  if (data2.tagClass !== asn1$3.Class.UNIVERSAL || data2.type !== asn1$3.Type.OCTETSTRING) {
    throw new Error("PKCS#12 authSafe content data is not an OCTET STRING.");
  }
  data2 = _decodePkcs7Data(data2);
  if (capture.mac) {
    var md = null;
    var macKeyBytes = 0;
    var macAlgorithm = asn1$3.derToOid(capture.macAlgorithm);
    switch (macAlgorithm) {
      case pki$1.oids.sha1:
        md = forge$b.md.sha1.create();
        macKeyBytes = 20;
        break;
      case pki$1.oids.sha256:
        md = forge$b.md.sha256.create();
        macKeyBytes = 32;
        break;
      case pki$1.oids.sha384:
        md = forge$b.md.sha384.create();
        macKeyBytes = 48;
        break;
      case pki$1.oids.sha512:
        md = forge$b.md.sha512.create();
        macKeyBytes = 64;
        break;
      case pki$1.oids.md5:
        md = forge$b.md.md5.create();
        macKeyBytes = 16;
        break;
    }
    if (md === null) {
      throw new Error("PKCS#12 uses unsupported MAC algorithm: " + macAlgorithm);
    }
    var macSalt = new forge$b.util.ByteBuffer(capture.macSalt);
    var macIterations = "macIterations" in capture ? parseInt(forge$b.util.bytesToHex(capture.macIterations), 16) : 1;
    var macKey = p12.generateKey(
      password,
      macSalt,
      3,
      macIterations,
      macKeyBytes,
      md
    );
    var mac = forge$b.hmac.create();
    mac.start(md, macKey);
    mac.update(data2.value);
    var macValue = mac.getMac();
    if (macValue.getBytes() !== capture.macDigest) {
      throw new Error("PKCS#12 MAC could not be verified. Invalid password?");
    }
  }
  _decodeAuthenticatedSafe(pfx, data2.value, strict, password);
  return pfx;
};
function _decodePkcs7Data(data2) {
  if (data2.composed || data2.constructed) {
    var value2 = forge$b.util.createBuffer();
    for (var i = 0; i < data2.value.length; ++i) {
      value2.putBytes(data2.value[i].value);
    }
    data2.composed = data2.constructed = false;
    data2.value = value2.getBytes();
  }
  return data2;
}
function _decodeAuthenticatedSafe(pfx, authSafe, strict, password) {
  authSafe = asn1$3.fromDer(authSafe, strict);
  if (authSafe.tagClass !== asn1$3.Class.UNIVERSAL || authSafe.type !== asn1$3.Type.SEQUENCE || authSafe.constructed !== true) {
    throw new Error("PKCS#12 AuthenticatedSafe expected to be a SEQUENCE OF ContentInfo");
  }
  for (var i = 0; i < authSafe.value.length; i++) {
    var contentInfo = authSafe.value[i];
    var capture = {};
    var errors2 = [];
    if (!asn1$3.validate(contentInfo, contentInfoValidator, capture, errors2)) {
      var error2 = new Error("Cannot read ContentInfo.");
      error2.errors = errors2;
      throw error2;
    }
    var obj = {
      encrypted: false
    };
    var safeContents = null;
    var data2 = capture.content.value[0];
    switch (asn1$3.derToOid(capture.contentType)) {
      case pki$1.oids.data:
        if (data2.tagClass !== asn1$3.Class.UNIVERSAL || data2.type !== asn1$3.Type.OCTETSTRING) {
          throw new Error("PKCS#12 SafeContents Data is not an OCTET STRING.");
        }
        safeContents = _decodePkcs7Data(data2).value;
        break;
      case pki$1.oids.encryptedData:
        safeContents = _decryptSafeContents(data2, password);
        obj.encrypted = true;
        break;
      default:
        var error2 = new Error("Unsupported PKCS#12 contentType.");
        error2.contentType = asn1$3.derToOid(capture.contentType);
        throw error2;
    }
    obj.safeBags = _decodeSafeContents(safeContents, strict, password);
    pfx.safeContents.push(obj);
  }
}
function _decryptSafeContents(data2, password) {
  var capture = {};
  var errors2 = [];
  if (!asn1$3.validate(
    data2,
    forge$b.pkcs7.asn1.encryptedDataValidator,
    capture,
    errors2
  )) {
    var error2 = new Error("Cannot read EncryptedContentInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = asn1$3.derToOid(capture.contentType);
  if (oid !== pki$1.oids.data) {
    var error2 = new Error(
      "PKCS#12 EncryptedContentInfo ContentType is not Data."
    );
    error2.oid = oid;
    throw error2;
  }
  oid = asn1$3.derToOid(capture.encAlgorithm);
  var cipher = pki$1.pbe.getCipher(oid, capture.encParameter, password);
  var encryptedContentAsn1 = _decodePkcs7Data(capture.encryptedContentAsn1);
  var encrypted = forge$b.util.createBuffer(encryptedContentAsn1.value);
  cipher.update(encrypted);
  if (!cipher.finish()) {
    throw new Error("Failed to decrypt PKCS#12 SafeContents.");
  }
  return cipher.output.getBytes();
}
function _decodeSafeContents(safeContents, strict, password) {
  if (!strict && safeContents.length === 0) {
    return [];
  }
  safeContents = asn1$3.fromDer(safeContents, strict);
  if (safeContents.tagClass !== asn1$3.Class.UNIVERSAL || safeContents.type !== asn1$3.Type.SEQUENCE || safeContents.constructed !== true) {
    throw new Error(
      "PKCS#12 SafeContents expected to be a SEQUENCE OF SafeBag."
    );
  }
  var res2 = [];
  for (var i = 0; i < safeContents.value.length; i++) {
    var safeBag = safeContents.value[i];
    var capture = {};
    var errors2 = [];
    if (!asn1$3.validate(safeBag, safeBagValidator, capture, errors2)) {
      var error2 = new Error("Cannot read SafeBag.");
      error2.errors = errors2;
      throw error2;
    }
    var bag = {
      type: asn1$3.derToOid(capture.bagId),
      attributes: _decodeBagAttributes(capture.bagAttributes)
    };
    res2.push(bag);
    var validator2, decoder;
    var bagAsn1 = capture.bagValue.value[0];
    switch (bag.type) {
      case pki$1.oids.pkcs8ShroudedKeyBag:
        bagAsn1 = pki$1.decryptPrivateKeyInfo(bagAsn1, password);
        if (bagAsn1 === null) {
          throw new Error(
            "Unable to decrypt PKCS#8 ShroudedKeyBag, wrong password?"
          );
        }
      case pki$1.oids.keyBag:
        try {
          bag.key = pki$1.privateKeyFromAsn1(bagAsn1);
        } catch (e) {
          bag.key = null;
          bag.asn1 = bagAsn1;
        }
        continue;
      case pki$1.oids.certBag:
        validator2 = certBagValidator;
        decoder = function() {
          if (asn1$3.derToOid(capture.certId) !== pki$1.oids.x509Certificate) {
            var error3 = new Error(
              "Unsupported certificate type, only X.509 supported."
            );
            error3.oid = asn1$3.derToOid(capture.certId);
            throw error3;
          }
          var certAsn1 = asn1$3.fromDer(capture.cert, strict);
          try {
            bag.cert = pki$1.certificateFromAsn1(certAsn1, true);
          } catch (e) {
            bag.cert = null;
            bag.asn1 = certAsn1;
          }
        };
        break;
      default:
        var error2 = new Error("Unsupported PKCS#12 SafeBag type.");
        error2.oid = bag.type;
        throw error2;
    }
    if (validator2 !== void 0 && !asn1$3.validate(bagAsn1, validator2, capture, errors2)) {
      var error2 = new Error("Cannot read PKCS#12 " + validator2.name);
      error2.errors = errors2;
      throw error2;
    }
    decoder();
  }
  return res2;
}
function _decodeBagAttributes(attributes) {
  var decodedAttrs = {};
  if (attributes !== void 0) {
    for (var i = 0; i < attributes.length; ++i) {
      var capture = {};
      var errors2 = [];
      if (!asn1$3.validate(attributes[i], attributeValidator, capture, errors2)) {
        var error2 = new Error("Cannot read PKCS#12 BagAttribute.");
        error2.errors = errors2;
        throw error2;
      }
      var oid = asn1$3.derToOid(capture.oid);
      if (pki$1.oids[oid] === void 0) {
        continue;
      }
      decodedAttrs[pki$1.oids[oid]] = [];
      for (var j2 = 0; j2 < capture.values.length; ++j2) {
        decodedAttrs[pki$1.oids[oid]].push(capture.values[j2].value);
      }
    }
  }
  return decodedAttrs;
}
p12.toPkcs12Asn1 = function(key, cert, password, options) {
  options = options || {};
  options.saltSize = options.saltSize || 8;
  options.count = options.count || 2048;
  options.algorithm = options.algorithm || options.encAlgorithm || "aes128";
  if (!("useMac" in options)) {
    options.useMac = true;
  }
  if (!("localKeyId" in options)) {
    options.localKeyId = null;
  }
  if (!("generateLocalKeyId" in options)) {
    options.generateLocalKeyId = true;
  }
  var localKeyId = options.localKeyId;
  var bagAttrs;
  if (localKeyId !== null) {
    localKeyId = forge$b.util.hexToBytes(localKeyId);
  } else if (options.generateLocalKeyId) {
    if (cert) {
      var pairedCert = forge$b.util.isArray(cert) ? cert[0] : cert;
      if (typeof pairedCert === "string") {
        pairedCert = pki$1.certificateFromPem(pairedCert);
      }
      var sha12 = forge$b.md.sha1.create();
      sha12.update(asn1$3.toDer(pki$1.certificateToAsn1(pairedCert)).getBytes());
      localKeyId = sha12.digest().getBytes();
    } else {
      localKeyId = forge$b.random.getBytes(20);
    }
  }
  var attrs = [];
  if (localKeyId !== null) {
    attrs.push(
      // localKeyID
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // attrId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.localKeyId).getBytes()
        ),
        // attrValues
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            false,
            localKeyId
          )
        ])
      ])
    );
  }
  if ("friendlyName" in options) {
    attrs.push(
      // friendlyName
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // attrId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.friendlyName).getBytes()
        ),
        // attrValues
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.BMPSTRING,
            false,
            options.friendlyName
          )
        ])
      ])
    );
  }
  if (attrs.length > 0) {
    bagAttrs = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SET, true, attrs);
  }
  var contents = [];
  var chain = [];
  if (cert !== null) {
    if (forge$b.util.isArray(cert)) {
      chain = cert;
    } else {
      chain = [cert];
    }
  }
  var certSafeBags = [];
  for (var i = 0; i < chain.length; ++i) {
    cert = chain[i];
    if (typeof cert === "string") {
      cert = pki$1.certificateFromPem(cert);
    }
    var certBagAttrs = i === 0 ? bagAttrs : void 0;
    var certAsn1 = pki$1.certificateToAsn1(cert);
    var certSafeBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
      // bagId
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        false,
        asn1$3.oidToDer(pki$1.oids.certBag).getBytes()
      ),
      // bagValue
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
        // CertBag
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          // certId
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OID,
            false,
            asn1$3.oidToDer(pki$1.oids.x509Certificate).getBytes()
          ),
          // certValue (x509Certificate)
          asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1$3.create(
              asn1$3.Class.UNIVERSAL,
              asn1$3.Type.OCTETSTRING,
              false,
              asn1$3.toDer(certAsn1).getBytes()
            )
          ])
        ])
      ]),
      // bagAttributes (OPTIONAL)
      certBagAttrs
    ]);
    certSafeBags.push(certSafeBag);
  }
  if (certSafeBags.length > 0) {
    var certSafeContents = asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.SEQUENCE,
      true,
      certSafeBags
    );
    var certCI = (
      // PKCS#7 ContentInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // contentType
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          // OID for the content type is 'data'
          asn1$3.oidToDer(pki$1.oids.data).getBytes()
        ),
        // content
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            false,
            asn1$3.toDer(certSafeContents).getBytes()
          )
        ])
      ])
    );
    contents.push(certCI);
  }
  var keyBag = null;
  if (key !== null) {
    var pkAsn1 = pki$1.wrapRsaPrivateKey(pki$1.privateKeyToAsn1(key));
    if (password === null) {
      keyBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // bagId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.keyBag).getBytes()
        ),
        // bagValue
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          // PrivateKeyInfo
          pkAsn1
        ]),
        // bagAttributes (OPTIONAL)
        bagAttrs
      ]);
    } else {
      keyBag = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // bagId
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          asn1$3.oidToDer(pki$1.oids.pkcs8ShroudedKeyBag).getBytes()
        ),
        // bagValue
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          // EncryptedPrivateKeyInfo
          pki$1.encryptPrivateKeyInfo(pkAsn1, password, options)
        ]),
        // bagAttributes (OPTIONAL)
        bagAttrs
      ]);
    }
    var keySafeContents = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [keyBag]);
    var keyCI = (
      // PKCS#7 ContentInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // contentType
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OID,
          false,
          // OID for the content type is 'data'
          asn1$3.oidToDer(pki$1.oids.data).getBytes()
        ),
        // content
        asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OCTETSTRING,
            false,
            asn1$3.toDer(keySafeContents).getBytes()
          )
        ])
      ])
    );
    contents.push(keyCI);
  }
  var safe = asn1$3.create(
    asn1$3.Class.UNIVERSAL,
    asn1$3.Type.SEQUENCE,
    true,
    contents
  );
  var macData;
  if (options.useMac) {
    var sha12 = forge$b.md.sha1.create();
    var macSalt = new forge$b.util.ByteBuffer(
      forge$b.random.getBytes(options.saltSize)
    );
    var count = options.count;
    var key = p12.generateKey(password, macSalt, 3, count, 20);
    var mac = forge$b.hmac.create();
    mac.start(sha12, key);
    mac.update(asn1$3.toDer(safe).getBytes());
    var macValue = mac.getMac();
    macData = asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
      // mac DigestInfo
      asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
        // digestAlgorithm
        asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
          // algorithm = SHA-1
          asn1$3.create(
            asn1$3.Class.UNIVERSAL,
            asn1$3.Type.OID,
            false,
            asn1$3.oidToDer(pki$1.oids.sha1).getBytes()
          ),
          // parameters = Null
          asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.NULL, false, "")
        ]),
        // digest
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          false,
          macValue.getBytes()
        )
      ]),
      // macSalt OCTET STRING
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OCTETSTRING,
        false,
        macSalt.getBytes()
      ),
      // iterations INTEGER (XXX: Only support count < 65536)
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.INTEGER,
        false,
        asn1$3.integerToDer(count).getBytes()
      )
    ]);
  }
  return asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
    // version (3)
    asn1$3.create(
      asn1$3.Class.UNIVERSAL,
      asn1$3.Type.INTEGER,
      false,
      asn1$3.integerToDer(3).getBytes()
    ),
    // PKCS#7 ContentInfo
    asn1$3.create(asn1$3.Class.UNIVERSAL, asn1$3.Type.SEQUENCE, true, [
      // contentType
      asn1$3.create(
        asn1$3.Class.UNIVERSAL,
        asn1$3.Type.OID,
        false,
        // OID for the content type is 'data'
        asn1$3.oidToDer(pki$1.oids.data).getBytes()
      ),
      // content
      asn1$3.create(asn1$3.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1$3.create(
          asn1$3.Class.UNIVERSAL,
          asn1$3.Type.OCTETSTRING,
          false,
          asn1$3.toDer(safe).getBytes()
        )
      ])
    ]),
    macData
  ]);
};
p12.generateKey = forge$b.pbe.generatePkcs12Key;
var forge$a = forge$D;
var asn1$2 = forge$a.asn1;
var pki = forge$a.pki = forge$a.pki || {};
pki.pemToDer = function(pem2) {
  var msg = forge$a.pem.decode(pem2)[0];
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert PEM to DER; PEM is encrypted.");
  }
  return forge$a.util.createBuffer(msg.body);
};
pki.privateKeyFromPem = function(pem2) {
  var msg = forge$a.pem.decode(pem2)[0];
  if (msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
    var error2 = new Error('Could not convert private key from PEM; PEM header type is not "PRIVATE KEY" or "RSA PRIVATE KEY".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert private key from PEM; PEM is encrypted.");
  }
  var obj = asn1$2.fromDer(msg.body);
  return pki.privateKeyFromAsn1(obj);
};
pki.privateKeyToPem = function(key, maxline) {
  var msg = {
    type: "RSA PRIVATE KEY",
    body: asn1$2.toDer(pki.privateKeyToAsn1(key)).getBytes()
  };
  return forge$a.pem.encode(msg, { maxline });
};
pki.privateKeyInfoToPem = function(pki2, maxline) {
  var msg = {
    type: "PRIVATE KEY",
    body: asn1$2.toDer(pki2).getBytes()
  };
  return forge$a.pem.encode(msg, { maxline });
};
var forge$9 = forge$D;
var prf_TLS1 = function(secret, label, seed, length) {
  var rval = forge$9.util.createBuffer();
  var idx = secret.length >> 1;
  var slen = idx + (secret.length & 1);
  var s1 = secret.substr(0, slen);
  var s2 = secret.substr(idx, slen);
  var ai = forge$9.util.createBuffer();
  var hmac2 = forge$9.hmac.create();
  seed = label + seed;
  var md5itr = Math.ceil(length / 16);
  var sha1itr = Math.ceil(length / 20);
  hmac2.start("MD5", s1);
  var md5bytes = forge$9.util.createBuffer();
  ai.putBytes(seed);
  for (var i = 0; i < md5itr; ++i) {
    hmac2.start(null, null);
    hmac2.update(ai.getBytes());
    ai.putBuffer(hmac2.digest());
    hmac2.start(null, null);
    hmac2.update(ai.bytes() + seed);
    md5bytes.putBuffer(hmac2.digest());
  }
  hmac2.start("SHA1", s2);
  var sha1bytes = forge$9.util.createBuffer();
  ai.clear();
  ai.putBytes(seed);
  for (var i = 0; i < sha1itr; ++i) {
    hmac2.start(null, null);
    hmac2.update(ai.getBytes());
    ai.putBuffer(hmac2.digest());
    hmac2.start(null, null);
    hmac2.update(ai.bytes() + seed);
    sha1bytes.putBuffer(hmac2.digest());
  }
  rval.putBytes(forge$9.util.xorBytes(
    md5bytes.getBytes(),
    sha1bytes.getBytes(),
    length
  ));
  return rval;
};
var hmac_sha1 = function(key, seqNum, record) {
  var hmac2 = forge$9.hmac.create();
  hmac2.start("SHA1", key);
  var b = forge$9.util.createBuffer();
  b.putInt32(seqNum[0]);
  b.putInt32(seqNum[1]);
  b.putByte(record.type);
  b.putByte(record.version.major);
  b.putByte(record.version.minor);
  b.putInt16(record.length);
  b.putBytes(record.fragment.bytes());
  hmac2.update(b.getBytes());
  return hmac2.digest().getBytes();
};
var deflate = function(c, record, s2) {
  var rval = false;
  try {
    var bytes2 = c.deflate(record.fragment.getBytes());
    record.fragment = forge$9.util.createBuffer(bytes2);
    record.length = bytes2.length;
    rval = true;
  } catch (ex) {
  }
  return rval;
};
var inflate = function(c, record, s2) {
  var rval = false;
  try {
    var bytes2 = c.inflate(record.fragment.getBytes());
    record.fragment = forge$9.util.createBuffer(bytes2);
    record.length = bytes2.length;
    rval = true;
  } catch (ex) {
  }
  return rval;
};
var readVector = function(b, lenBytes) {
  var len = 0;
  switch (lenBytes) {
    case 1:
      len = b.getByte();
      break;
    case 2:
      len = b.getInt16();
      break;
    case 3:
      len = b.getInt24();
      break;
    case 4:
      len = b.getInt32();
      break;
  }
  return forge$9.util.createBuffer(b.getBytes(len));
};
var writeVector = function(b, lenBytes, v) {
  b.putInt(v.length(), lenBytes << 3);
  b.putBuffer(v);
};
var tls$6 = {};
tls$6.Versions = {
  TLS_1_0: { major: 3, minor: 1 },
  TLS_1_1: { major: 3, minor: 2 },
  TLS_1_2: { major: 3, minor: 3 }
};
tls$6.SupportedVersions = [
  tls$6.Versions.TLS_1_1,
  tls$6.Versions.TLS_1_0
];
tls$6.Version = tls$6.SupportedVersions[0];
tls$6.MaxFragment = 16384 - 1024;
tls$6.ConnectionEnd = {
  server: 0,
  client: 1
};
tls$6.PRFAlgorithm = {
  tls_prf_sha256: 0
};
tls$6.BulkCipherAlgorithm = {
  none: null,
  rc4: 0,
  des3: 1,
  aes: 2
};
tls$6.CipherType = {
  stream: 0,
  block: 1,
  aead: 2
};
tls$6.MACAlgorithm = {
  none: null,
  hmac_md5: 0,
  hmac_sha1: 1,
  hmac_sha256: 2,
  hmac_sha384: 3,
  hmac_sha512: 4
};
tls$6.CompressionMethod = {
  none: 0,
  deflate: 1
};
tls$6.ContentType = {
  change_cipher_spec: 20,
  alert: 21,
  handshake: 22,
  application_data: 23,
  heartbeat: 24
};
tls$6.HandshakeType = {
  hello_request: 0,
  client_hello: 1,
  server_hello: 2,
  certificate: 11,
  server_key_exchange: 12,
  certificate_request: 13,
  server_hello_done: 14,
  certificate_verify: 15,
  client_key_exchange: 16,
  finished: 20
};
tls$6.Alert = {};
tls$6.Alert.Level = {
  warning: 1,
  fatal: 2
};
tls$6.Alert.Description = {
  close_notify: 0,
  unexpected_message: 10,
  bad_record_mac: 20,
  decryption_failed: 21,
  record_overflow: 22,
  decompression_failure: 30,
  handshake_failure: 40,
  bad_certificate: 42,
  unsupported_certificate: 43,
  certificate_revoked: 44,
  certificate_expired: 45,
  certificate_unknown: 46,
  illegal_parameter: 47,
  unknown_ca: 48,
  access_denied: 49,
  decode_error: 50,
  decrypt_error: 51,
  export_restriction: 60,
  protocol_version: 70,
  insufficient_security: 71,
  internal_error: 80,
  user_canceled: 90,
  no_renegotiation: 100
};
tls$6.HeartbeatMessageType = {
  heartbeat_request: 1,
  heartbeat_response: 2
};
tls$6.CipherSuites = {};
tls$6.getCipherSuite = function(twoBytes) {
  var rval = null;
  for (var key in tls$6.CipherSuites) {
    var cs = tls$6.CipherSuites[key];
    if (cs.id[0] === twoBytes.charCodeAt(0) && cs.id[1] === twoBytes.charCodeAt(1)) {
      rval = cs;
      break;
    }
  }
  return rval;
};
tls$6.handleUnexpected = function(c, record) {
  var ignore = !c.open && c.entity === tls$6.ConnectionEnd.client;
  if (!ignore) {
    c.error(c, {
      message: "Unexpected message. Received TLS record out of order.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.unexpected_message
      }
    });
  }
};
tls$6.handleHelloRequest = function(c, record, length) {
  if (!c.handshaking && c.handshakes > 0) {
    tls$6.queue(c, tls$6.createAlert(c, {
      level: tls$6.Alert.Level.warning,
      description: tls$6.Alert.Description.no_renegotiation
    }));
    tls$6.flush(c);
  }
  c.process();
};
tls$6.parseHelloMessage = function(c, record, length) {
  var msg = null;
  var client = c.entity === tls$6.ConnectionEnd.client;
  if (length < 38) {
    c.error(c, {
      message: client ? "Invalid ServerHello message. Message too short." : "Invalid ClientHello message. Message too short.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.illegal_parameter
      }
    });
  } else {
    var b = record.fragment;
    var remaining = b.length();
    msg = {
      version: {
        major: b.getByte(),
        minor: b.getByte()
      },
      random: forge$9.util.createBuffer(b.getBytes(32)),
      session_id: readVector(b, 1),
      extensions: []
    };
    if (client) {
      msg.cipher_suite = b.getBytes(2);
      msg.compression_method = b.getByte();
    } else {
      msg.cipher_suites = readVector(b, 2);
      msg.compression_methods = readVector(b, 1);
    }
    remaining = length - (remaining - b.length());
    if (remaining > 0) {
      var exts = readVector(b, 2);
      while (exts.length() > 0) {
        msg.extensions.push({
          type: [exts.getByte(), exts.getByte()],
          data: readVector(exts, 2)
        });
      }
      if (!client) {
        for (var i = 0; i < msg.extensions.length; ++i) {
          var ext = msg.extensions[i];
          if (ext.type[0] === 0 && ext.type[1] === 0) {
            var snl = readVector(ext.data, 2);
            while (snl.length() > 0) {
              var snType = snl.getByte();
              if (snType !== 0) {
                break;
              }
              c.session.extensions.server_name.serverNameList.push(
                readVector(snl, 2).getBytes()
              );
            }
          }
        }
      }
    }
    if (c.session.version) {
      if (msg.version.major !== c.session.version.major || msg.version.minor !== c.session.version.minor) {
        return c.error(c, {
          message: "TLS version change is disallowed during renegotiation.",
          send: true,
          alert: {
            level: tls$6.Alert.Level.fatal,
            description: tls$6.Alert.Description.protocol_version
          }
        });
      }
    }
    if (client) {
      c.session.cipherSuite = tls$6.getCipherSuite(msg.cipher_suite);
    } else {
      var tmp = forge$9.util.createBuffer(msg.cipher_suites.bytes());
      while (tmp.length() > 0) {
        c.session.cipherSuite = tls$6.getCipherSuite(tmp.getBytes(2));
        if (c.session.cipherSuite !== null) {
          break;
        }
      }
    }
    if (c.session.cipherSuite === null) {
      return c.error(c, {
        message: "No cipher suites in common.",
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.handshake_failure
        },
        cipherSuite: forge$9.util.bytesToHex(msg.cipher_suite)
      });
    }
    if (client) {
      c.session.compressionMethod = msg.compression_method;
    } else {
      c.session.compressionMethod = tls$6.CompressionMethod.none;
    }
  }
  return msg;
};
tls$6.createSecurityParameters = function(c, msg) {
  var client = c.entity === tls$6.ConnectionEnd.client;
  var msgRandom = msg.random.bytes();
  var cRandom = client ? c.session.sp.client_random : msgRandom;
  var sRandom = client ? msgRandom : tls$6.createRandom().getBytes();
  c.session.sp = {
    entity: c.entity,
    prf_algorithm: tls$6.PRFAlgorithm.tls_prf_sha256,
    bulk_cipher_algorithm: null,
    cipher_type: null,
    enc_key_length: null,
    block_length: null,
    fixed_iv_length: null,
    record_iv_length: null,
    mac_algorithm: null,
    mac_length: null,
    mac_key_length: null,
    compression_algorithm: c.session.compressionMethod,
    pre_master_secret: null,
    master_secret: null,
    client_random: cRandom,
    server_random: sRandom
  };
};
tls$6.handleServerHello = function(c, record, length) {
  var msg = tls$6.parseHelloMessage(c, record, length);
  if (c.fail) {
    return;
  }
  if (msg.version.minor <= c.version.minor) {
    c.version.minor = msg.version.minor;
  } else {
    return c.error(c, {
      message: "Incompatible TLS version.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.protocol_version
      }
    });
  }
  c.session.version = c.version;
  var sessionId = msg.session_id.bytes();
  if (sessionId.length > 0 && sessionId === c.session.id) {
    c.expect = SCC;
    c.session.resuming = true;
    c.session.sp.server_random = msg.random.bytes();
  } else {
    c.expect = SCE;
    c.session.resuming = false;
    tls$6.createSecurityParameters(c, msg);
  }
  c.session.id = sessionId;
  c.process();
};
tls$6.handleClientHello = function(c, record, length) {
  var msg = tls$6.parseHelloMessage(c, record, length);
  if (c.fail) {
    return;
  }
  var sessionId = msg.session_id.bytes();
  var session = null;
  if (c.sessionCache) {
    session = c.sessionCache.getSession(sessionId);
    if (session === null) {
      sessionId = "";
    } else if (session.version.major !== msg.version.major || session.version.minor > msg.version.minor) {
      session = null;
      sessionId = "";
    }
  }
  if (sessionId.length === 0) {
    sessionId = forge$9.random.getBytes(32);
  }
  c.session.id = sessionId;
  c.session.clientHelloVersion = msg.version;
  c.session.sp = {};
  if (session) {
    c.version = c.session.version = session.version;
    c.session.sp = session.sp;
  } else {
    var version2;
    for (var i = 1; i < tls$6.SupportedVersions.length; ++i) {
      version2 = tls$6.SupportedVersions[i];
      if (version2.minor <= msg.version.minor) {
        break;
      }
    }
    c.version = { major: version2.major, minor: version2.minor };
    c.session.version = c.version;
  }
  if (session !== null) {
    c.expect = CCC;
    c.session.resuming = true;
    c.session.sp.client_random = msg.random.bytes();
  } else {
    c.expect = c.verifyClient !== false ? CCE : CKE;
    c.session.resuming = false;
    tls$6.createSecurityParameters(c, msg);
  }
  c.open = true;
  tls$6.queue(c, tls$6.createRecord(c, {
    type: tls$6.ContentType.handshake,
    data: tls$6.createServerHello(c)
  }));
  if (c.session.resuming) {
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.change_cipher_spec,
      data: tls$6.createChangeCipherSpec()
    }));
    c.state.pending = tls$6.createConnectionState(c);
    c.state.current.write = c.state.pending.write;
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.handshake,
      data: tls$6.createFinished(c)
    }));
  } else {
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.handshake,
      data: tls$6.createCertificate(c)
    }));
    if (!c.fail) {
      tls$6.queue(c, tls$6.createRecord(c, {
        type: tls$6.ContentType.handshake,
        data: tls$6.createServerKeyExchange(c)
      }));
      if (c.verifyClient !== false) {
        tls$6.queue(c, tls$6.createRecord(c, {
          type: tls$6.ContentType.handshake,
          data: tls$6.createCertificateRequest(c)
        }));
      }
      tls$6.queue(c, tls$6.createRecord(c, {
        type: tls$6.ContentType.handshake,
        data: tls$6.createServerHelloDone(c)
      }));
    }
  }
  tls$6.flush(c);
  c.process();
};
tls$6.handleCertificate = function(c, record, length) {
  if (length < 3) {
    return c.error(c, {
      message: "Invalid Certificate message. Message too short.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.illegal_parameter
      }
    });
  }
  var b = record.fragment;
  var msg = {
    certificate_list: readVector(b, 3)
  };
  var cert, asn12;
  var certs = [];
  try {
    while (msg.certificate_list.length() > 0) {
      cert = readVector(msg.certificate_list, 3);
      asn12 = forge$9.asn1.fromDer(cert);
      cert = forge$9.pki.certificateFromAsn1(asn12, true);
      certs.push(cert);
    }
  } catch (ex) {
    return c.error(c, {
      message: "Could not parse certificate list.",
      cause: ex,
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.bad_certificate
      }
    });
  }
  var client = c.entity === tls$6.ConnectionEnd.client;
  if ((client || c.verifyClient === true) && certs.length === 0) {
    c.error(c, {
      message: client ? "No server certificate provided." : "No client certificate provided.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.illegal_parameter
      }
    });
  } else if (certs.length === 0) {
    c.expect = client ? SKE : CKE;
  } else {
    if (client) {
      c.session.serverCertificate = certs[0];
    } else {
      c.session.clientCertificate = certs[0];
    }
    if (tls$6.verifyCertificateChain(c, certs)) {
      c.expect = client ? SKE : CKE;
    }
  }
  c.process();
};
tls$6.handleServerKeyExchange = function(c, record, length) {
  if (length > 0) {
    return c.error(c, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.unsupported_certificate
      }
    });
  }
  c.expect = SCR;
  c.process();
};
tls$6.handleClientKeyExchange = function(c, record, length) {
  if (length < 48) {
    return c.error(c, {
      message: "Invalid key parameters. Only RSA is supported.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.unsupported_certificate
      }
    });
  }
  var b = record.fragment;
  var msg = {
    enc_pre_master_secret: readVector(b, 2).getBytes()
  };
  var privateKey = null;
  if (c.getPrivateKey) {
    try {
      privateKey = c.getPrivateKey(c, c.session.serverCertificate);
      privateKey = forge$9.pki.privateKeyFromPem(privateKey);
    } catch (ex) {
      c.error(c, {
        message: "Could not get private key.",
        cause: ex,
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.internal_error
        }
      });
    }
  }
  if (privateKey === null) {
    return c.error(c, {
      message: "No private key set.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.internal_error
      }
    });
  }
  try {
    var sp = c.session.sp;
    sp.pre_master_secret = privateKey.decrypt(msg.enc_pre_master_secret);
    var version2 = c.session.clientHelloVersion;
    if (version2.major !== sp.pre_master_secret.charCodeAt(0) || version2.minor !== sp.pre_master_secret.charCodeAt(1)) {
      throw new Error("TLS version rollback attack detected.");
    }
  } catch (ex) {
    sp.pre_master_secret = forge$9.random.getBytes(48);
  }
  c.expect = CCC;
  if (c.session.clientCertificate !== null) {
    c.expect = CCV;
  }
  c.process();
};
tls$6.handleCertificateRequest = function(c, record, length) {
  if (length < 3) {
    return c.error(c, {
      message: "Invalid CertificateRequest. Message too short.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.illegal_parameter
      }
    });
  }
  var b = record.fragment;
  var msg = {
    certificate_types: readVector(b, 1),
    certificate_authorities: readVector(b, 2)
  };
  c.session.certificateRequest = msg;
  c.expect = SHD;
  c.process();
};
tls$6.handleCertificateVerify = function(c, record, length) {
  if (length < 2) {
    return c.error(c, {
      message: "Invalid CertificateVerify. Message too short.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.illegal_parameter
      }
    });
  }
  var b = record.fragment;
  b.read -= 4;
  var msgBytes = b.bytes();
  b.read += 4;
  var msg = {
    signature: readVector(b, 2).getBytes()
  };
  var verify = forge$9.util.createBuffer();
  verify.putBuffer(c.session.md5.digest());
  verify.putBuffer(c.session.sha1.digest());
  verify = verify.getBytes();
  try {
    var cert = c.session.clientCertificate;
    if (!cert.publicKey.verify(verify, msg.signature, "NONE")) {
      throw new Error("CertificateVerify signature does not match.");
    }
    c.session.md5.update(msgBytes);
    c.session.sha1.update(msgBytes);
  } catch (ex) {
    return c.error(c, {
      message: "Bad signature in CertificateVerify.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.handshake_failure
      }
    });
  }
  c.expect = CCC;
  c.process();
};
tls$6.handleServerHelloDone = function(c, record, length) {
  if (length > 0) {
    return c.error(c, {
      message: "Invalid ServerHelloDone message. Invalid length.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.record_overflow
      }
    });
  }
  if (c.serverCertificate === null) {
    var error2 = {
      message: "No server certificate provided. Not enough security.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.insufficient_security
      }
    };
    var depth = 0;
    var ret = c.verify(c, error2.alert.description, depth, []);
    if (ret !== true) {
      if (ret || ret === 0) {
        if (typeof ret === "object" && !forge$9.util.isArray(ret)) {
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.alert) {
            error2.alert.description = ret.alert;
          }
        } else if (typeof ret === "number") {
          error2.alert.description = ret;
        }
      }
      return c.error(c, error2);
    }
  }
  if (c.session.certificateRequest !== null) {
    record = tls$6.createRecord(c, {
      type: tls$6.ContentType.handshake,
      data: tls$6.createCertificate(c)
    });
    tls$6.queue(c, record);
  }
  record = tls$6.createRecord(c, {
    type: tls$6.ContentType.handshake,
    data: tls$6.createClientKeyExchange(c)
  });
  tls$6.queue(c, record);
  c.expect = SER;
  var callback = function(c2, signature) {
    if (c2.session.certificateRequest !== null && c2.session.clientCertificate !== null) {
      tls$6.queue(c2, tls$6.createRecord(c2, {
        type: tls$6.ContentType.handshake,
        data: tls$6.createCertificateVerify(c2, signature)
      }));
    }
    tls$6.queue(c2, tls$6.createRecord(c2, {
      type: tls$6.ContentType.change_cipher_spec,
      data: tls$6.createChangeCipherSpec()
    }));
    c2.state.pending = tls$6.createConnectionState(c2);
    c2.state.current.write = c2.state.pending.write;
    tls$6.queue(c2, tls$6.createRecord(c2, {
      type: tls$6.ContentType.handshake,
      data: tls$6.createFinished(c2)
    }));
    c2.expect = SCC;
    tls$6.flush(c2);
    c2.process();
  };
  if (c.session.certificateRequest === null || c.session.clientCertificate === null) {
    return callback(c, null);
  }
  tls$6.getClientSignature(c, callback);
};
tls$6.handleChangeCipherSpec = function(c, record) {
  if (record.fragment.getByte() !== 1) {
    return c.error(c, {
      message: "Invalid ChangeCipherSpec message received.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.illegal_parameter
      }
    });
  }
  var client = c.entity === tls$6.ConnectionEnd.client;
  if (c.session.resuming && client || !c.session.resuming && !client) {
    c.state.pending = tls$6.createConnectionState(c);
  }
  c.state.current.read = c.state.pending.read;
  if (!c.session.resuming && client || c.session.resuming && !client) {
    c.state.pending = null;
  }
  c.expect = client ? SFI : CFI;
  c.process();
};
tls$6.handleFinished = function(c, record, length) {
  var b = record.fragment;
  b.read -= 4;
  var msgBytes = b.bytes();
  b.read += 4;
  var vd = record.fragment.getBytes();
  b = forge$9.util.createBuffer();
  b.putBuffer(c.session.md5.digest());
  b.putBuffer(c.session.sha1.digest());
  var client = c.entity === tls$6.ConnectionEnd.client;
  var label = client ? "server finished" : "client finished";
  var sp = c.session.sp;
  var vdl = 12;
  var prf = prf_TLS1;
  b = prf(sp.master_secret, label, b.getBytes(), vdl);
  if (b.getBytes() !== vd) {
    return c.error(c, {
      message: "Invalid verify_data in Finished message.",
      send: true,
      alert: {
        level: tls$6.Alert.Level.fatal,
        description: tls$6.Alert.Description.decrypt_error
      }
    });
  }
  c.session.md5.update(msgBytes);
  c.session.sha1.update(msgBytes);
  if (c.session.resuming && client || !c.session.resuming && !client) {
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.change_cipher_spec,
      data: tls$6.createChangeCipherSpec()
    }));
    c.state.current.write = c.state.pending.write;
    c.state.pending = null;
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.handshake,
      data: tls$6.createFinished(c)
    }));
  }
  c.expect = client ? SAD : CAD;
  c.handshaking = false;
  ++c.handshakes;
  c.peerCertificate = client ? c.session.serverCertificate : c.session.clientCertificate;
  tls$6.flush(c);
  c.isConnected = true;
  c.connected(c);
  c.process();
};
tls$6.handleAlert = function(c, record) {
  var b = record.fragment;
  var alert = {
    level: b.getByte(),
    description: b.getByte()
  };
  var msg;
  switch (alert.description) {
    case tls$6.Alert.Description.close_notify:
      msg = "Connection closed.";
      break;
    case tls$6.Alert.Description.unexpected_message:
      msg = "Unexpected message.";
      break;
    case tls$6.Alert.Description.bad_record_mac:
      msg = "Bad record MAC.";
      break;
    case tls$6.Alert.Description.decryption_failed:
      msg = "Decryption failed.";
      break;
    case tls$6.Alert.Description.record_overflow:
      msg = "Record overflow.";
      break;
    case tls$6.Alert.Description.decompression_failure:
      msg = "Decompression failed.";
      break;
    case tls$6.Alert.Description.handshake_failure:
      msg = "Handshake failure.";
      break;
    case tls$6.Alert.Description.bad_certificate:
      msg = "Bad certificate.";
      break;
    case tls$6.Alert.Description.unsupported_certificate:
      msg = "Unsupported certificate.";
      break;
    case tls$6.Alert.Description.certificate_revoked:
      msg = "Certificate revoked.";
      break;
    case tls$6.Alert.Description.certificate_expired:
      msg = "Certificate expired.";
      break;
    case tls$6.Alert.Description.certificate_unknown:
      msg = "Certificate unknown.";
      break;
    case tls$6.Alert.Description.illegal_parameter:
      msg = "Illegal parameter.";
      break;
    case tls$6.Alert.Description.unknown_ca:
      msg = "Unknown certificate authority.";
      break;
    case tls$6.Alert.Description.access_denied:
      msg = "Access denied.";
      break;
    case tls$6.Alert.Description.decode_error:
      msg = "Decode error.";
      break;
    case tls$6.Alert.Description.decrypt_error:
      msg = "Decrypt error.";
      break;
    case tls$6.Alert.Description.export_restriction:
      msg = "Export restriction.";
      break;
    case tls$6.Alert.Description.protocol_version:
      msg = "Unsupported protocol version.";
      break;
    case tls$6.Alert.Description.insufficient_security:
      msg = "Insufficient security.";
      break;
    case tls$6.Alert.Description.internal_error:
      msg = "Internal error.";
      break;
    case tls$6.Alert.Description.user_canceled:
      msg = "User canceled.";
      break;
    case tls$6.Alert.Description.no_renegotiation:
      msg = "Renegotiation not supported.";
      break;
    default:
      msg = "Unknown error.";
      break;
  }
  if (alert.description === tls$6.Alert.Description.close_notify) {
    return c.close();
  }
  c.error(c, {
    message: msg,
    send: false,
    // origin is the opposite end
    origin: c.entity === tls$6.ConnectionEnd.client ? "server" : "client",
    alert
  });
  c.process();
};
tls$6.handleHandshake = function(c, record) {
  var b = record.fragment;
  var type3 = b.getByte();
  var length = b.getInt24();
  if (length > b.length()) {
    c.fragmented = record;
    record.fragment = forge$9.util.createBuffer();
    b.read -= 4;
    return c.process();
  }
  c.fragmented = null;
  b.read -= 4;
  var bytes2 = b.bytes(length + 4);
  b.read += 4;
  if (type3 in hsTable[c.entity][c.expect]) {
    if (c.entity === tls$6.ConnectionEnd.server && !c.open && !c.fail) {
      c.handshaking = true;
      c.session = {
        version: null,
        extensions: {
          server_name: {
            serverNameList: []
          }
        },
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        clientCertificate: null,
        md5: forge$9.md.md5.create(),
        sha1: forge$9.md.sha1.create()
      };
    }
    if (type3 !== tls$6.HandshakeType.hello_request && type3 !== tls$6.HandshakeType.certificate_verify && type3 !== tls$6.HandshakeType.finished) {
      c.session.md5.update(bytes2);
      c.session.sha1.update(bytes2);
    }
    hsTable[c.entity][c.expect][type3](c, record, length);
  } else {
    tls$6.handleUnexpected(c, record);
  }
};
tls$6.handleApplicationData = function(c, record) {
  c.data.putBuffer(record.fragment);
  c.dataReady(c);
  c.process();
};
tls$6.handleHeartbeat = function(c, record) {
  var b = record.fragment;
  var type3 = b.getByte();
  var length = b.getInt16();
  var payload = b.getBytes(length);
  if (type3 === tls$6.HeartbeatMessageType.heartbeat_request) {
    if (c.handshaking || length > payload.length) {
      return c.process();
    }
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.heartbeat,
      data: tls$6.createHeartbeat(
        tls$6.HeartbeatMessageType.heartbeat_response,
        payload
      )
    }));
    tls$6.flush(c);
  } else if (type3 === tls$6.HeartbeatMessageType.heartbeat_response) {
    if (payload !== c.expectedHeartbeatPayload) {
      return c.process();
    }
    if (c.heartbeatReceived) {
      c.heartbeatReceived(c, forge$9.util.createBuffer(payload));
    }
  }
  c.process();
};
var SHE = 0;
var SCE = 1;
var SKE = 2;
var SCR = 3;
var SHD = 4;
var SCC = 5;
var SFI = 6;
var SAD = 7;
var SER = 8;
var CHE = 0;
var CCE = 1;
var CKE = 2;
var CCV = 3;
var CCC = 4;
var CFI = 5;
var CAD = 6;
var __ = tls$6.handleUnexpected;
var R0 = tls$6.handleChangeCipherSpec;
var R1 = tls$6.handleAlert;
var R2 = tls$6.handleHandshake;
var R3 = tls$6.handleApplicationData;
var R4 = tls$6.handleHeartbeat;
var ctTable = [];
ctTable[tls$6.ConnectionEnd.client] = [
  //      CC,AL,HS,AD,HB
  /*SHE*/
  [__, R1, R2, __, R4],
  /*SCE*/
  [__, R1, R2, __, R4],
  /*SKE*/
  [__, R1, R2, __, R4],
  /*SCR*/
  [__, R1, R2, __, R4],
  /*SHD*/
  [__, R1, R2, __, R4],
  /*SCC*/
  [R0, R1, __, __, R4],
  /*SFI*/
  [__, R1, R2, __, R4],
  /*SAD*/
  [__, R1, R2, R3, R4],
  /*SER*/
  [__, R1, R2, __, R4]
];
ctTable[tls$6.ConnectionEnd.server] = [
  //      CC,AL,HS,AD
  /*CHE*/
  [__, R1, R2, __, R4],
  /*CCE*/
  [__, R1, R2, __, R4],
  /*CKE*/
  [__, R1, R2, __, R4],
  /*CCV*/
  [__, R1, R2, __, R4],
  /*CCC*/
  [R0, R1, __, __, R4],
  /*CFI*/
  [__, R1, R2, __, R4],
  /*CAD*/
  [__, R1, R2, R3, R4],
  /*CER*/
  [__, R1, R2, __, R4]
];
var H0 = tls$6.handleHelloRequest;
var H1 = tls$6.handleServerHello;
var H2 = tls$6.handleCertificate;
var H3 = tls$6.handleServerKeyExchange;
var H4 = tls$6.handleCertificateRequest;
var H5 = tls$6.handleServerHelloDone;
var H6 = tls$6.handleFinished;
var hsTable = [];
hsTable[tls$6.ConnectionEnd.client] = [
  //      HR,01,SH,03,04,05,06,07,08,09,10,SC,SK,CR,HD,15,CK,17,18,19,FI
  /*SHE*/
  [__, __, H1, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SCE*/
  [H0, __, __, __, __, __, __, __, __, __, __, H2, H3, H4, H5, __, __, __, __, __, __],
  /*SKE*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, H3, H4, H5, __, __, __, __, __, __],
  /*SCR*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, H4, H5, __, __, __, __, __, __],
  /*SHD*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, H5, __, __, __, __, __, __],
  /*SCC*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SFI*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
  /*SAD*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*SER*/
  [H0, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
];
var H7 = tls$6.handleClientHello;
var H8 = tls$6.handleClientKeyExchange;
var H9 = tls$6.handleCertificateVerify;
hsTable[tls$6.ConnectionEnd.server] = [
  //      01,CH,02,03,04,05,06,07,08,09,10,CC,12,13,14,CV,CK,17,18,19,FI
  /*CHE*/
  [__, H7, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CCE*/
  [__, __, __, __, __, __, __, __, __, __, __, H2, __, __, __, __, __, __, __, __, __],
  /*CKE*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H8, __, __, __, __],
  /*CCV*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H9, __, __, __, __, __],
  /*CCC*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CFI*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, H6],
  /*CAD*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __],
  /*CER*/
  [__, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __, __]
];
tls$6.generateKeys = function(c, sp) {
  var prf = prf_TLS1;
  var random = sp.client_random + sp.server_random;
  if (!c.session.resuming) {
    sp.master_secret = prf(
      sp.pre_master_secret,
      "master secret",
      random,
      48
    ).bytes();
    sp.pre_master_secret = null;
  }
  random = sp.server_random + sp.client_random;
  var length = 2 * sp.mac_key_length + 2 * sp.enc_key_length;
  var tls10 = c.version.major === tls$6.Versions.TLS_1_0.major && c.version.minor === tls$6.Versions.TLS_1_0.minor;
  if (tls10) {
    length += 2 * sp.fixed_iv_length;
  }
  var km = prf(sp.master_secret, "key expansion", random, length);
  var rval = {
    client_write_MAC_key: km.getBytes(sp.mac_key_length),
    server_write_MAC_key: km.getBytes(sp.mac_key_length),
    client_write_key: km.getBytes(sp.enc_key_length),
    server_write_key: km.getBytes(sp.enc_key_length)
  };
  if (tls10) {
    rval.client_write_IV = km.getBytes(sp.fixed_iv_length);
    rval.server_write_IV = km.getBytes(sp.fixed_iv_length);
  }
  return rval;
};
tls$6.createConnectionState = function(c) {
  var client = c.entity === tls$6.ConnectionEnd.client;
  var createMode = function() {
    var mode = {
      // two 32-bit numbers, first is most significant
      sequenceNumber: [0, 0],
      macKey: null,
      macLength: 0,
      macFunction: null,
      cipherState: null,
      cipherFunction: function(record) {
        return true;
      },
      compressionState: null,
      compressFunction: function(record) {
        return true;
      },
      updateSequenceNumber: function() {
        if (mode.sequenceNumber[1] === 4294967295) {
          mode.sequenceNumber[1] = 0;
          ++mode.sequenceNumber[0];
        } else {
          ++mode.sequenceNumber[1];
        }
      }
    };
    return mode;
  };
  var state2 = {
    read: createMode(),
    write: createMode()
  };
  state2.read.update = function(c2, record) {
    if (!state2.read.cipherFunction(record, state2.read)) {
      c2.error(c2, {
        message: "Could not decrypt record or bad MAC.",
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          // doesn't matter if decryption failed or MAC was
          // invalid, return the same error so as not to reveal
          // which one occurred
          description: tls$6.Alert.Description.bad_record_mac
        }
      });
    } else if (!state2.read.compressFunction(c2, record, state2.read)) {
      c2.error(c2, {
        message: "Could not decompress record.",
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.decompression_failure
        }
      });
    }
    return !c2.fail;
  };
  state2.write.update = function(c2, record) {
    if (!state2.write.compressFunction(c2, record, state2.write)) {
      c2.error(c2, {
        message: "Could not compress record.",
        send: false,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.internal_error
        }
      });
    } else if (!state2.write.cipherFunction(record, state2.write)) {
      c2.error(c2, {
        message: "Could not encrypt record.",
        send: false,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.internal_error
        }
      });
    }
    return !c2.fail;
  };
  if (c.session) {
    var sp = c.session.sp;
    c.session.cipherSuite.initSecurityParameters(sp);
    sp.keys = tls$6.generateKeys(c, sp);
    state2.read.macKey = client ? sp.keys.server_write_MAC_key : sp.keys.client_write_MAC_key;
    state2.write.macKey = client ? sp.keys.client_write_MAC_key : sp.keys.server_write_MAC_key;
    c.session.cipherSuite.initConnectionState(state2, c, sp);
    switch (sp.compression_algorithm) {
      case tls$6.CompressionMethod.none:
        break;
      case tls$6.CompressionMethod.deflate:
        state2.read.compressFunction = inflate;
        state2.write.compressFunction = deflate;
        break;
      default:
        throw new Error("Unsupported compression algorithm.");
    }
  }
  return state2;
};
tls$6.createRandom = function() {
  var d2 = /* @__PURE__ */ new Date();
  var utc = +d2 + d2.getTimezoneOffset() * 6e4;
  var rval = forge$9.util.createBuffer();
  rval.putInt32(utc);
  rval.putBytes(forge$9.random.getBytes(28));
  return rval;
};
tls$6.createRecord = function(c, options) {
  if (!options.data) {
    return null;
  }
  var record = {
    type: options.type,
    version: {
      major: c.version.major,
      minor: c.version.minor
    },
    length: options.data.length(),
    fragment: options.data
  };
  return record;
};
tls$6.createAlert = function(c, alert) {
  var b = forge$9.util.createBuffer();
  b.putByte(alert.level);
  b.putByte(alert.description);
  return tls$6.createRecord(c, {
    type: tls$6.ContentType.alert,
    data: b
  });
};
tls$6.createClientHello = function(c) {
  c.session.clientHelloVersion = {
    major: c.version.major,
    minor: c.version.minor
  };
  var cipherSuites = forge$9.util.createBuffer();
  for (var i = 0; i < c.cipherSuites.length; ++i) {
    var cs = c.cipherSuites[i];
    cipherSuites.putByte(cs.id[0]);
    cipherSuites.putByte(cs.id[1]);
  }
  var cSuites = cipherSuites.length();
  var compressionMethods = forge$9.util.createBuffer();
  compressionMethods.putByte(tls$6.CompressionMethod.none);
  var cMethods = compressionMethods.length();
  var extensions2 = forge$9.util.createBuffer();
  if (c.virtualHost) {
    var ext = forge$9.util.createBuffer();
    ext.putByte(0);
    ext.putByte(0);
    var serverName = forge$9.util.createBuffer();
    serverName.putByte(0);
    writeVector(serverName, 2, forge$9.util.createBuffer(c.virtualHost));
    var snList = forge$9.util.createBuffer();
    writeVector(snList, 2, serverName);
    writeVector(ext, 2, snList);
    extensions2.putBuffer(ext);
  }
  var extLength = extensions2.length();
  if (extLength > 0) {
    extLength += 2;
  }
  var sessionId = c.session.id;
  var length = sessionId.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + cSuites + // cipher suites vector
  1 + cMethods + // compression methods vector
  extLength;
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.client_hello);
  rval.putInt24(length);
  rval.putByte(c.version.major);
  rval.putByte(c.version.minor);
  rval.putBytes(c.session.sp.client_random);
  writeVector(rval, 1, forge$9.util.createBuffer(sessionId));
  writeVector(rval, 2, cipherSuites);
  writeVector(rval, 1, compressionMethods);
  if (extLength > 0) {
    writeVector(rval, 2, extensions2);
  }
  return rval;
};
tls$6.createServerHello = function(c) {
  var sessionId = c.session.id;
  var length = sessionId.length + 1 + // session ID vector
  2 + // version (major + minor)
  4 + 28 + // random time and random bytes
  2 + // chosen cipher suite
  1;
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.server_hello);
  rval.putInt24(length);
  rval.putByte(c.version.major);
  rval.putByte(c.version.minor);
  rval.putBytes(c.session.sp.server_random);
  writeVector(rval, 1, forge$9.util.createBuffer(sessionId));
  rval.putByte(c.session.cipherSuite.id[0]);
  rval.putByte(c.session.cipherSuite.id[1]);
  rval.putByte(c.session.compressionMethod);
  return rval;
};
tls$6.createCertificate = function(c) {
  var client = c.entity === tls$6.ConnectionEnd.client;
  var cert = null;
  if (c.getCertificate) {
    var hint;
    if (client) {
      hint = c.session.certificateRequest;
    } else {
      hint = c.session.extensions.server_name.serverNameList;
    }
    cert = c.getCertificate(c, hint);
  }
  var certList = forge$9.util.createBuffer();
  if (cert !== null) {
    try {
      if (!forge$9.util.isArray(cert)) {
        cert = [cert];
      }
      var asn12 = null;
      for (var i = 0; i < cert.length; ++i) {
        var msg = forge$9.pem.decode(cert[i])[0];
        if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
          var error2 = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
          error2.headerType = msg.type;
          throw error2;
        }
        if (msg.procType && msg.procType.type === "ENCRYPTED") {
          throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
        }
        var der = forge$9.util.createBuffer(msg.body);
        if (asn12 === null) {
          asn12 = forge$9.asn1.fromDer(der.bytes(), false);
        }
        var certBuffer = forge$9.util.createBuffer();
        writeVector(certBuffer, 3, der);
        certList.putBuffer(certBuffer);
      }
      cert = forge$9.pki.certificateFromAsn1(asn12);
      if (client) {
        c.session.clientCertificate = cert;
      } else {
        c.session.serverCertificate = cert;
      }
    } catch (ex) {
      return c.error(c, {
        message: "Could not send certificate list.",
        cause: ex,
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.bad_certificate
        }
      });
    }
  }
  var length = 3 + certList.length();
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.certificate);
  rval.putInt24(length);
  writeVector(rval, 3, certList);
  return rval;
};
tls$6.createClientKeyExchange = function(c) {
  var b = forge$9.util.createBuffer();
  b.putByte(c.session.clientHelloVersion.major);
  b.putByte(c.session.clientHelloVersion.minor);
  b.putBytes(forge$9.random.getBytes(46));
  var sp = c.session.sp;
  sp.pre_master_secret = b.getBytes();
  var key = c.session.serverCertificate.publicKey;
  b = key.encrypt(sp.pre_master_secret);
  var length = b.length + 2;
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.client_key_exchange);
  rval.putInt24(length);
  rval.putInt16(b.length);
  rval.putBytes(b);
  return rval;
};
tls$6.createServerKeyExchange = function(c) {
  var rval = forge$9.util.createBuffer();
  return rval;
};
tls$6.getClientSignature = function(c, callback) {
  var b = forge$9.util.createBuffer();
  b.putBuffer(c.session.md5.digest());
  b.putBuffer(c.session.sha1.digest());
  b = b.getBytes();
  c.getSignature = c.getSignature || function(c2, b2, callback2) {
    var privateKey = null;
    if (c2.getPrivateKey) {
      try {
        privateKey = c2.getPrivateKey(c2, c2.session.clientCertificate);
        privateKey = forge$9.pki.privateKeyFromPem(privateKey);
      } catch (ex) {
        c2.error(c2, {
          message: "Could not get private key.",
          cause: ex,
          send: true,
          alert: {
            level: tls$6.Alert.Level.fatal,
            description: tls$6.Alert.Description.internal_error
          }
        });
      }
    }
    if (privateKey === null) {
      c2.error(c2, {
        message: "No private key set.",
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: tls$6.Alert.Description.internal_error
        }
      });
    } else {
      b2 = privateKey.sign(b2, null);
    }
    callback2(c2, b2);
  };
  c.getSignature(c, b, callback);
};
tls$6.createCertificateVerify = function(c, signature) {
  var length = signature.length + 2;
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.certificate_verify);
  rval.putInt24(length);
  rval.putInt16(signature.length);
  rval.putBytes(signature);
  return rval;
};
tls$6.createCertificateRequest = function(c) {
  var certTypes = forge$9.util.createBuffer();
  certTypes.putByte(1);
  var cAs = forge$9.util.createBuffer();
  for (var key in c.caStore.certs) {
    var cert = c.caStore.certs[key];
    var dn = forge$9.pki.distinguishedNameToAsn1(cert.subject);
    var byteBuffer = forge$9.asn1.toDer(dn);
    cAs.putInt16(byteBuffer.length());
    cAs.putBuffer(byteBuffer);
  }
  var length = 1 + certTypes.length() + 2 + cAs.length();
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.certificate_request);
  rval.putInt24(length);
  writeVector(rval, 1, certTypes);
  writeVector(rval, 2, cAs);
  return rval;
};
tls$6.createServerHelloDone = function(c) {
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.server_hello_done);
  rval.putInt24(0);
  return rval;
};
tls$6.createChangeCipherSpec = function() {
  var rval = forge$9.util.createBuffer();
  rval.putByte(1);
  return rval;
};
tls$6.createFinished = function(c) {
  var b = forge$9.util.createBuffer();
  b.putBuffer(c.session.md5.digest());
  b.putBuffer(c.session.sha1.digest());
  var client = c.entity === tls$6.ConnectionEnd.client;
  var sp = c.session.sp;
  var vdl = 12;
  var prf = prf_TLS1;
  var label = client ? "client finished" : "server finished";
  b = prf(sp.master_secret, label, b.getBytes(), vdl);
  var rval = forge$9.util.createBuffer();
  rval.putByte(tls$6.HandshakeType.finished);
  rval.putInt24(b.length());
  rval.putBuffer(b);
  return rval;
};
tls$6.createHeartbeat = function(type3, payload, payloadLength) {
  if (typeof payloadLength === "undefined") {
    payloadLength = payload.length;
  }
  var rval = forge$9.util.createBuffer();
  rval.putByte(type3);
  rval.putInt16(payloadLength);
  rval.putBytes(payload);
  var plaintextLength = rval.length();
  var paddingLength = Math.max(16, plaintextLength - payloadLength - 3);
  rval.putBytes(forge$9.random.getBytes(paddingLength));
  return rval;
};
tls$6.queue = function(c, record) {
  if (!record) {
    return;
  }
  if (record.fragment.length() === 0) {
    if (record.type === tls$6.ContentType.handshake || record.type === tls$6.ContentType.alert || record.type === tls$6.ContentType.change_cipher_spec) {
      return;
    }
  }
  if (record.type === tls$6.ContentType.handshake) {
    var bytes2 = record.fragment.bytes();
    c.session.md5.update(bytes2);
    c.session.sha1.update(bytes2);
    bytes2 = null;
  }
  var records;
  if (record.fragment.length() <= tls$6.MaxFragment) {
    records = [record];
  } else {
    records = [];
    var data2 = record.fragment.bytes();
    while (data2.length > tls$6.MaxFragment) {
      records.push(tls$6.createRecord(c, {
        type: record.type,
        data: forge$9.util.createBuffer(data2.slice(0, tls$6.MaxFragment))
      }));
      data2 = data2.slice(tls$6.MaxFragment);
    }
    if (data2.length > 0) {
      records.push(tls$6.createRecord(c, {
        type: record.type,
        data: forge$9.util.createBuffer(data2)
      }));
    }
  }
  for (var i = 0; i < records.length && !c.fail; ++i) {
    var rec = records[i];
    var s2 = c.state.current.write;
    if (s2.update(c, rec)) {
      c.records.push(rec);
    }
  }
};
tls$6.flush = function(c) {
  for (var i = 0; i < c.records.length; ++i) {
    var record = c.records[i];
    c.tlsData.putByte(record.type);
    c.tlsData.putByte(record.version.major);
    c.tlsData.putByte(record.version.minor);
    c.tlsData.putInt16(record.fragment.length());
    c.tlsData.putBuffer(c.records[i].fragment);
  }
  c.records = [];
  return c.tlsDataReady(c);
};
var _certErrorToAlertDesc = function(error2) {
  switch (error2) {
    case true:
      return true;
    case forge$9.pki.certificateError.bad_certificate:
      return tls$6.Alert.Description.bad_certificate;
    case forge$9.pki.certificateError.unsupported_certificate:
      return tls$6.Alert.Description.unsupported_certificate;
    case forge$9.pki.certificateError.certificate_revoked:
      return tls$6.Alert.Description.certificate_revoked;
    case forge$9.pki.certificateError.certificate_expired:
      return tls$6.Alert.Description.certificate_expired;
    case forge$9.pki.certificateError.certificate_unknown:
      return tls$6.Alert.Description.certificate_unknown;
    case forge$9.pki.certificateError.unknown_ca:
      return tls$6.Alert.Description.unknown_ca;
    default:
      return tls$6.Alert.Description.bad_certificate;
  }
};
var _alertDescToCertError = function(desc2) {
  switch (desc2) {
    case true:
      return true;
    case tls$6.Alert.Description.bad_certificate:
      return forge$9.pki.certificateError.bad_certificate;
    case tls$6.Alert.Description.unsupported_certificate:
      return forge$9.pki.certificateError.unsupported_certificate;
    case tls$6.Alert.Description.certificate_revoked:
      return forge$9.pki.certificateError.certificate_revoked;
    case tls$6.Alert.Description.certificate_expired:
      return forge$9.pki.certificateError.certificate_expired;
    case tls$6.Alert.Description.certificate_unknown:
      return forge$9.pki.certificateError.certificate_unknown;
    case tls$6.Alert.Description.unknown_ca:
      return forge$9.pki.certificateError.unknown_ca;
    default:
      return forge$9.pki.certificateError.bad_certificate;
  }
};
tls$6.verifyCertificateChain = function(c, chain) {
  try {
    var options = {};
    for (var key in c.verifyOptions) {
      options[key] = c.verifyOptions[key];
    }
    options.verify = function(vfd, depth, chain2) {
      var desc2 = _certErrorToAlertDesc(vfd);
      var ret = c.verify(c, vfd, depth, chain2);
      if (ret !== true) {
        if (typeof ret === "object" && !forge$9.util.isArray(ret)) {
          var error2 = new Error("The application rejected the certificate.");
          error2.send = true;
          error2.alert = {
            level: tls$6.Alert.Level.fatal,
            description: tls$6.Alert.Description.bad_certificate
          };
          if (ret.message) {
            error2.message = ret.message;
          }
          if (ret.alert) {
            error2.alert.description = ret.alert;
          }
          throw error2;
        }
        if (ret !== vfd) {
          ret = _alertDescToCertError(ret);
        }
      }
      return ret;
    };
    forge$9.pki.verifyCertificateChain(c.caStore, chain, options);
  } catch (ex) {
    var err = ex;
    if (typeof err !== "object" || forge$9.util.isArray(err)) {
      err = {
        send: true,
        alert: {
          level: tls$6.Alert.Level.fatal,
          description: _certErrorToAlertDesc(ex)
        }
      };
    }
    if (!("send" in err)) {
      err.send = true;
    }
    if (!("alert" in err)) {
      err.alert = {
        level: tls$6.Alert.Level.fatal,
        description: _certErrorToAlertDesc(err.error)
      };
    }
    c.error(c, err);
  }
  return !c.fail;
};
tls$6.createSessionCache = function(cache2, capacity) {
  var rval = null;
  if (cache2 && cache2.getSession && cache2.setSession && cache2.order) {
    rval = cache2;
  } else {
    rval = {};
    rval.cache = cache2 || {};
    rval.capacity = Math.max(capacity || 100, 1);
    rval.order = [];
    for (var key in cache2) {
      if (rval.order.length <= capacity) {
        rval.order.push(key);
      } else {
        delete cache2[key];
      }
    }
    rval.getSession = function(sessionId) {
      var session = null;
      var key2 = null;
      if (sessionId) {
        key2 = forge$9.util.bytesToHex(sessionId);
      } else if (rval.order.length > 0) {
        key2 = rval.order[0];
      }
      if (key2 !== null && key2 in rval.cache) {
        session = rval.cache[key2];
        delete rval.cache[key2];
        for (var i in rval.order) {
          if (rval.order[i] === key2) {
            rval.order.splice(i, 1);
            break;
          }
        }
      }
      return session;
    };
    rval.setSession = function(sessionId, session) {
      if (rval.order.length === rval.capacity) {
        var key2 = rval.order.shift();
        delete rval.cache[key2];
      }
      var key2 = forge$9.util.bytesToHex(sessionId);
      rval.order.push(key2);
      rval.cache[key2] = session;
    };
  }
  return rval;
};
tls$6.createConnection = function(options) {
  var caStore = null;
  if (options.caStore) {
    if (forge$9.util.isArray(options.caStore)) {
      caStore = forge$9.pki.createCaStore(options.caStore);
    } else {
      caStore = options.caStore;
    }
  } else {
    caStore = forge$9.pki.createCaStore();
  }
  var cipherSuites = options.cipherSuites || null;
  if (cipherSuites === null) {
    cipherSuites = [];
    for (var key in tls$6.CipherSuites) {
      cipherSuites.push(tls$6.CipherSuites[key]);
    }
  }
  var entity = options.server || false ? tls$6.ConnectionEnd.server : tls$6.ConnectionEnd.client;
  var sessionCache = options.sessionCache ? tls$6.createSessionCache(options.sessionCache) : null;
  var c = {
    version: { major: tls$6.Version.major, minor: tls$6.Version.minor },
    entity,
    sessionId: options.sessionId,
    caStore,
    sessionCache,
    cipherSuites,
    connected: options.connected,
    virtualHost: options.virtualHost || null,
    verifyClient: options.verifyClient || false,
    verify: options.verify || function(cn, vfd, dpth, cts) {
      return vfd;
    },
    verifyOptions: options.verifyOptions || {},
    getCertificate: options.getCertificate || null,
    getPrivateKey: options.getPrivateKey || null,
    getSignature: options.getSignature || null,
    input: forge$9.util.createBuffer(),
    tlsData: forge$9.util.createBuffer(),
    data: forge$9.util.createBuffer(),
    tlsDataReady: options.tlsDataReady,
    dataReady: options.dataReady,
    heartbeatReceived: options.heartbeatReceived,
    closed: options.closed,
    error: function(c2, ex) {
      ex.origin = ex.origin || (c2.entity === tls$6.ConnectionEnd.client ? "client" : "server");
      if (ex.send) {
        tls$6.queue(c2, tls$6.createAlert(c2, ex.alert));
        tls$6.flush(c2);
      }
      var fatal = ex.fatal !== false;
      if (fatal) {
        c2.fail = true;
      }
      options.error(c2, ex);
      if (fatal) {
        c2.close(false);
      }
    },
    deflate: options.deflate || null,
    inflate: options.inflate || null
  };
  c.reset = function(clearFail) {
    c.version = { major: tls$6.Version.major, minor: tls$6.Version.minor };
    c.record = null;
    c.session = null;
    c.peerCertificate = null;
    c.state = {
      pending: null,
      current: null
    };
    c.expect = c.entity === tls$6.ConnectionEnd.client ? SHE : CHE;
    c.fragmented = null;
    c.records = [];
    c.open = false;
    c.handshakes = 0;
    c.handshaking = false;
    c.isConnected = false;
    c.fail = !(clearFail || typeof clearFail === "undefined");
    c.input.clear();
    c.tlsData.clear();
    c.data.clear();
    c.state.current = tls$6.createConnectionState(c);
  };
  c.reset();
  var _update2 = function(c2, record) {
    var aligned = record.type - tls$6.ContentType.change_cipher_spec;
    var handlers = ctTable[c2.entity][c2.expect];
    if (aligned in handlers) {
      handlers[aligned](c2, record);
    } else {
      tls$6.handleUnexpected(c2, record);
    }
  };
  var _readRecordHeader = function(c2) {
    var rval = 0;
    var b = c2.input;
    var len = b.length();
    if (len < 5) {
      rval = 5 - len;
    } else {
      c2.record = {
        type: b.getByte(),
        version: {
          major: b.getByte(),
          minor: b.getByte()
        },
        length: b.getInt16(),
        fragment: forge$9.util.createBuffer(),
        ready: false
      };
      var compatibleVersion = c2.record.version.major === c2.version.major;
      if (compatibleVersion && c2.session && c2.session.version) {
        compatibleVersion = c2.record.version.minor === c2.version.minor;
      }
      if (!compatibleVersion) {
        c2.error(c2, {
          message: "Incompatible TLS version.",
          send: true,
          alert: {
            level: tls$6.Alert.Level.fatal,
            description: tls$6.Alert.Description.protocol_version
          }
        });
      }
    }
    return rval;
  };
  var _readRecord = function(c2) {
    var rval = 0;
    var b = c2.input;
    var len = b.length();
    if (len < c2.record.length) {
      rval = c2.record.length - len;
    } else {
      c2.record.fragment.putBytes(b.getBytes(c2.record.length));
      b.compact();
      var s2 = c2.state.current.read;
      if (s2.update(c2, c2.record)) {
        if (c2.fragmented !== null) {
          if (c2.fragmented.type === c2.record.type) {
            c2.fragmented.fragment.putBuffer(c2.record.fragment);
            c2.record = c2.fragmented;
          } else {
            c2.error(c2, {
              message: "Invalid fragmented record.",
              send: true,
              alert: {
                level: tls$6.Alert.Level.fatal,
                description: tls$6.Alert.Description.unexpected_message
              }
            });
          }
        }
        c2.record.ready = true;
      }
    }
    return rval;
  };
  c.handshake = function(sessionId) {
    if (c.entity !== tls$6.ConnectionEnd.client) {
      c.error(c, {
        message: "Cannot initiate handshake as a server.",
        fatal: false
      });
    } else if (c.handshaking) {
      c.error(c, {
        message: "Handshake already in progress.",
        fatal: false
      });
    } else {
      if (c.fail && !c.open && c.handshakes === 0) {
        c.fail = false;
      }
      c.handshaking = true;
      sessionId = sessionId || "";
      var session = null;
      if (sessionId.length > 0) {
        if (c.sessionCache) {
          session = c.sessionCache.getSession(sessionId);
        }
        if (session === null) {
          sessionId = "";
        }
      }
      if (sessionId.length === 0 && c.sessionCache) {
        session = c.sessionCache.getSession();
        if (session !== null) {
          sessionId = session.id;
        }
      }
      c.session = {
        id: sessionId,
        version: null,
        cipherSuite: null,
        compressionMethod: null,
        serverCertificate: null,
        certificateRequest: null,
        clientCertificate: null,
        sp: {},
        md5: forge$9.md.md5.create(),
        sha1: forge$9.md.sha1.create()
      };
      if (session) {
        c.version = session.version;
        c.session.sp = session.sp;
      }
      c.session.sp.client_random = tls$6.createRandom().getBytes();
      c.open = true;
      tls$6.queue(c, tls$6.createRecord(c, {
        type: tls$6.ContentType.handshake,
        data: tls$6.createClientHello(c)
      }));
      tls$6.flush(c);
    }
  };
  c.process = function(data2) {
    var rval = 0;
    if (data2) {
      c.input.putBytes(data2);
    }
    if (!c.fail) {
      if (c.record !== null && c.record.ready && c.record.fragment.isEmpty()) {
        c.record = null;
      }
      if (c.record === null) {
        rval = _readRecordHeader(c);
      }
      if (!c.fail && c.record !== null && !c.record.ready) {
        rval = _readRecord(c);
      }
      if (!c.fail && c.record !== null && c.record.ready) {
        _update2(c, c.record);
      }
    }
    return rval;
  };
  c.prepare = function(data2) {
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.application_data,
      data: forge$9.util.createBuffer(data2)
    }));
    return tls$6.flush(c);
  };
  c.prepareHeartbeatRequest = function(payload, payloadLength) {
    if (payload instanceof forge$9.util.ByteBuffer) {
      payload = payload.bytes();
    }
    if (typeof payloadLength === "undefined") {
      payloadLength = payload.length;
    }
    c.expectedHeartbeatPayload = payload;
    tls$6.queue(c, tls$6.createRecord(c, {
      type: tls$6.ContentType.heartbeat,
      data: tls$6.createHeartbeat(
        tls$6.HeartbeatMessageType.heartbeat_request,
        payload,
        payloadLength
      )
    }));
    return tls$6.flush(c);
  };
  c.close = function(clearFail) {
    if (!c.fail && c.sessionCache && c.session) {
      var session = {
        id: c.session.id,
        version: c.session.version,
        sp: c.session.sp
      };
      session.sp.keys = null;
      c.sessionCache.setSession(session.id, session);
    }
    if (c.open) {
      c.open = false;
      c.input.clear();
      if (c.isConnected || c.handshaking) {
        c.isConnected = c.handshaking = false;
        tls$6.queue(c, tls$6.createAlert(c, {
          level: tls$6.Alert.Level.warning,
          description: tls$6.Alert.Description.close_notify
        }));
        tls$6.flush(c);
      }
      c.closed(c);
    }
    c.reset(clearFail);
  };
  return c;
};
forge$9.tls = forge$9.tls || {};
for (var key in tls$6) {
  if (typeof tls$6[key] !== "function") {
    forge$9.tls[key] = tls$6[key];
  }
}
forge$9.tls.prf_tls1 = prf_TLS1;
forge$9.tls.hmac_sha1 = hmac_sha1;
forge$9.tls.createSessionCache = tls$6.createSessionCache;
forge$9.tls.createConnection = tls$6.createConnection;
var forge$8 = forge$D;
var tls$5 = forge$8.tls;
tls$5.CipherSuites["TLS_RSA_WITH_AES_128_CBC_SHA"] = {
  id: [0, 47],
  name: "TLS_RSA_WITH_AES_128_CBC_SHA",
  initSecurityParameters: function(sp) {
    sp.bulk_cipher_algorithm = tls$5.BulkCipherAlgorithm.aes;
    sp.cipher_type = tls$5.CipherType.block;
    sp.enc_key_length = 16;
    sp.block_length = 16;
    sp.fixed_iv_length = 16;
    sp.record_iv_length = 16;
    sp.mac_algorithm = tls$5.MACAlgorithm.hmac_sha1;
    sp.mac_length = 20;
    sp.mac_key_length = 20;
  },
  initConnectionState
};
tls$5.CipherSuites["TLS_RSA_WITH_AES_256_CBC_SHA"] = {
  id: [0, 53],
  name: "TLS_RSA_WITH_AES_256_CBC_SHA",
  initSecurityParameters: function(sp) {
    sp.bulk_cipher_algorithm = tls$5.BulkCipherAlgorithm.aes;
    sp.cipher_type = tls$5.CipherType.block;
    sp.enc_key_length = 32;
    sp.block_length = 16;
    sp.fixed_iv_length = 16;
    sp.record_iv_length = 16;
    sp.mac_algorithm = tls$5.MACAlgorithm.hmac_sha1;
    sp.mac_length = 20;
    sp.mac_key_length = 20;
  },
  initConnectionState
};
function initConnectionState(state2, c, sp) {
  var client = c.entity === forge$8.tls.ConnectionEnd.client;
  state2.read.cipherState = {
    init: false,
    cipher: forge$8.cipher.createDecipher("AES-CBC", client ? sp.keys.server_write_key : sp.keys.client_write_key),
    iv: client ? sp.keys.server_write_IV : sp.keys.client_write_IV
  };
  state2.write.cipherState = {
    init: false,
    cipher: forge$8.cipher.createCipher("AES-CBC", client ? sp.keys.client_write_key : sp.keys.server_write_key),
    iv: client ? sp.keys.client_write_IV : sp.keys.server_write_IV
  };
  state2.read.cipherFunction = decrypt_aes_cbc_sha1;
  state2.write.cipherFunction = encrypt_aes_cbc_sha1;
  state2.read.macLength = state2.write.macLength = sp.mac_length;
  state2.read.macFunction = state2.write.macFunction = tls$5.hmac_sha1;
}
function encrypt_aes_cbc_sha1(record, s2) {
  var rval = false;
  var mac = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
  record.fragment.putBytes(mac);
  s2.updateSequenceNumber();
  var iv2;
  if (record.version.minor === tls$5.Versions.TLS_1_0.minor) {
    iv2 = s2.cipherState.init ? null : s2.cipherState.iv;
  } else {
    iv2 = forge$8.random.getBytesSync(16);
  }
  s2.cipherState.init = true;
  var cipher = s2.cipherState.cipher;
  cipher.start({ iv: iv2 });
  if (record.version.minor >= tls$5.Versions.TLS_1_1.minor) {
    cipher.output.putBytes(iv2);
  }
  cipher.update(record.fragment);
  if (cipher.finish(encrypt_aes_cbc_sha1_padding)) {
    record.fragment = cipher.output;
    record.length = record.fragment.length();
    rval = true;
  }
  return rval;
}
function encrypt_aes_cbc_sha1_padding(blockSize, input, decrypt2) {
  if (!decrypt2) {
    var padding = blockSize - input.length() % blockSize;
    input.fillWithByte(padding - 1, padding);
  }
  return true;
}
function decrypt_aes_cbc_sha1_padding(blockSize, output, decrypt2) {
  var rval = true;
  if (decrypt2) {
    var len = output.length();
    var paddingLength = output.last();
    for (var i = len - 1 - paddingLength; i < len - 1; ++i) {
      rval = rval && output.at(i) == paddingLength;
    }
    if (rval) {
      output.truncate(paddingLength + 1);
    }
  }
  return rval;
}
function decrypt_aes_cbc_sha1(record, s2) {
  var rval = false;
  var iv2;
  if (record.version.minor === tls$5.Versions.TLS_1_0.minor) {
    iv2 = s2.cipherState.init ? null : s2.cipherState.iv;
  } else {
    iv2 = record.fragment.getBytes(16);
  }
  s2.cipherState.init = true;
  var cipher = s2.cipherState.cipher;
  cipher.start({ iv: iv2 });
  cipher.update(record.fragment);
  rval = cipher.finish(decrypt_aes_cbc_sha1_padding);
  var macLen = s2.macLength;
  var mac = forge$8.random.getBytesSync(macLen);
  var len = cipher.output.length();
  if (len >= macLen) {
    record.fragment = cipher.output.getBytes(len - macLen);
    mac = cipher.output.getBytes(macLen);
  } else {
    record.fragment = cipher.output.getBytes();
  }
  record.fragment = forge$8.util.createBuffer(record.fragment);
  record.length = record.fragment.length();
  var mac2 = s2.macFunction(s2.macKey, s2.sequenceNumber, record);
  s2.updateSequenceNumber();
  rval = compareMacs(s2.macKey, mac, mac2) && rval;
  return rval;
}
function compareMacs(key, mac1, mac2) {
  var hmac2 = forge$8.hmac.create();
  hmac2.start("SHA1", key);
  hmac2.update(mac1);
  mac1 = hmac2.digest().getBytes();
  hmac2.start(null, null);
  hmac2.update(mac2);
  mac2 = hmac2.digest().getBytes();
  return mac1 === mac2;
}
var forge$7 = forge$D;
var sha512$1 = forge$7.sha512 = forge$7.sha512 || {};
forge$7.md.sha512 = forge$7.md.algorithms.sha512 = sha512$1;
var sha384 = forge$7.sha384 = forge$7.sha512.sha384 = forge$7.sha512.sha384 || {};
sha384.create = function() {
  return sha512$1.create("SHA-384");
};
forge$7.md.sha384 = forge$7.md.algorithms.sha384 = sha384;
forge$7.sha512.sha256 = forge$7.sha512.sha256 || {
  create: function() {
    return sha512$1.create("SHA-512/256");
  }
};
forge$7.md["sha512/256"] = forge$7.md.algorithms["sha512/256"] = forge$7.sha512.sha256;
forge$7.sha512.sha224 = forge$7.sha512.sha224 || {
  create: function() {
    return sha512$1.create("SHA-512/224");
  }
};
forge$7.md["sha512/224"] = forge$7.md.algorithms["sha512/224"] = forge$7.sha512.sha224;
sha512$1.create = function(algorithm) {
  if (!_initialized) {
    _init();
  }
  if (typeof algorithm === "undefined") {
    algorithm = "SHA-512";
  }
  if (!(algorithm in _states)) {
    throw new Error("Invalid SHA-512 algorithm: " + algorithm);
  }
  var _state = _states[algorithm];
  var _h = null;
  var _input = forge$7.util.createBuffer();
  var _w = new Array(80);
  for (var wi = 0; wi < 80; ++wi) {
    _w[wi] = new Array(2);
  }
  var digestLength = 64;
  switch (algorithm) {
    case "SHA-384":
      digestLength = 48;
      break;
    case "SHA-512/256":
      digestLength = 32;
      break;
    case "SHA-512/224":
      digestLength = 28;
      break;
  }
  var md = {
    // SHA-512 => sha512
    algorithm: algorithm.replace("-", "").toLowerCase(),
    blockLength: 128,
    digestLength,
    // 56-bit length of message so far (does not including padding)
    messageLength: 0,
    // true message length
    fullMessageLength: null,
    // size of message length in bytes
    messageLengthSize: 16
  };
  md.start = function() {
    md.messageLength = 0;
    md.fullMessageLength = md.messageLength128 = [];
    var int32s = md.messageLengthSize / 4;
    for (var i = 0; i < int32s; ++i) {
      md.fullMessageLength.push(0);
    }
    _input = forge$7.util.createBuffer();
    _h = new Array(_state.length);
    for (var i = 0; i < _state.length; ++i) {
      _h[i] = _state[i].slice(0);
    }
    return md;
  };
  md.start();
  md.update = function(msg, encoding3) {
    if (encoding3 === "utf8") {
      msg = forge$7.util.encodeUtf8(msg);
    }
    var len = msg.length;
    md.messageLength += len;
    len = [len / 4294967296 >>> 0, len >>> 0];
    for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
      md.fullMessageLength[i] += len[1];
      len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
      md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
      len[0] = len[1] / 4294967296 >>> 0;
    }
    _input.putBytes(msg);
    _update(_h, _w, _input);
    if (_input.read > 2048 || _input.length() === 0) {
      _input.compact();
    }
    return md;
  };
  md.digest = function() {
    var finalBlock = forge$7.util.createBuffer();
    finalBlock.putBytes(_input.bytes());
    var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
    var overflow = remaining & md.blockLength - 1;
    finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
    var next, carry;
    var bits = md.fullMessageLength[0] * 8;
    for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
      next = md.fullMessageLength[i + 1] * 8;
      carry = next / 4294967296 >>> 0;
      bits += carry;
      finalBlock.putInt32(bits >>> 0);
      bits = next >>> 0;
    }
    finalBlock.putInt32(bits);
    var h2 = new Array(_h.length);
    for (var i = 0; i < _h.length; ++i) {
      h2[i] = _h[i].slice(0);
    }
    _update(h2, _w, finalBlock);
    var rval = forge$7.util.createBuffer();
    var hlen;
    if (algorithm === "SHA-512") {
      hlen = h2.length;
    } else if (algorithm === "SHA-384") {
      hlen = h2.length - 2;
    } else {
      hlen = h2.length - 4;
    }
    for (var i = 0; i < hlen; ++i) {
      rval.putInt32(h2[i][0]);
      if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
        rval.putInt32(h2[i][1]);
      }
    }
    return rval;
  };
  return md;
};
var _padding = null;
var _initialized = false;
var _k = null;
var _states = null;
function _init() {
  _padding = String.fromCharCode(128);
  _padding += forge$7.util.fillString(String.fromCharCode(0), 128);
  _k = [
    [1116352408, 3609767458],
    [1899447441, 602891725],
    [3049323471, 3964484399],
    [3921009573, 2173295548],
    [961987163, 4081628472],
    [1508970993, 3053834265],
    [2453635748, 2937671579],
    [2870763221, 3664609560],
    [3624381080, 2734883394],
    [310598401, 1164996542],
    [607225278, 1323610764],
    [1426881987, 3590304994],
    [1925078388, 4068182383],
    [2162078206, 991336113],
    [2614888103, 633803317],
    [3248222580, 3479774868],
    [3835390401, 2666613458],
    [4022224774, 944711139],
    [264347078, 2341262773],
    [604807628, 2007800933],
    [770255983, 1495990901],
    [1249150122, 1856431235],
    [1555081692, 3175218132],
    [1996064986, 2198950837],
    [2554220882, 3999719339],
    [2821834349, 766784016],
    [2952996808, 2566594879],
    [3210313671, 3203337956],
    [3336571891, 1034457026],
    [3584528711, 2466948901],
    [113926993, 3758326383],
    [338241895, 168717936],
    [666307205, 1188179964],
    [773529912, 1546045734],
    [1294757372, 1522805485],
    [1396182291, 2643833823],
    [1695183700, 2343527390],
    [1986661051, 1014477480],
    [2177026350, 1206759142],
    [2456956037, 344077627],
    [2730485921, 1290863460],
    [2820302411, 3158454273],
    [3259730800, 3505952657],
    [3345764771, 106217008],
    [3516065817, 3606008344],
    [3600352804, 1432725776],
    [4094571909, 1467031594],
    [275423344, 851169720],
    [430227734, 3100823752],
    [506948616, 1363258195],
    [659060556, 3750685593],
    [883997877, 3785050280],
    [958139571, 3318307427],
    [1322822218, 3812723403],
    [1537002063, 2003034995],
    [1747873779, 3602036899],
    [1955562222, 1575990012],
    [2024104815, 1125592928],
    [2227730452, 2716904306],
    [2361852424, 442776044],
    [2428436474, 593698344],
    [2756734187, 3733110249],
    [3204031479, 2999351573],
    [3329325298, 3815920427],
    [3391569614, 3928383900],
    [3515267271, 566280711],
    [3940187606, 3454069534],
    [4118630271, 4000239992],
    [116418474, 1914138554],
    [174292421, 2731055270],
    [289380356, 3203993006],
    [460393269, 320620315],
    [685471733, 587496836],
    [852142971, 1086792851],
    [1017036298, 365543100],
    [1126000580, 2618297676],
    [1288033470, 3409855158],
    [1501505948, 4234509866],
    [1607167915, 987167468],
    [1816402316, 1246189591]
  ];
  _states = {};
  _states["SHA-512"] = [
    [1779033703, 4089235720],
    [3144134277, 2227873595],
    [1013904242, 4271175723],
    [2773480762, 1595750129],
    [1359893119, 2917565137],
    [2600822924, 725511199],
    [528734635, 4215389547],
    [1541459225, 327033209]
  ];
  _states["SHA-384"] = [
    [3418070365, 3238371032],
    [1654270250, 914150663],
    [2438529370, 812702999],
    [355462360, 4144912697],
    [1731405415, 4290775857],
    [2394180231, 1750603025],
    [3675008525, 1694076839],
    [1203062813, 3204075428]
  ];
  _states["SHA-512/256"] = [
    [573645204, 4230739756],
    [2673172387, 3360449730],
    [596883563, 1867755857],
    [2520282905, 1497426621],
    [2519219938, 2827943907],
    [3193839141, 1401305490],
    [721525244, 746961066],
    [246885852, 2177182882]
  ];
  _states["SHA-512/224"] = [
    [2352822216, 424955298],
    [1944164710, 2312950998],
    [502970286, 855612546],
    [1738396948, 1479516111],
    [258812777, 2077511080],
    [2011393907, 79989058],
    [1067287976, 1780299464],
    [286451373, 2446758561]
  ];
  _initialized = true;
}
function _update(s2, w2, bytes2) {
  var t1_hi, t1_lo;
  var t2_hi, t2_lo;
  var s0_hi, s0_lo;
  var s1_hi, s1_lo;
  var ch_hi, ch_lo;
  var maj_hi, maj_lo;
  var a_hi, a_lo;
  var b_hi, b_lo;
  var c_hi, c_lo;
  var d_hi, d_lo;
  var e_hi, e_lo;
  var f_hi, f_lo;
  var g_hi, g_lo;
  var h_hi, h_lo;
  var i, hi, lo, w22, w7, w15, w16;
  var len = bytes2.length();
  while (len >= 128) {
    for (i = 0; i < 16; ++i) {
      w2[i][0] = bytes2.getInt32() >>> 0;
      w2[i][1] = bytes2.getInt32() >>> 0;
    }
    for (; i < 80; ++i) {
      w22 = w2[i - 2];
      hi = w22[0];
      lo = w22[1];
      t1_hi = ((hi >>> 19 | lo << 13) ^ // ROTR 19
      (lo >>> 29 | hi << 3) ^ // ROTR 61/(swap + ROTR 29)
      hi >>> 6) >>> 0;
      t1_lo = ((hi << 13 | lo >>> 19) ^ // ROTR 19
      (lo << 3 | hi >>> 29) ^ // ROTR 61/(swap + ROTR 29)
      (hi << 26 | lo >>> 6)) >>> 0;
      w15 = w2[i - 15];
      hi = w15[0];
      lo = w15[1];
      t2_hi = ((hi >>> 1 | lo << 31) ^ // ROTR 1
      (hi >>> 8 | lo << 24) ^ // ROTR 8
      hi >>> 7) >>> 0;
      t2_lo = ((hi << 31 | lo >>> 1) ^ // ROTR 1
      (hi << 24 | lo >>> 8) ^ // ROTR 8
      (hi << 25 | lo >>> 7)) >>> 0;
      w7 = w2[i - 7];
      w16 = w2[i - 16];
      lo = t1_lo + w7[1] + t2_lo + w16[1];
      w2[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
      w2[i][1] = lo >>> 0;
    }
    a_hi = s2[0][0];
    a_lo = s2[0][1];
    b_hi = s2[1][0];
    b_lo = s2[1][1];
    c_hi = s2[2][0];
    c_lo = s2[2][1];
    d_hi = s2[3][0];
    d_lo = s2[3][1];
    e_hi = s2[4][0];
    e_lo = s2[4][1];
    f_hi = s2[5][0];
    f_lo = s2[5][1];
    g_hi = s2[6][0];
    g_lo = s2[6][1];
    h_hi = s2[7][0];
    h_lo = s2[7][1];
    for (i = 0; i < 80; ++i) {
      s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ // ROTR 14
      (e_hi >>> 18 | e_lo << 14) ^ // ROTR 18
      (e_lo >>> 9 | e_hi << 23)) >>> 0;
      s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ // ROTR 14
      (e_hi << 14 | e_lo >>> 18) ^ // ROTR 18
      (e_lo << 23 | e_hi >>> 9)) >>> 0;
      ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
      ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
      s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ // ROTR 28
      (a_lo >>> 2 | a_hi << 30) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo >>> 7 | a_hi << 25)) >>> 0;
      s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ // ROTR 28
      (a_lo << 30 | a_hi >>> 2) ^ // ROTR 34/(swap + ROTR 2)
      (a_lo << 25 | a_hi >>> 7)) >>> 0;
      maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
      maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
      lo = h_lo + s1_lo + ch_lo + _k[i][1] + w2[i][1];
      t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w2[i][0] + (lo / 4294967296 >>> 0) >>> 0;
      t1_lo = lo >>> 0;
      lo = s0_lo + maj_lo;
      t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
      t2_lo = lo >>> 0;
      h_hi = g_hi;
      h_lo = g_lo;
      g_hi = f_hi;
      g_lo = f_lo;
      f_hi = e_hi;
      f_lo = e_lo;
      lo = d_lo + t1_lo;
      e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
      e_lo = lo >>> 0;
      d_hi = c_hi;
      d_lo = c_lo;
      c_hi = b_hi;
      c_lo = b_lo;
      b_hi = a_hi;
      b_lo = a_lo;
      lo = t1_lo + t2_lo;
      a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
      a_lo = lo >>> 0;
    }
    lo = s2[0][1] + a_lo;
    s2[0][0] = s2[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[0][1] = lo >>> 0;
    lo = s2[1][1] + b_lo;
    s2[1][0] = s2[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[1][1] = lo >>> 0;
    lo = s2[2][1] + c_lo;
    s2[2][0] = s2[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[2][1] = lo >>> 0;
    lo = s2[3][1] + d_lo;
    s2[3][0] = s2[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[3][1] = lo >>> 0;
    lo = s2[4][1] + e_lo;
    s2[4][0] = s2[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[4][1] = lo >>> 0;
    lo = s2[5][1] + f_lo;
    s2[5][0] = s2[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[5][1] = lo >>> 0;
    lo = s2[6][1] + g_lo;
    s2[6][0] = s2[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[6][1] = lo >>> 0;
    lo = s2[7][1] + h_lo;
    s2[7][0] = s2[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
    s2[7][1] = lo >>> 0;
    len -= 128;
  }
}
var asn1Validator$1 = {};
var forge$6 = forge$D;
var asn1$1 = forge$6.asn1;
asn1Validator$1.privateKeyValidator = {
  // PrivateKeyInfo
  name: "PrivateKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  value: [{
    // Version (INTEGER)
    name: "PrivateKeyInfo.version",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.INTEGER,
    constructed: false,
    capture: "privateKeyVersion"
  }, {
    // privateKeyAlgorithm
    name: "PrivateKeyInfo.privateKeyAlgorithm",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "AlgorithmIdentifier.algorithm",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.OID,
      constructed: false,
      capture: "privateKeyOid"
    }]
  }, {
    // PrivateKey
    name: "PrivateKeyInfo",
    tagClass: asn1$1.Class.UNIVERSAL,
    type: asn1$1.Type.OCTETSTRING,
    constructed: false,
    capture: "privateKey"
  }]
};
asn1Validator$1.publicKeyValidator = {
  name: "SubjectPublicKeyInfo",
  tagClass: asn1$1.Class.UNIVERSAL,
  type: asn1$1.Type.SEQUENCE,
  constructed: true,
  captureAsn1: "subjectPublicKeyInfo",
  value: [
    {
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1$1.Class.UNIVERSAL,
        type: asn1$1.Type.OID,
        constructed: false,
        capture: "publicKeyOid"
      }]
    },
    // capture group for ed25519PublicKey
    {
      tagClass: asn1$1.Class.UNIVERSAL,
      type: asn1$1.Type.BITSTRING,
      constructed: false,
      composed: true,
      captureBitStringValue: "ed25519PublicKey"
    }
    // FIXME: this is capture group for rsaPublicKey, use it in this API or
    // discard?
    /* {
      // subjectPublicKey
      name: 'SubjectPublicKeyInfo.subjectPublicKey',
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        // RSAPublicKey
        name: 'SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey',
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: 'rsaPublicKey'
      }]
    } */
  ]
};
var forge$5 = forge$D;
var asn1Validator = asn1Validator$1;
var publicKeyValidator = asn1Validator.publicKeyValidator;
var privateKeyValidator = asn1Validator.privateKeyValidator;
if (typeof BigInteger$1 === "undefined") {
  var BigInteger$1 = forge$5.jsbn.BigInteger;
}
var ByteBuffer = forge$5.util.ByteBuffer;
var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
forge$5.pki = forge$5.pki || {};
forge$5.pki.ed25519 = forge$5.ed25519 = forge$5.ed25519 || {};
var ed25519 = forge$5.ed25519;
ed25519.constants = {};
ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
ed25519.constants.SEED_BYTE_LENGTH = 32;
ed25519.constants.SIGN_BYTE_LENGTH = 64;
ed25519.constants.HASH_BYTE_LENGTH = 64;
ed25519.generateKeyPair = function(options) {
  options = options || {};
  var seed = options.seed;
  if (seed === void 0) {
    seed = forge$5.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
  } else if (typeof seed === "string") {
    if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
      throw new TypeError(
        '"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length."
      );
    }
  } else if (!(seed instanceof Uint8Array)) {
    throw new TypeError(
      '"seed" must be a node.js Buffer, Uint8Array, or a binary string.'
    );
  }
  seed = messageToNativeBuffer({ message: seed, encoding: "binary" });
  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
  var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
  for (var i = 0; i < 32; ++i) {
    sk[i] = seed[i];
  }
  crypto_sign_keypair(pk, sk);
  return { publicKey: pk, privateKey: sk };
};
ed25519.privateKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  var valid = forge$5.asn1.validate(obj, privateKeyValidator, capture, errors2);
  if (!valid) {
    var error2 = new Error("Invalid Key.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = forge$5.asn1.derToOid(capture.privateKeyOid);
  var ed25519Oid = forge$5.oids.EdDSA25519;
  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }
  var privateKey = capture.privateKey;
  var privateKeyBytes = messageToNativeBuffer({
    message: forge$5.asn1.fromDer(privateKey).value,
    encoding: "binary"
  });
  return { privateKeyBytes };
};
ed25519.publicKeyFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  var valid = forge$5.asn1.validate(obj, publicKeyValidator, capture, errors2);
  if (!valid) {
    var error2 = new Error("Invalid Key.");
    error2.errors = errors2;
    throw error2;
  }
  var oid = forge$5.asn1.derToOid(capture.publicKeyOid);
  var ed25519Oid = forge$5.oids.EdDSA25519;
  if (oid !== ed25519Oid) {
    throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
  }
  var publicKeyBytes = capture.ed25519PublicKey;
  if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new Error("Key length is invalid.");
  }
  return messageToNativeBuffer({
    message: publicKeyBytes,
    encoding: "binary"
  });
};
ed25519.publicKeyFromPrivateKey = function(options) {
  options = options || {};
  var privateKey = messageToNativeBuffer({
    message: options.privateKey,
    encoding: "binary"
  });
  if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  }
  var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
  for (var i = 0; i < pk.length; ++i) {
    pk[i] = privateKey[32 + i];
  }
  return pk;
};
ed25519.sign = function(options) {
  options = options || {};
  var msg = messageToNativeBuffer(options);
  var privateKey = messageToNativeBuffer({
    message: options.privateKey,
    encoding: "binary"
  });
  if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
    var keyPair = ed25519.generateKeyPair({ seed: privateKey });
    privateKey = keyPair.privateKey;
  } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
    throw new TypeError(
      '"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH
    );
  }
  var signedMsg = new NativeBuffer(
    ed25519.constants.SIGN_BYTE_LENGTH + msg.length
  );
  crypto_sign(signedMsg, msg, msg.length, privateKey);
  var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
  for (var i = 0; i < sig.length; ++i) {
    sig[i] = signedMsg[i];
  }
  return sig;
};
ed25519.verify = function(options) {
  options = options || {};
  var msg = messageToNativeBuffer(options);
  if (options.signature === void 0) {
    throw new TypeError(
      '"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.'
    );
  }
  var sig = messageToNativeBuffer({
    message: options.signature,
    encoding: "binary"
  });
  if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
    throw new TypeError(
      '"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH
    );
  }
  var publicKey2 = messageToNativeBuffer({
    message: options.publicKey,
    encoding: "binary"
  });
  if (publicKey2.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
    throw new TypeError(
      '"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH
    );
  }
  var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  var m2 = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
  var i;
  for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
    sm[i] = sig[i];
  }
  for (i = 0; i < msg.length; ++i) {
    sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
  }
  return crypto_sign_open(m2, sm, sm.length, publicKey2) >= 0;
};
function messageToNativeBuffer(options) {
  var message = options.message;
  if (message instanceof Uint8Array || message instanceof NativeBuffer) {
    return message;
  }
  var encoding3 = options.encoding;
  if (message === void 0) {
    if (options.md) {
      message = options.md.digest().getBytes();
      encoding3 = "binary";
    } else {
      throw new TypeError('"options.message" or "options.md" not specified.');
    }
  }
  if (typeof message === "string" && !encoding3) {
    throw new TypeError('"options.encoding" must be "binary" or "utf8".');
  }
  if (typeof message === "string") {
    if (typeof Buffer !== "undefined") {
      return Buffer.from(message, encoding3);
    }
    message = new ByteBuffer(message, encoding3);
  } else if (!(message instanceof ByteBuffer)) {
    throw new TypeError(
      '"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.'
    );
  }
  var buffer = new NativeBuffer(message.length());
  for (var i = 0; i < buffer.length; ++i) {
    buffer[i] = message.at(i);
  }
  return buffer;
}
var gf0 = gf();
var gf1 = gf([1]);
var D = gf([
  30883,
  4953,
  19914,
  30187,
  55467,
  16705,
  2637,
  112,
  59544,
  30585,
  16505,
  36039,
  65139,
  11119,
  27886,
  20995
]);
var D2 = gf([
  61785,
  9906,
  39828,
  60374,
  45398,
  33411,
  5274,
  224,
  53552,
  61171,
  33010,
  6542,
  64743,
  22239,
  55772,
  9222
]);
var X = gf([
  54554,
  36645,
  11616,
  51542,
  42930,
  38181,
  51040,
  26924,
  56412,
  64982,
  57905,
  49316,
  21502,
  52590,
  14035,
  8553
]);
var Y = gf([
  26200,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214,
  26214
]);
var L = new Float64Array([
  237,
  211,
  245,
  92,
  26,
  99,
  18,
  88,
  214,
  156,
  247,
  162,
  222,
  249,
  222,
  20,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  16
]);
var I = gf([
  41136,
  18958,
  6951,
  50414,
  58488,
  44335,
  6150,
  12099,
  55207,
  15867,
  153,
  11085,
  57099,
  20417,
  9344,
  11139
]);
function sha512(msg, msgLen) {
  var md = forge$5.md.sha512.create();
  var buffer = new ByteBuffer(msg);
  md.update(buffer.getBytes(msgLen), "binary");
  var hash2 = md.digest().getBytes();
  if (typeof Buffer !== "undefined") {
    return Buffer.from(hash2, "binary");
  }
  var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
  for (var i = 0; i < 64; ++i) {
    out[i] = hash2.charCodeAt(i);
  }
  return out;
}
function crypto_sign_keypair(pk, sk) {
  var p = [gf(), gf(), gf(), gf()];
  var i;
  var d2 = sha512(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  scalarbase(p, d2);
  pack(pk, p);
  for (i = 0; i < 32; ++i) {
    sk[i + 32] = pk[i];
  }
  return 0;
}
function crypto_sign(sm, m2, n, sk) {
  var i, j2, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var d2 = sha512(sk, 32);
  d2[0] &= 248;
  d2[31] &= 127;
  d2[31] |= 64;
  var smlen = n + 64;
  for (i = 0; i < n; ++i) {
    sm[64 + i] = m2[i];
  }
  for (i = 0; i < 32; ++i) {
    sm[32 + i] = d2[32 + i];
  }
  var r = sha512(sm.subarray(32), n + 32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);
  for (i = 32; i < 64; ++i) {
    sm[i] = sk[i];
  }
  var h2 = sha512(sm, n + 64);
  reduce(h2);
  for (i = 32; i < 64; ++i) {
    x[i] = 0;
  }
  for (i = 0; i < 32; ++i) {
    x[i] = r[i];
  }
  for (i = 0; i < 32; ++i) {
    for (j2 = 0; j2 < 32; j2++) {
      x[i + j2] += h2[i] * d2[j2];
    }
  }
  modL(sm.subarray(32), x);
  return smlen;
}
function crypto_sign_open(m2, sm, n, pk) {
  var i, mlen;
  var t2 = new NativeBuffer(32);
  var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
  mlen = -1;
  if (n < 64) {
    return -1;
  }
  if (unpackneg(q, pk)) {
    return -1;
  }
  for (i = 0; i < n; ++i) {
    m2[i] = sm[i];
  }
  for (i = 0; i < 32; ++i) {
    m2[i + 32] = pk[i];
  }
  var h2 = sha512(m2, n);
  reduce(h2);
  scalarmult(p, q, h2);
  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t2, p);
  n -= 64;
  if (crypto_verify_32(sm, 0, t2, 0)) {
    for (i = 0; i < n; ++i) {
      m2[i] = 0;
    }
    return -1;
  }
  for (i = 0; i < n; ++i) {
    m2[i] = sm[i + 64];
  }
  mlen = n;
  return mlen;
}
function modL(r, x) {
  var carry, i, j2, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j2 = i - 32, k = i - 12; j2 < k; ++j2) {
      x[j2] += carry - 16 * x[i] * L[j2 - (i - 32)];
      carry = x[j2] + 128 >> 8;
      x[j2] -= carry * 256;
    }
    x[j2] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j2 = 0; j2 < 32; ++j2) {
    x[j2] += carry - (x[31] >> 4) * L[j2];
    carry = x[j2] >> 8;
    x[j2] &= 255;
  }
  for (j2 = 0; j2 < 32; ++j2) {
    x[j2] -= carry * L[j2];
  }
  for (i = 0; i < 32; ++i) {
    x[i + 1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}
function reduce(r) {
  var x = new Float64Array(64);
  for (var i = 0; i < 64; ++i) {
    x[i] = r[i];
    r[i] = 0;
  }
  modL(r, x);
}
function add(p, q) {
  var a = gf(), b = gf(), c = gf(), d2 = gf(), e = gf(), f = gf(), g = gf(), h2 = gf(), t2 = gf();
  Z(a, p[1], p[0]);
  Z(t2, q[1], q[0]);
  M(a, a, t2);
  A(b, p[0], p[1]);
  A(t2, q[0], q[1]);
  M(b, b, t2);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d2, p[2], q[2]);
  A(d2, d2, d2);
  Z(e, b, a);
  Z(f, d2, c);
  A(g, d2, c);
  A(h2, b, a);
  M(p[0], e, f);
  M(p[1], h2, g);
  M(p[2], g, f);
  M(p[3], e, h2);
}
function cswap(p, q, b) {
  for (var i = 0; i < 4; ++i) {
    sel25519(p[i], q[i], b);
  }
}
function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}
function pack25519(o, n) {
  var i, j2, b;
  var m2 = gf(), t2 = gf();
  for (i = 0; i < 16; ++i) {
    t2[i] = n[i];
  }
  car25519(t2);
  car25519(t2);
  car25519(t2);
  for (j2 = 0; j2 < 2; ++j2) {
    m2[0] = t2[0] - 65517;
    for (i = 1; i < 15; ++i) {
      m2[i] = t2[i] - 65535 - (m2[i - 1] >> 16 & 1);
      m2[i - 1] &= 65535;
    }
    m2[15] = t2[15] - 32767 - (m2[14] >> 16 & 1);
    b = m2[15] >> 16 & 1;
    m2[14] &= 65535;
    sel25519(t2, m2, 1 - b);
  }
  for (i = 0; i < 16; i++) {
    o[2 * i] = t2[i] & 255;
    o[2 * i + 1] = t2[i] >> 8;
  }
}
function unpackneg(r, p) {
  var t2 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);
  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t2, den6, num);
  M(t2, t2, den);
  pow2523(t2, t2);
  M(t2, t2, num);
  M(t2, t2, den);
  M(t2, t2, den);
  M(r[0], t2, den);
  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    M(r[0], r[0], I);
  }
  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) {
    return -1;
  }
  if (par25519(r[0]) === p[31] >> 7) {
    Z(r[0], gf0, r[0]);
  }
  M(r[3], r[0], r[1]);
  return 0;
}
function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; ++i) {
    o[i] = n[2 * i] + (n[2 * i + 1] << 8);
  }
  o[15] &= 32767;
}
function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; ++a) {
    c[a] = i[a];
  }
  for (a = 250; a >= 0; --a) {
    S(c, c);
    if (a !== 1) {
      M(c, c, i);
    }
  }
  for (a = 0; a < 16; ++a) {
    o[a] = c[a];
  }
}
function neq25519(a, b) {
  var c = new NativeBuffer(32);
  var d2 = new NativeBuffer(32);
  pack25519(c, a);
  pack25519(d2, b);
  return crypto_verify_32(c, 0, d2, 0);
}
function crypto_verify_32(x, xi, y2, yi) {
  return vn(x, xi, y2, yi, 32);
}
function vn(x, xi, y2, yi, n) {
  var i, d2 = 0;
  for (i = 0; i < n; ++i) {
    d2 |= x[xi + i] ^ y2[yi + i];
  }
  return (1 & d2 - 1 >>> 8) - 1;
}
function par25519(a) {
  var d2 = new NativeBuffer(32);
  pack25519(d2, a);
  return d2[0] & 1;
}
function scalarmult(p, q, s2) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = s2[i / 8 | 0] >> (i & 7) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}
function scalarbase(p, s2) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s2);
}
function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) {
    r[i] = a[i] | 0;
  }
}
function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; ++a) {
    c[a] = i[a];
  }
  for (a = 253; a >= 0; --a) {
    S(c, c);
    if (a !== 2 && a !== 4) {
      M(c, c, i);
    }
  }
  for (a = 0; a < 16; ++a) {
    o[a] = c[a];
  }
}
function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; ++i) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c - 1 + 37 * (c - 1);
}
function sel25519(p, q, b) {
  var t2, c = ~(b - 1);
  for (var i = 0; i < 16; ++i) {
    t2 = c & (p[i] ^ q[i]);
    p[i] ^= t2;
    q[i] ^= t2;
  }
}
function gf(init2) {
  var i, r = new Float64Array(16);
  if (init2) {
    for (i = 0; i < init2.length; ++i) {
      r[i] = init2[i];
    }
  }
  return r;
}
function A(o, a, b) {
  for (var i = 0; i < 16; ++i) {
    o[i] = a[i] + b[i];
  }
}
function Z(o, a, b) {
  for (var i = 0; i < 16; ++i) {
    o[i] = a[i] - b[i];
  }
}
function S(o, a) {
  M(o, a, a);
}
function M(o, a, b) {
  var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;
  t0 += 38 * t16;
  t1 += 38 * t17;
  t2 += 38 * t18;
  t3 += 38 * t19;
  t4 += 38 * t20;
  t5 += 38 * t21;
  t6 += 38 * t22;
  t7 += 38 * t23;
  t8 += 38 * t24;
  t9 += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  c = 1;
  v = t0 + c + 65535;
  c = Math.floor(v / 65536);
  t0 = v - c * 65536;
  v = t1 + c + 65535;
  c = Math.floor(v / 65536);
  t1 = v - c * 65536;
  v = t2 + c + 65535;
  c = Math.floor(v / 65536);
  t2 = v - c * 65536;
  v = t3 + c + 65535;
  c = Math.floor(v / 65536);
  t3 = v - c * 65536;
  v = t4 + c + 65535;
  c = Math.floor(v / 65536);
  t4 = v - c * 65536;
  v = t5 + c + 65535;
  c = Math.floor(v / 65536);
  t5 = v - c * 65536;
  v = t6 + c + 65535;
  c = Math.floor(v / 65536);
  t6 = v - c * 65536;
  v = t7 + c + 65535;
  c = Math.floor(v / 65536);
  t7 = v - c * 65536;
  v = t8 + c + 65535;
  c = Math.floor(v / 65536);
  t8 = v - c * 65536;
  v = t9 + c + 65535;
  c = Math.floor(v / 65536);
  t9 = v - c * 65536;
  v = t10 + c + 65535;
  c = Math.floor(v / 65536);
  t10 = v - c * 65536;
  v = t11 + c + 65535;
  c = Math.floor(v / 65536);
  t11 = v - c * 65536;
  v = t12 + c + 65535;
  c = Math.floor(v / 65536);
  t12 = v - c * 65536;
  v = t13 + c + 65535;
  c = Math.floor(v / 65536);
  t13 = v - c * 65536;
  v = t14 + c + 65535;
  c = Math.floor(v / 65536);
  t14 = v - c * 65536;
  v = t15 + c + 65535;
  c = Math.floor(v / 65536);
  t15 = v - c * 65536;
  t0 += c - 1 + 37 * (c - 1);
  o[0] = t0;
  o[1] = t1;
  o[2] = t2;
  o[3] = t3;
  o[4] = t4;
  o[5] = t5;
  o[6] = t6;
  o[7] = t7;
  o[8] = t8;
  o[9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}
var forge$4 = forge$D;
forge$4.kem = forge$4.kem || {};
var BigInteger = forge$4.jsbn.BigInteger;
forge$4.kem.rsa = {};
forge$4.kem.rsa.create = function(kdf, options) {
  options = options || {};
  var prng2 = options.prng || forge$4.random;
  var kem = {};
  kem.encrypt = function(publicKey2, keyLength) {
    var byteLength = Math.ceil(publicKey2.n.bitLength() / 8);
    var r;
    do {
      r = new BigInteger(
        forge$4.util.bytesToHex(prng2.getBytesSync(byteLength)),
        16
      ).mod(publicKey2.n);
    } while (r.compareTo(BigInteger.ONE) <= 0);
    r = forge$4.util.hexToBytes(r.toString(16));
    var zeros = byteLength - r.length;
    if (zeros > 0) {
      r = forge$4.util.fillString(String.fromCharCode(0), zeros) + r;
    }
    var encapsulation = publicKey2.encrypt(r, "NONE");
    var key = kdf.generate(r, keyLength);
    return { encapsulation, key };
  };
  kem.decrypt = function(privateKey, encapsulation, keyLength) {
    var r = privateKey.decrypt(encapsulation, "NONE");
    return kdf.generate(r, keyLength);
  };
  return kem;
};
forge$4.kem.kdf1 = function(md, digestLength) {
  _createKDF(this, md, 0, digestLength || md.digestLength);
};
forge$4.kem.kdf2 = function(md, digestLength) {
  _createKDF(this, md, 1, digestLength || md.digestLength);
};
function _createKDF(kdf, md, counterStart, digestLength) {
  kdf.generate = function(x, length) {
    var key = new forge$4.util.ByteBuffer();
    var k = Math.ceil(length / digestLength) + counterStart;
    var c = new forge$4.util.ByteBuffer();
    for (var i = counterStart; i < k; ++i) {
      c.putInt32(i);
      md.start();
      md.update(x + c.getBytes());
      var hash2 = md.digest();
      key.putBytes(hash2.getBytes(digestLength));
    }
    key.truncate(key.length() - length);
    return key.getBytes();
  };
}
var forge$3 = forge$D;
forge$3.log = forge$3.log || {};
forge$3.log.levels = [
  "none",
  "error",
  "warning",
  "info",
  "debug",
  "verbose",
  "max"
];
var sLevelInfo = {};
var sLoggers = [];
var sConsoleLogger = null;
forge$3.log.LEVEL_LOCKED = 1 << 1;
forge$3.log.NO_LEVEL_CHECK = 1 << 2;
forge$3.log.INTERPOLATE = 1 << 3;
for (var i = 0; i < forge$3.log.levels.length; ++i) {
  var level = forge$3.log.levels[i];
  sLevelInfo[level] = {
    index: i,
    name: level.toUpperCase()
  };
}
forge$3.log.logMessage = function(message) {
  var messageLevelIndex = sLevelInfo[message.level].index;
  for (var i = 0; i < sLoggers.length; ++i) {
    var logger = sLoggers[i];
    if (logger.flags & forge$3.log.NO_LEVEL_CHECK) {
      logger.f(message);
    } else {
      var loggerLevelIndex = sLevelInfo[logger.level].index;
      if (messageLevelIndex <= loggerLevelIndex) {
        logger.f(logger, message);
      }
    }
  }
};
forge$3.log.prepareStandard = function(message) {
  if (!("standard" in message)) {
    message.standard = sLevelInfo[message.level].name + //' ' + +message.timestamp +
    " [" + message.category + "] " + message.message;
  }
};
forge$3.log.prepareFull = function(message) {
  if (!("full" in message)) {
    var args = [message.message];
    args = args.concat([]);
    message.full = forge$3.util.format.apply(this, args);
  }
};
forge$3.log.prepareStandardFull = function(message) {
  if (!("standardFull" in message)) {
    forge$3.log.prepareStandard(message);
    message.standardFull = message.standard;
  }
};
{
  var levels = ["error", "warning", "info", "debug", "verbose"];
  for (var i = 0; i < levels.length; ++i) {
    (function(level) {
      forge$3.log[level] = function(category, message) {
        var args = Array.prototype.slice.call(arguments).slice(2);
        var msg = {
          timestamp: /* @__PURE__ */ new Date(),
          level,
          category,
          message,
          "arguments": args
          /*standard*/
          /*full*/
          /*fullMessage*/
        };
        forge$3.log.logMessage(msg);
      };
    })(levels[i]);
  }
}
forge$3.log.makeLogger = function(logFunction) {
  var logger = {
    flags: 0,
    f: logFunction
  };
  forge$3.log.setLevel(logger, "none");
  return logger;
};
forge$3.log.setLevel = function(logger, level) {
  var rval = false;
  if (logger && !(logger.flags & forge$3.log.LEVEL_LOCKED)) {
    for (var i = 0; i < forge$3.log.levels.length; ++i) {
      var aValidLevel = forge$3.log.levels[i];
      if (level == aValidLevel) {
        logger.level = level;
        rval = true;
        break;
      }
    }
  }
  return rval;
};
forge$3.log.lock = function(logger, lock) {
  if (typeof lock === "undefined" || lock) {
    logger.flags |= forge$3.log.LEVEL_LOCKED;
  } else {
    logger.flags &= ~forge$3.log.LEVEL_LOCKED;
  }
};
forge$3.log.addLogger = function(logger) {
  sLoggers.push(logger);
};
if (typeof console !== "undefined" && "log" in console) {
  var logger;
  if (console.error && console.warn && console.info && console.debug) {
    var levelHandlers = {
      error: console.error,
      warning: console.warn,
      info: console.info,
      debug: console.debug,
      verbose: console.debug
    };
    var f = function(logger2, message) {
      forge$3.log.prepareStandard(message);
      var handler = levelHandlers[message.level];
      var args = [message.standard];
      args = args.concat(message["arguments"].slice());
      handler.apply(console, args);
    };
    logger = forge$3.log.makeLogger(f);
  } else {
    var f = function(logger2, message) {
      forge$3.log.prepareStandardFull(message);
      console.log(message.standardFull);
    };
    logger = forge$3.log.makeLogger(f);
  }
  forge$3.log.setLevel(logger, "debug");
  forge$3.log.addLogger(logger);
  sConsoleLogger = logger;
} else {
  console = {
    log: function() {
    }
  };
}
if (sConsoleLogger !== null && typeof window !== "undefined" && window.location) {
  var query = new URL(window.location.href).searchParams;
  if (query.has("console.level")) {
    forge$3.log.setLevel(
      sConsoleLogger,
      query.get("console.level").slice(-1)[0]
    );
  }
  if (query.has("console.lock")) {
    var lock = query.get("console.lock").slice(-1)[0];
    if (lock == "true") {
      forge$3.log.lock(sConsoleLogger);
    }
  }
}
forge$3.log.consoleLogger = sConsoleLogger;
var forge$2 = forge$D;
var asn1 = forge$2.asn1;
var p7 = forge$2.pkcs7 = forge$2.pkcs7 || {};
p7.messageFromPem = function(pem2) {
  var msg = forge$2.pem.decode(pem2)[0];
  if (msg.type !== "PKCS7") {
    var error2 = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
    error2.headerType = msg.type;
    throw error2;
  }
  if (msg.procType && msg.procType.type === "ENCRYPTED") {
    throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
  }
  var obj = asn1.fromDer(msg.body);
  return p7.messageFromAsn1(obj);
};
p7.messageToPem = function(msg, maxline) {
  var pemObj = {
    type: "PKCS7",
    body: asn1.toDer(msg.toAsn1()).getBytes()
  };
  return forge$2.pem.encode(pemObj, { maxline });
};
p7.messageFromAsn1 = function(obj) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
    error2.errors = errors2;
    throw error2;
  }
  var contentType3 = asn1.derToOid(capture.contentType);
  var msg;
  switch (contentType3) {
    case forge$2.pki.oids.envelopedData:
      msg = p7.createEnvelopedData();
      break;
    case forge$2.pki.oids.encryptedData:
      msg = p7.createEncryptedData();
      break;
    case forge$2.pki.oids.signedData:
      msg = p7.createSignedData();
      break;
    default:
      throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType3 + " is not (yet) supported.");
  }
  msg.fromAsn1(capture.content.value[0]);
  return msg;
};
p7.createSignedData = function() {
  var msg = null;
  msg = {
    type: forge$2.pki.oids.signedData,
    version: 1,
    certificates: [],
    crls: [],
    // TODO: add json-formatted signer stuff here?
    signers: [],
    // populated during sign()
    digestAlgorithmIdentifiers: [],
    contentInfo: null,
    signerInfos: [],
    fromAsn1: function(obj) {
      _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
      msg.certificates = [];
      msg.crls = [];
      msg.digestAlgorithmIdentifiers = [];
      msg.contentInfo = null;
      msg.signerInfos = [];
      if (msg.rawCapture.certificates) {
        var certs = msg.rawCapture.certificates.value;
        for (var i = 0; i < certs.length; ++i) {
          msg.certificates.push(forge$2.pki.certificateFromAsn1(certs[i]));
        }
      }
    },
    toAsn1: function() {
      if (!msg.contentInfo) {
        msg.sign();
      }
      var certs = [];
      for (var i = 0; i < msg.certificates.length; ++i) {
        certs.push(forge$2.pki.certificateToAsn1(msg.certificates[i]));
      }
      var crls = [];
      var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // Version
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.INTEGER,
            false,
            asn1.integerToDer(msg.version).getBytes()
          ),
          // DigestAlgorithmIdentifiers
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.SET,
            true,
            msg.digestAlgorithmIdentifiers
          ),
          // ContentInfo
          msg.contentInfo
        ])
      ]);
      if (certs.length > 0) {
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs)
        );
      }
      if (crls.length > 0) {
        signedData.value[0].value.push(
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls)
        );
      }
      signedData.value[0].value.push(
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          true,
          msg.signerInfos
        )
      );
      return asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.SEQUENCE,
        true,
        [
          // ContentType
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(msg.type).getBytes()
          ),
          // [0] SignedData
          signedData
        ]
      );
    },
    /**
     * Add (another) entity to list of signers.
     *
     * Note: If authenticatedAttributes are provided, then, per RFC 2315,
     * they must include at least two attributes: content type and
     * message digest. The message digest attribute value will be
     * auto-calculated during signing and will be ignored if provided.
     *
     * Here's an example of providing these two attributes:
     *
     * forge.pkcs7.createSignedData();
     * p7.addSigner({
     *   issuer: cert.issuer.attributes,
     *   serialNumber: cert.serialNumber,
     *   key: privateKey,
     *   digestAlgorithm: forge.pki.oids.sha1,
     *   authenticatedAttributes: [{
     *     type: forge.pki.oids.contentType,
     *     value: forge.pki.oids.data
     *   }, {
     *     type: forge.pki.oids.messageDigest
     *   }]
     * });
     *
     * TODO: Support [subjectKeyIdentifier] as signer's ID.
     *
     * @param signer the signer information:
     *          key the signer's private key.
     *          [certificate] a certificate containing the public key
     *            associated with the signer's private key; use this option as
     *            an alternative to specifying signer.issuer and
     *            signer.serialNumber.
     *          [issuer] the issuer attributes (eg: cert.issuer.attributes).
     *          [serialNumber] the signer's certificate's serial number in
     *           hexadecimal (eg: cert.serialNumber).
     *          [digestAlgorithm] the message digest OID, as a string, to use
     *            (eg: forge.pki.oids.sha1).
     *          [authenticatedAttributes] an optional array of attributes
     *            to also sign along with the content.
     */
    addSigner: function(signer) {
      var issuer = signer.issuer;
      var serialNumber = signer.serialNumber;
      if (signer.certificate) {
        var cert = signer.certificate;
        if (typeof cert === "string") {
          cert = forge$2.pki.certificateFromPem(cert);
        }
        issuer = cert.issuer.attributes;
        serialNumber = cert.serialNumber;
      }
      var key = signer.key;
      if (!key) {
        throw new Error(
          "Could not add PKCS#7 signer; no private key specified."
        );
      }
      if (typeof key === "string") {
        key = forge$2.pki.privateKeyFromPem(key);
      }
      var digestAlgorithm = signer.digestAlgorithm || forge$2.pki.oids.sha1;
      switch (digestAlgorithm) {
        case forge$2.pki.oids.sha1:
        case forge$2.pki.oids.sha256:
        case forge$2.pki.oids.sha384:
        case forge$2.pki.oids.sha512:
        case forge$2.pki.oids.md5:
          break;
        default:
          throw new Error(
            "Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm
          );
      }
      var authenticatedAttributes = signer.authenticatedAttributes || [];
      if (authenticatedAttributes.length > 0) {
        var contentType3 = false;
        var messageDigest = false;
        for (var i = 0; i < authenticatedAttributes.length; ++i) {
          var attr = authenticatedAttributes[i];
          if (!contentType3 && attr.type === forge$2.pki.oids.contentType) {
            contentType3 = true;
            if (messageDigest) {
              break;
            }
            continue;
          }
          if (!messageDigest && attr.type === forge$2.pki.oids.messageDigest) {
            messageDigest = true;
            if (contentType3) {
              break;
            }
            continue;
          }
        }
        if (!contentType3 || !messageDigest) {
          throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
        }
      }
      msg.signers.push({
        key,
        version: 1,
        issuer,
        serialNumber,
        digestAlgorithm,
        signatureAlgorithm: forge$2.pki.oids.rsaEncryption,
        signature: null,
        authenticatedAttributes,
        unauthenticatedAttributes: []
      });
    },
    /**
     * Signs the content.
     * @param options Options to apply when signing:
     *    [detached] boolean. If signing should be done in detached mode. Defaults to false.
     */
    sign: function(options) {
      options = options || {};
      if (typeof msg.content !== "object" || msg.contentInfo === null) {
        msg.contentInfo = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SEQUENCE,
          true,
          [
            // ContentType
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.OID,
              false,
              asn1.oidToDer(forge$2.pki.oids.data).getBytes()
            )
          ]
        );
        if ("content" in msg) {
          var content;
          if (msg.content instanceof forge$2.util.ByteBuffer) {
            content = msg.content.bytes();
          } else if (typeof msg.content === "string") {
            content = forge$2.util.encodeUtf8(msg.content);
          }
          if (options.detached) {
            msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
          } else {
            msg.contentInfo.value.push(
              // [0] EXPLICIT content
              asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(
                  asn1.Class.UNIVERSAL,
                  asn1.Type.OCTETSTRING,
                  false,
                  content
                )
              ])
            );
          }
        }
      }
      if (msg.signers.length === 0) {
        return;
      }
      var mds = addDigestAlgorithmIds();
      addSignerInfos(mds);
    },
    verify: function() {
      throw new Error("PKCS#7 signature verification not yet implemented.");
    },
    /**
     * Add a certificate.
     *
     * @param cert the certificate to add.
     */
    addCertificate: function(cert) {
      if (typeof cert === "string") {
        cert = forge$2.pki.certificateFromPem(cert);
      }
      msg.certificates.push(cert);
    },
    /**
     * Add a certificate revokation list.
     *
     * @param crl the certificate revokation list to add.
     */
    addCertificateRevokationList: function(crl) {
      throw new Error("PKCS#7 CRL support not yet implemented.");
    }
  };
  return msg;
  function addDigestAlgorithmIds() {
    var mds = {};
    for (var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];
      var oid = signer.digestAlgorithm;
      if (!(oid in mds)) {
        mds[oid] = forge$2.md[forge$2.pki.oids[oid]].create();
      }
      if (signer.authenticatedAttributes.length === 0) {
        signer.md = mds[oid];
      } else {
        signer.md = forge$2.md[forge$2.pki.oids[oid]].create();
      }
    }
    msg.digestAlgorithmIdentifiers = [];
    for (var oid in mds) {
      msg.digestAlgorithmIdentifiers.push(
        // AlgorithmIdentifier
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          // algorithm
          asn1.create(
            asn1.Class.UNIVERSAL,
            asn1.Type.OID,
            false,
            asn1.oidToDer(oid).getBytes()
          ),
          // parameters (null)
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ])
      );
    }
    return mds;
  }
  function addSignerInfos(mds) {
    var content;
    if (msg.detachedContent) {
      content = msg.detachedContent;
    } else {
      content = msg.contentInfo.value[1];
      content = content.value[0];
    }
    if (!content) {
      throw new Error(
        "Could not sign PKCS#7 message; there is no content to sign."
      );
    }
    var contentType3 = asn1.derToOid(msg.contentInfo.value[0].value);
    var bytes2 = asn1.toDer(content);
    bytes2.getByte();
    asn1.getBerValueLength(bytes2);
    bytes2 = bytes2.getBytes();
    for (var oid in mds) {
      mds[oid].start().update(bytes2);
    }
    var signingTime = /* @__PURE__ */ new Date();
    for (var i = 0; i < msg.signers.length; ++i) {
      var signer = msg.signers[i];
      if (signer.authenticatedAttributes.length === 0) {
        if (contentType3 !== forge$2.pki.oids.data) {
          throw new Error(
            "Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data."
          );
        }
      } else {
        signer.authenticatedAttributesAsn1 = asn1.create(
          asn1.Class.CONTEXT_SPECIFIC,
          0,
          true,
          []
        );
        var attrsAsn1 = asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.SET,
          true,
          []
        );
        for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
          var attr = signer.authenticatedAttributes[ai];
          if (attr.type === forge$2.pki.oids.messageDigest) {
            attr.value = mds[signer.digestAlgorithm].digest();
          } else if (attr.type === forge$2.pki.oids.signingTime) {
            if (!attr.value) {
              attr.value = signingTime;
            }
          }
          attrsAsn1.value.push(_attributeToAsn1(attr));
          signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
        }
        bytes2 = asn1.toDer(attrsAsn1).getBytes();
        signer.md.start().update(bytes2);
      }
      signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
    }
    msg.signerInfos = _signersToAsn1(msg.signers);
  }
};
p7.createEncryptedData = function() {
  var msg = null;
  msg = {
    type: forge$2.pki.oids.encryptedData,
    version: 0,
    encryptedContent: {
      algorithm: forge$2.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EncryptedData content block (in ASN.1 format)
     *
     * @param obj The ASN.1 representation of the EncryptedData content block
     */
    fromAsn1: function(obj) {
      _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
    },
    /**
     * Decrypt encrypted content
     *
     * @param key The (symmetric) key as a byte buffer
     */
    decrypt: function(key) {
      if (key !== void 0) {
        msg.encryptedContent.key = key;
      }
      _decryptContent(msg);
    }
  };
  return msg;
};
p7.createEnvelopedData = function() {
  var msg = null;
  msg = {
    type: forge$2.pki.oids.envelopedData,
    version: 0,
    recipients: [],
    encryptedContent: {
      algorithm: forge$2.pki.oids["aes256-CBC"]
    },
    /**
     * Reads an EnvelopedData content block (in ASN.1 format)
     *
     * @param obj the ASN.1 representation of the EnvelopedData content block.
     */
    fromAsn1: function(obj) {
      var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
      msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
    },
    toAsn1: function() {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        // ContentType
        asn1.create(
          asn1.Class.UNIVERSAL,
          asn1.Type.OID,
          false,
          asn1.oidToDer(msg.type).getBytes()
        ),
        // [0] EnvelopedData
        asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            // Version
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.INTEGER,
              false,
              asn1.integerToDer(msg.version).getBytes()
            ),
            // RecipientInfos
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SET,
              true,
              _recipientsToAsn1(msg.recipients)
            ),
            // EncryptedContentInfo
            asn1.create(
              asn1.Class.UNIVERSAL,
              asn1.Type.SEQUENCE,
              true,
              _encryptedContentToAsn1(msg.encryptedContent)
            )
          ])
        ])
      ]);
    },
    /**
     * Find recipient by X.509 certificate's issuer.
     *
     * @param cert the certificate with the issuer to look for.
     *
     * @return the recipient object.
     */
    findRecipient: function(cert) {
      var sAttr = cert.issuer.attributes;
      for (var i = 0; i < msg.recipients.length; ++i) {
        var r = msg.recipients[i];
        var rAttr = r.issuer;
        if (r.serialNumber !== cert.serialNumber) {
          continue;
        }
        if (rAttr.length !== sAttr.length) {
          continue;
        }
        var match2 = true;
        for (var j2 = 0; j2 < sAttr.length; ++j2) {
          if (rAttr[j2].type !== sAttr[j2].type || rAttr[j2].value !== sAttr[j2].value) {
            match2 = false;
            break;
          }
        }
        if (match2) {
          return r;
        }
      }
      return null;
    },
    /**
     * Decrypt enveloped content
     *
     * @param recipient The recipient object related to the private key
     * @param privKey The (RSA) private key object
     */
    decrypt: function(recipient, privKey) {
      if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
        switch (recipient.encryptedContent.algorithm) {
          case forge$2.pki.oids.rsaEncryption:
          case forge$2.pki.oids.desCBC:
            var key = privKey.decrypt(recipient.encryptedContent.content);
            msg.encryptedContent.key = forge$2.util.createBuffer(key);
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
      }
      _decryptContent(msg);
    },
    /**
     * Add (another) entity to list of recipients.
     *
     * @param cert The certificate of the entity to add.
     */
    addRecipient: function(cert) {
      msg.recipients.push({
        version: 0,
        issuer: cert.issuer.attributes,
        serialNumber: cert.serialNumber,
        encryptedContent: {
          // We simply assume rsaEncryption here, since forge.pki only
          // supports RSA so far.  If the PKI module supports other
          // ciphers one day, we need to modify this one as well.
          algorithm: forge$2.pki.oids.rsaEncryption,
          key: cert.publicKey
        }
      });
    },
    /**
     * Encrypt enveloped content.
     *
     * This function supports two optional arguments, cipher and key, which
     * can be used to influence symmetric encryption.  Unless cipher is
     * provided, the cipher specified in encryptedContent.algorithm is used
     * (defaults to AES-256-CBC).  If no key is provided, encryptedContent.key
     * is (re-)used.  If that one's not set, a random key will be generated
     * automatically.
     *
     * @param [key] The key to be used for symmetric encryption.
     * @param [cipher] The OID of the symmetric cipher to use.
     */
    encrypt: function(key, cipher) {
      if (msg.encryptedContent.content === void 0) {
        cipher = cipher || msg.encryptedContent.algorithm;
        key = key || msg.encryptedContent.key;
        var keyLen, ivLen, ciphFn;
        switch (cipher) {
          case forge$2.pki.oids["aes128-CBC"]:
            keyLen = 16;
            ivLen = 16;
            ciphFn = forge$2.aes.createEncryptionCipher;
            break;
          case forge$2.pki.oids["aes192-CBC"]:
            keyLen = 24;
            ivLen = 16;
            ciphFn = forge$2.aes.createEncryptionCipher;
            break;
          case forge$2.pki.oids["aes256-CBC"]:
            keyLen = 32;
            ivLen = 16;
            ciphFn = forge$2.aes.createEncryptionCipher;
            break;
          case forge$2.pki.oids["des-EDE3-CBC"]:
            keyLen = 24;
            ivLen = 8;
            ciphFn = forge$2.des.createEncryptionCipher;
            break;
          default:
            throw new Error("Unsupported symmetric cipher, OID " + cipher);
        }
        if (key === void 0) {
          key = forge$2.util.createBuffer(forge$2.random.getBytes(keyLen));
        } else if (key.length() != keyLen) {
          throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
        }
        msg.encryptedContent.algorithm = cipher;
        msg.encryptedContent.key = key;
        msg.encryptedContent.parameter = forge$2.util.createBuffer(
          forge$2.random.getBytes(ivLen)
        );
        var ciph = ciphFn(key);
        ciph.start(msg.encryptedContent.parameter.copy());
        ciph.update(msg.content);
        if (!ciph.finish()) {
          throw new Error("Symmetric encryption failed.");
        }
        msg.encryptedContent.content = ciph.output;
      }
      for (var i = 0; i < msg.recipients.length; ++i) {
        var recipient = msg.recipients[i];
        if (recipient.encryptedContent.content !== void 0) {
          continue;
        }
        switch (recipient.encryptedContent.algorithm) {
          case forge$2.pki.oids.rsaEncryption:
            recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(
              msg.encryptedContent.key.data
            );
            break;
          default:
            throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
        }
      }
    }
  };
  return msg;
};
function _recipientFromAsn1(obj) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
    error2.errors = errors2;
    throw error2;
  }
  return {
    version: capture.version.charCodeAt(0),
    issuer: forge$2.pki.RDNAttributesAsArray(capture.issuer),
    serialNumber: forge$2.util.createBuffer(capture.serial).toHex(),
    encryptedContent: {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: capture.encParameter ? capture.encParameter.value : void 0,
      content: capture.encKey
    }
  };
}
function _recipientToAsn1(obj) {
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // Version
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      false,
      asn1.integerToDer(obj.version).getBytes()
    ),
    // IssuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Name
      forge$2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
      // Serial
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        false,
        forge$2.util.hexToBytes(obj.serialNumber)
      )
    ]),
    // KeyEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()
      ),
      // Parameter, force NULL, only RSA supported for now.
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ]),
    // EncryptedKey
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      false,
      obj.encryptedContent.content
    )
  ]);
}
function _recipientsFromAsn1(infos) {
  var ret = [];
  for (var i = 0; i < infos.length; ++i) {
    ret.push(_recipientFromAsn1(infos[i]));
  }
  return ret;
}
function _recipientsToAsn1(recipients) {
  var ret = [];
  for (var i = 0; i < recipients.length; ++i) {
    ret.push(_recipientToAsn1(recipients[i]));
  }
  return ret;
}
function _signerToAsn1(obj) {
  var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // version
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.INTEGER,
      false,
      asn1.integerToDer(obj.version).getBytes()
    ),
    // issuerAndSerialNumber
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // name
      forge$2.pki.distinguishedNameToAsn1({ attributes: obj.issuer }),
      // serial
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.INTEGER,
        false,
        forge$2.util.hexToBytes(obj.serialNumber)
      )
    ]),
    // digestAlgorithm
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(obj.digestAlgorithm).getBytes()
      ),
      // parameters (null)
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ])
  ]);
  if (obj.authenticatedAttributesAsn1) {
    rval.value.push(obj.authenticatedAttributesAsn1);
  }
  rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // algorithm
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(obj.signatureAlgorithm).getBytes()
    ),
    // parameters (null)
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
  ]));
  rval.value.push(asn1.create(
    asn1.Class.UNIVERSAL,
    asn1.Type.OCTETSTRING,
    false,
    obj.signature
  ));
  if (obj.unauthenticatedAttributes.length > 0) {
    var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
    for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
      var attr = obj.unauthenticatedAttributes[i];
      attrsAsn1.values.push(_attributeToAsn1(attr));
    }
    rval.value.push(attrsAsn1);
  }
  return rval;
}
function _signersToAsn1(signers) {
  var ret = [];
  for (var i = 0; i < signers.length; ++i) {
    ret.push(_signerToAsn1(signers[i]));
  }
  return ret;
}
function _attributeToAsn1(attr) {
  var value2;
  if (attr.type === forge$2.pki.oids.contentType) {
    value2 = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(attr.value).getBytes()
    );
  } else if (attr.type === forge$2.pki.oids.messageDigest) {
    value2 = asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OCTETSTRING,
      false,
      attr.value.bytes()
    );
  } else if (attr.type === forge$2.pki.oids.signingTime) {
    var jan_1_19502 = /* @__PURE__ */ new Date("1950-01-01T00:00:00Z");
    var jan_1_20502 = /* @__PURE__ */ new Date("2050-01-01T00:00:00Z");
    var date = attr.value;
    if (typeof date === "string") {
      var timestamp = Date.parse(date);
      if (!isNaN(timestamp)) {
        date = new Date(timestamp);
      } else if (date.length === 13) {
        date = asn1.utcTimeToDate(date);
      } else {
        date = asn1.generalizedTimeToDate(date);
      }
    }
    if (date >= jan_1_19502 && date < jan_1_20502) {
      value2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.UTCTIME,
        false,
        asn1.dateToUtcTime(date)
      );
    } else {
      value2 = asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.GENERALIZEDTIME,
        false,
        asn1.dateToGeneralizedTime(date)
      );
    }
  }
  return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
    // AttributeType
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(attr.type).getBytes()
    ),
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
      // AttributeValue
      value2
    ])
  ]);
}
function _encryptedContentToAsn1(ec) {
  return [
    // ContentType, always Data for the moment
    asn1.create(
      asn1.Class.UNIVERSAL,
      asn1.Type.OID,
      false,
      asn1.oidToDer(forge$2.pki.oids.data).getBytes()
    ),
    // ContentEncryptionAlgorithmIdentifier
    asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      // Algorithm
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OID,
        false,
        asn1.oidToDer(ec.algorithm).getBytes()
      ),
      // Parameters (IV)
      !ec.parameter ? void 0 : asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        ec.parameter.getBytes()
      )
    ]),
    // [0] EncryptedContent
    asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
      asn1.create(
        asn1.Class.UNIVERSAL,
        asn1.Type.OCTETSTRING,
        false,
        ec.content.getBytes()
      )
    ])
  ];
}
function _fromAsn1(msg, obj, validator2) {
  var capture = {};
  var errors2 = [];
  if (!asn1.validate(obj, validator2, capture, errors2)) {
    var error2 = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
    error2.errors = error2;
    throw error2;
  }
  var contentType3 = asn1.derToOid(capture.contentType);
  if (contentType3 !== forge$2.pki.oids.data) {
    throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
  }
  if (capture.encryptedContent) {
    var content = "";
    if (forge$2.util.isArray(capture.encryptedContent)) {
      for (var i = 0; i < capture.encryptedContent.length; ++i) {
        if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
        }
        content += capture.encryptedContent[i].value;
      }
    } else {
      content = capture.encryptedContent;
    }
    msg.encryptedContent = {
      algorithm: asn1.derToOid(capture.encAlgorithm),
      parameter: forge$2.util.createBuffer(capture.encParameter.value),
      content: forge$2.util.createBuffer(content)
    };
  }
  if (capture.content) {
    var content = "";
    if (forge$2.util.isArray(capture.content)) {
      for (var i = 0; i < capture.content.length; ++i) {
        if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
          throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
        }
        content += capture.content[i].value;
      }
    } else {
      content = capture.content;
    }
    msg.content = forge$2.util.createBuffer(content);
  }
  msg.version = capture.version.charCodeAt(0);
  msg.rawCapture = capture;
  return capture;
}
function _decryptContent(msg) {
  if (msg.encryptedContent.key === void 0) {
    throw new Error("Symmetric key not available.");
  }
  if (msg.content === void 0) {
    var ciph;
    switch (msg.encryptedContent.algorithm) {
      case forge$2.pki.oids["aes128-CBC"]:
      case forge$2.pki.oids["aes192-CBC"]:
      case forge$2.pki.oids["aes256-CBC"]:
        ciph = forge$2.aes.createDecryptionCipher(msg.encryptedContent.key);
        break;
      case forge$2.pki.oids["desCBC"]:
      case forge$2.pki.oids["des-EDE3-CBC"]:
        ciph = forge$2.des.createDecryptionCipher(msg.encryptedContent.key);
        break;
      default:
        throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
    }
    ciph.start(msg.encryptedContent.parameter);
    ciph.update(msg.encryptedContent.content);
    if (!ciph.finish()) {
      throw new Error("Symmetric decryption failed.");
    }
    msg.content = ciph.output;
  }
}
var forge$1 = forge$D;
var ssh = forge$1.ssh = forge$1.ssh || {};
ssh.privateKeyToPutty = function(privateKey, passphrase, comment) {
  comment = comment || "";
  passphrase = passphrase || "";
  var algorithm = "ssh-rsa";
  var encryptionAlgorithm = passphrase === "" ? "none" : "aes256-cbc";
  var ppk = "PuTTY-User-Key-File-2: " + algorithm + "\r\n";
  ppk += "Encryption: " + encryptionAlgorithm + "\r\n";
  ppk += "Comment: " + comment + "\r\n";
  var pubbuffer = forge$1.util.createBuffer();
  _addStringToBuffer(pubbuffer, algorithm);
  _addBigIntegerToBuffer(pubbuffer, privateKey.e);
  _addBigIntegerToBuffer(pubbuffer, privateKey.n);
  var pub = forge$1.util.encode64(pubbuffer.bytes(), 64);
  var length = Math.floor(pub.length / 66) + 1;
  ppk += "Public-Lines: " + length + "\r\n";
  ppk += pub;
  var privbuffer = forge$1.util.createBuffer();
  _addBigIntegerToBuffer(privbuffer, privateKey.d);
  _addBigIntegerToBuffer(privbuffer, privateKey.p);
  _addBigIntegerToBuffer(privbuffer, privateKey.q);
  _addBigIntegerToBuffer(privbuffer, privateKey.qInv);
  var priv;
  if (!passphrase) {
    priv = forge$1.util.encode64(privbuffer.bytes(), 64);
  } else {
    var encLen = privbuffer.length() + 16 - 1;
    encLen -= encLen % 16;
    var padding = _sha1(privbuffer.bytes());
    padding.truncate(padding.length() - encLen + privbuffer.length());
    privbuffer.putBuffer(padding);
    var aeskey = forge$1.util.createBuffer();
    aeskey.putBuffer(_sha1("\0\0\0\0", passphrase));
    aeskey.putBuffer(_sha1("\0\0\0", passphrase));
    var cipher = forge$1.aes.createEncryptionCipher(aeskey.truncate(8), "CBC");
    cipher.start(forge$1.util.createBuffer().fillWithByte(0, 16));
    cipher.update(privbuffer.copy());
    cipher.finish();
    var encrypted = cipher.output;
    encrypted.truncate(16);
    priv = forge$1.util.encode64(encrypted.bytes(), 64);
  }
  length = Math.floor(priv.length / 66) + 1;
  ppk += "\r\nPrivate-Lines: " + length + "\r\n";
  ppk += priv;
  var mackey = _sha1("putty-private-key-file-mac-key", passphrase);
  var macbuffer = forge$1.util.createBuffer();
  _addStringToBuffer(macbuffer, algorithm);
  _addStringToBuffer(macbuffer, encryptionAlgorithm);
  _addStringToBuffer(macbuffer, comment);
  macbuffer.putInt32(pubbuffer.length());
  macbuffer.putBuffer(pubbuffer);
  macbuffer.putInt32(privbuffer.length());
  macbuffer.putBuffer(privbuffer);
  var hmac2 = forge$1.hmac.create();
  hmac2.start("sha1", mackey);
  hmac2.update(macbuffer.bytes());
  ppk += "\r\nPrivate-MAC: " + hmac2.digest().toHex() + "\r\n";
  return ppk;
};
ssh.publicKeyToOpenSSH = function(key, comment) {
  var type3 = "ssh-rsa";
  comment = comment || "";
  var buffer = forge$1.util.createBuffer();
  _addStringToBuffer(buffer, type3);
  _addBigIntegerToBuffer(buffer, key.e);
  _addBigIntegerToBuffer(buffer, key.n);
  return type3 + " " + forge$1.util.encode64(buffer.bytes()) + " " + comment;
};
ssh.privateKeyToOpenSSH = function(privateKey, passphrase) {
  if (!passphrase) {
    return forge$1.pki.privateKeyToPem(privateKey);
  }
  return forge$1.pki.encryptRsaPrivateKey(
    privateKey,
    passphrase,
    { legacy: true, algorithm: "aes128" }
  );
};
ssh.getPublicKeyFingerprint = function(key, options) {
  options = options || {};
  var md = options.md || forge$1.md.md5.create();
  var type3 = "ssh-rsa";
  var buffer = forge$1.util.createBuffer();
  _addStringToBuffer(buffer, type3);
  _addBigIntegerToBuffer(buffer, key.e);
  _addBigIntegerToBuffer(buffer, key.n);
  md.start();
  md.update(buffer.getBytes());
  var digest = md.digest();
  if (options.encoding === "hex") {
    var hex = digest.toHex();
    if (options.delimiter) {
      return hex.match(/.{2}/g).join(options.delimiter);
    }
    return hex;
  } else if (options.encoding === "binary") {
    return digest.getBytes();
  } else if (options.encoding) {
    throw new Error('Unknown encoding "' + options.encoding + '".');
  }
  return digest;
};
function _addBigIntegerToBuffer(buffer, val) {
  var hexVal = val.toString(16);
  if (hexVal[0] >= "8") {
    hexVal = "00" + hexVal;
  }
  var bytes2 = forge$1.util.hexToBytes(hexVal);
  buffer.putInt32(bytes2.length);
  buffer.putBytes(bytes2);
}
function _addStringToBuffer(buffer, val) {
  buffer.putInt32(val.length);
  buffer.putString(val);
}
function _sha1() {
  var sha = forge$1.md.sha1.create();
  var num = arguments.length;
  for (var i = 0; i < num; ++i) {
    sha.update(arguments[i]);
  }
  return sha.digest();
}
var lib$3 = forge$D;
const CryptoJS$1 = cryptoJsExports;
const forge = lib$3;
const iv = "0102030405060708";
const presetKey = "0CoJUm6Qyw8W8jud";
const linuxapiKey = "rFgB&h#%2?^eDg:Q";
const base62 = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
const publicKey = `-----BEGIN PUBLIC KEY-----
MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDgtQn2JZ34ZC28NWYpAUd98iZ37BUrX/aKzmFbt7clFSs6sXqHauqKWqdtLkF2KexO40H1YTX8z2lSgBBOAxLsvaklV8k4cBFK9snQXE9/DDaFt6Rr7iVZMldczhC0JNgTz+SHXT6CBHuX3e9SdB1Ua44oncaTWz7OBGLbCiK45wIDAQAB
-----END PUBLIC KEY-----`;
const eapiKey = "e82ckenh8dichen8";
const aesEncrypt = (text, mode, key, iv2, format2 = "base64") => {
  let encrypted = CryptoJS$1.AES.encrypt(
    CryptoJS$1.enc.Utf8.parse(text),
    CryptoJS$1.enc.Utf8.parse(key),
    {
      iv: CryptoJS$1.enc.Utf8.parse(iv2),
      mode: CryptoJS$1.mode[mode.toUpperCase()],
      padding: CryptoJS$1.pad.Pkcs7
    }
  );
  if (format2 === "base64") {
    return encrypted.toString();
  }
  return encrypted.ciphertext.toString().toUpperCase();
};
const aesDecrypt = (ciphertext, key, iv2, format2 = "base64") => {
  let bytes2;
  if (format2 === "base64") {
    bytes2 = CryptoJS$1.AES.decrypt(ciphertext, CryptoJS$1.enc.Utf8.parse(key), {
      iv: CryptoJS$1.enc.Utf8.parse(iv2),
      mode: CryptoJS$1.mode.ECB,
      padding: CryptoJS$1.pad.Pkcs7
    });
  } else {
    bytes2 = CryptoJS$1.AES.decrypt(
      { ciphertext: CryptoJS$1.enc.Hex.parse(ciphertext) },
      CryptoJS$1.enc.Utf8.parse(key),
      {
        iv: CryptoJS$1.enc.Utf8.parse(iv2),
        mode: CryptoJS$1.mode.ECB,
        padding: CryptoJS$1.pad.Pkcs7
      }
    );
  }
  return bytes2.toString(CryptoJS$1.enc.Utf8);
};
const rsaEncrypt = (str2, key) => {
  const forgePublicKey = forge.pki.publicKeyFromPem(key);
  const encrypted = forgePublicKey.encrypt(str2, "NONE");
  return forge.util.bytesToHex(encrypted);
};
const weapi = (object) => {
  const text = JSON.stringify(object);
  let secretKey = "";
  for (let i = 0; i < 16; i++) {
    secretKey += base62.charAt(Math.round(Math.random() * 61));
  }
  return {
    params: aesEncrypt(
      aesEncrypt(text, "cbc", presetKey, iv),
      "cbc",
      secretKey,
      iv
    ),
    encSecKey: rsaEncrypt(secretKey.split("").reverse().join(""), publicKey)
  };
};
const linuxapi = (object) => {
  const text = JSON.stringify(object);
  return {
    eparams: aesEncrypt(text, "ecb", linuxapiKey, "", "hex")
  };
};
const eapi = (url2, object) => {
  const text = typeof object === "object" ? JSON.stringify(object) : object;
  const message = `nobody${url2}use${text}md5forencrypt`;
  const digest = CryptoJS$1.MD5(message).toString();
  const data2 = `${url2}-36cd479b6b5-${text}-36cd479b6b5-${digest}`;
  return {
    params: aesEncrypt(data2, "ecb", eapiKey, "", "hex")
  };
};
const eapiResDecrypt = (encryptedParams) => {
  const decryptedData = aesDecrypt(encryptedParams, eapiKey, "", "hex");
  return JSON.parse(decryptedData);
};
const eapiReqDecrypt = (encryptedParams) => {
  const decryptedData = aesDecrypt(encryptedParams, eapiKey, "", "hex");
  const match2 = decryptedData.match(/(.*?)-36cd479b6b5-(.*?)-36cd479b6b5-(.*)/);
  if (match2) {
    const url2 = match2[1];
    const data2 = JSON.parse(match2[2]);
    return { url: url2, data: data2 };
  }
  return null;
};
const decrypt = (cipher) => {
  const decipher = CryptoJS$1.AES.decrypt(
    {
      ciphertext: CryptoJS$1.enc.Hex.parse(cipher)
    },
    eapiKey,
    {
      mode: CryptoJS$1.mode.ECB
    }
  );
  const decryptedBytes = CryptoJS$1.enc.Utf8.stringify(decipher);
  return decryptedBytes;
};
var crypto$4 = {
  weapi,
  linuxapi,
  eapi,
  decrypt,
  aesEncrypt,
  aesDecrypt,
  eapiReqDecrypt,
  eapiResDecrypt
};
var Stream$3 = require$$1$4.Stream;
var util$9 = require$$1$3;
var delayed_stream = DelayedStream$1;
function DelayedStream$1() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;
  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$9.inherits(DelayedStream$1, Stream$3);
DelayedStream$1.create = function(source, options) {
  var delayedStream = new this();
  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }
  delayedStream.source = source;
  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };
  source.on("error", function() {
  });
  if (delayedStream.pauseStream) {
    source.pause();
  }
  return delayedStream;
};
Object.defineProperty(DelayedStream$1.prototype, "readable", {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});
DelayedStream$1.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};
DelayedStream$1.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }
  this.source.resume();
};
DelayedStream$1.prototype.pause = function() {
  this.source.pause();
};
DelayedStream$1.prototype.release = function() {
  this._released = true;
  this._bufferedEvents.forEach((function(args) {
    this.emit.apply(this, args);
  }).bind(this));
  this._bufferedEvents = [];
};
DelayedStream$1.prototype.pipe = function() {
  var r = Stream$3.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};
DelayedStream$1.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }
  if (args[0] === "data") {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }
  this._bufferedEvents.push(args);
};
DelayedStream$1.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  this._maxDataSizeExceeded = true;
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this.emit("error", new Error(message));
};
var util$8 = require$$1$3;
var Stream$2 = require$$1$4.Stream;
var DelayedStream = delayed_stream;
var combined_stream = CombinedStream$1;
function CombinedStream$1() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;
  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$8.inherits(CombinedStream$1, Stream$2);
CombinedStream$1.create = function(options) {
  var combinedStream = new this();
  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }
  return combinedStream;
};
CombinedStream$1.isStreamLike = function(stream3) {
  return typeof stream3 !== "function" && typeof stream3 !== "string" && typeof stream3 !== "boolean" && typeof stream3 !== "number" && !Buffer.isBuffer(stream3);
};
CombinedStream$1.prototype.append = function(stream3) {
  var isStreamLike = CombinedStream$1.isStreamLike(stream3);
  if (isStreamLike) {
    if (!(stream3 instanceof DelayedStream)) {
      var newStream = DelayedStream.create(stream3, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams
      });
      stream3.on("data", this._checkDataSize.bind(this));
      stream3 = newStream;
    }
    this._handleErrors(stream3);
    if (this.pauseStreams) {
      stream3.pause();
    }
  }
  this._streams.push(stream3);
  return this;
};
CombinedStream$1.prototype.pipe = function(dest, options) {
  Stream$2.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};
CombinedStream$1.prototype._getNext = function() {
  this._currentStream = null;
  if (this._insideLoop) {
    this._pendingNext = true;
    return;
  }
  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};
CombinedStream$1.prototype._realGetNext = function() {
  var stream3 = this._streams.shift();
  if (typeof stream3 == "undefined") {
    this.end();
    return;
  }
  if (typeof stream3 !== "function") {
    this._pipeNext(stream3);
    return;
  }
  var getStream = stream3;
  getStream((function(stream4) {
    var isStreamLike = CombinedStream$1.isStreamLike(stream4);
    if (isStreamLike) {
      stream4.on("data", this._checkDataSize.bind(this));
      this._handleErrors(stream4);
    }
    this._pipeNext(stream4);
  }).bind(this));
};
CombinedStream$1.prototype._pipeNext = function(stream3) {
  this._currentStream = stream3;
  var isStreamLike = CombinedStream$1.isStreamLike(stream3);
  if (isStreamLike) {
    stream3.on("end", this._getNext.bind(this));
    stream3.pipe(this, { end: false });
    return;
  }
  var value2 = stream3;
  this.write(value2);
  this._getNext();
};
CombinedStream$1.prototype._handleErrors = function(stream3) {
  var self3 = this;
  stream3.on("error", function(err) {
    self3._emitError(err);
  });
};
CombinedStream$1.prototype.write = function(data2) {
  this.emit("data", data2);
};
CombinedStream$1.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.pause == "function") this._currentStream.pause();
  this.emit("pause");
};
CombinedStream$1.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }
  if (this.pauseStreams && this._currentStream && typeof this._currentStream.resume == "function") this._currentStream.resume();
  this.emit("resume");
};
CombinedStream$1.prototype.end = function() {
  this._reset();
  this.emit("end");
};
CombinedStream$1.prototype.destroy = function() {
  this._reset();
  this.emit("close");
};
CombinedStream$1.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};
CombinedStream$1.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }
  var message = "DelayedStream#maxDataSize of " + this.maxDataSize + " bytes exceeded.";
  this._emitError(new Error(message));
};
CombinedStream$1.prototype._updateDataSize = function() {
  this.dataSize = 0;
  var self3 = this;
  this._streams.forEach(function(stream3) {
    if (!stream3.dataSize) {
      return;
    }
    self3.dataSize += stream3.dataSize;
  });
  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};
CombinedStream$1.prototype._emitError = function(err) {
  this._reset();
  this.emit("error", err);
};
var defer_1 = defer$1;
function defer$1(fn) {
  var nextTick2 = typeof setImmediate == "function" ? setImmediate : typeof process == "object" && typeof process.nextTick == "function" ? process.nextTick : null;
  if (nextTick2) {
    nextTick2(fn);
  } else {
    setTimeout(fn, 0);
  }
}
var defer = defer_1;
var async_1 = async$3;
function async$3(callback) {
  var isAsync = false;
  defer(function() {
    isAsync = true;
  });
  return function async_callback(err, result) {
    if (isAsync) {
      callback(err, result);
    } else {
      defer(function nextTick_callback() {
        callback(err, result);
      });
    }
  };
}
var abort_1 = abort$2;
function abort$2(state2) {
  Object.keys(state2.jobs).forEach(clean.bind(state2));
  state2.jobs = {};
}
function clean(key) {
  if (typeof this.jobs[key] == "function") {
    this.jobs[key]();
  }
}
var async$2 = async_1, abort$1 = abort_1;
var iterate_1 = iterate$2;
function iterate$2(list, iterator, state2, callback) {
  var key = state2["keyedList"] ? state2["keyedList"][state2.index] : state2.index;
  state2.jobs[key] = runJob(iterator, key, list[key], function(error2, output) {
    if (!(key in state2.jobs)) {
      return;
    }
    delete state2.jobs[key];
    if (error2) {
      abort$1(state2);
    } else {
      state2.results[key] = output;
    }
    callback(error2, state2.results);
  });
}
function runJob(iterator, key, item, callback) {
  var aborter;
  if (iterator.length == 2) {
    aborter = iterator(item, async$2(callback));
  } else {
    aborter = iterator(item, key, async$2(callback));
  }
  return aborter;
}
var state_1 = state$2;
function state$2(list, sortMethod) {
  var isNamedList = !Array.isArray(list), initState2 = {
    index: 0,
    keyedList: isNamedList || sortMethod ? Object.keys(list) : null,
    jobs: {},
    results: isNamedList ? {} : [],
    size: isNamedList ? Object.keys(list).length : list.length
  };
  if (sortMethod) {
    initState2.keyedList.sort(isNamedList ? sortMethod : function(a, b) {
      return sortMethod(list[a], list[b]);
    });
  }
  return initState2;
}
var abort = abort_1, async$1 = async_1;
var terminator_1 = terminator$2;
function terminator$2(callback) {
  if (!Object.keys(this.jobs).length) {
    return;
  }
  this.index = this.size;
  abort(this);
  async$1(callback)(null, this.results);
}
var iterate$1 = iterate_1, initState$1 = state_1, terminator$1 = terminator_1;
var parallel_1 = parallel;
function parallel(list, iterator, callback) {
  var state2 = initState$1(list);
  while (state2.index < (state2["keyedList"] || list).length) {
    iterate$1(list, iterator, state2, function(error2, result) {
      if (error2) {
        callback(error2, result);
        return;
      }
      if (Object.keys(state2.jobs).length === 0) {
        callback(null, state2.results);
        return;
      }
    });
    state2.index++;
  }
  return terminator$1.bind(state2, callback);
}
var serialOrdered$2 = { exports: {} };
var iterate = iterate_1, initState = state_1, terminator = terminator_1;
serialOrdered$2.exports = serialOrdered$1;
serialOrdered$2.exports.ascending = ascending;
serialOrdered$2.exports.descending = descending;
function serialOrdered$1(list, iterator, sortMethod, callback) {
  var state2 = initState(list, sortMethod);
  iterate(list, iterator, state2, function iteratorHandler(error2, result) {
    if (error2) {
      callback(error2, result);
      return;
    }
    state2.index++;
    if (state2.index < (state2["keyedList"] || list).length) {
      iterate(list, iterator, state2, iteratorHandler);
      return;
    }
    callback(null, state2.results);
  });
  return terminator.bind(state2, callback);
}
function ascending(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
}
function descending(a, b) {
  return -1 * ascending(a, b);
}
var serialOrderedExports = serialOrdered$2.exports;
var serialOrdered = serialOrderedExports;
var serial_1 = serial;
function serial(list, iterator, callback) {
  return serialOrdered(list, iterator, null, callback);
}
var asynckit$1 = {
  parallel: parallel_1,
  serial: serial_1,
  serialOrdered: serialOrderedExports
};
var populate$1 = function(dst, src2) {
  Object.keys(src2).forEach(function(prop) {
    dst[prop] = dst[prop] || src2[prop];
  });
  return dst;
};
var CombinedStream = combined_stream;
var util$7 = require$$1$3;
var path$i = require$$1$2;
var http$7 = require$$0$a;
var https$8 = require$$2$4;
var parseUrl$2 = require$$5$2.parse;
var fs$m = require$$0$7;
var Stream$1 = require$$1$4.Stream;
var mime = mimeTypes;
var asynckit = asynckit$1;
var populate = populate$1;
var form_data = FormData$2;
util$7.inherits(FormData$2, CombinedStream);
function FormData$2(options) {
  if (!(this instanceof FormData$2)) {
    return new FormData$2(options);
  }
  this._overheadLength = 0;
  this._valueLength = 0;
  this._valuesToMeasure = [];
  CombinedStream.call(this);
  options = options || {};
  for (var option in options) {
    this[option] = options[option];
  }
}
FormData$2.LINE_BREAK = "\r\n";
FormData$2.DEFAULT_CONTENT_TYPE = "application/octet-stream";
FormData$2.prototype.append = function(field, value2, options) {
  options = options || {};
  if (typeof options == "string") {
    options = { filename: options };
  }
  var append4 = CombinedStream.prototype.append.bind(this);
  if (typeof value2 == "number") {
    value2 = "" + value2;
  }
  if (util$7.isArray(value2)) {
    this._error(new Error("Arrays are not supported."));
    return;
  }
  var header3 = this._multiPartHeader(field, value2, options);
  var footer = this._multiPartFooter();
  append4(header3);
  append4(value2);
  append4(footer);
  this._trackLength(header3, value2, options);
};
FormData$2.prototype._trackLength = function(header3, value2, options) {
  var valueLength = 0;
  if (options.knownLength != null) {
    valueLength += +options.knownLength;
  } else if (Buffer.isBuffer(value2)) {
    valueLength = value2.length;
  } else if (typeof value2 === "string") {
    valueLength = Buffer.byteLength(value2);
  }
  this._valueLength += valueLength;
  this._overheadLength += Buffer.byteLength(header3) + FormData$2.LINE_BREAK.length;
  if (!value2 || !value2.path && !(value2.readable && value2.hasOwnProperty("httpVersion")) && !(value2 instanceof Stream$1)) {
    return;
  }
  if (!options.knownLength) {
    this._valuesToMeasure.push(value2);
  }
};
FormData$2.prototype._lengthRetriever = function(value2, callback) {
  if (value2.hasOwnProperty("fd")) {
    if (value2.end != void 0 && value2.end != Infinity && value2.start != void 0) {
      callback(null, value2.end + 1 - (value2.start ? value2.start : 0));
    } else {
      fs$m.stat(value2.path, function(err, stat2) {
        var fileSize;
        if (err) {
          callback(err);
          return;
        }
        fileSize = stat2.size - (value2.start ? value2.start : 0);
        callback(null, fileSize);
      });
    }
  } else if (value2.hasOwnProperty("httpVersion")) {
    callback(null, +value2.headers["content-length"]);
  } else if (value2.hasOwnProperty("httpModule")) {
    value2.on("response", function(response2) {
      value2.pause();
      callback(null, +response2.headers["content-length"]);
    });
    value2.resume();
  } else {
    callback("Unknown stream");
  }
};
FormData$2.prototype._multiPartHeader = function(field, value2, options) {
  if (typeof options.header == "string") {
    return options.header;
  }
  var contentDisposition2 = this._getContentDisposition(value2, options);
  var contentType3 = this._getContentType(value2, options);
  var contents = "";
  var headers = {
    // add custom disposition as third element or keep it two elements if not
    "Content-Disposition": ["form-data", 'name="' + field + '"'].concat(contentDisposition2 || []),
    // if no content type. allow it to be empty array
    "Content-Type": [].concat(contentType3 || [])
  };
  if (typeof options.header == "object") {
    populate(headers, options.header);
  }
  var header3;
  for (var prop in headers) {
    if (!headers.hasOwnProperty(prop)) continue;
    header3 = headers[prop];
    if (header3 == null) {
      continue;
    }
    if (!Array.isArray(header3)) {
      header3 = [header3];
    }
    if (header3.length) {
      contents += prop + ": " + header3.join("; ") + FormData$2.LINE_BREAK;
    }
  }
  return "--" + this.getBoundary() + FormData$2.LINE_BREAK + contents + FormData$2.LINE_BREAK;
};
FormData$2.prototype._getContentDisposition = function(value2, options) {
  var filename, contentDisposition2;
  if (typeof options.filepath === "string") {
    filename = path$i.normalize(options.filepath).replace(/\\/g, "/");
  } else if (options.filename || value2.name || value2.path) {
    filename = path$i.basename(options.filename || value2.name || value2.path);
  } else if (value2.readable && value2.hasOwnProperty("httpVersion")) {
    filename = path$i.basename(value2.client._httpMessage.path || "");
  }
  if (filename) {
    contentDisposition2 = 'filename="' + filename + '"';
  }
  return contentDisposition2;
};
FormData$2.prototype._getContentType = function(value2, options) {
  var contentType3 = options.contentType;
  if (!contentType3 && value2.name) {
    contentType3 = mime.lookup(value2.name);
  }
  if (!contentType3 && value2.path) {
    contentType3 = mime.lookup(value2.path);
  }
  if (!contentType3 && value2.readable && value2.hasOwnProperty("httpVersion")) {
    contentType3 = value2.headers["content-type"];
  }
  if (!contentType3 && (options.filepath || options.filename)) {
    contentType3 = mime.lookup(options.filepath || options.filename);
  }
  if (!contentType3 && typeof value2 == "object") {
    contentType3 = FormData$2.DEFAULT_CONTENT_TYPE;
  }
  return contentType3;
};
FormData$2.prototype._multiPartFooter = function() {
  return (function(next) {
    var footer = FormData$2.LINE_BREAK;
    var lastPart = this._streams.length === 0;
    if (lastPart) {
      footer += this._lastBoundary();
    }
    next(footer);
  }).bind(this);
};
FormData$2.prototype._lastBoundary = function() {
  return "--" + this.getBoundary() + "--" + FormData$2.LINE_BREAK;
};
FormData$2.prototype.getHeaders = function(userHeaders) {
  var header3;
  var formHeaders = {
    "content-type": "multipart/form-data; boundary=" + this.getBoundary()
  };
  for (header3 in userHeaders) {
    if (userHeaders.hasOwnProperty(header3)) {
      formHeaders[header3.toLowerCase()] = userHeaders[header3];
    }
  }
  return formHeaders;
};
FormData$2.prototype.setBoundary = function(boundary) {
  this._boundary = boundary;
};
FormData$2.prototype.getBoundary = function() {
  if (!this._boundary) {
    this._generateBoundary();
  }
  return this._boundary;
};
FormData$2.prototype.getBuffer = function() {
  var dataBuffer = new Buffer.alloc(0);
  var boundary = this.getBoundary();
  for (var i = 0, len = this._streams.length; i < len; i++) {
    if (typeof this._streams[i] !== "function") {
      if (Buffer.isBuffer(this._streams[i])) {
        dataBuffer = Buffer.concat([dataBuffer, this._streams[i]]);
      } else {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(this._streams[i])]);
      }
      if (typeof this._streams[i] !== "string" || this._streams[i].substring(2, boundary.length + 2) !== boundary) {
        dataBuffer = Buffer.concat([dataBuffer, Buffer.from(FormData$2.LINE_BREAK)]);
      }
    }
  }
  return Buffer.concat([dataBuffer, Buffer.from(this._lastBoundary())]);
};
FormData$2.prototype._generateBoundary = function() {
  var boundary = "--------------------------";
  for (var i = 0; i < 24; i++) {
    boundary += Math.floor(Math.random() * 10).toString(16);
  }
  this._boundary = boundary;
};
FormData$2.prototype.getLengthSync = function() {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this.hasKnownLength()) {
    this._error(new Error("Cannot calculate proper length in synchronous way."));
  }
  return knownLength;
};
FormData$2.prototype.hasKnownLength = function() {
  var hasKnownLength = true;
  if (this._valuesToMeasure.length) {
    hasKnownLength = false;
  }
  return hasKnownLength;
};
FormData$2.prototype.getLength = function(cb) {
  var knownLength = this._overheadLength + this._valueLength;
  if (this._streams.length) {
    knownLength += this._lastBoundary().length;
  }
  if (!this._valuesToMeasure.length) {
    process.nextTick(cb.bind(this, null, knownLength));
    return;
  }
  asynckit.parallel(this._valuesToMeasure, this._lengthRetriever, function(err, values) {
    if (err) {
      cb(err);
      return;
    }
    values.forEach(function(length) {
      knownLength += length;
    });
    cb(null, knownLength);
  });
};
FormData$2.prototype.submit = function(params, cb) {
  var request2, options, defaults2 = { method: "post" };
  if (typeof params == "string") {
    params = parseUrl$2(params);
    options = populate({
      port: params.port,
      path: params.pathname,
      host: params.hostname,
      protocol: params.protocol
    }, defaults2);
  } else {
    options = populate(params, defaults2);
    if (!options.port) {
      options.port = options.protocol == "https:" ? 443 : 80;
    }
  }
  options.headers = this.getHeaders(params.headers);
  if (options.protocol == "https:") {
    request2 = https$8.request(options);
  } else {
    request2 = http$7.request(options);
  }
  this.getLength((function(err, length) {
    if (err && err !== "Unknown stream") {
      this._error(err);
      return;
    }
    if (length) {
      request2.setHeader("Content-Length", length);
    }
    this.pipe(request2);
    if (cb) {
      var onResponse;
      var callback = function(error2, responce) {
        request2.removeListener("error", callback);
        request2.removeListener("response", onResponse);
        return cb.call(this, error2, responce);
      };
      onResponse = callback.bind(this, null);
      request2.on("error", callback);
      request2.on("response", onResponse);
    }
  }).bind(this));
  return request2;
};
FormData$2.prototype._error = function(err) {
  if (!this.error) {
    this.error = err;
    this.pause();
    this.emit("error", err);
  }
};
FormData$2.prototype.toString = function() {
  return "[object FormData]";
};
var proxyFromEnv$1 = {};
var parseUrl$1 = require$$5$2.parse;
var DEFAULT_PORTS = {
  ftp: 21,
  gopher: 70,
  http: 80,
  https: 443,
  ws: 80,
  wss: 443
};
var stringEndsWith = String.prototype.endsWith || function(s2) {
  return s2.length <= this.length && this.indexOf(s2, this.length - s2.length) !== -1;
};
function getProxyForUrl(url2) {
  var parsedUrl = typeof url2 === "string" ? parseUrl$1(url2) : url2 || {};
  var proto2 = parsedUrl.protocol;
  var hostname2 = parsedUrl.host;
  var port = parsedUrl.port;
  if (typeof hostname2 !== "string" || !hostname2 || typeof proto2 !== "string") {
    return "";
  }
  proto2 = proto2.split(":", 1)[0];
  hostname2 = hostname2.replace(/:\d*$/, "");
  port = parseInt(port) || DEFAULT_PORTS[proto2] || 0;
  if (!shouldProxy(hostname2, port)) {
    return "";
  }
  var proxy = getEnv("npm_config_" + proto2 + "_proxy") || getEnv(proto2 + "_proxy") || getEnv("npm_config_proxy") || getEnv("all_proxy");
  if (proxy && proxy.indexOf("://") === -1) {
    proxy = proto2 + "://" + proxy;
  }
  return proxy;
}
function shouldProxy(hostname2, port) {
  var NO_PROXY = (getEnv("npm_config_no_proxy") || getEnv("no_proxy")).toLowerCase();
  if (!NO_PROXY) {
    return true;
  }
  if (NO_PROXY === "*") {
    return false;
  }
  return NO_PROXY.split(/[,\s]/).every(function(proxy) {
    if (!proxy) {
      return true;
    }
    var parsedProxy = proxy.match(/^(.+):(\d+)$/);
    var parsedProxyHostname = parsedProxy ? parsedProxy[1] : proxy;
    var parsedProxyPort = parsedProxy ? parseInt(parsedProxy[2]) : 0;
    if (parsedProxyPort && parsedProxyPort !== port) {
      return true;
    }
    if (!/^[.*]/.test(parsedProxyHostname)) {
      return hostname2 !== parsedProxyHostname;
    }
    if (parsedProxyHostname.charAt(0) === "*") {
      parsedProxyHostname = parsedProxyHostname.slice(1);
    }
    return !stringEndsWith.call(hostname2, parsedProxyHostname);
  });
}
function getEnv(key) {
  return process.env[key.toLowerCase()] || process.env[key.toUpperCase()] || "";
}
proxyFromEnv$1.getProxyForUrl = getProxyForUrl;
var followRedirects$1 = { exports: {} };
var src$1 = { exports: {} };
var browser = { exports: {} };
var ms;
var hasRequiredMs;
function requireMs() {
  if (hasRequiredMs) return ms;
  hasRequiredMs = 1;
  var s2 = 1e3;
  var m2 = s2 * 60;
  var h2 = m2 * 60;
  var d2 = h2 * 24;
  var w2 = d2 * 7;
  var y2 = d2 * 365.25;
  ms = function(val, options) {
    options = options || {};
    var type3 = typeof val;
    if (type3 === "string" && val.length > 0) {
      return parse2(val);
    } else if (type3 === "number" && isFinite(val)) {
      return options.long ? fmtLong2(val) : fmtShort2(val);
    }
    throw new Error(
      "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
    );
  };
  function parse2(str2) {
    str2 = String(str2);
    if (str2.length > 100) {
      return;
    }
    var match2 = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str2
    );
    if (!match2) {
      return;
    }
    var n = parseFloat(match2[1]);
    var type3 = (match2[2] || "ms").toLowerCase();
    switch (type3) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y2;
      case "weeks":
      case "week":
      case "w":
        return n * w2;
      case "days":
      case "day":
      case "d":
        return n * d2;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h2;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m2;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s2;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return Math.round(ms2 / d2) + "d";
    }
    if (msAbs >= h2) {
      return Math.round(ms2 / h2) + "h";
    }
    if (msAbs >= m2) {
      return Math.round(ms2 / m2) + "m";
    }
    if (msAbs >= s2) {
      return Math.round(ms2 / s2) + "s";
    }
    return ms2 + "ms";
  }
  function fmtLong2(ms2) {
    var msAbs = Math.abs(ms2);
    if (msAbs >= d2) {
      return plural2(ms2, msAbs, d2, "day");
    }
    if (msAbs >= h2) {
      return plural2(ms2, msAbs, h2, "hour");
    }
    if (msAbs >= m2) {
      return plural2(ms2, msAbs, m2, "minute");
    }
    if (msAbs >= s2) {
      return plural2(ms2, msAbs, s2, "second");
    }
    return ms2 + " ms";
  }
  function plural2(ms2, msAbs, n, name2) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms2 / n) + " " + name2 + (isPlural ? "s" : "");
  }
  return ms;
}
var common$4;
var hasRequiredCommon;
function requireCommon() {
  if (hasRequiredCommon) return common$4;
  hasRequiredCommon = 1;
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce2;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = requireMs();
    createDebug.destroy = destroy2;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash2 = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash2 = (hash2 << 5) - hash2 + namespace.charCodeAt(i);
        hash2 |= 0;
      }
      return createDebug.colors[Math.abs(hash2) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug2(...args) {
        if (!debug2.enabled) {
          return;
        }
        const self3 = debug2;
        const curr = Number(/* @__PURE__ */ new Date());
        const ms2 = curr - (prevTime || curr);
        self3.diff = ms2;
        self3.prev = prevTime;
        self3.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index2 = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match2, format2) => {
          if (match2 === "%%") {
            return "%";
          }
          index2++;
          const formatter = createDebug.formatters[format2];
          if (typeof formatter === "function") {
            const val = args[index2];
            match2 = formatter.call(self3, val);
            args.splice(index2, 1);
            index2--;
          }
          return match2;
        });
        createDebug.formatArgs.call(self3, args);
        const logFn = self3.log || createDebug.log;
        logFn.apply(self3, args);
      }
      debug2.namespace = namespace;
      debug2.useColors = createDebug.useColors();
      debug2.color = createDebug.selectColor(namespace);
      debug2.extend = extend2;
      debug2.destroy = createDebug.destroy;
      Object.defineProperty(debug2, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug2);
      }
      return debug2;
    }
    function extend2(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name2) {
      if (name2[name2.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name2)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name2)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce2(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy2() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  common$4 = setup;
  return common$4;
}
var hasRequiredBrowser;
function requireBrowser() {
  if (hasRequiredBrowser) return browser.exports;
  hasRequiredBrowser = 1;
  (function(module2, exports) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m2;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m2 = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m2[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index2 = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match2) => {
        if (match2 === "%%") {
          return;
        }
        index2++;
        if (match2 === "%c") {
          lastC = index2;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error2) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error2) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error2) {
      }
    }
    module2.exports = requireCommon()(exports);
    const { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error2) {
        return "[UnexpectedJSONParseError]: " + error2.message;
      }
    };
  })(browser, browser.exports);
  return browser.exports;
}
var node$1 = { exports: {} };
var hasFlag;
var hasRequiredHasFlag;
function requireHasFlag() {
  if (hasRequiredHasFlag) return hasFlag;
  hasRequiredHasFlag = 1;
  hasFlag = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
  return hasFlag;
}
var supportsColor_1;
var hasRequiredSupportsColor;
function requireSupportsColor() {
  if (hasRequiredSupportsColor) return supportsColor_1;
  hasRequiredSupportsColor = 1;
  const os = require$$0$b;
  const tty = require$$0$5;
  const hasFlag2 = requireHasFlag();
  const { env } = process;
  let forceColor;
  if (hasFlag2("no-color") || hasFlag2("no-colors") || hasFlag2("color=false") || hasFlag2("color=never")) {
    forceColor = 0;
  } else if (hasFlag2("color") || hasFlag2("colors") || hasFlag2("color=true") || hasFlag2("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  function translateLevel(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }
  function supportsColor2(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag2("color=16m") || hasFlag2("color=full") || hasFlag2("color=truecolor")) {
      return 3;
    }
    if (hasFlag2("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === void 0) {
      return 0;
    }
    const min2 = forceColor || 0;
    if (env.TERM === "dumb") {
      return min2;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign2) => sign2 in env) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min2;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version2 = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version2 >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min2;
  }
  function getSupportLevel(stream3) {
    const level = supportsColor2(stream3, stream3 && stream3.isTTY);
    return translateLevel(level);
  }
  supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor2(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor2(true, tty.isatty(2)))
  };
  return supportsColor_1;
}
var hasRequiredNode;
function requireNode() {
  if (hasRequiredNode) return node$1.exports;
  hasRequiredNode = 1;
  (function(module2, exports) {
    const tty = require$$0$5;
    const util2 = require$$1$3;
    exports.init = init2;
    exports.log = log2;
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.destroy = util2.deprecate(
      () => {
      },
      "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
    );
    exports.colors = [6, 2, 3, 4, 5, 1];
    try {
      const supportsColor2 = requireSupportsColor();
      if (supportsColor2 && (supportsColor2.stderr || supportsColor2).level >= 2) {
        exports.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error2) {
    }
    exports.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    function formatArgs(args) {
      const { namespace: name2, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name2} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name2 + " " + args[0];
      }
    }
    function getDate() {
      if (exports.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    function log2(...args) {
      return process.stderr.write(util2.formatWithOptions(exports.inspectOpts, ...args) + "\n");
    }
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    function load() {
      return process.env.DEBUG;
    }
    function init2(debug2) {
      debug2.inspectOpts = {};
      const keys2 = Object.keys(exports.inspectOpts);
      for (let i = 0; i < keys2.length; i++) {
        debug2.inspectOpts[keys2[i]] = exports.inspectOpts[keys2[i]];
      }
    }
    module2.exports = requireCommon()(exports);
    const { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str2) => str2.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  })(node$1, node$1.exports);
  return node$1.exports;
}
if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
  src$1.exports = requireBrowser();
} else {
  src$1.exports = requireNode();
}
var srcExports = src$1.exports;
var debug$c;
var debug_1$9 = function() {
  if (!debug$c) {
    try {
      debug$c = srcExports("follow-redirects");
    } catch (error2) {
    }
    if (typeof debug$c !== "function") {
      debug$c = function() {
      };
    }
  }
  debug$c.apply(null, arguments);
};
var url$2 = require$$5$2;
var URL$2 = url$2.URL;
var http$6 = require$$0$a;
var https$7 = require$$2$4;
var Writable$2 = require$$1$4.Writable;
var assert$1 = require$$5$3;
var debug$b = debug_1$9;
var useNativeURL = false;
try {
  assert$1(new URL$2());
} catch (error2) {
  useNativeURL = error2.code === "ERR_INVALID_URL";
}
var preservedUrlFields = [
  "auth",
  "host",
  "hostname",
  "href",
  "path",
  "pathname",
  "port",
  "protocol",
  "query",
  "search",
  "hash"
];
var events$2 = ["abort", "aborted", "connect", "error", "socket", "timeout"];
var eventHandlers = /* @__PURE__ */ Object.create(null);
events$2.forEach(function(event) {
  eventHandlers[event] = function(arg1, arg2, arg3) {
    this._redirectable.emit(event, arg1, arg2, arg3);
  };
});
var InvalidUrlError = createErrorType(
  "ERR_INVALID_URL",
  "Invalid URL",
  TypeError
);
var RedirectionError = createErrorType(
  "ERR_FR_REDIRECTION_FAILURE",
  "Redirected request failed"
);
var TooManyRedirectsError = createErrorType(
  "ERR_FR_TOO_MANY_REDIRECTS",
  "Maximum number of redirects exceeded",
  RedirectionError
);
var MaxBodyLengthExceededError = createErrorType(
  "ERR_FR_MAX_BODY_LENGTH_EXCEEDED",
  "Request body larger than maxBodyLength limit"
);
var WriteAfterEndError = createErrorType(
  "ERR_STREAM_WRITE_AFTER_END",
  "write after end"
);
var destroy = Writable$2.prototype.destroy || noop$5;
function RedirectableRequest(options, responseCallback) {
  Writable$2.call(this);
  this._sanitizeOptions(options);
  this._options = options;
  this._ended = false;
  this._ending = false;
  this._redirectCount = 0;
  this._redirects = [];
  this._requestBodyLength = 0;
  this._requestBodyBuffers = [];
  if (responseCallback) {
    this.on("response", responseCallback);
  }
  var self3 = this;
  this._onNativeResponse = function(response2) {
    try {
      self3._processResponse(response2);
    } catch (cause) {
      self3.emit("error", cause instanceof RedirectionError ? cause : new RedirectionError({ cause }));
    }
  };
  this._performRequest();
}
RedirectableRequest.prototype = Object.create(Writable$2.prototype);
RedirectableRequest.prototype.abort = function() {
  destroyRequest(this._currentRequest);
  this._currentRequest.abort();
  this.emit("abort");
};
RedirectableRequest.prototype.destroy = function(error2) {
  destroyRequest(this._currentRequest, error2);
  destroy.call(this, error2);
  return this;
};
RedirectableRequest.prototype.write = function(data2, encoding3, callback) {
  if (this._ending) {
    throw new WriteAfterEndError();
  }
  if (!isString$2(data2) && !isBuffer$1(data2)) {
    throw new TypeError("data should be a string, Buffer or Uint8Array");
  }
  if (isFunction$3(encoding3)) {
    callback = encoding3;
    encoding3 = null;
  }
  if (data2.length === 0) {
    if (callback) {
      callback();
    }
    return;
  }
  if (this._requestBodyLength + data2.length <= this._options.maxBodyLength) {
    this._requestBodyLength += data2.length;
    this._requestBodyBuffers.push({ data: data2, encoding: encoding3 });
    this._currentRequest.write(data2, encoding3, callback);
  } else {
    this.emit("error", new MaxBodyLengthExceededError());
    this.abort();
  }
};
RedirectableRequest.prototype.end = function(data2, encoding3, callback) {
  if (isFunction$3(data2)) {
    callback = data2;
    data2 = encoding3 = null;
  } else if (isFunction$3(encoding3)) {
    callback = encoding3;
    encoding3 = null;
  }
  if (!data2) {
    this._ended = this._ending = true;
    this._currentRequest.end(null, null, callback);
  } else {
    var self3 = this;
    var currentRequest = this._currentRequest;
    this.write(data2, encoding3, function() {
      self3._ended = true;
      currentRequest.end(null, null, callback);
    });
    this._ending = true;
  }
};
RedirectableRequest.prototype.setHeader = function(name2, value2) {
  this._options.headers[name2] = value2;
  this._currentRequest.setHeader(name2, value2);
};
RedirectableRequest.prototype.removeHeader = function(name2) {
  delete this._options.headers[name2];
  this._currentRequest.removeHeader(name2);
};
RedirectableRequest.prototype.setTimeout = function(msecs, callback) {
  var self3 = this;
  function destroyOnTimeout(socket) {
    socket.setTimeout(msecs);
    socket.removeListener("timeout", socket.destroy);
    socket.addListener("timeout", socket.destroy);
  }
  function startTimer(socket) {
    if (self3._timeout) {
      clearTimeout(self3._timeout);
    }
    self3._timeout = setTimeout(function() {
      self3.emit("timeout");
      clearTimer();
    }, msecs);
    destroyOnTimeout(socket);
  }
  function clearTimer() {
    if (self3._timeout) {
      clearTimeout(self3._timeout);
      self3._timeout = null;
    }
    self3.removeListener("abort", clearTimer);
    self3.removeListener("error", clearTimer);
    self3.removeListener("response", clearTimer);
    self3.removeListener("close", clearTimer);
    if (callback) {
      self3.removeListener("timeout", callback);
    }
    if (!self3.socket) {
      self3._currentRequest.removeListener("socket", startTimer);
    }
  }
  if (callback) {
    this.on("timeout", callback);
  }
  if (this.socket) {
    startTimer(this.socket);
  } else {
    this._currentRequest.once("socket", startTimer);
  }
  this.on("socket", destroyOnTimeout);
  this.on("abort", clearTimer);
  this.on("error", clearTimer);
  this.on("response", clearTimer);
  this.on("close", clearTimer);
  return this;
};
[
  "flushHeaders",
  "getHeader",
  "setNoDelay",
  "setSocketKeepAlive"
].forEach(function(method) {
  RedirectableRequest.prototype[method] = function(a, b) {
    return this._currentRequest[method](a, b);
  };
});
["aborted", "connection", "socket"].forEach(function(property) {
  Object.defineProperty(RedirectableRequest.prototype, property, {
    get: function() {
      return this._currentRequest[property];
    }
  });
});
RedirectableRequest.prototype._sanitizeOptions = function(options) {
  if (!options.headers) {
    options.headers = {};
  }
  if (options.host) {
    if (!options.hostname) {
      options.hostname = options.host;
    }
    delete options.host;
  }
  if (!options.pathname && options.path) {
    var searchPos = options.path.indexOf("?");
    if (searchPos < 0) {
      options.pathname = options.path;
    } else {
      options.pathname = options.path.substring(0, searchPos);
      options.search = options.path.substring(searchPos);
    }
  }
};
RedirectableRequest.prototype._performRequest = function() {
  var protocol2 = this._options.protocol;
  var nativeProtocol = this._options.nativeProtocols[protocol2];
  if (!nativeProtocol) {
    throw new TypeError("Unsupported protocol " + protocol2);
  }
  if (this._options.agents) {
    var scheme = protocol2.slice(0, -1);
    this._options.agent = this._options.agents[scheme];
  }
  var request2 = this._currentRequest = nativeProtocol.request(this._options, this._onNativeResponse);
  request2._redirectable = this;
  for (var event of events$2) {
    request2.on(event, eventHandlers[event]);
  }
  this._currentUrl = /^\//.test(this._options.path) ? url$2.format(this._options) : (
    // When making a request to a proxy, [â€¦]
    // a client MUST send the target URI in absolute-form [â€¦].
    this._options.path
  );
  if (this._isRedirect) {
    var i = 0;
    var self3 = this;
    var buffers = this._requestBodyBuffers;
    (function writeNext(error2) {
      if (request2 === self3._currentRequest) {
        if (error2) {
          self3.emit("error", error2);
        } else if (i < buffers.length) {
          var buffer = buffers[i++];
          if (!request2.finished) {
            request2.write(buffer.data, buffer.encoding, writeNext);
          }
        } else if (self3._ended) {
          request2.end();
        }
      }
    })();
  }
};
RedirectableRequest.prototype._processResponse = function(response2) {
  var statusCode = response2.statusCode;
  if (this._options.trackRedirects) {
    this._redirects.push({
      url: this._currentUrl,
      headers: response2.headers,
      statusCode
    });
  }
  var location2 = response2.headers.location;
  if (!location2 || this._options.followRedirects === false || statusCode < 300 || statusCode >= 400) {
    response2.responseUrl = this._currentUrl;
    response2.redirects = this._redirects;
    this.emit("response", response2);
    this._requestBodyBuffers = [];
    return;
  }
  destroyRequest(this._currentRequest);
  response2.destroy();
  if (++this._redirectCount > this._options.maxRedirects) {
    throw new TooManyRedirectsError();
  }
  var requestHeaders;
  var beforeRedirect = this._options.beforeRedirect;
  if (beforeRedirect) {
    requestHeaders = Object.assign({
      // The Host header was set by nativeProtocol.request
      Host: response2.req.getHeader("host")
    }, this._options.headers);
  }
  var method = this._options.method;
  if ((statusCode === 301 || statusCode === 302) && this._options.method === "POST" || // RFC7231Â§6.4.4: The 303 (See Other) status code indicates that
  // the server is redirecting the user agent to a different resource [â€¦]
  // A user agent can perform a retrieval request targeting that URI
  // (a GET or HEAD request if using HTTP) [â€¦]
  statusCode === 303 && !/^(?:GET|HEAD)$/.test(this._options.method)) {
    this._options.method = "GET";
    this._requestBodyBuffers = [];
    removeMatchingHeaders(/^content-/i, this._options.headers);
  }
  var currentHostHeader = removeMatchingHeaders(/^host$/i, this._options.headers);
  var currentUrlParts = parseUrl(this._currentUrl);
  var currentHost = currentHostHeader || currentUrlParts.host;
  var currentUrl = /^\w+:/.test(location2) ? this._currentUrl : url$2.format(Object.assign(currentUrlParts, { host: currentHost }));
  var redirectUrl = resolveUrl(location2, currentUrl);
  debug$b("redirecting to", redirectUrl.href);
  this._isRedirect = true;
  spreadUrlObject(redirectUrl, this._options);
  if (redirectUrl.protocol !== currentUrlParts.protocol && redirectUrl.protocol !== "https:" || redirectUrl.host !== currentHost && !isSubdomain(redirectUrl.host, currentHost)) {
    removeMatchingHeaders(/^(?:(?:proxy-)?authorization|cookie)$/i, this._options.headers);
  }
  if (isFunction$3(beforeRedirect)) {
    var responseDetails = {
      headers: response2.headers,
      statusCode
    };
    var requestDetails = {
      url: currentUrl,
      method,
      headers: requestHeaders
    };
    beforeRedirect(this._options, responseDetails, requestDetails);
    this._sanitizeOptions(this._options);
  }
  this._performRequest();
};
function wrap(protocols) {
  var exports = {
    maxRedirects: 21,
    maxBodyLength: 10 * 1024 * 1024
  };
  var nativeProtocols = {};
  Object.keys(protocols).forEach(function(scheme) {
    var protocol2 = scheme + ":";
    var nativeProtocol = nativeProtocols[protocol2] = protocols[scheme];
    var wrappedProtocol = exports[scheme] = Object.create(nativeProtocol);
    function request2(input, options, callback) {
      if (isURL(input)) {
        input = spreadUrlObject(input);
      } else if (isString$2(input)) {
        input = spreadUrlObject(parseUrl(input));
      } else {
        callback = options;
        options = validateUrl(input);
        input = { protocol: protocol2 };
      }
      if (isFunction$3(options)) {
        callback = options;
        options = null;
      }
      options = Object.assign({
        maxRedirects: exports.maxRedirects,
        maxBodyLength: exports.maxBodyLength
      }, input, options);
      options.nativeProtocols = nativeProtocols;
      if (!isString$2(options.host) && !isString$2(options.hostname)) {
        options.hostname = "::1";
      }
      assert$1.equal(options.protocol, protocol2, "protocol mismatch");
      debug$b("options", options);
      return new RedirectableRequest(options, callback);
    }
    function get2(input, options, callback) {
      var wrappedRequest = wrappedProtocol.request(input, options, callback);
      wrappedRequest.end();
      return wrappedRequest;
    }
    Object.defineProperties(wrappedProtocol, {
      request: { value: request2, configurable: true, enumerable: true, writable: true },
      get: { value: get2, configurable: true, enumerable: true, writable: true }
    });
  });
  return exports;
}
function noop$5() {
}
function parseUrl(input) {
  var parsed;
  if (useNativeURL) {
    parsed = new URL$2(input);
  } else {
    parsed = validateUrl(url$2.parse(input));
    if (!isString$2(parsed.protocol)) {
      throw new InvalidUrlError({ input });
    }
  }
  return parsed;
}
function resolveUrl(relative2, base) {
  return useNativeURL ? new URL$2(relative2, base) : parseUrl(url$2.resolve(base, relative2));
}
function validateUrl(input) {
  if (/^\[/.test(input.hostname) && !/^\[[:0-9a-f]+\]$/i.test(input.hostname)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  if (/^\[/.test(input.host) && !/^\[[:0-9a-f]+\](:\d+)?$/i.test(input.host)) {
    throw new InvalidUrlError({ input: input.href || input });
  }
  return input;
}
function spreadUrlObject(urlObject, target) {
  var spread2 = target || {};
  for (var key of preservedUrlFields) {
    spread2[key] = urlObject[key];
  }
  if (spread2.hostname.startsWith("[")) {
    spread2.hostname = spread2.hostname.slice(1, -1);
  }
  if (spread2.port !== "") {
    spread2.port = Number(spread2.port);
  }
  spread2.path = spread2.search ? spread2.pathname + spread2.search : spread2.pathname;
  return spread2;
}
function removeMatchingHeaders(regex, headers) {
  var lastValue;
  for (var header3 in headers) {
    if (regex.test(header3)) {
      lastValue = headers[header3];
      delete headers[header3];
    }
  }
  return lastValue === null || typeof lastValue === "undefined" ? void 0 : String(lastValue).trim();
}
function createErrorType(code2, message, baseClass) {
  function CustomError(properties) {
    Error.captureStackTrace(this, this.constructor);
    Object.assign(this, properties || {});
    this.code = code2;
    this.message = this.cause ? message + ": " + this.cause.message : message;
  }
  CustomError.prototype = new (baseClass || Error)();
  Object.defineProperties(CustomError.prototype, {
    constructor: {
      value: CustomError,
      enumerable: false
    },
    name: {
      value: "Error [" + code2 + "]",
      enumerable: false
    }
  });
  return CustomError;
}
function destroyRequest(request2, error2) {
  for (var event of events$2) {
    request2.removeListener(event, eventHandlers[event]);
  }
  request2.on("error", noop$5);
  request2.destroy(error2);
}
function isSubdomain(subdomain, domain) {
  assert$1(isString$2(subdomain) && isString$2(domain));
  var dot = subdomain.length - domain.length - 1;
  return dot > 0 && subdomain[dot] === "." && subdomain.endsWith(domain);
}
function isString$2(value2) {
  return typeof value2 === "string" || value2 instanceof String;
}
function isFunction$3(value2) {
  return typeof value2 === "function";
}
function isBuffer$1(value2) {
  return typeof value2 === "object" && "length" in value2;
}
function isURL(value2) {
  return URL$2 && value2 instanceof URL$2;
}
followRedirects$1.exports = wrap({ http: http$6, https: https$7 });
followRedirects$1.exports.wrap = wrap;
var followRedirectsExports = followRedirects$1.exports;
const FormData$1 = form_data;
const url$1 = require$$5$2;
const proxyFromEnv = proxyFromEnv$1;
const http$5 = require$$0$a;
const https$6 = require$$2$4;
const util$6 = require$$1$3;
const followRedirects = followRedirectsExports;
const zlib = require$$3$3;
const stream$1 = require$$1$4;
const events$1 = require$$0$8;
function _interopDefaultLegacy(e) {
  return e && typeof e === "object" && "default" in e ? e : { "default": e };
}
const FormData__default = /* @__PURE__ */ _interopDefaultLegacy(FormData$1);
const url__default = /* @__PURE__ */ _interopDefaultLegacy(url$1);
const http__default = /* @__PURE__ */ _interopDefaultLegacy(http$5);
const https__default = /* @__PURE__ */ _interopDefaultLegacy(https$6);
const util__default = /* @__PURE__ */ _interopDefaultLegacy(util$6);
const followRedirects__default = /* @__PURE__ */ _interopDefaultLegacy(followRedirects);
const zlib__default = /* @__PURE__ */ _interopDefaultLegacy(zlib);
const stream__default = /* @__PURE__ */ _interopDefaultLegacy(stream$1);
function bind$1(fn, thisArg) {
  return function wrap2() {
    return fn.apply(thisArg, arguments);
  };
}
const { toString } = Object.prototype;
const { getPrototypeOf: getPrototypeOf$3 } = Object;
const kindOf = /* @__PURE__ */ ((cache2) => (thing) => {
  const str2 = toString.call(thing);
  return cache2[str2] || (cache2[str2] = str2.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
const kindOfTest = (type3) => {
  type3 = type3.toLowerCase();
  return (thing) => kindOf(thing) === type3;
};
const typeOfTest = (type3) => (thing) => typeof thing === type3;
const { isArray: isArray$1 } = Array;
const isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction$2(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
const isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
const isString$1 = typeOfTest("string");
const isFunction$2 = typeOfTest("function");
const isNumber = typeOfTest("number");
const isObject$3 = (thing) => thing !== null && typeof thing === "object";
const isBoolean = (thing) => thing === true || thing === false;
const isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype2 = getPrototypeOf$3(val);
  return (prototype2 === null || prototype2 === Object.prototype || Object.getPrototypeOf(prototype2) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
const isDate = kindOfTest("Date");
const isFile = kindOfTest("File");
const isBlob = kindOfTest("Blob");
const isFileList = kindOfTest("FileList");
const isStream = (val) => isObject$3(val) && isFunction$2(val.pipe);
const isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction$2(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction$2(thing.toString) && thing.toString() === "[object FormData]"));
};
const isURLSearchParams = kindOfTest("URLSearchParams");
const [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
const trim = (str2) => str2.trim ? str2.trim() : str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach$7(obj, fn, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i;
  let l;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray$1(obj)) {
    for (i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    const keys2 = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys2.length;
    let key;
    for (i = 0; i < len; i++) {
      key = keys2[i];
      fn.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys2 = Object.keys(obj);
  let i = keys2.length;
  let _key;
  while (i-- > 0) {
    _key = keys2[i];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
const _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : commonjsGlobal;
})();
const isContextDefined = (context2) => !isUndefined(context2) && context2 !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray$1(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i = 0, l = arguments.length; i < l; i++) {
    arguments[i] && forEach$7(arguments[i], assignValue);
  }
  return result;
}
const extend = (a, b, thisArg, { allOwnKeys } = {}) => {
  forEach$7(b, (val, key) => {
    if (thisArg && isFunction$2(val)) {
      a[key] = bind$1(val, thisArg);
    } else {
      a[key] = val;
    }
  }, { allOwnKeys });
  return a;
};
const stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
const inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
const toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i = props.length;
    while (i-- > 0) {
      prop = props[i];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf$3(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
const endsWith = (str2, searchString, position) => {
  str2 = String(str2);
  if (position === void 0 || position > str2.length) {
    position = str2.length;
  }
  position -= searchString.length;
  const lastIndex = str2.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
const toArray$2 = (thing) => {
  if (!thing) return null;
  if (isArray$1(thing)) return thing;
  let i = thing.length;
  if (!isNumber(i)) return null;
  const arr = new Array(i);
  while (i-- > 0) {
    arr[i] = thing[i];
  }
  return arr;
};
const isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf$3(Uint8Array));
const forEachEntry = (obj, fn) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn.call(obj, pair[0], pair[1]);
  }
};
const matchAll = (regExp, str2) => {
  let matches2;
  const arr = [];
  while ((matches2 = regExp.exec(str2)) !== null) {
    arr.push(matches2);
  }
  return arr;
};
const isHTMLForm = kindOfTest("HTMLFormElement");
const toCamelCase = (str2) => {
  return str2.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m2, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
const hasOwnProperty$2 = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
const isRegExp = kindOfTest("RegExp");
const reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach$7(descriptors2, (descriptor, name2) => {
    let ret;
    if ((ret = reducer(descriptor, name2, obj)) !== false) {
      reducedDescriptors[name2] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
const freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name2) => {
    if (isFunction$2(obj) && ["arguments", "caller", "callee"].indexOf(name2) !== -1) {
      return false;
    }
    const value2 = obj[name2];
    if (!isFunction$2(value2)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name2 + "'");
      };
    }
  });
};
const toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define2 = (arr) => {
    arr.forEach((value2) => {
      obj[value2] = true;
    });
  };
  isArray$1(arrayOrString) ? define2(arrayOrString) : define2(String(arrayOrString).split(delimiter));
  return obj;
};
const noop$4 = () => {
};
const toFiniteNumber = (value2, defaultValue) => {
  return value2 != null && Number.isFinite(value2 = +value2) ? value2 : defaultValue;
};
const ALPHA = "abcdefghijklmnopqrstuvwxyz";
const DIGIT = "0123456789";
const ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
const generateString = (size = 16, alphabet = ALPHABET.ALPHA_DIGIT) => {
  let str2 = "";
  const { length } = alphabet;
  while (size--) {
    str2 += alphabet[Math.random() * length | 0];
  }
  return str2;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction$2(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
const toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i) => {
    if (isObject$3(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i] = source;
        const target = isArray$1(source) ? [] : {};
        forEach$7(source, (value2, key) => {
          const reducedValue = visit(value2, i + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
const isAsyncFn = kindOfTest("AsyncFunction");
const isThenable = (thing) => thing && (isObject$3(thing) || isFunction$2(thing)) && isFunction$2(thing.then) && isFunction$2(thing.catch);
const _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data: data2 }) => {
      if (source === _global && data2 === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction$2(_global.postMessage)
);
const asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
const utils$1$1 = {
  isArray: isArray$1,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString$1,
  isNumber,
  isBoolean,
  isObject: isObject$3,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction: isFunction$2,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach: forEach$7,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray: toArray$2,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty: hasOwnProperty$2,
  hasOwnProp: hasOwnProperty$2,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop$4,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};
function AxiosError(message, code2, config, request2, response2) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code2 && (this.code = code2);
  config && (this.config = config);
  request2 && (this.request = request2);
  if (response2) {
    this.response = response2;
    this.status = response2.status ? response2.status : null;
  }
}
utils$1$1.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils$1$1.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
const prototype$1 = AxiosError.prototype;
const descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code2) => {
  descriptors[code2] = { value: code2 };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype$1, "isAxiosError", { value: true });
AxiosError.from = (error2, code2, config, request2, response2, customProps) => {
  const axiosError = Object.create(prototype$1);
  utils$1$1.toFlatObject(error2, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error2.message, code2, config, request2, response2);
  axiosError.cause = error2;
  axiosError.name = error2.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
function isVisitable(thing) {
  return utils$1$1.isPlainObject(thing) || utils$1$1.isArray(thing);
}
function removeBrackets(key) {
  return utils$1$1.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path3, key, dots) {
  if (!path3) return key;
  return path3.concat(key).map(function each(token, i) {
    token = removeBrackets(token);
    return !dots && i ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils$1$1.isArray(arr) && !arr.some(isVisitable);
}
const predicates = utils$1$1.toFlatObject(utils$1$1, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils$1$1.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (FormData__default["default"] || FormData)();
  options = utils$1$1.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils$1$1.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils$1$1.isSpecCompliantForm(formData);
  if (!utils$1$1.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value2) {
    if (value2 === null) return "";
    if (utils$1$1.isDate(value2)) {
      return value2.toISOString();
    }
    if (!useBlob && utils$1$1.isBlob(value2)) {
      throw new AxiosError("Blob is not supported. Use a Buffer instead.");
    }
    if (utils$1$1.isArrayBuffer(value2) || utils$1$1.isTypedArray(value2)) {
      return useBlob && typeof Blob === "function" ? new Blob([value2]) : Buffer.from(value2);
    }
    return value2;
  }
  function defaultVisitor(value2, key, path3) {
    let arr = value2;
    if (value2 && !path3 && typeof value2 === "object") {
      if (utils$1$1.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value2 = JSON.stringify(value2);
      } else if (utils$1$1.isArray(value2) && isFlatArray(value2) || (utils$1$1.isFileList(value2) || utils$1$1.endsWith(key, "[]")) && (arr = utils$1$1.toArray(value2))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index2) {
          !(utils$1$1.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index2, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value2)) {
      return true;
    }
    formData.append(renderKey(path3, key, dots), convertValue(value2));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build2(value2, path3) {
    if (utils$1$1.isUndefined(value2)) return;
    if (stack.indexOf(value2) !== -1) {
      throw Error("Circular reference detected in " + path3.join("."));
    }
    stack.push(value2);
    utils$1$1.forEach(value2, function each(el, key) {
      const result = !(utils$1$1.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils$1$1.isString(key) ? key.trim() : key,
        path3,
        exposedHelpers
      );
      if (result === true) {
        build2(el, path3 ? path3.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils$1$1.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build2(obj);
  return formData;
}
function encode$1(str2) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str2).replace(/[!'()~]|%20|%00/g, function replacer(match2) {
    return charMap[match2];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData(params, this, options);
}
const prototype = AxiosURLSearchParams.prototype;
prototype.append = function append3(name2, value2) {
  this._pairs.push([name2, value2]);
};
prototype.toString = function toString2(encoder) {
  const _encode = encoder ? function(value2) {
    return encoder.call(this, value2, encode$1);
  } : encode$1;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
function encode(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url2, params, options) {
  if (!params) {
    return url2;
  }
  const _encode = options && options.encode || encode;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils$1$1.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url2.indexOf("#");
    if (hashmarkIndex !== -1) {
      url2 = url2.slice(0, hashmarkIndex);
    }
    url2 += (url2.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url2;
}
class InterceptorManager {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn) {
    utils$1$1.forEach(this.handlers, function forEachHandler(h2) {
      if (h2 !== null) {
        fn(h2);
      }
    });
  }
}
const InterceptorManager$1 = InterceptorManager;
const transitionalDefaults = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};
const URLSearchParams$1 = url__default["default"].URLSearchParams;
const platform$1 = {
  isNode: true,
  classes: {
    URLSearchParams: URLSearchParams$1,
    FormData: FormData__default["default"],
    Blob: typeof Blob !== "undefined" && Blob || null
  },
  protocols: ["http", "https", "file", "data"]
};
const hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
const _navigator = typeof navigator === "object" && navigator || void 0;
const hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
const hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
const origin = hasBrowserEnv && window.location.href || "http://localhost";
const utils$5 = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  hasBrowserEnv,
  hasStandardBrowserWebWorkerEnv,
  hasStandardBrowserEnv,
  navigator: _navigator,
  origin
});
const platform$2 = {
  ...utils$5,
  ...platform$1
};
function toURLEncodedForm(data2, options) {
  return toFormData(data2, new platform$2.classes.URLSearchParams(), Object.assign({
    visitor: function(value2, key, path3, helpers2) {
      if (platform$2.isNode && utils$1$1.isBuffer(value2)) {
        this.append(key, value2.toString("base64"));
        return false;
      }
      return helpers2.defaultVisitor.apply(this, arguments);
    }
  }, options));
}
function parsePropPath(name2) {
  return utils$1$1.matchAll(/\w+|\[(\w*)]/g, name2).map((match2) => {
    return match2[0] === "[]" ? "" : match2[1] || match2[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys2 = Object.keys(arr);
  let i;
  const len = keys2.length;
  let key;
  for (i = 0; i < len; i++) {
    key = keys2[i];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path3, value2, target, index2) {
    let name2 = path3[index2++];
    if (name2 === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name2);
    const isLast = index2 >= path3.length;
    name2 = !name2 && utils$1$1.isArray(target) ? target.length : name2;
    if (isLast) {
      if (utils$1$1.hasOwnProp(target, name2)) {
        target[name2] = [target[name2], value2];
      } else {
        target[name2] = value2;
      }
      return !isNumericKey;
    }
    if (!target[name2] || !utils$1$1.isObject(target[name2])) {
      target[name2] = [];
    }
    const result = buildPath(path3, value2, target[name2], index2);
    if (result && utils$1$1.isArray(target[name2])) {
      target[name2] = arrayToObject(target[name2]);
    }
    return !isNumericKey;
  }
  if (utils$1$1.isFormData(formData) && utils$1$1.isFunction(formData.entries)) {
    const obj = {};
    utils$1$1.forEachEntry(formData, (name2, value2) => {
      buildPath(parsePropPath(name2), value2, obj, 0);
    });
    return obj;
  }
  return null;
}
function stringifySafely(rawValue, parser, encoder) {
  if (utils$1$1.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils$1$1.trim(rawValue);
    } catch (e) {
      if (e.name !== "SyntaxError") {
        throw e;
      }
    }
  }
  return (0, JSON.stringify)(rawValue);
}
const defaults = {
  transitional: transitionalDefaults,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data2, headers) {
    const contentType3 = headers.getContentType() || "";
    const hasJSONContentType = contentType3.indexOf("application/json") > -1;
    const isObjectPayload = utils$1$1.isObject(data2);
    if (isObjectPayload && utils$1$1.isHTMLForm(data2)) {
      data2 = new FormData(data2);
    }
    const isFormData2 = utils$1$1.isFormData(data2);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON(data2)) : data2;
    }
    if (utils$1$1.isArrayBuffer(data2) || utils$1$1.isBuffer(data2) || utils$1$1.isStream(data2) || utils$1$1.isFile(data2) || utils$1$1.isBlob(data2) || utils$1$1.isReadableStream(data2)) {
      return data2;
    }
    if (utils$1$1.isArrayBufferView(data2)) {
      return data2.buffer;
    }
    if (utils$1$1.isURLSearchParams(data2)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data2.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType3.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data2, this.formSerializer).toString();
      }
      if ((isFileList2 = utils$1$1.isFileList(data2)) || contentType3.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData(
          isFileList2 ? { "files[]": data2 } : data2,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data2);
    }
    return data2;
  }],
  transformResponse: [function transformResponse(data2) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils$1$1.isResponse(data2) || utils$1$1.isReadableStream(data2)) {
      return data2;
    }
    if (data2 && utils$1$1.isString(data2) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data2);
      } catch (e) {
        if (strictJSONParsing) {
          if (e.name === "SyntaxError") {
            throw AxiosError.from(e, AxiosError.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e;
        }
      }
    }
    return data2;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform$2.classes.FormData,
    Blob: platform$2.classes.Blob
  },
  validateStatus: function validateStatus(status3) {
    return status3 >= 200 && status3 < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils$1$1.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
const defaults$1 = defaults;
const ignoreDuplicateOf = utils$1$1.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
const parseHeaders = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i = line.indexOf(":");
    key = line.substring(0, i).trim().toLowerCase();
    val = line.substring(i + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};
const $internals = Symbol("internals");
function normalizeHeader(header3) {
  return header3 && String(header3).trim().toLowerCase();
}
function normalizeValue(value2) {
  if (value2 === false || value2 == null) {
    return value2;
  }
  return utils$1$1.isArray(value2) ? value2.map(normalizeValue) : String(value2);
}
function parseTokens(str2) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match2;
  while (match2 = tokensRE.exec(str2)) {
    tokens[match2[1]] = match2[2];
  }
  return tokens;
}
const isValidHeaderName = (str2) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str2.trim());
function matchHeaderValue(context2, value2, header3, filter3, isHeaderNameFilter) {
  if (utils$1$1.isFunction(filter3)) {
    return filter3.call(this, value2, header3);
  }
  if (isHeaderNameFilter) {
    value2 = header3;
  }
  if (!utils$1$1.isString(value2)) return;
  if (utils$1$1.isString(filter3)) {
    return value2.indexOf(filter3) !== -1;
  }
  if (utils$1$1.isRegExp(filter3)) {
    return filter3.test(value2);
  }
}
function formatHeader(header3) {
  return header3.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str2) => {
    return char.toUpperCase() + str2;
  });
}
function buildAccessors(obj, header3) {
  const accessorName = utils$1$1.toCamelCase(" " + header3);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header3, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
class AxiosHeaders {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header3, valueOrRewrite, rewrite) {
    const self3 = this;
    function setHeader2(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils$1$1.findKey(self3, lHeader);
      if (!key || self3[key] === void 0 || _rewrite === true || _rewrite === void 0 && self3[key] !== false) {
        self3[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders2 = (headers, _rewrite) => utils$1$1.forEach(headers, (_value, _header) => setHeader2(_value, _header, _rewrite));
    if (utils$1$1.isPlainObject(header3) || header3 instanceof this.constructor) {
      setHeaders2(header3, valueOrRewrite);
    } else if (utils$1$1.isString(header3) && (header3 = header3.trim()) && !isValidHeaderName(header3)) {
      setHeaders2(parseHeaders(header3), valueOrRewrite);
    } else if (utils$1$1.isHeaders(header3)) {
      for (const [key, value2] of header3.entries()) {
        setHeader2(value2, key, rewrite);
      }
    } else {
      header3 != null && setHeader2(valueOrRewrite, header3, rewrite);
    }
    return this;
  }
  get(header3, parser) {
    header3 = normalizeHeader(header3);
    if (header3) {
      const key = utils$1$1.findKey(this, header3);
      if (key) {
        const value2 = this[key];
        if (!parser) {
          return value2;
        }
        if (parser === true) {
          return parseTokens(value2);
        }
        if (utils$1$1.isFunction(parser)) {
          return parser.call(this, value2, key);
        }
        if (utils$1$1.isRegExp(parser)) {
          return parser.exec(value2);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header3, matcher) {
    header3 = normalizeHeader(header3);
    if (header3) {
      const key = utils$1$1.findKey(this, header3);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header3, matcher) {
    const self3 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils$1$1.findKey(self3, _header);
        if (key && (!matcher || matchHeaderValue(self3, self3[key], key, matcher))) {
          delete self3[key];
          deleted = true;
        }
      }
    }
    if (utils$1$1.isArray(header3)) {
      header3.forEach(deleteHeader);
    } else {
      deleteHeader(header3);
    }
    return deleted;
  }
  clear(matcher) {
    const keys2 = Object.keys(this);
    let i = keys2.length;
    let deleted = false;
    while (i--) {
      const key = keys2[i];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format2) {
    const self3 = this;
    const headers = {};
    utils$1$1.forEach(this, (value2, header3) => {
      const key = utils$1$1.findKey(headers, header3);
      if (key) {
        self3[key] = normalizeValue(value2);
        delete self3[header3];
        return;
      }
      const normalized = format2 ? formatHeader(header3) : String(header3).trim();
      if (normalized !== header3) {
        delete self3[header3];
      }
      self3[normalized] = normalizeValue(value2);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils$1$1.forEach(this, (value2, header3) => {
      value2 != null && value2 !== false && (obj[header3] = asStrings && utils$1$1.isArray(value2) ? value2.join(", ") : value2);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header3, value2]) => header3 + ": " + value2).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first2, ...targets) {
    const computed = new this(first2);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header3) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype2 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype2, _header);
        accessors[lHeader] = true;
      }
    }
    utils$1$1.isArray(header3) ? header3.forEach(defineAccessor) : defineAccessor(header3);
    return this;
  }
}
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils$1$1.reduceDescriptors(AxiosHeaders.prototype, ({ value: value2 }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value2,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils$1$1.freezeMethods(AxiosHeaders);
const AxiosHeaders$1 = AxiosHeaders;
function transformData(fns, response2) {
  const config = this || defaults$1;
  const context2 = response2 || config;
  const headers = AxiosHeaders$1.from(context2.headers);
  let data2 = context2.data;
  utils$1$1.forEach(fns, function transform(fn) {
    data2 = fn.call(config, data2, headers.normalize(), response2 ? response2.status : void 0);
  });
  headers.normalize();
  return data2;
}
function isCancel(value2) {
  return !!(value2 && value2.__CANCEL__);
}
function CanceledError(message, config, request2) {
  AxiosError.call(this, message == null ? "canceled" : message, AxiosError.ERR_CANCELED, config, request2);
  this.name = "CanceledError";
}
utils$1$1.inherits(CanceledError, AxiosError, {
  __CANCEL__: true
});
function settle(resolve3, reject, response2) {
  const validateStatus2 = response2.config.validateStatus;
  if (!response2.status || !validateStatus2 || validateStatus2(response2.status)) {
    resolve3(response2);
  } else {
    reject(new AxiosError(
      "Request failed with status code " + response2.status,
      [AxiosError.ERR_BAD_REQUEST, AxiosError.ERR_BAD_RESPONSE][Math.floor(response2.status / 100) - 4],
      response2.config,
      response2.request,
      response2
    ));
  }
}
function isAbsoluteURL(url2) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url2);
}
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}
const VERSION = "1.7.7";
function parseProtocol(url2) {
  const match2 = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url2);
  return match2 && match2[1] || "";
}
const DATA_URL_PATTERN = /^(?:([^;]+);)?(?:[^;]+;)?(base64|),([\s\S]*)$/;
function fromDataURI(uri2, asBlob, options) {
  const _Blob = options && options.Blob || platform$2.classes.Blob;
  const protocol2 = parseProtocol(uri2);
  if (asBlob === void 0 && _Blob) {
    asBlob = true;
  }
  if (protocol2 === "data") {
    uri2 = protocol2.length ? uri2.slice(protocol2.length + 1) : uri2;
    const match2 = DATA_URL_PATTERN.exec(uri2);
    if (!match2) {
      throw new AxiosError("Invalid URL", AxiosError.ERR_INVALID_URL);
    }
    const mime2 = match2[1];
    const isBase64 = match2[2];
    const body = match2[3];
    const buffer = Buffer.from(decodeURIComponent(body), isBase64 ? "base64" : "utf8");
    if (asBlob) {
      if (!_Blob) {
        throw new AxiosError("Blob is not supported", AxiosError.ERR_NOT_SUPPORT);
      }
      return new _Blob([buffer], { type: mime2 });
    }
    return buffer;
  }
  throw new AxiosError("Unsupported protocol " + protocol2, AxiosError.ERR_NOT_SUPPORT);
}
const kInternals = Symbol("internals");
class AxiosTransformStream extends stream__default["default"].Transform {
  constructor(options) {
    options = utils$1$1.toFlatObject(options, {
      maxRate: 0,
      chunkSize: 64 * 1024,
      minChunkSize: 100,
      timeWindow: 500,
      ticksRate: 2,
      samplesCount: 15
    }, null, (prop, source) => {
      return !utils$1$1.isUndefined(source[prop]);
    });
    super({
      readableHighWaterMark: options.chunkSize
    });
    const internals = this[kInternals] = {
      timeWindow: options.timeWindow,
      chunkSize: options.chunkSize,
      maxRate: options.maxRate,
      minChunkSize: options.minChunkSize,
      bytesSeen: 0,
      isCaptured: false,
      notifiedBytesLoaded: 0,
      ts: Date.now(),
      bytes: 0,
      onReadCallback: null
    };
    this.on("newListener", (event) => {
      if (event === "progress") {
        if (!internals.isCaptured) {
          internals.isCaptured = true;
        }
      }
    });
  }
  _read(size) {
    const internals = this[kInternals];
    if (internals.onReadCallback) {
      internals.onReadCallback();
    }
    return super._read(size);
  }
  _transform(chunk, encoding3, callback) {
    const internals = this[kInternals];
    const maxRate = internals.maxRate;
    const readableHighWaterMark = this.readableHighWaterMark;
    const timeWindow = internals.timeWindow;
    const divider = 1e3 / timeWindow;
    const bytesThreshold = maxRate / divider;
    const minChunkSize = internals.minChunkSize !== false ? Math.max(internals.minChunkSize, bytesThreshold * 0.01) : 0;
    const pushChunk = (_chunk, _callback) => {
      const bytes2 = Buffer.byteLength(_chunk);
      internals.bytesSeen += bytes2;
      internals.bytes += bytes2;
      internals.isCaptured && this.emit("progress", internals.bytesSeen);
      if (this.push(_chunk)) {
        process.nextTick(_callback);
      } else {
        internals.onReadCallback = () => {
          internals.onReadCallback = null;
          process.nextTick(_callback);
        };
      }
    };
    const transformChunk = (_chunk, _callback) => {
      const chunkSize = Buffer.byteLength(_chunk);
      let chunkRemainder = null;
      let maxChunkSize = readableHighWaterMark;
      let bytesLeft;
      let passed = 0;
      if (maxRate) {
        const now = Date.now();
        if (!internals.ts || (passed = now - internals.ts) >= timeWindow) {
          internals.ts = now;
          bytesLeft = bytesThreshold - internals.bytes;
          internals.bytes = bytesLeft < 0 ? -bytesLeft : 0;
          passed = 0;
        }
        bytesLeft = bytesThreshold - internals.bytes;
      }
      if (maxRate) {
        if (bytesLeft <= 0) {
          return setTimeout(() => {
            _callback(null, _chunk);
          }, timeWindow - passed);
        }
        if (bytesLeft < maxChunkSize) {
          maxChunkSize = bytesLeft;
        }
      }
      if (maxChunkSize && chunkSize > maxChunkSize && chunkSize - maxChunkSize > minChunkSize) {
        chunkRemainder = _chunk.subarray(maxChunkSize);
        _chunk = _chunk.subarray(0, maxChunkSize);
      }
      pushChunk(_chunk, chunkRemainder ? () => {
        process.nextTick(_callback, null, chunkRemainder);
      } : _callback);
    };
    transformChunk(chunk, function transformNextChunk(err, _chunk) {
      if (err) {
        return callback(err);
      }
      if (_chunk) {
        transformChunk(_chunk, transformNextChunk);
      } else {
        callback(null);
      }
    });
  }
}
const AxiosTransformStream$1 = AxiosTransformStream;
const { asyncIterator } = Symbol;
const readBlob = async function* (blob) {
  if (blob.stream) {
    yield* blob.stream();
  } else if (blob.arrayBuffer) {
    yield await blob.arrayBuffer();
  } else if (blob[asyncIterator]) {
    yield* blob[asyncIterator]();
  } else {
    yield blob;
  }
};
const readBlob$1 = readBlob;
const BOUNDARY_ALPHABET = utils$1$1.ALPHABET.ALPHA_DIGIT + "-_";
const textEncoder = new util$6.TextEncoder();
const CRLF = "\r\n";
const CRLF_BYTES = textEncoder.encode(CRLF);
const CRLF_BYTES_COUNT = 2;
class FormDataPart {
  constructor(name2, value2) {
    const { escapeName } = this.constructor;
    const isStringValue = utils$1$1.isString(value2);
    let headers = `Content-Disposition: form-data; name="${escapeName(name2)}"${!isStringValue && value2.name ? `; filename="${escapeName(value2.name)}"` : ""}${CRLF}`;
    if (isStringValue) {
      value2 = textEncoder.encode(String(value2).replace(/\r?\n|\r\n?/g, CRLF));
    } else {
      headers += `Content-Type: ${value2.type || "application/octet-stream"}${CRLF}`;
    }
    this.headers = textEncoder.encode(headers + CRLF);
    this.contentLength = isStringValue ? value2.byteLength : value2.size;
    this.size = this.headers.byteLength + this.contentLength + CRLF_BYTES_COUNT;
    this.name = name2;
    this.value = value2;
  }
  async *encode() {
    yield this.headers;
    const { value: value2 } = this;
    if (utils$1$1.isTypedArray(value2)) {
      yield value2;
    } else {
      yield* readBlob$1(value2);
    }
    yield CRLF_BYTES;
  }
  static escapeName(name2) {
    return String(name2).replace(/[\r\n"]/g, (match2) => ({
      "\r": "%0D",
      "\n": "%0A",
      '"': "%22"
    })[match2]);
  }
}
const formDataToStream = (form, headersHandler, options) => {
  const {
    tag = "form-data-boundary",
    size = 25,
    boundary = tag + "-" + utils$1$1.generateString(size, BOUNDARY_ALPHABET)
  } = options || {};
  if (!utils$1$1.isFormData(form)) {
    throw TypeError("FormData instance required");
  }
  if (boundary.length < 1 || boundary.length > 70) {
    throw Error("boundary must be 10-70 characters long");
  }
  const boundaryBytes = textEncoder.encode("--" + boundary + CRLF);
  const footerBytes = textEncoder.encode("--" + boundary + "--" + CRLF + CRLF);
  let contentLength = footerBytes.byteLength;
  const parts = Array.from(form.entries()).map(([name2, value2]) => {
    const part = new FormDataPart(name2, value2);
    contentLength += part.size;
    return part;
  });
  contentLength += boundaryBytes.byteLength * parts.length;
  contentLength = utils$1$1.toFiniteNumber(contentLength);
  const computedHeaders = {
    "Content-Type": `multipart/form-data; boundary=${boundary}`
  };
  if (Number.isFinite(contentLength)) {
    computedHeaders["Content-Length"] = contentLength;
  }
  headersHandler && headersHandler(computedHeaders);
  return stream$1.Readable.from(async function* () {
    for (const part of parts) {
      yield boundaryBytes;
      yield* part.encode();
    }
    yield footerBytes;
  }());
};
const formDataToStream$1 = formDataToStream;
class ZlibHeaderTransformStream extends stream__default["default"].Transform {
  __transform(chunk, encoding3, callback) {
    this.push(chunk);
    callback();
  }
  _transform(chunk, encoding3, callback) {
    if (chunk.length !== 0) {
      this._transform = this.__transform;
      if (chunk[0] !== 120) {
        const header3 = Buffer.alloc(2);
        header3[0] = 120;
        header3[1] = 156;
        this.push(header3, encoding3);
      }
    }
    this.__transform(chunk, encoding3, callback);
  }
}
const ZlibHeaderTransformStream$1 = ZlibHeaderTransformStream;
const callbackify = (fn, reducer) => {
  return utils$1$1.isAsyncFn(fn) ? function(...args) {
    const cb = args.pop();
    fn.apply(this, args).then((value2) => {
      try {
        reducer ? cb(null, ...reducer(value2)) : cb(null, value2);
      } catch (err) {
        cb(err);
      }
    }, cb);
  } : fn;
};
const callbackify$1 = callbackify;
function speedometer(samplesCount, min2) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min2 = min2 !== void 0 ? min2 : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i = tail;
    let bytesCount = 0;
    while (i !== head) {
      bytesCount += bytes2[i++];
      i = i % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min2) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
function throttle(fn, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
const progressEventReducer = (listener2, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer(50, 250);
  return throttle((e) => {
    const loaded = e.loaded;
    const total = e.lengthComputable ? e.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data2 = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener2(data2);
  }, freq);
};
const progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
const asyncDecorator = (fn) => (...args) => utils$1$1.asap(() => fn(...args));
const zlibOptions = {
  flush: zlib__default["default"].constants.Z_SYNC_FLUSH,
  finishFlush: zlib__default["default"].constants.Z_SYNC_FLUSH
};
const brotliOptions = {
  flush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH,
  finishFlush: zlib__default["default"].constants.BROTLI_OPERATION_FLUSH
};
const isBrotliSupported = utils$1$1.isFunction(zlib__default["default"].createBrotliDecompress);
const { http: httpFollow, https: httpsFollow } = followRedirects__default["default"];
const isHttps = /https:?/;
const supportedProtocols = platform$2.protocols.map((protocol2) => {
  return protocol2 + ":";
});
const flushOnFinish = (stream3, [throttled, flush]) => {
  stream3.on("end", flush).on("error", flush);
  return throttled;
};
function dispatchBeforeRedirect(options, responseDetails) {
  if (options.beforeRedirects.proxy) {
    options.beforeRedirects.proxy(options);
  }
  if (options.beforeRedirects.config) {
    options.beforeRedirects.config(options, responseDetails);
  }
}
function setProxy(options, configProxy, location2) {
  let proxy = configProxy;
  if (!proxy && proxy !== false) {
    const proxyUrl = proxyFromEnv.getProxyForUrl(location2);
    if (proxyUrl) {
      proxy = new URL(proxyUrl);
    }
  }
  if (proxy) {
    if (proxy.username) {
      proxy.auth = (proxy.username || "") + ":" + (proxy.password || "");
    }
    if (proxy.auth) {
      if (proxy.auth.username || proxy.auth.password) {
        proxy.auth = (proxy.auth.username || "") + ":" + (proxy.auth.password || "");
      }
      const base642 = Buffer.from(proxy.auth, "utf8").toString("base64");
      options.headers["Proxy-Authorization"] = "Basic " + base642;
    }
    options.headers.host = options.hostname + (options.port ? ":" + options.port : "");
    const proxyHost = proxy.hostname || proxy.host;
    options.hostname = proxyHost;
    options.host = proxyHost;
    options.port = proxy.port;
    options.path = location2;
    if (proxy.protocol) {
      options.protocol = proxy.protocol.includes(":") ? proxy.protocol : `${proxy.protocol}:`;
    }
  }
  options.beforeRedirects.proxy = function beforeRedirect(redirectOptions) {
    setProxy(redirectOptions, configProxy, redirectOptions.href);
  };
}
const isHttpAdapterSupported = typeof process !== "undefined" && utils$1$1.kindOf(process) === "process";
const wrapAsync = (asyncExecutor) => {
  return new Promise((resolve3, reject) => {
    let onDone;
    let isDone;
    const done = (value2, isRejected) => {
      if (isDone) return;
      isDone = true;
      onDone && onDone(value2, isRejected);
    };
    const _resolve = (value2) => {
      done(value2);
      resolve3(value2);
    };
    const _reject = (reason) => {
      done(reason, true);
      reject(reason);
    };
    asyncExecutor(_resolve, _reject, (onDoneHandler) => onDone = onDoneHandler).catch(_reject);
  });
};
const resolveFamily = ({ address, family }) => {
  if (!utils$1$1.isString(address)) {
    throw TypeError("address must be a string");
  }
  return {
    address,
    family: family || (address.indexOf(".") < 0 ? 6 : 4)
  };
};
const buildAddressEntry = (address, family) => resolveFamily(utils$1$1.isObject(address) ? address : { address, family });
const httpAdapter = isHttpAdapterSupported && function httpAdapter2(config) {
  return wrapAsync(async function dispatchHttpRequest(resolve3, reject, onDone) {
    let { data: data2, lookup: lookup2, family } = config;
    const { responseType, responseEncoding } = config;
    const method = config.method.toUpperCase();
    let isDone;
    let rejected = false;
    let req2;
    if (lookup2) {
      const _lookup = callbackify$1(lookup2, (value2) => utils$1$1.isArray(value2) ? value2 : [value2]);
      lookup2 = (hostname2, opt, cb) => {
        _lookup(hostname2, opt, (err, arg0, arg1) => {
          if (err) {
            return cb(err);
          }
          const addresses = utils$1$1.isArray(arg0) ? arg0.map((addr) => buildAddressEntry(addr)) : [buildAddressEntry(arg0, arg1)];
          opt.all ? cb(err, addresses) : cb(err, addresses[0].address, addresses[0].family);
        });
      };
    }
    const emitter = new events$1.EventEmitter();
    const onFinished2 = () => {
      if (config.cancelToken) {
        config.cancelToken.unsubscribe(abort2);
      }
      if (config.signal) {
        config.signal.removeEventListener("abort", abort2);
      }
      emitter.removeAllListeners();
    };
    onDone((value2, isRejected) => {
      isDone = true;
      if (isRejected) {
        rejected = true;
        onFinished2();
      }
    });
    function abort2(reason) {
      emitter.emit("abort", !reason || reason.type ? new CanceledError(null, config, req2) : reason);
    }
    emitter.once("abort", reject);
    if (config.cancelToken || config.signal) {
      config.cancelToken && config.cancelToken.subscribe(abort2);
      if (config.signal) {
        config.signal.aborted ? abort2() : config.signal.addEventListener("abort", abort2);
      }
    }
    const fullPath = buildFullPath(config.baseURL, config.url);
    const parsed = new URL(fullPath, platform$2.hasBrowserEnv ? platform$2.origin : void 0);
    const protocol2 = parsed.protocol || supportedProtocols[0];
    if (protocol2 === "data:") {
      let convertedData;
      if (method !== "GET") {
        return settle(resolve3, reject, {
          status: 405,
          statusText: "method not allowed",
          headers: {},
          config
        });
      }
      try {
        convertedData = fromDataURI(config.url, responseType === "blob", {
          Blob: config.env && config.env.Blob
        });
      } catch (err) {
        throw AxiosError.from(err, AxiosError.ERR_BAD_REQUEST, config);
      }
      if (responseType === "text") {
        convertedData = convertedData.toString(responseEncoding);
        if (!responseEncoding || responseEncoding === "utf8") {
          convertedData = utils$1$1.stripBOM(convertedData);
        }
      } else if (responseType === "stream") {
        convertedData = stream__default["default"].Readable.from(convertedData);
      }
      return settle(resolve3, reject, {
        data: convertedData,
        status: 200,
        statusText: "OK",
        headers: new AxiosHeaders$1(),
        config
      });
    }
    if (supportedProtocols.indexOf(protocol2) === -1) {
      return reject(new AxiosError(
        "Unsupported protocol " + protocol2,
        AxiosError.ERR_BAD_REQUEST,
        config
      ));
    }
    const headers = AxiosHeaders$1.from(config.headers).normalize();
    headers.set("User-Agent", "axios/" + VERSION, false);
    const { onUploadProgress, onDownloadProgress } = config;
    const maxRate = config.maxRate;
    let maxUploadRate = void 0;
    let maxDownloadRate = void 0;
    if (utils$1$1.isSpecCompliantForm(data2)) {
      const userBoundary = headers.getContentType(/boundary=([-_\w\d]{10,70})/i);
      data2 = formDataToStream$1(data2, (formHeaders) => {
        headers.set(formHeaders);
      }, {
        tag: `axios-${VERSION}-boundary`,
        boundary: userBoundary && userBoundary[1] || void 0
      });
    } else if (utils$1$1.isFormData(data2) && utils$1$1.isFunction(data2.getHeaders)) {
      headers.set(data2.getHeaders());
      if (!headers.hasContentLength()) {
        try {
          const knownLength = await util__default["default"].promisify(data2.getLength).call(data2);
          Number.isFinite(knownLength) && knownLength >= 0 && headers.setContentLength(knownLength);
        } catch (e) {
        }
      }
    } else if (utils$1$1.isBlob(data2)) {
      data2.size && headers.setContentType(data2.type || "application/octet-stream");
      headers.setContentLength(data2.size || 0);
      data2 = stream__default["default"].Readable.from(readBlob$1(data2));
    } else if (data2 && !utils$1$1.isStream(data2)) {
      if (Buffer.isBuffer(data2)) ;
      else if (utils$1$1.isArrayBuffer(data2)) {
        data2 = Buffer.from(new Uint8Array(data2));
      } else if (utils$1$1.isString(data2)) {
        data2 = Buffer.from(data2, "utf-8");
      } else {
        return reject(new AxiosError(
          "Data after transformation must be a string, an ArrayBuffer, a Buffer, or a Stream",
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
      headers.setContentLength(data2.length, false);
      if (config.maxBodyLength > -1 && data2.length > config.maxBodyLength) {
        return reject(new AxiosError(
          "Request body larger than maxBodyLength limit",
          AxiosError.ERR_BAD_REQUEST,
          config
        ));
      }
    }
    const contentLength = utils$1$1.toFiniteNumber(headers.getContentLength());
    if (utils$1$1.isArray(maxRate)) {
      maxUploadRate = maxRate[0];
      maxDownloadRate = maxRate[1];
    } else {
      maxUploadRate = maxDownloadRate = maxRate;
    }
    if (data2 && (onUploadProgress || maxUploadRate)) {
      if (!utils$1$1.isStream(data2)) {
        data2 = stream__default["default"].Readable.from(data2, { objectMode: false });
      }
      data2 = stream__default["default"].pipeline([data2, new AxiosTransformStream$1({
        maxRate: utils$1$1.toFiniteNumber(maxUploadRate)
      })], utils$1$1.noop);
      onUploadProgress && data2.on("progress", flushOnFinish(
        data2,
        progressEventDecorator(
          contentLength,
          progressEventReducer(asyncDecorator(onUploadProgress), false, 3)
        )
      ));
    }
    let auth = void 0;
    if (config.auth) {
      const username = config.auth.username || "";
      const password = config.auth.password || "";
      auth = username + ":" + password;
    }
    if (!auth && parsed.username) {
      const urlUsername = parsed.username;
      const urlPassword = parsed.password;
      auth = urlUsername + ":" + urlPassword;
    }
    auth && headers.delete("authorization");
    let path3;
    try {
      path3 = buildURL(
        parsed.pathname + parsed.search,
        config.params,
        config.paramsSerializer
      ).replace(/^\?/, "");
    } catch (err) {
      const customErr = new Error(err.message);
      customErr.config = config;
      customErr.url = config.url;
      customErr.exists = true;
      return reject(customErr);
    }
    headers.set(
      "Accept-Encoding",
      "gzip, compress, deflate" + (isBrotliSupported ? ", br" : ""),
      false
    );
    const options = {
      path: path3,
      method,
      headers: headers.toJSON(),
      agents: { http: config.httpAgent, https: config.httpsAgent },
      auth,
      protocol: protocol2,
      family,
      beforeRedirect: dispatchBeforeRedirect,
      beforeRedirects: {}
    };
    !utils$1$1.isUndefined(lookup2) && (options.lookup = lookup2);
    if (config.socketPath) {
      options.socketPath = config.socketPath;
    } else {
      options.hostname = parsed.hostname.startsWith("[") ? parsed.hostname.slice(1, -1) : parsed.hostname;
      options.port = parsed.port;
      setProxy(options, config.proxy, protocol2 + "//" + parsed.hostname + (parsed.port ? ":" + parsed.port : "") + options.path);
    }
    let transport;
    const isHttpsRequest = isHttps.test(options.protocol);
    options.agent = isHttpsRequest ? config.httpsAgent : config.httpAgent;
    if (config.transport) {
      transport = config.transport;
    } else if (config.maxRedirects === 0) {
      transport = isHttpsRequest ? https__default["default"] : http__default["default"];
    } else {
      if (config.maxRedirects) {
        options.maxRedirects = config.maxRedirects;
      }
      if (config.beforeRedirect) {
        options.beforeRedirects.config = config.beforeRedirect;
      }
      transport = isHttpsRequest ? httpsFollow : httpFollow;
    }
    if (config.maxBodyLength > -1) {
      options.maxBodyLength = config.maxBodyLength;
    } else {
      options.maxBodyLength = Infinity;
    }
    if (config.insecureHTTPParser) {
      options.insecureHTTPParser = config.insecureHTTPParser;
    }
    req2 = transport.request(options, function handleResponse(res2) {
      if (req2.destroyed) return;
      const streams2 = [res2];
      const responseLength = +res2.headers["content-length"];
      if (onDownloadProgress || maxDownloadRate) {
        const transformStream = new AxiosTransformStream$1({
          maxRate: utils$1$1.toFiniteNumber(maxDownloadRate)
        });
        onDownloadProgress && transformStream.on("progress", flushOnFinish(
          transformStream,
          progressEventDecorator(
            responseLength,
            progressEventReducer(asyncDecorator(onDownloadProgress), true, 3)
          )
        ));
        streams2.push(transformStream);
      }
      let responseStream = res2;
      const lastRequest = res2.req || req2;
      if (config.decompress !== false && res2.headers["content-encoding"]) {
        if (method === "HEAD" || res2.statusCode === 204) {
          delete res2.headers["content-encoding"];
        }
        switch ((res2.headers["content-encoding"] || "").toLowerCase()) {
          case "gzip":
          case "x-gzip":
          case "compress":
          case "x-compress":
            streams2.push(zlib__default["default"].createUnzip(zlibOptions));
            delete res2.headers["content-encoding"];
            break;
          case "deflate":
            streams2.push(new ZlibHeaderTransformStream$1());
            streams2.push(zlib__default["default"].createUnzip(zlibOptions));
            delete res2.headers["content-encoding"];
            break;
          case "br":
            if (isBrotliSupported) {
              streams2.push(zlib__default["default"].createBrotliDecompress(brotliOptions));
              delete res2.headers["content-encoding"];
            }
        }
      }
      responseStream = streams2.length > 1 ? stream__default["default"].pipeline(streams2, utils$1$1.noop) : streams2[0];
      const offListeners = stream__default["default"].finished(responseStream, () => {
        offListeners();
        onFinished2();
      });
      const response2 = {
        status: res2.statusCode,
        statusText: res2.statusMessage,
        headers: new AxiosHeaders$1(res2.headers),
        config,
        request: lastRequest
      };
      if (responseType === "stream") {
        response2.data = responseStream;
        settle(resolve3, reject, response2);
      } else {
        const responseBuffer = [];
        let totalResponseBytes = 0;
        responseStream.on("data", function handleStreamData(chunk) {
          responseBuffer.push(chunk);
          totalResponseBytes += chunk.length;
          if (config.maxContentLength > -1 && totalResponseBytes > config.maxContentLength) {
            rejected = true;
            responseStream.destroy();
            reject(new AxiosError(
              "maxContentLength size of " + config.maxContentLength + " exceeded",
              AxiosError.ERR_BAD_RESPONSE,
              config,
              lastRequest
            ));
          }
        });
        responseStream.on("aborted", function handlerStreamAborted() {
          if (rejected) {
            return;
          }
          const err = new AxiosError(
            "maxContentLength size of " + config.maxContentLength + " exceeded",
            AxiosError.ERR_BAD_RESPONSE,
            config,
            lastRequest
          );
          responseStream.destroy(err);
          reject(err);
        });
        responseStream.on("error", function handleStreamError(err) {
          if (req2.destroyed) return;
          reject(AxiosError.from(err, null, config, lastRequest));
        });
        responseStream.on("end", function handleStreamEnd() {
          try {
            let responseData = responseBuffer.length === 1 ? responseBuffer[0] : Buffer.concat(responseBuffer);
            if (responseType !== "arraybuffer") {
              responseData = responseData.toString(responseEncoding);
              if (!responseEncoding || responseEncoding === "utf8") {
                responseData = utils$1$1.stripBOM(responseData);
              }
            }
            response2.data = responseData;
          } catch (err) {
            return reject(AxiosError.from(err, null, config, response2.request, response2));
          }
          settle(resolve3, reject, response2);
        });
      }
      emitter.once("abort", (err) => {
        if (!responseStream.destroyed) {
          responseStream.emit("error", err);
          responseStream.destroy();
        }
      });
    });
    emitter.once("abort", (err) => {
      reject(err);
      req2.destroy(err);
    });
    req2.on("error", function handleRequestError(err) {
      reject(AxiosError.from(err, null, config, req2));
    });
    req2.on("socket", function handleRequestSocket(socket) {
      socket.setKeepAlive(true, 1e3 * 60);
    });
    if (config.timeout) {
      const timeout = parseInt(config.timeout, 10);
      if (Number.isNaN(timeout)) {
        reject(new AxiosError(
          "error trying to parse `config.timeout` to int",
          AxiosError.ERR_BAD_OPTION_VALUE,
          config,
          req2
        ));
        return;
      }
      req2.setTimeout(timeout, function handleRequestTimeout() {
        if (isDone) return;
        let timeoutErrorMessage = config.timeout ? "timeout of " + config.timeout + "ms exceeded" : "timeout exceeded";
        const transitional2 = config.transitional || transitionalDefaults;
        if (config.timeoutErrorMessage) {
          timeoutErrorMessage = config.timeoutErrorMessage;
        }
        reject(new AxiosError(
          timeoutErrorMessage,
          transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
          config,
          req2
        ));
        abort2();
      });
    }
    if (utils$1$1.isStream(data2)) {
      let ended = false;
      let errored = false;
      data2.on("end", () => {
        ended = true;
      });
      data2.once("error", (err) => {
        errored = true;
        req2.destroy(err);
      });
      data2.on("close", () => {
        if (!ended && !errored) {
          abort2(new CanceledError("Request stream has been aborted", config, req2));
        }
      });
      data2.pipe(req2);
    } else {
      req2.end(data2);
    }
  });
};
const isURLSameOrigin = platform$2.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = platform$2.navigator && /(msie|trident)/i.test(platform$2.navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url2) {
      let href = url2;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin2(requestURL) {
      const parsed = utils$1$1.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin2() {
      return true;
    };
  }()
);
const cookies = platform$2.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name2, value2, expires, path3, domain, secure2) {
      const cookie2 = [name2 + "=" + encodeURIComponent(value2)];
      utils$1$1.isNumber(expires) && cookie2.push("expires=" + new Date(expires).toGMTString());
      utils$1$1.isString(path3) && cookie2.push("path=" + path3);
      utils$1$1.isString(domain) && cookie2.push("domain=" + domain);
      secure2 === true && cookie2.push("secure");
      document.cookie = cookie2.join("; ");
    },
    read(name2) {
      const match2 = document.cookie.match(new RegExp("(^|;\\s*)(" + name2 + ")=([^;]*)"));
      return match2 ? decodeURIComponent(match2[3]) : null;
    },
    remove(name2) {
      this.write(name2, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);
const headersToObject = (thing) => thing instanceof AxiosHeaders$1 ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils$1$1.isPlainObject(target) && utils$1$1.isPlainObject(source)) {
      return utils$1$1.merge.call({ caseless }, target, source);
    } else if (utils$1$1.isPlainObject(source)) {
      return utils$1$1.merge({}, source);
    } else if (utils$1$1.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a, b, caseless) {
    if (!utils$1$1.isUndefined(b)) {
      return getMergedValue(a, b, caseless);
    } else if (!utils$1$1.isUndefined(a)) {
      return getMergedValue(void 0, a, caseless);
    }
  }
  function valueFromConfig2(a, b) {
    if (!utils$1$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    }
  }
  function defaultToConfig2(a, b) {
    if (!utils$1$1.isUndefined(b)) {
      return getMergedValue(void 0, b);
    } else if (!utils$1$1.isUndefined(a)) {
      return getMergedValue(void 0, a);
    }
  }
  function mergeDirectKeys(a, b, prop) {
    if (prop in config2) {
      return getMergedValue(a, b);
    } else if (prop in config1) {
      return getMergedValue(void 0, a);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a, b) => mergeDeepProperties(headersToObject(a), headersToObject(b), true)
  };
  utils$1$1.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils$1$1.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}
const resolveConfig = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data: data2, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders$1.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType3;
  if (utils$1$1.isFormData(data2)) {
    if (platform$2.hasStandardBrowserEnv || platform$2.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType3 = headers.getContentType()) !== false) {
      const [type3, ...tokens] = contentType3 ? contentType3.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type3 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform$2.hasStandardBrowserEnv) {
    withXSRFToken && utils$1$1.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};
const isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
const xhrAdapter = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve3, reject) {
    const _config = resolveConfig(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders$1.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request2 = new XMLHttpRequest();
    request2.open(_config.method.toUpperCase(), _config.url, true);
    request2.timeout = _config.timeout;
    function onloadend() {
      if (!request2) {
        return;
      }
      const responseHeaders = AxiosHeaders$1.from(
        "getAllResponseHeaders" in request2 && request2.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request2.responseText : request2.response;
      const response2 = {
        data: responseData,
        status: request2.status,
        statusText: request2.statusText,
        headers: responseHeaders,
        config,
        request: request2
      };
      settle(function _resolve(value2) {
        resolve3(value2);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response2);
      request2 = null;
    }
    if ("onloadend" in request2) {
      request2.onloadend = onloadend;
    } else {
      request2.onreadystatechange = function handleLoad() {
        if (!request2 || request2.readyState !== 4) {
          return;
        }
        if (request2.status === 0 && !(request2.responseURL && request2.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request2.onabort = function handleAbort() {
      if (!request2) {
        return;
      }
      reject(new AxiosError("Request aborted", AxiosError.ECONNABORTED, config, request2));
      request2 = null;
    };
    request2.onerror = function handleError() {
      reject(new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2));
      request2 = null;
    };
    request2.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitionalDefaults;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError.ETIMEDOUT : AxiosError.ECONNABORTED,
        config,
        request2
      ));
      request2 = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request2) {
      utils$1$1.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request2.setRequestHeader(key, val);
      });
    }
    if (!utils$1$1.isUndefined(_config.withCredentials)) {
      request2.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request2.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request2.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request2.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request2.upload.addEventListener("progress", uploadThrottled);
      request2.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request2) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError(null, config, request2) : cancel);
        request2.abort();
        request2 = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol2 = parseProtocol(_config.url);
    if (protocol2 && platform$2.protocols.indexOf(protocol2) === -1) {
      reject(new AxiosError("Unsupported protocol " + protocol2 + ":", AxiosError.ERR_BAD_REQUEST, config));
      return;
    }
    request2.send(requestData || null);
  });
};
const composeSignals = (signals, timeout) => {
  const { length } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError ? err : new CanceledError(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError(`timeout ${timeout} of ms exceeded`, AxiosError.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils$1$1.asap(unsubscribe);
    return signal;
  }
};
const composeSignals$1 = composeSignals;
const streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
const readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
const readStream = async function* (stream3) {
  if (stream3[Symbol.asyncIterator]) {
    yield* stream3;
    return;
  }
  const reader = stream3.getReader();
  try {
    for (; ; ) {
      const { done, value: value2 } = await reader.read();
      if (done) {
        break;
      }
      yield value2;
    }
  } finally {
    await reader.cancel();
  }
};
const trackStream = (stream3, chunkSize, onProgress, onFinish) => {
  const iterator = readBytes(stream3, chunkSize);
  let bytes2 = 0;
  let done;
  let _onFinish = (e) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value: value2 } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value2.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value2));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};
const isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
const isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
const encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str2) => encoder.encode(str2))(new TextEncoder()) : async (str2) => new Uint8Array(await new Response(str2).arrayBuffer()));
const test$1 = (fn, ...args) => {
  try {
    return !!fn(...args);
  } catch (e) {
    return false;
  }
};
const supportsRequestStream = isReadableStreamSupported && test$1(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform$2.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
const DEFAULT_CHUNK_SIZE = 64 * 1024;
const supportsResponseStream = isReadableStreamSupported && test$1(() => utils$1$1.isReadableStream(new Response("").body));
const resolvers = {
  stream: supportsResponseStream && ((res2) => res2.body)
};
isFetchSupported && ((res2) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type3) => {
    !resolvers[type3] && (resolvers[type3] = utils$1$1.isFunction(res2[type3]) ? (res3) => res3[type3]() : (_, config) => {
      throw new AxiosError(`Response type '${type3}' is not supported`, AxiosError.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
const getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils$1$1.isBlob(body)) {
    return body.size;
  }
  if (utils$1$1.isSpecCompliantForm(body)) {
    const _request = new Request(platform$2.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils$1$1.isArrayBufferView(body) || utils$1$1.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils$1$1.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils$1$1.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
const resolveBodyLength = async (headers, body) => {
  const length = utils$1$1.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
const fetchAdapter = isFetchSupported && (async (config) => {
  let {
    url: url2,
    method,
    data: data2,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals$1([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request2;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data2)) !== 0) {
      let _request = new Request(url2, {
        method: "POST",
        body: data2,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils$1$1.isFormData(data2) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data2 = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils$1$1.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request2 = new Request(url2, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data2,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response2 = await fetch(request2);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response2[prop];
      });
      const responseContentLength = utils$1$1.toFiniteNumber(response2.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response2 = new Response(
        trackStream(response2.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils$1$1.findKey(resolvers, responseType) || "text"](response2, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve3, reject) => {
      settle(resolve3, reject, {
        data: responseData,
        headers: AxiosHeaders$1.from(response2.headers),
        status: response2.status,
        statusText: response2.statusText,
        config,
        request: request2
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError("Network Error", AxiosError.ERR_NETWORK, config, request2),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError.from(err, err && err.code, config, request2);
  }
});
const knownAdapters = {
  http: httpAdapter,
  xhr: xhrAdapter,
  fetch: fetchAdapter
};
utils$1$1.forEach(knownAdapters, (fn, value2) => {
  if (fn) {
    try {
      Object.defineProperty(fn, "name", { value: value2 });
    } catch (e) {
    }
    Object.defineProperty(fn, "adapterName", { value: value2 });
  }
});
const renderReason = (reason) => `- ${reason}`;
const isResolvedHandle = (adapter) => utils$1$1.isFunction(adapter) || adapter === null || adapter === false;
const adapters = {
  getAdapter: (adapters2) => {
    adapters2 = utils$1$1.isArray(adapters2) ? adapters2 : [adapters2];
    const { length } = adapters2;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i = 0; i < length; i++) {
      nameOrAdapter = adapters2[i];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state2]) => `adapter ${id} ` + (state2 === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders$1.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters.getAdapter(config.adapter || defaults$1.adapter);
  return adapter(config).then(function onAdapterResolution(response2) {
    throwIfCancellationRequested(config);
    response2.data = transformData.call(
      config,
      config.transformResponse,
      response2
    );
    response2.headers = AxiosHeaders$1.from(response2.headers);
    return response2;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders$1.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}
const validators$1 = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type3, i) => {
  validators$1[type3] = function validator2(thing) {
    return typeof thing === type3 || "a" + (i < 1 ? "n " : " ") + type3;
  };
});
const deprecatedWarnings = {};
validators$1.transitional = function transitional(validator2, version2, message) {
  function formatMessage(opt, desc2) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc2 + (message ? ". " + message : "");
  }
  return (value2, opt, opts) => {
    if (validator2 === false) {
      throw new AxiosError(
        formatMessage(opt, " has been removed" + (version2 ? " in " + version2 : "")),
        AxiosError.ERR_DEPRECATED
      );
    }
    if (version2 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version2 + " and will be removed in the near future"
        )
      );
    }
    return validator2 ? validator2(value2, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError("options must be an object", AxiosError.ERR_BAD_OPTION_VALUE);
  }
  const keys2 = Object.keys(options);
  let i = keys2.length;
  while (i-- > 0) {
    const opt = keys2[i];
    const validator2 = schema[opt];
    if (validator2) {
      const value2 = options[opt];
      const result = value2 === void 0 || validator2(value2, opt, options);
      if (result !== true) {
        throw new AxiosError("option " + opt + " must be " + result, AxiosError.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError("Unknown option " + opt, AxiosError.ERR_BAD_OPTION);
    }
  }
}
const validator = {
  assertOptions,
  validators: validators$1
};
const validators = validator.validators;
class Axios {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager$1(),
      response: new InterceptorManager$1()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator.assertOptions(transitional2, {
        silentJSONParsing: validators.transitional(validators.boolean),
        forcedJSONParsing: validators.transitional(validators.boolean),
        clarifyTimeoutError: validators.transitional(validators.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils$1$1.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator.assertOptions(paramsSerializer, {
          encode: validators.function,
          serialize: validators.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils$1$1.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils$1$1.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders$1.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise2;
    let i = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain = [dispatchRequest.bind(this), void 0];
      chain.unshift.apply(chain, requestInterceptorChain);
      chain.push.apply(chain, responseInterceptorChain);
      len = chain.length;
      promise2 = Promise.resolve(config);
      while (i < len) {
        promise2 = promise2.then(chain[i++], chain[i++]);
      }
      return promise2;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i = 0;
    while (i < len) {
      const onFulfilled = requestInterceptorChain[i++];
      const onRejected = requestInterceptorChain[i++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error2) {
        onRejected.call(this, error2);
        break;
      }
    }
    try {
      promise2 = dispatchRequest.call(this, newConfig);
    } catch (error2) {
      return Promise.reject(error2);
    }
    i = 0;
    len = responseInterceptorChain.length;
    while (i < len) {
      promise2 = promise2.then(responseInterceptorChain[i++], responseInterceptorChain[i++]);
    }
    return promise2;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
}
utils$1$1.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url2, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url: url2,
      data: (config || {}).data
    }));
  };
});
utils$1$1.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url2, data2, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url: url2,
        data: data2
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
const Axios$1 = Axios;
class CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve3) {
      resolvePromise = resolve3;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i = token._listeners.length;
      while (i-- > 0) {
        token._listeners[i](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise2 = new Promise((resolve3) => {
        token.subscribe(resolve3);
        _resolve = resolve3;
      }).then(onfulfilled);
      promise2.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise2;
    };
    executor(function cancel(message, config, request2) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError(message, config, request2);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener2) {
    if (this.reason) {
      listener2(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener2);
    } else {
      this._listeners = [listener2];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener2) {
    if (!this._listeners) {
      return;
    }
    const index2 = this._listeners.indexOf(listener2);
    if (index2 !== -1) {
      this._listeners.splice(index2, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort2 = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort2);
    controller.signal.unsubscribe = () => this.unsubscribe(abort2);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new CancelToken(function executor(c) {
      cancel = c;
    });
    return {
      token,
      cancel
    };
  }
}
const CancelToken$1 = CancelToken;
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}
function isAxiosError(payload) {
  return utils$1$1.isObject(payload) && payload.isAxiosError === true;
}
const HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value2]) => {
  HttpStatusCode[value2] = key;
});
const HttpStatusCode$1 = HttpStatusCode;
function createInstance(defaultConfig) {
  const context2 = new Axios$1(defaultConfig);
  const instance = bind$1(Axios$1.prototype.request, context2);
  utils$1$1.extend(instance, Axios$1.prototype, context2, { allOwnKeys: true });
  utils$1$1.extend(instance, context2, null, { allOwnKeys: true });
  instance.create = function create2(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
const axios$1 = createInstance(defaults$1);
axios$1.Axios = Axios$1;
axios$1.CanceledError = CanceledError;
axios$1.CancelToken = CancelToken$1;
axios$1.isCancel = isCancel;
axios$1.VERSION = VERSION;
axios$1.toFormData = toFormData;
axios$1.AxiosError = AxiosError;
axios$1.Cancel = axios$1.CanceledError;
axios$1.all = function all2(promises) {
  return Promise.all(promises);
};
axios$1.spread = spread;
axios$1.isAxiosError = isAxiosError;
axios$1.mergeConfig = mergeConfig;
axios$1.AxiosHeaders = AxiosHeaders$1;
axios$1.formToJSON = (thing) => formDataToJSON(utils$1$1.isHTMLForm(thing) ? new FormData(thing) : thing);
axios$1.getAdapter = adapters.getAdapter;
axios$1.HttpStatusCode = HttpStatusCode$1;
axios$1.default = axios$1;
var axios_1 = axios$1;
var dist$a = {};
var dist$9 = {};
var helpers$4 = {};
var __createBinding$a = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$a = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$a = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$a(result, mod, k);
  }
  __setModuleDefault$a(result, mod);
  return result;
};
Object.defineProperty(helpers$4, "__esModule", { value: true });
helpers$4.req = helpers$4.json = helpers$4.toBuffer = void 0;
const http$4 = __importStar$a(require$$0$a);
const https$5 = __importStar$a(require$$2$4);
async function toBuffer$1(stream3) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream3) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers$4.toBuffer = toBuffer$1;
async function json$2(stream3) {
  const buf = await toBuffer$1(stream3);
  const str2 = buf.toString("utf8");
  try {
    return JSON.parse(str2);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str2})`;
    throw err;
  }
}
helpers$4.json = json$2;
function req$1(url2, opts = {}) {
  const href = typeof url2 === "string" ? url2 : url2.href;
  const req2 = (href.startsWith("https:") ? https$5 : http$4).request(url2, opts);
  const promise2 = new Promise((resolve3, reject) => {
    req2.once("response", resolve3).once("error", reject).end();
  });
  req2.then = promise2.then.bind(promise2);
  return req2;
}
helpers$4.req = req$1;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = void 0;
  const net2 = __importStar2(require$$0$6);
  const http2 = __importStar2(require$$0$a);
  const https_12 = require$$2$4;
  __exportStar2(helpers$4, exports);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name2) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name2]) {
        this.sockets[name2] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name2].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name2, socket) {
      if (!this.sockets[name2] || socket === null) {
        return;
      }
      const sockets = this.sockets[name2];
      const index2 = sockets.indexOf(socket);
      if (index2 !== -1) {
        sockets.splice(index2, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name2];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_12.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name2 = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name2);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name2, fakeSocket);
        if (socket instanceof http2.Agent) {
          return socket.addRequest(req2, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name2, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
})(dist$9);
var dist$8 = {};
var __createBinding$9 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$9 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$9 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$9(result, mod, k);
  }
  __setModuleDefault$9(result, mod);
  return result;
};
var __importDefault$a = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$8, "__esModule", { value: true });
dist$8.HttpProxyAgent = void 0;
const net$3 = __importStar$9(require$$0$6);
const tls$4 = __importStar$9(require$$1$6);
const debug_1$8 = __importDefault$a(srcExports);
const events_1$1 = require$$0$8;
const agent_base_1$3 = dist$9;
const url_1$4 = require$$5$2;
const debug$a = (0, debug_1$8.default)("http-proxy-agent");
class HttpProxyAgent extends agent_base_1$3.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.proxy = typeof proxy === "string" ? new url_1$4.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$a("Creating new HttpProxyAgent instance: %o", this.proxy.href);
    const host2 = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      ...opts ? omit$2(opts, "headers") : null,
      host: host2,
      port
    };
  }
  addRequest(req2, opts) {
    req2._header = null;
    this.setRequestProps(req2, opts);
    super.addRequest(req2, opts);
  }
  setRequestProps(req2, opts) {
    const { proxy } = this;
    const protocol2 = opts.secureEndpoint ? "https:" : "http:";
    const hostname2 = req2.getHeader("host") || "localhost";
    const base = `${protocol2}//${hostname2}`;
    const url2 = new url_1$4.URL(req2.path, base);
    if (opts.port !== 80) {
      url2.port = String(opts.port);
    }
    req2.path = String(url2);
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      const value2 = headers[name2];
      if (value2) {
        req2.setHeader(name2, value2);
      }
    }
  }
  async connect(req2, opts) {
    req2._header = null;
    if (!req2.path.includes("://")) {
      this.setRequestProps(req2, opts);
    }
    let first2;
    let endOfHeaders;
    debug$a("Regenerating stored HTTP header string for request");
    req2._implicitHeader();
    if (req2.outputData && req2.outputData.length > 0) {
      debug$a("Patching connection write() output buffer with updated header");
      first2 = req2.outputData[0].data;
      endOfHeaders = first2.indexOf("\r\n\r\n") + 4;
      req2.outputData[0].data = req2._header + first2.substring(endOfHeaders);
      debug$a("Output buffer: %o", req2.outputData[0].data);
    }
    let socket;
    if (this.proxy.protocol === "https:") {
      debug$a("Creating `tls.Socket`: %o", this.connectOpts);
      socket = tls$4.connect(this.connectOpts);
    } else {
      debug$a("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$3.connect(this.connectOpts);
    }
    await (0, events_1$1.once)(socket, "connect");
    return socket;
  }
}
HttpProxyAgent.protocols = ["http", "https"];
dist$8.HttpProxyAgent = HttpProxyAgent;
function omit$2(obj, ...keys2) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys2.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist$7 = {};
var parseProxyResponse$1 = {};
var __importDefault$9 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(parseProxyResponse$1, "__esModule", { value: true });
parseProxyResponse$1.parseProxyResponse = void 0;
const debug_1$7 = __importDefault$9(srcExports);
const debug$9 = (0, debug_1$7.default)("https-proxy-agent:parse-proxy-response");
function parseProxyResponse(socket) {
  return new Promise((resolve3, reject) => {
    let buffersLength = 0;
    const buffers = [];
    function read() {
      const b = socket.read();
      if (b)
        ondata(b);
      else
        socket.once("readable", read);
    }
    function cleanup() {
      socket.removeListener("end", onend);
      socket.removeListener("error", onerror);
      socket.removeListener("readable", read);
    }
    function onend() {
      cleanup();
      debug$9("onend");
      reject(new Error("Proxy connection ended before receiving CONNECT response"));
    }
    function onerror(err) {
      cleanup();
      debug$9("onerror %o", err);
      reject(err);
    }
    function ondata(b) {
      buffers.push(b);
      buffersLength += b.length;
      const buffered = Buffer.concat(buffers, buffersLength);
      const endOfHeaders = buffered.indexOf("\r\n\r\n");
      if (endOfHeaders === -1) {
        debug$9("have not received end of HTTP headers yet...");
        read();
        return;
      }
      const headerParts = buffered.slice(0, endOfHeaders).toString("ascii").split("\r\n");
      const firstLine = headerParts.shift();
      if (!firstLine) {
        socket.destroy();
        return reject(new Error("No header received from proxy CONNECT response"));
      }
      const firstLineParts = firstLine.split(" ");
      const statusCode = +firstLineParts[1];
      const statusText = firstLineParts.slice(2).join(" ");
      const headers = {};
      for (const header3 of headerParts) {
        if (!header3)
          continue;
        const firstColon = header3.indexOf(":");
        if (firstColon === -1) {
          socket.destroy();
          return reject(new Error(`Invalid header from proxy CONNECT response: "${header3}"`));
        }
        const key = header3.slice(0, firstColon).toLowerCase();
        const value2 = header3.slice(firstColon + 1).trimStart();
        const current = headers[key];
        if (typeof current === "string") {
          headers[key] = [current, value2];
        } else if (Array.isArray(current)) {
          current.push(value2);
        } else {
          headers[key] = value2;
        }
      }
      debug$9("got proxy server response: %o %o", firstLine, headers);
      cleanup();
      resolve3({
        connect: {
          statusCode,
          statusText,
          headers
        },
        buffered
      });
    }
    socket.on("error", onerror);
    socket.on("end", onend);
    read();
  });
}
parseProxyResponse$1.parseProxyResponse = parseProxyResponse;
var __createBinding$8 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$8 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$8 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$8(result, mod, k);
  }
  __setModuleDefault$8(result, mod);
  return result;
};
var __importDefault$8 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$7, "__esModule", { value: true });
dist$7.HttpsProxyAgent = void 0;
const net$2 = __importStar$8(require$$0$6);
const tls$3 = __importStar$8(require$$1$6);
const assert_1 = __importDefault$8(require$$5$3);
const debug_1$6 = __importDefault$8(srcExports);
const agent_base_1$2 = dist$9;
const url_1$3 = require$$5$2;
const parse_proxy_response_1 = parseProxyResponse$1;
const debug$8 = (0, debug_1$6.default)("https-proxy-agent");
class HttpsProxyAgent extends agent_base_1$2.Agent {
  constructor(proxy, opts) {
    super(opts);
    this.options = { path: void 0 };
    this.proxy = typeof proxy === "string" ? new url_1$3.URL(proxy) : proxy;
    this.proxyHeaders = (opts == null ? void 0 : opts.headers) ?? {};
    debug$8("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
    const host2 = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, "");
    const port = this.proxy.port ? parseInt(this.proxy.port, 10) : this.proxy.protocol === "https:" ? 443 : 80;
    this.connectOpts = {
      // Attempt to negotiate http/1.1 for proxy servers that support http/2
      ALPNProtocols: ["http/1.1"],
      ...opts ? omit$1(opts, "headers") : null,
      host: host2,
      port
    };
  }
  /**
   * Called when the node-core HTTP client library is creating a
   * new HTTP request.
   */
  async connect(req2, opts) {
    const { proxy } = this;
    if (!opts.host) {
      throw new TypeError('No "host" provided');
    }
    let socket;
    if (proxy.protocol === "https:") {
      debug$8("Creating `tls.Socket`: %o", this.connectOpts);
      const servername = this.connectOpts.servername || this.connectOpts.host;
      socket = tls$3.connect({
        ...this.connectOpts,
        servername
      });
    } else {
      debug$8("Creating `net.Socket`: %o", this.connectOpts);
      socket = net$2.connect(this.connectOpts);
    }
    const headers = typeof this.proxyHeaders === "function" ? this.proxyHeaders() : { ...this.proxyHeaders };
    const host2 = net$2.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
    let payload = `CONNECT ${host2}:${opts.port} HTTP/1.1\r
`;
    if (proxy.username || proxy.password) {
      const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
      headers["Proxy-Authorization"] = `Basic ${Buffer.from(auth).toString("base64")}`;
    }
    headers.Host = `${host2}:${opts.port}`;
    if (!headers["Proxy-Connection"]) {
      headers["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
    }
    for (const name2 of Object.keys(headers)) {
      payload += `${name2}: ${headers[name2]}\r
`;
    }
    const proxyResponsePromise = (0, parse_proxy_response_1.parseProxyResponse)(socket);
    socket.write(`${payload}\r
`);
    const { connect, buffered } = await proxyResponsePromise;
    req2.emit("proxyConnect", connect);
    this.emit("proxyConnect", connect, req2);
    if (connect.statusCode === 200) {
      req2.once("socket", resume);
      if (opts.secureEndpoint) {
        debug$8("Upgrading socket connection to TLS");
        const servername = opts.servername || opts.host;
        return tls$3.connect({
          ...omit$1(opts, "host", "path", "port"),
          socket,
          servername
        });
      }
      return socket;
    }
    socket.destroy();
    const fakeSocket = new net$2.Socket({ writable: false });
    fakeSocket.readable = true;
    req2.once("socket", (s2) => {
      debug$8("Replaying proxy buffer for failed request");
      (0, assert_1.default)(s2.listenerCount("data") > 0);
      s2.push(buffered);
      s2.push(null);
    });
    return fakeSocket;
  }
}
HttpsProxyAgent.protocols = ["http", "https"];
dist$7.HttpsProxyAgent = HttpsProxyAgent;
function resume(socket) {
  socket.resume();
}
function omit$1(obj, ...keys2) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys2.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist$6 = {};
var build = {};
var socksclient = {};
var smartbuffer = {};
var utils$4 = {};
Object.defineProperty(utils$4, "__esModule", { value: true });
const buffer_1 = require$$0$9;
const ERRORS$1 = {
  INVALID_ENCODING: "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
  INVALID_SMARTBUFFER_SIZE: "Invalid size provided. Size must be a valid integer greater than zero.",
  INVALID_SMARTBUFFER_BUFFER: "Invalid Buffer provided in SmartBufferOptions.",
  INVALID_SMARTBUFFER_OBJECT: "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
  INVALID_OFFSET: "An invalid offset value was provided.",
  INVALID_OFFSET_NON_NUMBER: "An invalid offset value was provided. A numeric value is required.",
  INVALID_LENGTH: "An invalid length value was provided.",
  INVALID_LENGTH_NON_NUMBER: "An invalid length value was provived. A numeric value is required.",
  INVALID_TARGET_OFFSET: "Target offset is beyond the bounds of the internal SmartBuffer data.",
  INVALID_TARGET_LENGTH: "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
  INVALID_READ_BEYOND_BOUNDS: "Attempted to read beyond the bounds of the managed data.",
  INVALID_WRITE_BEYOND_BOUNDS: "Attempted to write beyond the bounds of the managed data."
};
utils$4.ERRORS = ERRORS$1;
function checkEncoding(encoding3) {
  if (!buffer_1.Buffer.isEncoding(encoding3)) {
    throw new Error(ERRORS$1.INVALID_ENCODING);
  }
}
utils$4.checkEncoding = checkEncoding;
function isFiniteInteger(value2) {
  return typeof value2 === "number" && isFinite(value2) && isInteger(value2);
}
utils$4.isFiniteInteger = isFiniteInteger;
function checkOffsetOrLengthValue(value2, offset) {
  if (typeof value2 === "number") {
    if (!isFiniteInteger(value2) || value2 < 0) {
      throw new Error(offset ? ERRORS$1.INVALID_OFFSET : ERRORS$1.INVALID_LENGTH);
    }
  } else {
    throw new Error(offset ? ERRORS$1.INVALID_OFFSET_NON_NUMBER : ERRORS$1.INVALID_LENGTH_NON_NUMBER);
  }
}
function checkLengthValue(length) {
  checkOffsetOrLengthValue(length, false);
}
utils$4.checkLengthValue = checkLengthValue;
function checkOffsetValue(offset) {
  checkOffsetOrLengthValue(offset, true);
}
utils$4.checkOffsetValue = checkOffsetValue;
function checkTargetOffset(offset, buff) {
  if (offset < 0 || offset > buff.length) {
    throw new Error(ERRORS$1.INVALID_TARGET_OFFSET);
  }
}
utils$4.checkTargetOffset = checkTargetOffset;
function isInteger(value2) {
  return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
}
function bigIntAndBufferInt64Check(bufferMethod) {
  if (typeof BigInt === "undefined") {
    throw new Error("Platform does not support JS BigInt type.");
  }
  if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
    throw new Error(`Platform does not support Buffer.prototype.${bufferMethod}.`);
  }
}
utils$4.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
Object.defineProperty(smartbuffer, "__esModule", { value: true });
const utils_1 = utils$4;
const DEFAULT_SMARTBUFFER_SIZE = 4096;
const DEFAULT_SMARTBUFFER_ENCODING = "utf8";
class SmartBuffer {
  /**
   * Creates a new SmartBuffer instance.
   *
   * @param options { SmartBufferOptions } The SmartBufferOptions to apply to this instance.
   */
  constructor(options) {
    this.length = 0;
    this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
    this._writeOffset = 0;
    this._readOffset = 0;
    if (SmartBuffer.isSmartBufferOptions(options)) {
      if (options.encoding) {
        utils_1.checkEncoding(options.encoding);
        this._encoding = options.encoding;
      }
      if (options.size) {
        if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
          this._buff = Buffer.allocUnsafe(options.size);
        } else {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
        }
      } else if (options.buff) {
        if (Buffer.isBuffer(options.buff)) {
          this._buff = options.buff;
          this.length = options.buff.length;
        } else {
          throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
        }
      } else {
        this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
      }
    } else {
      if (typeof options !== "undefined") {
        throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
      }
      this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
    }
  }
  /**
   * Creates a new SmartBuffer instance with the provided internal Buffer size and optional encoding.
   *
   * @param size { Number } The size of the internal Buffer.
   * @param encoding { String } The BufferEncoding to use for strings.
   *
   * @return { SmartBuffer }
   */
  static fromSize(size, encoding3) {
    return new this({
      size,
      encoding: encoding3
    });
  }
  /**
   * Creates a new SmartBuffer instance with the provided Buffer and optional encoding.
   *
   * @param buffer { Buffer } The Buffer to use as the internal Buffer value.
   * @param encoding { String } The BufferEncoding to use for strings.
   *
   * @return { SmartBuffer }
   */
  static fromBuffer(buff, encoding3) {
    return new this({
      buff,
      encoding: encoding3
    });
  }
  /**
   * Creates a new SmartBuffer instance with the provided SmartBufferOptions options.
   *
   * @param options { SmartBufferOptions } The options to use when creating the SmartBuffer instance.
   */
  static fromOptions(options) {
    return new this(options);
  }
  /**
   * Type checking function that determines if an object is a SmartBufferOptions object.
   */
  static isSmartBufferOptions(options) {
    const castOptions = options;
    return castOptions && (castOptions.encoding !== void 0 || castOptions.size !== void 0 || castOptions.buff !== void 0);
  }
  // Signed integers
  /**
   * Reads an Int8 value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt8(offset) {
    return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
  }
  /**
   * Reads an Int16BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt16BE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
  }
  /**
   * Reads an Int16LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt16LE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
  }
  /**
   * Reads an Int32BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt32BE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
  }
  /**
   * Reads an Int32LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readInt32LE(offset) {
    return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
  }
  /**
   * Reads a BigInt64BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigInt64BE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
    return this._readNumberValue(Buffer.prototype.readBigInt64BE, 8, offset);
  }
  /**
   * Reads a BigInt64LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigInt64LE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
    return this._readNumberValue(Buffer.prototype.readBigInt64LE, 8, offset);
  }
  /**
   * Writes an Int8 value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt8(value2, offset) {
    this._writeNumberValue(Buffer.prototype.writeInt8, 1, value2, offset);
    return this;
  }
  /**
   * Inserts an Int8 value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt8(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt8, 1, value2, offset);
  }
  /**
   * Writes an Int16BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt16BE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt16BE, 2, value2, offset);
  }
  /**
   * Inserts an Int16BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt16BE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt16BE, 2, value2, offset);
  }
  /**
   * Writes an Int16LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt16LE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt16LE, 2, value2, offset);
  }
  /**
   * Inserts an Int16LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt16LE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt16LE, 2, value2, offset);
  }
  /**
   * Writes an Int32BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt32BE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt32BE, 4, value2, offset);
  }
  /**
   * Inserts an Int32BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt32BE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt32BE, 4, value2, offset);
  }
  /**
   * Writes an Int32LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeInt32LE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeInt32LE, 4, value2, offset);
  }
  /**
   * Inserts an Int32LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertInt32LE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeInt32LE, 4, value2, offset);
  }
  /**
   * Writes a BigInt64BE value to the current write position (or at optional offset).
   *
   * @param value { BigInt } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigInt64BE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
    return this._writeNumberValue(Buffer.prototype.writeBigInt64BE, 8, value2, offset);
  }
  /**
   * Inserts a BigInt64BE value at the given offset value.
   *
   * @param value { BigInt } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigInt64BE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
    return this._insertNumberValue(Buffer.prototype.writeBigInt64BE, 8, value2, offset);
  }
  /**
   * Writes a BigInt64LE value to the current write position (or at optional offset).
   *
   * @param value { BigInt } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigInt64LE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
    return this._writeNumberValue(Buffer.prototype.writeBigInt64LE, 8, value2, offset);
  }
  /**
   * Inserts a Int64LE value at the given offset value.
   *
   * @param value { BigInt } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigInt64LE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
    return this._insertNumberValue(Buffer.prototype.writeBigInt64LE, 8, value2, offset);
  }
  // Unsigned Integers
  /**
   * Reads an UInt8 value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt8(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
  }
  /**
   * Reads an UInt16BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt16BE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt16BE, 2, offset);
  }
  /**
   * Reads an UInt16LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt16LE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt16LE, 2, offset);
  }
  /**
   * Reads an UInt32BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt32BE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt32BE, 4, offset);
  }
  /**
   * Reads an UInt32LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readUInt32LE(offset) {
    return this._readNumberValue(Buffer.prototype.readUInt32LE, 4, offset);
  }
  /**
   * Reads a BigUInt64BE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigUInt64BE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
    return this._readNumberValue(Buffer.prototype.readBigUInt64BE, 8, offset);
  }
  /**
   * Reads a BigUInt64LE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { BigInt }
   */
  readBigUInt64LE(offset) {
    utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
    return this._readNumberValue(Buffer.prototype.readBigUInt64LE, 8, offset);
  }
  /**
   * Writes an UInt8 value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt8(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt8, 1, value2, offset);
  }
  /**
   * Inserts an UInt8 value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt8(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt8, 1, value2, offset);
  }
  /**
   * Writes an UInt16BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt16BE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt16BE, 2, value2, offset);
  }
  /**
   * Inserts an UInt16BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt16BE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt16BE, 2, value2, offset);
  }
  /**
   * Writes an UInt16LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt16LE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt16LE, 2, value2, offset);
  }
  /**
   * Inserts an UInt16LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt16LE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt16LE, 2, value2, offset);
  }
  /**
   * Writes an UInt32BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt32BE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt32BE, 4, value2, offset);
  }
  /**
   * Inserts an UInt32BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt32BE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt32BE, 4, value2, offset);
  }
  /**
   * Writes an UInt32LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeUInt32LE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeUInt32LE, 4, value2, offset);
  }
  /**
   * Inserts an UInt32LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertUInt32LE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeUInt32LE, 4, value2, offset);
  }
  /**
   * Writes a BigUInt64BE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigUInt64BE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
    return this._writeNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value2, offset);
  }
  /**
   * Inserts a BigUInt64BE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigUInt64BE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
    return this._insertNumberValue(Buffer.prototype.writeBigUInt64BE, 8, value2, offset);
  }
  /**
   * Writes a BigUInt64LE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeBigUInt64LE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
    return this._writeNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value2, offset);
  }
  /**
   * Inserts a BigUInt64LE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertBigUInt64LE(value2, offset) {
    utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
    return this._insertNumberValue(Buffer.prototype.writeBigUInt64LE, 8, value2, offset);
  }
  // Floating Point
  /**
   * Reads an FloatBE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readFloatBE(offset) {
    return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
  }
  /**
   * Reads an FloatLE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readFloatLE(offset) {
    return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
  }
  /**
   * Writes a FloatBE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeFloatBE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeFloatBE, 4, value2, offset);
  }
  /**
   * Inserts a FloatBE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertFloatBE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeFloatBE, 4, value2, offset);
  }
  /**
   * Writes a FloatLE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeFloatLE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeFloatLE, 4, value2, offset);
  }
  /**
   * Inserts a FloatLE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertFloatLE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeFloatLE, 4, value2, offset);
  }
  // Double Floating Point
  /**
   * Reads an DoublEBE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readDoubleBE(offset) {
    return this._readNumberValue(Buffer.prototype.readDoubleBE, 8, offset);
  }
  /**
   * Reads an DoubleLE value from the current read position or an optionally provided offset.
   *
   * @param offset { Number } The offset to read data from (optional)
   * @return { Number }
   */
  readDoubleLE(offset) {
    return this._readNumberValue(Buffer.prototype.readDoubleLE, 8, offset);
  }
  /**
   * Writes a DoubleBE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeDoubleBE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeDoubleBE, 8, value2, offset);
  }
  /**
   * Inserts a DoubleBE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertDoubleBE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeDoubleBE, 8, value2, offset);
  }
  /**
   * Writes a DoubleLE value to the current write position (or at optional offset).
   *
   * @param value { Number } The value to write.
   * @param offset { Number } The offset to write the value at.
   *
   * @return this
   */
  writeDoubleLE(value2, offset) {
    return this._writeNumberValue(Buffer.prototype.writeDoubleLE, 8, value2, offset);
  }
  /**
   * Inserts a DoubleLE value at the given offset value.
   *
   * @param value { Number } The value to insert.
   * @param offset { Number } The offset to insert the value at.
   *
   * @return this
   */
  insertDoubleLE(value2, offset) {
    return this._insertNumberValue(Buffer.prototype.writeDoubleLE, 8, value2, offset);
  }
  // Strings
  /**
   * Reads a String from the current read position.
   *
   * @param arg1 { Number | String } The number of bytes to read as a String, or the BufferEncoding to use for
   *             the string (Defaults to instance level encoding).
   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
   *
   * @return { String }
   */
  readString(arg1, encoding3) {
    let lengthVal;
    if (typeof arg1 === "number") {
      utils_1.checkLengthValue(arg1);
      lengthVal = Math.min(arg1, this.length - this._readOffset);
    } else {
      encoding3 = arg1;
      lengthVal = this.length - this._readOffset;
    }
    if (typeof encoding3 !== "undefined") {
      utils_1.checkEncoding(encoding3);
    }
    const value2 = this._buff.slice(this._readOffset, this._readOffset + lengthVal).toString(encoding3 || this._encoding);
    this._readOffset += lengthVal;
    return value2;
  }
  /**
   * Inserts a String
   *
   * @param value { String } The String value to insert.
   * @param offset { Number } The offset to insert the string at.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  insertString(value2, offset, encoding3) {
    utils_1.checkOffsetValue(offset);
    return this._handleString(value2, true, offset, encoding3);
  }
  /**
   * Writes a String
   *
   * @param value { String } The String value to write.
   * @param arg2 { Number | String } The offset to write the string at, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  writeString(value2, arg2, encoding3) {
    return this._handleString(value2, false, arg2, encoding3);
  }
  /**
   * Reads a null-terminated String from the current read position.
   *
   * @param encoding { String } The BufferEncoding to use for the string (Defaults to instance level encoding).
   *
   * @return { String }
   */
  readStringNT(encoding3) {
    if (typeof encoding3 !== "undefined") {
      utils_1.checkEncoding(encoding3);
    }
    let nullPos = this.length;
    for (let i = this._readOffset; i < this.length; i++) {
      if (this._buff[i] === 0) {
        nullPos = i;
        break;
      }
    }
    const value2 = this._buff.slice(this._readOffset, nullPos);
    this._readOffset = nullPos + 1;
    return value2.toString(encoding3 || this._encoding);
  }
  /**
   * Inserts a null-terminated String.
   *
   * @param value { String } The String value to write.
   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  insertStringNT(value2, offset, encoding3) {
    utils_1.checkOffsetValue(offset);
    this.insertString(value2, offset, encoding3);
    this.insertUInt8(0, offset + value2.length);
    return this;
  }
  /**
   * Writes a null-terminated String.
   *
   * @param value { String } The String value to write.
   * @param arg2 { Number | String } The offset to write the string to, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   *
   * @return this
   */
  writeStringNT(value2, arg2, encoding3) {
    this.writeString(value2, arg2, encoding3);
    this.writeUInt8(0, typeof arg2 === "number" ? arg2 + value2.length : this.writeOffset);
    return this;
  }
  // Buffers
  /**
   * Reads a Buffer from the internal read position.
   *
   * @param length { Number } The length of data to read as a Buffer.
   *
   * @return { Buffer }
   */
  readBuffer(length) {
    if (typeof length !== "undefined") {
      utils_1.checkLengthValue(length);
    }
    const lengthVal = typeof length === "number" ? length : this.length;
    const endPoint = Math.min(this.length, this._readOffset + lengthVal);
    const value2 = this._buff.slice(this._readOffset, endPoint);
    this._readOffset = endPoint;
    return value2;
  }
  /**
   * Writes a Buffer to the current write position.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  insertBuffer(value2, offset) {
    utils_1.checkOffsetValue(offset);
    return this._handleBuffer(value2, true, offset);
  }
  /**
   * Writes a Buffer to the current write position.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  writeBuffer(value2, offset) {
    return this._handleBuffer(value2, false, offset);
  }
  /**
   * Reads a null-terminated Buffer from the current read poisiton.
   *
   * @return { Buffer }
   */
  readBufferNT() {
    let nullPos = this.length;
    for (let i = this._readOffset; i < this.length; i++) {
      if (this._buff[i] === 0) {
        nullPos = i;
        break;
      }
    }
    const value2 = this._buff.slice(this._readOffset, nullPos);
    this._readOffset = nullPos + 1;
    return value2;
  }
  /**
   * Inserts a null-terminated Buffer.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  insertBufferNT(value2, offset) {
    utils_1.checkOffsetValue(offset);
    this.insertBuffer(value2, offset);
    this.insertUInt8(0, offset + value2.length);
    return this;
  }
  /**
   * Writes a null-terminated Buffer.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   *
   * @return this
   */
  writeBufferNT(value2, offset) {
    if (typeof offset !== "undefined") {
      utils_1.checkOffsetValue(offset);
    }
    this.writeBuffer(value2, offset);
    this.writeUInt8(0, typeof offset === "number" ? offset + value2.length : this._writeOffset);
    return this;
  }
  /**
   * Clears the SmartBuffer instance to its original empty state.
   */
  clear() {
    this._writeOffset = 0;
    this._readOffset = 0;
    this.length = 0;
    return this;
  }
  /**
   * Gets the remaining data left to be read from the SmartBuffer instance.
   *
   * @return { Number }
   */
  remaining() {
    return this.length - this._readOffset;
  }
  /**
   * Gets the current read offset value of the SmartBuffer instance.
   *
   * @return { Number }
   */
  get readOffset() {
    return this._readOffset;
  }
  /**
   * Sets the read offset value of the SmartBuffer instance.
   *
   * @param offset { Number } - The offset value to set.
   */
  set readOffset(offset) {
    utils_1.checkOffsetValue(offset);
    utils_1.checkTargetOffset(offset, this);
    this._readOffset = offset;
  }
  /**
   * Gets the current write offset value of the SmartBuffer instance.
   *
   * @return { Number }
   */
  get writeOffset() {
    return this._writeOffset;
  }
  /**
   * Sets the write offset value of the SmartBuffer instance.
   *
   * @param offset { Number } - The offset value to set.
   */
  set writeOffset(offset) {
    utils_1.checkOffsetValue(offset);
    utils_1.checkTargetOffset(offset, this);
    this._writeOffset = offset;
  }
  /**
   * Gets the currently set string encoding of the SmartBuffer instance.
   *
   * @return { BufferEncoding } The string Buffer encoding currently set.
   */
  get encoding() {
    return this._encoding;
  }
  /**
   * Sets the string encoding of the SmartBuffer instance.
   *
   * @param encoding { BufferEncoding } The string Buffer encoding to set.
   */
  set encoding(encoding3) {
    utils_1.checkEncoding(encoding3);
    this._encoding = encoding3;
  }
  /**
   * Gets the underlying internal Buffer. (This includes unmanaged data in the Buffer)
   *
   * @return { Buffer } The Buffer value.
   */
  get internalBuffer() {
    return this._buff;
  }
  /**
   * Gets the value of the internal managed Buffer (Includes managed data only)
   *
   * @param { Buffer }
   */
  toBuffer() {
    return this._buff.slice(0, this.length);
  }
  /**
   * Gets the String value of the internal managed Buffer
   *
   * @param encoding { String } The BufferEncoding to display the Buffer as (defaults to instance level encoding).
   */
  toString(encoding3) {
    const encodingVal = typeof encoding3 === "string" ? encoding3 : this._encoding;
    utils_1.checkEncoding(encodingVal);
    return this._buff.toString(encodingVal, 0, this.length);
  }
  /**
   * Destroys the SmartBuffer instance.
   */
  destroy() {
    this.clear();
    return this;
  }
  /**
   * Handles inserting and writing strings.
   *
   * @param value { String } The String value to insert.
   * @param isInsert { Boolean } True if inserting a string, false if writing.
   * @param arg2 { Number | String } The offset to insert the string at, or the BufferEncoding to use.
   * @param encoding { String } The BufferEncoding to use for writing strings (defaults to instance encoding).
   */
  _handleString(value2, isInsert, arg3, encoding3) {
    let offsetVal = this._writeOffset;
    let encodingVal = this._encoding;
    if (typeof arg3 === "number") {
      offsetVal = arg3;
    } else if (typeof arg3 === "string") {
      utils_1.checkEncoding(arg3);
      encodingVal = arg3;
    }
    if (typeof encoding3 === "string") {
      utils_1.checkEncoding(encoding3);
      encodingVal = encoding3;
    }
    const byteLength = Buffer.byteLength(value2, encodingVal);
    if (isInsert) {
      this.ensureInsertable(byteLength, offsetVal);
    } else {
      this._ensureWriteable(byteLength, offsetVal);
    }
    this._buff.write(value2, offsetVal, byteLength, encodingVal);
    if (isInsert) {
      this._writeOffset += byteLength;
    } else {
      if (typeof arg3 === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + byteLength);
      } else {
        this._writeOffset += byteLength;
      }
    }
    return this;
  }
  /**
   * Handles writing or insert of a Buffer.
   *
   * @param value { Buffer } The Buffer to write.
   * @param offset { Number } The offset to write the Buffer to.
   */
  _handleBuffer(value2, isInsert, offset) {
    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
    if (isInsert) {
      this.ensureInsertable(value2.length, offsetVal);
    } else {
      this._ensureWriteable(value2.length, offsetVal);
    }
    value2.copy(this._buff, offsetVal);
    if (isInsert) {
      this._writeOffset += value2.length;
    } else {
      if (typeof offset === "number") {
        this._writeOffset = Math.max(this._writeOffset, offsetVal + value2.length);
      } else {
        this._writeOffset += value2.length;
      }
    }
    return this;
  }
  /**
   * Ensures that the internal Buffer is large enough to read data.
   *
   * @param length { Number } The length of the data that needs to be read.
   * @param offset { Number } The offset of the data that needs to be read.
   */
  ensureReadable(length, offset) {
    let offsetVal = this._readOffset;
    if (typeof offset !== "undefined") {
      utils_1.checkOffsetValue(offset);
      offsetVal = offset;
    }
    if (offsetVal < 0 || offsetVal + length > this.length) {
      throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
    }
  }
  /**
   * Ensures that the internal Buffer is large enough to insert data.
   *
   * @param dataLength { Number } The length of the data that needs to be written.
   * @param offset { Number } The offset of the data to be written.
   */
  ensureInsertable(dataLength, offset) {
    utils_1.checkOffsetValue(offset);
    this._ensureCapacity(this.length + dataLength);
    if (offset < this.length) {
      this._buff.copy(this._buff, offset + dataLength, offset, this._buff.length);
    }
    if (offset + dataLength > this.length) {
      this.length = offset + dataLength;
    } else {
      this.length += dataLength;
    }
  }
  /**
   * Ensures that the internal Buffer is large enough to write data.
   *
   * @param dataLength { Number } The length of the data that needs to be written.
   * @param offset { Number } The offset of the data to be written (defaults to writeOffset).
   */
  _ensureWriteable(dataLength, offset) {
    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
    this._ensureCapacity(offsetVal + dataLength);
    if (offsetVal + dataLength > this.length) {
      this.length = offsetVal + dataLength;
    }
  }
  /**
   * Ensures that the internal Buffer is large enough to write at least the given amount of data.
   *
   * @param minLength { Number } The minimum length of the data needs to be written.
   */
  _ensureCapacity(minLength) {
    const oldLength = this._buff.length;
    if (minLength > oldLength) {
      let data2 = this._buff;
      let newLength = oldLength * 3 / 2 + 1;
      if (newLength < minLength) {
        newLength = minLength;
      }
      this._buff = Buffer.allocUnsafe(newLength);
      data2.copy(this._buff, 0, 0, oldLength);
    }
  }
  /**
   * Reads a numeric number value using the provided function.
   *
   * @typeparam T { number | bigint } The type of the value to be read
   *
   * @param func { Function(offset: number) => number } The function to read data on the internal Buffer with.
   * @param byteSize { Number } The number of bytes read.
   * @param offset { Number } The offset to read from (optional). When this is not provided, the managed readOffset is used instead.
   *
   * @returns { T } the number value
   */
  _readNumberValue(func, byteSize, offset) {
    this.ensureReadable(byteSize, offset);
    const value2 = func.call(this._buff, typeof offset === "number" ? offset : this._readOffset);
    if (typeof offset === "undefined") {
      this._readOffset += byteSize;
    }
    return value2;
  }
  /**
   * Inserts a numeric number value based on the given offset and value.
   *
   * @typeparam T { number | bigint } The type of the value to be written
   *
   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
   * @param byteSize { Number } The number of bytes written.
   * @param value { T } The number value to write.
   * @param offset { Number } the offset to write the number at (REQUIRED).
   *
   * @returns SmartBuffer this buffer
   */
  _insertNumberValue(func, byteSize, value2, offset) {
    utils_1.checkOffsetValue(offset);
    this.ensureInsertable(byteSize, offset);
    func.call(this._buff, value2, offset);
    this._writeOffset += byteSize;
    return this;
  }
  /**
   * Writes a numeric number value based on the given offset and value.
   *
   * @typeparam T { number | bigint } The type of the value to be written
   *
   * @param func { Function(offset: T, offset?) => number} The function to write data on the internal Buffer with.
   * @param byteSize { Number } The number of bytes written.
   * @param value { T } The number value to write.
   * @param offset { Number } the offset to write the number at (REQUIRED).
   *
   * @returns SmartBuffer this buffer
   */
  _writeNumberValue(func, byteSize, value2, offset) {
    if (typeof offset === "number") {
      if (offset < 0) {
        throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
      }
      utils_1.checkOffsetValue(offset);
    }
    const offsetVal = typeof offset === "number" ? offset : this._writeOffset;
    this._ensureWriteable(byteSize, offsetVal);
    func.call(this._buff, value2, offsetVal);
    if (typeof offset === "number") {
      this._writeOffset = Math.max(this._writeOffset, offsetVal + byteSize);
    } else {
      this._writeOffset += byteSize;
    }
    return this;
  }
}
smartbuffer.SmartBuffer = SmartBuffer;
var constants$4 = {};
Object.defineProperty(constants$4, "__esModule", { value: true });
constants$4.SOCKS5_NO_ACCEPTABLE_AUTH = constants$4.SOCKS5_CUSTOM_AUTH_END = constants$4.SOCKS5_CUSTOM_AUTH_START = constants$4.SOCKS_INCOMING_PACKET_SIZES = constants$4.SocksClientState = constants$4.Socks5Response = constants$4.Socks5HostType = constants$4.Socks5Auth = constants$4.Socks4Response = constants$4.SocksCommand = constants$4.ERRORS = constants$4.DEFAULT_TIMEOUT = void 0;
const DEFAULT_TIMEOUT = 3e4;
constants$4.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
const ERRORS = {
  InvalidSocksCommand: "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
  InvalidSocksCommandForOperation: "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
  InvalidSocksCommandChain: "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
  InvalidSocksClientOptionsDestination: "An invalid destination host was provided.",
  InvalidSocksClientOptionsExistingSocket: "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
  InvalidSocksClientOptionsProxy: "Invalid SOCKS proxy details were provided.",
  InvalidSocksClientOptionsTimeout: "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
  InvalidSocksClientOptionsProxiesLength: "At least two socks proxies must be provided for chaining.",
  InvalidSocksClientOptionsCustomAuthRange: "Custom auth must be a value between 0x80 and 0xFE.",
  InvalidSocksClientOptionsCustomAuthOptions: "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
  NegotiationError: "Negotiation error",
  SocketClosed: "Socket closed",
  ProxyConnectionTimedOut: "Proxy connection timed out",
  InternalError: "SocksClient internal error (this should not happen)",
  InvalidSocks4HandshakeResponse: "Received invalid Socks4 handshake response",
  Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
  InvalidSocks4IncomingConnectionResponse: "Socks4 invalid incoming connection response",
  Socks4ProxyRejectedIncomingBoundConnection: "Socks4 Proxy rejected incoming bound connection",
  InvalidSocks5InitialHandshakeResponse: "Received invalid Socks5 initial handshake response",
  InvalidSocks5IntiailHandshakeSocksVersion: "Received invalid Socks5 initial handshake (invalid socks version)",
  InvalidSocks5InitialHandshakeNoAcceptedAuthType: "Received invalid Socks5 initial handshake (no accepted authentication type)",
  InvalidSocks5InitialHandshakeUnknownAuthType: "Received invalid Socks5 initial handshake (unknown authentication type)",
  Socks5AuthenticationFailed: "Socks5 Authentication failed",
  InvalidSocks5FinalHandshake: "Received invalid Socks5 final handshake response",
  InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
  InvalidSocks5IncomingConnectionResponse: "Received invalid Socks5 incoming connection response",
  Socks5ProxyRejectedIncomingBoundConnection: "Socks5 Proxy rejected incoming bound connection"
};
constants$4.ERRORS = ERRORS;
const SOCKS_INCOMING_PACKET_SIZES = {
  Socks5InitialHandshakeResponse: 2,
  Socks5UserPassAuthenticationResponse: 2,
  // Command response + incoming connection (bind)
  Socks5ResponseHeader: 5,
  // We need at least 5 to read the hostname length, then we wait for the address+port information.
  Socks5ResponseIPv4: 10,
  // 4 header + 4 ip + 2 port
  Socks5ResponseIPv6: 22,
  // 4 header + 16 ip + 2 port
  Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
  // 4 header + 1 host length + host + 2 port
  // Command response + incoming connection (bind)
  Socks4Response: 8
  // 2 header + 2 port + 4 ip
};
constants$4.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
var SocksCommand;
(function(SocksCommand2) {
  SocksCommand2[SocksCommand2["connect"] = 1] = "connect";
  SocksCommand2[SocksCommand2["bind"] = 2] = "bind";
  SocksCommand2[SocksCommand2["associate"] = 3] = "associate";
})(SocksCommand || (constants$4.SocksCommand = SocksCommand = {}));
var Socks4Response;
(function(Socks4Response2) {
  Socks4Response2[Socks4Response2["Granted"] = 90] = "Granted";
  Socks4Response2[Socks4Response2["Failed"] = 91] = "Failed";
  Socks4Response2[Socks4Response2["Rejected"] = 92] = "Rejected";
  Socks4Response2[Socks4Response2["RejectedIdent"] = 93] = "RejectedIdent";
})(Socks4Response || (constants$4.Socks4Response = Socks4Response = {}));
var Socks5Auth;
(function(Socks5Auth2) {
  Socks5Auth2[Socks5Auth2["NoAuth"] = 0] = "NoAuth";
  Socks5Auth2[Socks5Auth2["GSSApi"] = 1] = "GSSApi";
  Socks5Auth2[Socks5Auth2["UserPass"] = 2] = "UserPass";
})(Socks5Auth || (constants$4.Socks5Auth = Socks5Auth = {}));
const SOCKS5_CUSTOM_AUTH_START = 128;
constants$4.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
const SOCKS5_CUSTOM_AUTH_END = 254;
constants$4.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
const SOCKS5_NO_ACCEPTABLE_AUTH = 255;
constants$4.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
var Socks5Response;
(function(Socks5Response2) {
  Socks5Response2[Socks5Response2["Granted"] = 0] = "Granted";
  Socks5Response2[Socks5Response2["Failure"] = 1] = "Failure";
  Socks5Response2[Socks5Response2["NotAllowed"] = 2] = "NotAllowed";
  Socks5Response2[Socks5Response2["NetworkUnreachable"] = 3] = "NetworkUnreachable";
  Socks5Response2[Socks5Response2["HostUnreachable"] = 4] = "HostUnreachable";
  Socks5Response2[Socks5Response2["ConnectionRefused"] = 5] = "ConnectionRefused";
  Socks5Response2[Socks5Response2["TTLExpired"] = 6] = "TTLExpired";
  Socks5Response2[Socks5Response2["CommandNotSupported"] = 7] = "CommandNotSupported";
  Socks5Response2[Socks5Response2["AddressNotSupported"] = 8] = "AddressNotSupported";
})(Socks5Response || (constants$4.Socks5Response = Socks5Response = {}));
var Socks5HostType;
(function(Socks5HostType2) {
  Socks5HostType2[Socks5HostType2["IPv4"] = 1] = "IPv4";
  Socks5HostType2[Socks5HostType2["Hostname"] = 3] = "Hostname";
  Socks5HostType2[Socks5HostType2["IPv6"] = 4] = "IPv6";
})(Socks5HostType || (constants$4.Socks5HostType = Socks5HostType = {}));
var SocksClientState;
(function(SocksClientState2) {
  SocksClientState2[SocksClientState2["Created"] = 0] = "Created";
  SocksClientState2[SocksClientState2["Connecting"] = 1] = "Connecting";
  SocksClientState2[SocksClientState2["Connected"] = 2] = "Connected";
  SocksClientState2[SocksClientState2["SentInitialHandshake"] = 3] = "SentInitialHandshake";
  SocksClientState2[SocksClientState2["ReceivedInitialHandshakeResponse"] = 4] = "ReceivedInitialHandshakeResponse";
  SocksClientState2[SocksClientState2["SentAuthentication"] = 5] = "SentAuthentication";
  SocksClientState2[SocksClientState2["ReceivedAuthenticationResponse"] = 6] = "ReceivedAuthenticationResponse";
  SocksClientState2[SocksClientState2["SentFinalHandshake"] = 7] = "SentFinalHandshake";
  SocksClientState2[SocksClientState2["ReceivedFinalResponse"] = 8] = "ReceivedFinalResponse";
  SocksClientState2[SocksClientState2["BoundWaitingForConnection"] = 9] = "BoundWaitingForConnection";
  SocksClientState2[SocksClientState2["Established"] = 10] = "Established";
  SocksClientState2[SocksClientState2["Disconnected"] = 11] = "Disconnected";
  SocksClientState2[SocksClientState2["Error"] = 99] = "Error";
})(SocksClientState || (constants$4.SocksClientState = SocksClientState = {}));
var helpers$3 = {};
var util$5 = {};
Object.defineProperty(util$5, "__esModule", { value: true });
util$5.shuffleArray = util$5.SocksClientError = void 0;
class SocksClientError extends Error {
  constructor(message, options) {
    super(message);
    this.options = options;
  }
}
util$5.SocksClientError = SocksClientError;
function shuffleArray(array2) {
  for (let i = array2.length - 1; i > 0; i--) {
    const j2 = Math.floor(Math.random() * (i + 1));
    [array2[i], array2[j2]] = [array2[j2], array2[i]];
  }
}
util$5.shuffleArray = shuffleArray;
var ipAddress = {};
var ipv4 = {};
var common$3 = {};
Object.defineProperty(common$3, "__esModule", { value: true });
common$3.isCorrect = common$3.isInSubnet = void 0;
function isInSubnet(address) {
  if (this.subnetMask < address.subnetMask) {
    return false;
  }
  if (this.mask(address.subnetMask) === address.mask()) {
    return true;
  }
  return false;
}
common$3.isInSubnet = isInSubnet;
function isCorrect(defaultBits) {
  return function() {
    if (this.addressMinusSuffix !== this.correctForm()) {
      return false;
    }
    if (this.subnetMask === defaultBits && !this.parsedSubnet) {
      return true;
    }
    return this.parsedSubnet === String(this.subnetMask);
  };
}
common$3.isCorrect = isCorrect;
var constants$3 = {};
Object.defineProperty(constants$3, "__esModule", { value: true });
constants$3.RE_SUBNET_STRING = constants$3.RE_ADDRESS = constants$3.GROUPS = constants$3.BITS = void 0;
constants$3.BITS = 32;
constants$3.GROUPS = 4;
constants$3.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
constants$3.RE_SUBNET_STRING = /\/\d{1,2}$/;
var addressError = {};
Object.defineProperty(addressError, "__esModule", { value: true });
addressError.AddressError = void 0;
class AddressError extends Error {
  constructor(message, parseMessage) {
    super(message);
    this.name = "AddressError";
    if (parseMessage !== null) {
      this.parseMessage = parseMessage;
    }
  }
}
addressError.AddressError = AddressError;
var jsbn = { exports: {} };
(function(module2, exports) {
  (function() {
    var dbits2;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger2(a, b, c) {
      if (a != null)
        if ("number" == typeof a) this.fromNumber(a, b, c);
        else if (b == null && "string" != typeof a) this.fromString(a, 256);
        else this.fromString(a, b);
    }
    function nbi2() {
      return new BigInteger2(null);
    }
    function am12(i, x, w2, j2, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w2[j2] + c;
        c = Math.floor(v / 67108864);
        w2[j2++] = v & 67108863;
      }
      return c;
    }
    function am22(i, x, w2, j2, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this[i] & 32767;
        var h2 = this[i++] >> 15;
        var m2 = xh * l + h2 * xl;
        l = xl * l + ((m2 & 32767) << 15) + w2[j2] + (c & 1073741823);
        c = (l >>> 30) + (m2 >>> 15) + xh * h2 + (c >>> 30);
        w2[j2++] = l & 1073741823;
      }
      return c;
    }
    function am32(i, x, w2, j2, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h2 = this[i++] >> 14;
        var m2 = xh * l + h2 * xl;
        l = xl * l + ((m2 & 16383) << 14) + w2[j2] + c;
        c = (l >> 28) + (m2 >> 14) + xh * h2;
        w2[j2++] = l & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger2.prototype.am = am22;
      dbits2 = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger2.prototype.am = am12;
      dbits2 = 26;
    } else {
      BigInteger2.prototype.am = am32;
      dbits2 = 28;
    }
    BigInteger2.prototype.DB = dbits2;
    BigInteger2.prototype.DM = (1 << dbits2) - 1;
    BigInteger2.prototype.DV = 1 << dbits2;
    var BI_FP2 = 52;
    BigInteger2.prototype.FV = Math.pow(2, BI_FP2);
    BigInteger2.prototype.F1 = BI_FP2 - dbits2;
    BigInteger2.prototype.F2 = 2 * dbits2 - BI_FP2;
    var BI_RM2 = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC2 = new Array();
    var rr2, vv2;
    rr2 = "0".charCodeAt(0);
    for (vv2 = 0; vv2 <= 9; ++vv2) BI_RC2[rr2++] = vv2;
    rr2 = "a".charCodeAt(0);
    for (vv2 = 10; vv2 < 36; ++vv2) BI_RC2[rr2++] = vv2;
    rr2 = "A".charCodeAt(0);
    for (vv2 = 10; vv2 < 36; ++vv2) BI_RC2[rr2++] = vv2;
    function int2char2(n) {
      return BI_RM2.charAt(n);
    }
    function intAt2(s2, i) {
      var c = BI_RC2[s2.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo2(r) {
      for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt2(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0) this[0] = x;
      else if (x < -1) this[0] = x + this.DV;
      else this.t = 0;
    }
    function nbv2(i) {
      var r = nbi2();
      r.fromInt(i);
      return r;
    }
    function bnpFromString2(s2, b) {
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 256) k = 8;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else {
        this.fromRadix(s2, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s2.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s2[i] & 255 : intAt2(s2, i);
        if (x < 0) {
          if (s2.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB) sh -= this.DB;
      }
      if (k == 8 && (s2[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0) this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi) BigInteger2.ZERO.subTo(this, this);
    }
    function bnpClamp2() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c) --this.t;
    }
    function bnToString2(b) {
      if (this.s < 0) return "-" + this.negate().toString(b);
      var k;
      if (b == 16) k = 4;
      else if (b == 8) k = 3;
      else if (b == 2) k = 1;
      else if (b == 32) k = 5;
      else if (b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1 << k) - 1, d2, m2 = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d2 = this[i] >> p) > 0) {
          m2 = true;
          r = int2char2(d2);
        }
        while (i >= 0) {
          if (p < k) {
            d2 = (this[i] & (1 << p) - 1) << k - p;
            d2 |= this[--i] >> (p += this.DB - k);
          } else {
            d2 = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d2 > 0) m2 = true;
          if (m2) r += int2char2(d2);
        }
      }
      return m2 ? r : "0";
    }
    function bnNegate2() {
      var r = nbi2();
      BigInteger2.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs2() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo2(a) {
      var r = this.s - a.s;
      if (r != 0) return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0) return this.s < 0 ? -r : r;
      while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
      return 0;
    }
    function nbits2(x) {
      var r = 1, t3;
      if ((t3 = x >>> 16) != 0) {
        x = t3;
        r += 16;
      }
      if ((t3 = x >> 8) != 0) {
        x = t3;
        r += 8;
      }
      if ((t3 = x >> 4) != 0) {
        x = t3;
        r += 4;
      }
      if ((t3 = x >> 2) != 0) {
        x = t3;
        r += 2;
      }
      if ((t3 = x >> 1) != 0) {
        x = t3;
        r += 1;
      }
      return r;
    }
    function bnBitLength2() {
      if (this.t <= 0) return 0;
      return this.DB * (this.t - 1) + nbits2(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo2(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
      for (i = n - 1; i >= 0; --i) r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo2(n, r) {
      for (var i = n; i < this.t; ++i) r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo2(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo2(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo2(a, r) {
      var i = 0, c = 0, m2 = Math.min(a.t, this.t);
      while (i < m2) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1) r[i++] = this.DV + c;
      else if (c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo2(a, r) {
      var x = this.abs(), y2 = a.abs();
      var i = x.t;
      r.t = i + y2.t;
      while (--i >= 0) r[i] = 0;
      for (i = 0; i < y2.t; ++i) r[i + x.t] = x.am(0, y2[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s) BigInteger2.ZERO.subTo(r, r);
    }
    function bnpSquareTo2(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0) r[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo2(m2, q, r) {
      var pm = m2.abs();
      if (pm.t <= 0) return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null) q.fromInt(0);
        if (r != null) this.copyTo(r);
        return;
      }
      if (r == null) r = nbi2();
      var y2 = nbi2(), ts = this.s, ms2 = m2.s;
      var nsh = this.DB - nbits2(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y2);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y2);
        pt.copyTo(r);
      }
      var ys = y2.t;
      var y0 = y2[ys - 1];
      if (y0 == 0) return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y2[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j2 = i - ys, t3 = q == null ? nbi2() : q;
      y2.dlShiftTo(j2, t3);
      if (r.compareTo(t3) >= 0) {
        r[r.t++] = 1;
        r.subTo(t3, r);
      }
      BigInteger2.ONE.dlShiftTo(ys, t3);
      t3.subTo(y2, y2);
      while (y2.t < ys) y2[y2.t++] = 0;
      while (--j2 >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y2.am(0, qd, r, j2, 0, ys)) < qd) {
          y2.dlShiftTo(j2, t3);
          r.subTo(t3, r);
          while (r[i] < --qd) r.subTo(t3, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms2) BigInteger2.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0) r.rShiftTo(nsh, r);
      if (ts < 0) BigInteger2.ZERO.subTo(r, r);
    }
    function bnMod2(a) {
      var r = nbi2();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger2.ZERO) > 0) a.subTo(r, r);
      return r;
    }
    function Classic2(m2) {
      this.m = m2;
    }
    function cConvert2(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert2(x) {
      return x;
    }
    function cReduce2(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo2(x, y2, r) {
      x.multiplyTo(y2, r);
      this.reduce(r);
    }
    function cSqrTo2(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic2.prototype.convert = cConvert2;
    Classic2.prototype.revert = cRevert2;
    Classic2.prototype.reduce = cReduce2;
    Classic2.prototype.mulTo = cMulTo2;
    Classic2.prototype.sqrTo = cSqrTo2;
    function bnpInvDigit2() {
      if (this.t < 1) return 0;
      var x = this[0];
      if ((x & 1) == 0) return 0;
      var y2 = x & 3;
      y2 = y2 * (2 - (x & 15) * y2) & 15;
      y2 = y2 * (2 - (x & 255) * y2) & 255;
      y2 = y2 * (2 - ((x & 65535) * y2 & 65535)) & 65535;
      y2 = y2 * (2 - x * y2 % this.DV) % this.DV;
      return y2 > 0 ? this.DV - y2 : -y2;
    }
    function Montgomery2(m2) {
      this.m = m2;
      this.mp = m2.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m2.DB - 15) - 1;
      this.mt2 = 2 * m2.t;
    }
    function montConvert2(x) {
      var r = nbi2();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger2.ZERO) > 0) this.m.subTo(r, r);
      return r;
    }
    function montRevert2(x) {
      var r = nbi2();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce2(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j2 = x[i] & 32767;
        var u0 = j2 * this.mpl + ((j2 * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j2 = i + this.m.t;
        x[j2] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j2] >= x.DV) {
          x[j2] -= x.DV;
          x[++j2]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function montSqrTo2(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo2(x, y2, r) {
      x.multiplyTo(y2, r);
      this.reduce(r);
    }
    Montgomery2.prototype.convert = montConvert2;
    Montgomery2.prototype.revert = montRevert2;
    Montgomery2.prototype.reduce = montReduce2;
    Montgomery2.prototype.mulTo = montMulTo2;
    Montgomery2.prototype.sqrTo = montSqrTo2;
    function bnpIsEven2() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp2(e, z2) {
      if (e > 4294967295 || e < 1) return BigInteger2.ONE;
      var r = nbi2(), r2 = nbi2(), g = z2.convert(this), i = nbits2(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0) z2.mulTo(r2, g, r);
        else {
          var t3 = r;
          r = r2;
          r2 = t3;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt2(e, m2) {
      var z2;
      if (e < 256 || m2.isEven()) z2 = new Classic2(m2);
      else z2 = new Montgomery2(m2);
      return this.exp(e, z2);
    }
    BigInteger2.prototype.copyTo = bnpCopyTo2;
    BigInteger2.prototype.fromInt = bnpFromInt2;
    BigInteger2.prototype.fromString = bnpFromString2;
    BigInteger2.prototype.clamp = bnpClamp2;
    BigInteger2.prototype.dlShiftTo = bnpDLShiftTo2;
    BigInteger2.prototype.drShiftTo = bnpDRShiftTo2;
    BigInteger2.prototype.lShiftTo = bnpLShiftTo2;
    BigInteger2.prototype.rShiftTo = bnpRShiftTo2;
    BigInteger2.prototype.subTo = bnpSubTo2;
    BigInteger2.prototype.multiplyTo = bnpMultiplyTo2;
    BigInteger2.prototype.squareTo = bnpSquareTo2;
    BigInteger2.prototype.divRemTo = bnpDivRemTo2;
    BigInteger2.prototype.invDigit = bnpInvDigit2;
    BigInteger2.prototype.isEven = bnpIsEven2;
    BigInteger2.prototype.exp = bnpExp2;
    BigInteger2.prototype.toString = bnToString2;
    BigInteger2.prototype.negate = bnNegate2;
    BigInteger2.prototype.abs = bnAbs2;
    BigInteger2.prototype.compareTo = bnCompareTo2;
    BigInteger2.prototype.bitLength = bnBitLength2;
    BigInteger2.prototype.mod = bnMod2;
    BigInteger2.prototype.modPowInt = bnModPowInt2;
    BigInteger2.ZERO = nbv2(0);
    BigInteger2.ONE = nbv2(1);
    function bnClone2() {
      var r = nbi2();
      this.copyTo(r);
      return r;
    }
    function bnIntValue2() {
      if (this.s < 0) {
        if (this.t == 1) return this[0] - this.DV;
        else if (this.t == 0) return -1;
      } else if (this.t == 1) return this[0];
      else if (this.t == 0) return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue2() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue2() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize2(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum2() {
      if (this.s < 0) return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0) return 0;
      else return 1;
    }
    function bnpToRadix2(b) {
      if (b == null) b = 10;
      if (this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d2 = nbv2(a), y2 = nbi2(), z2 = nbi2(), r = "";
      this.divRemTo(d2, y2, z2);
      while (y2.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y2.divRemTo(d2, y2, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix2(s2, b) {
      this.fromInt(0);
      if (b == null) b = 10;
      var cs = this.chunkSize(b);
      var d2 = Math.pow(b, cs), mi = false, j2 = 0, w2 = 0;
      for (var i = 0; i < s2.length; ++i) {
        var x = intAt2(s2, i);
        if (x < 0) {
          if (s2.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w2 = b * w2 + x;
        if (++j2 >= cs) {
          this.dMultiply(d2);
          this.dAddOffset(w2, 0);
          j2 = 0;
          w2 = 0;
        }
      }
      if (j2 > 0) {
        this.dMultiply(Math.pow(b, j2));
        this.dAddOffset(w2, 0);
      }
      if (mi) BigInteger2.ZERO.subTo(this, this);
    }
    function bnpFromNumber2(a, b, c) {
      if ("number" == typeof b) {
        if (a < 2) this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger2.ONE.shiftLeft(a - 1), op_or2, this);
          if (this.isEven()) this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a) this.subTo(BigInteger2.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t3 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t3 > 0) x[0] &= (1 << t3) - 1;
        else x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray2() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d2, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d2 = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d2 | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d2 = (this[i] & (1 << p) - 1) << 8 - p;
            d2 |= this[--i] >> (p += this.DB - 8);
          } else {
            d2 = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d2 & 128) != 0) d2 |= -256;
          if (k == 0 && (this.s & 128) != (d2 & 128)) ++k;
          if (k > 0 || d2 != this.s) r[k++] = d2;
        }
      }
      return r;
    }
    function bnEquals2(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin2(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax2(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo2(a, op, r) {
      var i, f, m2 = Math.min(a.t, this.t);
      for (i = 0; i < m2; ++i) r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m2; i < this.t; ++i) r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m2; i < a.t; ++i) r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and2(x, y2) {
      return x & y2;
    }
    function bnAnd2(a) {
      var r = nbi2();
      this.bitwiseTo(a, op_and2, r);
      return r;
    }
    function op_or2(x, y2) {
      return x | y2;
    }
    function bnOr2(a) {
      var r = nbi2();
      this.bitwiseTo(a, op_or2, r);
      return r;
    }
    function op_xor2(x, y2) {
      return x ^ y2;
    }
    function bnXor2(a) {
      var r = nbi2();
      this.bitwiseTo(a, op_xor2, r);
      return r;
    }
    function op_andnot2(x, y2) {
      return x & ~y2;
    }
    function bnAndNot2(a) {
      var r = nbi2();
      this.bitwiseTo(a, op_andnot2, r);
      return r;
    }
    function bnNot2() {
      var r = nbi2();
      for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft2(n) {
      var r = nbi2();
      if (n < 0) this.rShiftTo(-n, r);
      else this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight2(n) {
      var r = nbi2();
      if (n < 0) this.lShiftTo(-n, r);
      else this.rShiftTo(n, r);
      return r;
    }
    function lbit2(x) {
      if (x == 0) return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0) ++r;
      return r;
    }
    function bnGetLowestSetBit2() {
      for (var i = 0; i < this.t; ++i)
        if (this[i] != 0) return i * this.DB + lbit2(this[i]);
      if (this.s < 0) return this.t * this.DB;
      return -1;
    }
    function cbit2(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount2() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i) r += cbit2(this[i] ^ x);
      return r;
    }
    function bnTestBit2(n) {
      var j2 = Math.floor(n / this.DB);
      if (j2 >= this.t) return this.s != 0;
      return (this[j2] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit2(n, op) {
      var r = BigInteger2.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit2(n) {
      return this.changeBit(n, op_or2);
    }
    function bnClearBit2(n) {
      return this.changeBit(n, op_andnot2);
    }
    function bnFlipBit2(n) {
      return this.changeBit(n, op_xor2);
    }
    function bnpAddTo2(a, r) {
      var i = 0, c = 0, m2 = Math.min(a.t, this.t);
      while (i < m2) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0) r[i++] = c;
      else if (c < -1) r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd2(a) {
      var r = nbi2();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract2(a) {
      var r = nbi2();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply2(a) {
      var r = nbi2();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi2();
      this.squareTo(r);
      return r;
    }
    function bnDivide2(a) {
      var r = nbi2();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder2(a) {
      var r = nbi2();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder2(a) {
      var q = nbi2(), r = nbi2();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply2(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset2(n, w2) {
      if (n == 0) return;
      while (this.t <= w2) this[this.t++] = 0;
      this[w2] += n;
      while (this[w2] >= this.DV) {
        this[w2] -= this.DV;
        if (++w2 >= this.t) this[this.t++] = 0;
        ++this[w2];
      }
    }
    function NullExp2() {
    }
    function nNop2(x) {
      return x;
    }
    function nMulTo2(x, y2, r) {
      x.multiplyTo(y2, r);
    }
    function nSqrTo2(x, r) {
      x.squareTo(r);
    }
    NullExp2.prototype.convert = nNop2;
    NullExp2.prototype.revert = nNop2;
    NullExp2.prototype.mulTo = nMulTo2;
    NullExp2.prototype.sqrTo = nSqrTo2;
    function bnPow2(e) {
      return this.exp(e, new NullExp2());
    }
    function bnpMultiplyLowerTo2(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0) r[--i] = 0;
      var j2;
      for (j2 = r.t - this.t; i < j2; ++i) r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j2 = Math.min(a.t, n); i < j2; ++i) this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo2(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0) r[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett2(m2) {
      this.r2 = nbi2();
      this.q3 = nbi2();
      BigInteger2.ONE.dlShiftTo(2 * m2.t, this.r2);
      this.mu = this.r2.divide(m2);
      this.m = m2;
    }
    function barrettConvert2(x) {
      if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
      else if (x.compareTo(this.m) < 0) return x;
      else {
        var r = nbi2();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert2(x) {
      return x;
    }
    function barrettReduce2(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
    }
    function barrettSqrTo2(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo2(x, y2, r) {
      x.multiplyTo(y2, r);
      this.reduce(r);
    }
    Barrett2.prototype.convert = barrettConvert2;
    Barrett2.prototype.revert = barrettRevert2;
    Barrett2.prototype.reduce = barrettReduce2;
    Barrett2.prototype.mulTo = barrettMulTo2;
    Barrett2.prototype.sqrTo = barrettSqrTo2;
    function bnModPow2(e, m2) {
      var i = e.bitLength(), k, r = nbv2(1), z2;
      if (i <= 0) return r;
      else if (i < 18) k = 1;
      else if (i < 48) k = 3;
      else if (i < 144) k = 4;
      else if (i < 768) k = 5;
      else k = 6;
      if (i < 8)
        z2 = new Classic2(m2);
      else if (m2.isEven())
        z2 = new Barrett2(m2);
      else
        z2 = new Montgomery2(m2);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi2();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi2();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j2 = e.t - 1, w2, is1 = true, r2 = nbi2(), t3;
      i = nbits2(e[j2]) - 1;
      while (j2 >= 0) {
        if (i >= k1) w2 = e[j2] >> i - k1 & km;
        else {
          w2 = (e[j2] & (1 << i + 1) - 1) << k1 - i;
          if (j2 > 0) w2 |= e[j2 - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w2 & 1) == 0) {
          w2 >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j2;
        }
        if (is1) {
          g[w2].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0) z2.sqrTo(r, r2);
          else {
            t3 = r;
            r = r2;
            r2 = t3;
          }
          z2.mulTo(r2, g[w2], r);
        }
        while (j2 >= 0 && (e[j2] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t3 = r;
          r = r2;
          r2 = t3;
          if (--i < 0) {
            i = this.DB - 1;
            --j2;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD2(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y2 = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y2) < 0) {
        var t3 = x;
        x = y2;
        y2 = t3;
      }
      var i = x.getLowestSetBit(), g = y2.getLowestSetBit();
      if (g < 0) return x;
      if (i < g) g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y2.rShiftTo(g, y2);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
        if ((i = y2.getLowestSetBit()) > 0) y2.rShiftTo(i, y2);
        if (x.compareTo(y2) >= 0) {
          x.subTo(y2, x);
          x.rShiftTo(1, x);
        } else {
          y2.subTo(x, y2);
          y2.rShiftTo(1, y2);
        }
      }
      if (g > 0) y2.lShiftTo(g, y2);
      return y2;
    }
    function bnpModInt2(n) {
      if (n <= 0) return 0;
      var d2 = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d2 == 0) r = this[0] % n;
        else for (var i = this.t - 1; i >= 0; --i) r = (d2 * r + this[i]) % n;
      return r;
    }
    function bnModInverse2(m2) {
      var ac = m2.isEven();
      if (this.isEven() && ac || m2.signum() == 0) return BigInteger2.ZERO;
      var u2 = m2.clone(), v = this.clone();
      var a = nbv2(1), b = nbv2(0), c = nbv2(0), d2 = nbv2(1);
      while (u2.signum() != 0) {
        while (u2.isEven()) {
          u2.rShiftTo(1, u2);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m2, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven()) b.subTo(m2, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d2.isEven()) {
              c.addTo(this, c);
              d2.subTo(m2, d2);
            }
            c.rShiftTo(1, c);
          } else if (!d2.isEven()) d2.subTo(m2, d2);
          d2.rShiftTo(1, d2);
        }
        if (u2.compareTo(v) >= 0) {
          u2.subTo(v, u2);
          if (ac) a.subTo(c, a);
          b.subTo(d2, b);
        } else {
          v.subTo(u2, v);
          if (ac) c.subTo(a, c);
          d2.subTo(b, d2);
        }
      }
      if (v.compareTo(BigInteger2.ONE) != 0) return BigInteger2.ZERO;
      if (d2.compareTo(m2) >= 0) return d2.subtract(m2);
      if (d2.signum() < 0) d2.addTo(m2, d2);
      else return d2;
      if (d2.signum() < 0) return d2.add(m2);
      else return d2;
    }
    var lowprimes2 = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim2 = (1 << 26) / lowprimes2[lowprimes2.length - 1];
    function bnIsProbablePrime2(t3) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes2[lowprimes2.length - 1]) {
        for (i = 0; i < lowprimes2.length; ++i)
          if (x[0] == lowprimes2[i]) return true;
        return false;
      }
      if (x.isEven()) return false;
      i = 1;
      while (i < lowprimes2.length) {
        var m2 = lowprimes2[i], j2 = i + 1;
        while (j2 < lowprimes2.length && m2 < lplim2) m2 *= lowprimes2[j2++];
        m2 = x.modInt(m2);
        while (i < j2) if (m2 % lowprimes2[i++] == 0) return false;
      }
      return x.millerRabin(t3);
    }
    function bnpMillerRabin2(t3) {
      var n1 = this.subtract(BigInteger2.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0) return false;
      var r = n1.shiftRight(k);
      t3 = t3 + 1 >> 1;
      if (t3 > lowprimes2.length) t3 = lowprimes2.length;
      var a = nbi2();
      for (var i = 0; i < t3; ++i) {
        a.fromInt(lowprimes2[Math.floor(Math.random() * lowprimes2.length)]);
        var y2 = a.modPow(r, this);
        if (y2.compareTo(BigInteger2.ONE) != 0 && y2.compareTo(n1) != 0) {
          var j2 = 1;
          while (j2++ < k && y2.compareTo(n1) != 0) {
            y2 = y2.modPowInt(2, this);
            if (y2.compareTo(BigInteger2.ONE) == 0) return false;
          }
          if (y2.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }
    BigInteger2.prototype.chunkSize = bnpChunkSize2;
    BigInteger2.prototype.toRadix = bnpToRadix2;
    BigInteger2.prototype.fromRadix = bnpFromRadix2;
    BigInteger2.prototype.fromNumber = bnpFromNumber2;
    BigInteger2.prototype.bitwiseTo = bnpBitwiseTo2;
    BigInteger2.prototype.changeBit = bnpChangeBit2;
    BigInteger2.prototype.addTo = bnpAddTo2;
    BigInteger2.prototype.dMultiply = bnpDMultiply2;
    BigInteger2.prototype.dAddOffset = bnpDAddOffset2;
    BigInteger2.prototype.multiplyLowerTo = bnpMultiplyLowerTo2;
    BigInteger2.prototype.multiplyUpperTo = bnpMultiplyUpperTo2;
    BigInteger2.prototype.modInt = bnpModInt2;
    BigInteger2.prototype.millerRabin = bnpMillerRabin2;
    BigInteger2.prototype.clone = bnClone2;
    BigInteger2.prototype.intValue = bnIntValue2;
    BigInteger2.prototype.byteValue = bnByteValue2;
    BigInteger2.prototype.shortValue = bnShortValue2;
    BigInteger2.prototype.signum = bnSigNum2;
    BigInteger2.prototype.toByteArray = bnToByteArray2;
    BigInteger2.prototype.equals = bnEquals2;
    BigInteger2.prototype.min = bnMin2;
    BigInteger2.prototype.max = bnMax2;
    BigInteger2.prototype.and = bnAnd2;
    BigInteger2.prototype.or = bnOr2;
    BigInteger2.prototype.xor = bnXor2;
    BigInteger2.prototype.andNot = bnAndNot2;
    BigInteger2.prototype.not = bnNot2;
    BigInteger2.prototype.shiftLeft = bnShiftLeft2;
    BigInteger2.prototype.shiftRight = bnShiftRight2;
    BigInteger2.prototype.getLowestSetBit = bnGetLowestSetBit2;
    BigInteger2.prototype.bitCount = bnBitCount2;
    BigInteger2.prototype.testBit = bnTestBit2;
    BigInteger2.prototype.setBit = bnSetBit2;
    BigInteger2.prototype.clearBit = bnClearBit2;
    BigInteger2.prototype.flipBit = bnFlipBit2;
    BigInteger2.prototype.add = bnAdd2;
    BigInteger2.prototype.subtract = bnSubtract2;
    BigInteger2.prototype.multiply = bnMultiply2;
    BigInteger2.prototype.divide = bnDivide2;
    BigInteger2.prototype.remainder = bnRemainder2;
    BigInteger2.prototype.divideAndRemainder = bnDivideAndRemainder2;
    BigInteger2.prototype.modPow = bnModPow2;
    BigInteger2.prototype.modInverse = bnModInverse2;
    BigInteger2.prototype.pow = bnPow2;
    BigInteger2.prototype.gcd = bnGCD2;
    BigInteger2.prototype.isProbablePrime = bnIsProbablePrime2;
    BigInteger2.prototype.square = bnSquare;
    BigInteger2.prototype.Barrett = Barrett2;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= x >> 8 & 255;
      rng_pool[rng_pptr++] ^= x >> 16 & 255;
      rng_pool[rng_pptr++] ^= x >> 24 & 255;
      if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int((/* @__PURE__ */ new Date()).getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      var t2;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t2 = 0; t2 < 32; ++t2)
            rng_pool[rng_pptr++] = ua[t2];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z = window.crypto.random(32);
          for (t2 = 0; t2 < z.length; ++t2)
            rng_pool[rng_pptr++] = z.charCodeAt(t2) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t2 = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t2 >>> 8;
        rng_pool[rng_pptr++] = t2 & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
    }
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }
    function ARC4init(key) {
      var i, j2, t3;
      for (i = 0; i < 256; ++i)
        this.S[i] = i;
      j2 = 0;
      for (i = 0; i < 256; ++i) {
        j2 = j2 + this.S[i] + key[i % key.length] & 255;
        t3 = this.S[i];
        this.S[i] = this.S[j2];
        this.S[j2] = t3;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t3;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t3 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t3;
      return this.S[t3 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour();
    }
    var rng_psize = 256;
    {
      module2.exports = {
        default: BigInteger2,
        BigInteger: BigInteger2,
        SecureRandom
      };
    }
  }).call(commonjsGlobal);
})(jsbn);
var jsbnExports = jsbn.exports;
var sprintf = {};
(function(exports) {
  !function() {
    var re = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf2(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf2.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign2;
      for (i = 0; i < tree_length; i++) {
        if (typeof parse_tree[i] === "string") {
          output += parse_tree[i];
        } else if (typeof parse_tree[i] === "object") {
          ph = parse_tree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0; k < ph.keys.length; k++) {
              if (arg == void 0) {
                throw new Error(sprintf2('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf2("[sprintf] expecting number but found %T", arg));
          }
          if (re.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign2 = is_positive ? "+" : "-";
              arg = arg.toString().replace(re.sign, "");
            } else {
              sign2 = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign2 + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign2 + arg + pad : pad_character === "0" ? sign2 + pad + arg : pad + sign2 + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = /* @__PURE__ */ Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match2, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match2 = re.text.exec(_fmt)) !== null) {
          parse_tree.push(match2[0]);
        } else if ((match2 = re.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match2 = re.placeholder.exec(_fmt)) !== null) {
          if (match2[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match2[2], field_match = [];
            if ((field_match = re.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match2[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push(
            {
              placeholder: match2[0],
              param_no: match2[1],
              keys: match2[2],
              sign: match2[3],
              pad_char: match2[4],
              align: match2[5],
              width: match2[6],
              precision: match2[7],
              type: match2[8]
            }
          );
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match2[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    {
      exports["sprintf"] = sprintf2;
      exports["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf2;
      window["vsprintf"] = vsprintf;
    }
  }();
})(sprintf);
var __createBinding$7 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$7 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$7 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$7(result, mod, k);
  }
  __setModuleDefault$7(result, mod);
  return result;
};
Object.defineProperty(ipv4, "__esModule", { value: true });
ipv4.Address4 = void 0;
const common$2 = __importStar$7(common$3);
const constants$2 = __importStar$7(constants$3);
const address_error_1$1 = addressError;
const jsbn_1$1 = jsbnExports;
const sprintf_js_1$3 = sprintf;
class Address4 {
  constructor(address) {
    this.groups = constants$2.GROUPS;
    this.parsedAddress = [];
    this.parsedSubnet = "";
    this.subnet = "/32";
    this.subnetMask = 32;
    this.v4 = true;
    this.isCorrect = common$2.isCorrect(constants$2.BITS);
    this.isInSubnet = common$2.isInSubnet;
    this.address = address;
    const subnet = constants$2.RE_SUBNET_STRING.exec(address);
    if (subnet) {
      this.parsedSubnet = subnet[0].replace("/", "");
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;
      if (this.subnetMask < 0 || this.subnetMask > constants$2.BITS) {
        throw new address_error_1$1.AddressError("Invalid subnet mask.");
      }
      address = address.replace(constants$2.RE_SUBNET_STRING, "");
    }
    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(address);
  }
  static isValid(address) {
    try {
      new Address4(address);
      return true;
    } catch (e) {
      return false;
    }
  }
  /*
   * Parses a v4 address
   */
  parse(address) {
    const groups = address.split(".");
    if (!address.match(constants$2.RE_ADDRESS)) {
      throw new address_error_1$1.AddressError("Invalid IPv4 address.");
    }
    return groups;
  }
  /**
   * Returns the correct form of an address
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  correctForm() {
    return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
  }
  /**
   * Converts a hex string to an IPv4 address object
   * @memberof Address4
   * @static
   * @param {string} hex - a hex string to convert
   * @returns {Address4}
   */
  static fromHex(hex) {
    const padded = hex.replace(/:/g, "").padStart(8, "0");
    const groups = [];
    let i;
    for (i = 0; i < 8; i += 2) {
      const h2 = padded.slice(i, i + 2);
      groups.push(parseInt(h2, 16));
    }
    return new Address4(groups.join("."));
  }
  /**
   * Converts an integer into a IPv4 address object
   * @memberof Address4
   * @static
   * @param {integer} integer - a number to convert
   * @returns {Address4}
   */
  static fromInteger(integer) {
    return Address4.fromHex(integer.toString(16));
  }
  /**
   * Return an address from in-addr.arpa form
   * @memberof Address4
   * @static
   * @param {string} arpaFormAddress - an 'in-addr.arpa' form ipv4 address
   * @returns {Adress4}
   * @example
   * var address = Address4.fromArpa(42.2.0.192.in-addr.arpa.)
   * address.correctForm(); // '192.0.2.42'
   */
  static fromArpa(arpaFormAddress) {
    const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
    const address = leader.split(".").reverse().join(".");
    return new Address4(address);
  }
  /**
   * Converts an IPv4 address object to a hex string
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  toHex() {
    return this.parsedAddress.map((part) => (0, sprintf_js_1$3.sprintf)("%02x", parseInt(part, 10))).join(":");
  }
  /**
   * Converts an IPv4 address object to an array of bytes
   * @memberof Address4
   * @instance
   * @returns {Array}
   */
  toArray() {
    return this.parsedAddress.map((part) => parseInt(part, 10));
  }
  /**
   * Converts an IPv4 address object to an IPv6 address group
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  toGroup6() {
    const output = [];
    let i;
    for (i = 0; i < constants$2.GROUPS; i += 2) {
      const hex = (0, sprintf_js_1$3.sprintf)("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
      output.push((0, sprintf_js_1$3.sprintf)("%x", parseInt(hex, 16)));
    }
    return output.join(":");
  }
  /**
   * Returns the address as a BigInteger
   * @memberof Address4
   * @instance
   * @returns {BigInteger}
   */
  bigInteger() {
    return new jsbn_1$1.BigInteger(this.parsedAddress.map((n) => (0, sprintf_js_1$3.sprintf)("%02x", parseInt(n, 10))).join(""), 16);
  }
  /**
   * Helper function getting start address.
   * @memberof Address4
   * @instance
   * @returns {BigInteger}
   */
  _startAddress() {
    return new jsbn_1$1.BigInteger(this.mask() + "0".repeat(constants$2.BITS - this.subnetMask), 2);
  }
  /**
   * The first address in the range given by this address' subnet.
   * Often referred to as the Network Address.
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  startAddress() {
    return Address4.fromBigInteger(this._startAddress());
  }
  /**
   * The first host address in the range given by this address's subnet ie
   * the first address after the Network Address
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  startAddressExclusive() {
    const adjust = new jsbn_1$1.BigInteger("1");
    return Address4.fromBigInteger(this._startAddress().add(adjust));
  }
  /**
   * Helper function getting end address.
   * @memberof Address4
   * @instance
   * @returns {BigInteger}
   */
  _endAddress() {
    return new jsbn_1$1.BigInteger(this.mask() + "1".repeat(constants$2.BITS - this.subnetMask), 2);
  }
  /**
   * The last address in the range given by this address' subnet
   * Often referred to as the Broadcast
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  endAddress() {
    return Address4.fromBigInteger(this._endAddress());
  }
  /**
   * The last host address in the range given by this address's subnet ie
   * the last address prior to the Broadcast Address
   * @memberof Address4
   * @instance
   * @returns {Address4}
   */
  endAddressExclusive() {
    const adjust = new jsbn_1$1.BigInteger("1");
    return Address4.fromBigInteger(this._endAddress().subtract(adjust));
  }
  /**
   * Converts a BigInteger to a v4 address object
   * @memberof Address4
   * @static
   * @param {BigInteger} bigInteger - a BigInteger to convert
   * @returns {Address4}
   */
  static fromBigInteger(bigInteger) {
    return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
  }
  /**
   * Returns the first n bits of the address, defaulting to the
   * subnet mask
   * @memberof Address4
   * @instance
   * @returns {String}
   */
  mask(mask) {
    if (mask === void 0) {
      mask = this.subnetMask;
    }
    return this.getBitsBase2(0, mask);
  }
  /**
   * Returns the bits in the given range as a base-2 string
   * @memberof Address4
   * @instance
   * @returns {string}
   */
  getBitsBase2(start, end) {
    return this.binaryZeroPad().slice(start, end);
  }
  /**
   * Return the reversed ip6.arpa form of the address
   * @memberof Address4
   * @param {Object} options
   * @param {boolean} options.omitSuffix - omit the "in-addr.arpa" suffix
   * @instance
   * @returns {String}
   */
  reverseForm(options) {
    if (!options) {
      options = {};
    }
    const reversed = this.correctForm().split(".").reverse().join(".");
    if (options.omitSuffix) {
      return reversed;
    }
    return (0, sprintf_js_1$3.sprintf)("%s.in-addr.arpa.", reversed);
  }
  /**
   * Returns true if the given address is a multicast address
   * @memberof Address4
   * @instance
   * @returns {boolean}
   */
  isMulticast() {
    return this.isInSubnet(new Address4("224.0.0.0/4"));
  }
  /**
   * Returns a zero-padded base-2 string representation of the address
   * @memberof Address4
   * @instance
   * @returns {string}
   */
  binaryZeroPad() {
    return this.bigInteger().toString(2).padStart(constants$2.BITS, "0");
  }
  /**
   * Groups an IPv4 address for inclusion at the end of an IPv6 address
   * @returns {String}
   */
  groupForV6() {
    const segments = this.parsedAddress;
    return this.address.replace(constants$2.RE_ADDRESS, (0, sprintf_js_1$3.sprintf)('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
  }
}
ipv4.Address4 = Address4;
var ipv6 = {};
var constants$1 = {};
Object.defineProperty(constants$1, "__esModule", { value: true });
constants$1.RE_URL_WITH_PORT = constants$1.RE_URL = constants$1.RE_ZONE_STRING = constants$1.RE_SUBNET_STRING = constants$1.RE_BAD_ADDRESS = constants$1.RE_BAD_CHARACTERS = constants$1.TYPES = constants$1.SCOPES = constants$1.GROUPS = constants$1.BITS = void 0;
constants$1.BITS = 128;
constants$1.GROUPS = 8;
constants$1.SCOPES = {
  0: "Reserved",
  1: "Interface local",
  2: "Link local",
  4: "Admin local",
  5: "Site local",
  8: "Organization local",
  14: "Global",
  15: "Reserved"
};
constants$1.TYPES = {
  "ff01::1/128": "Multicast (All nodes on this interface)",
  "ff01::2/128": "Multicast (All routers on this interface)",
  "ff02::1/128": "Multicast (All nodes on this link)",
  "ff02::2/128": "Multicast (All routers on this link)",
  "ff05::2/128": "Multicast (All routers in this site)",
  "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
  "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
  "ff02::9/128": "Multicast (RIP routers)",
  "ff02::a/128": "Multicast (EIGRP routers)",
  "ff02::d/128": "Multicast (PIM routers)",
  "ff02::16/128": "Multicast (MLDv2 reports)",
  "ff01::fb/128": "Multicast (mDNSv6)",
  "ff02::fb/128": "Multicast (mDNSv6)",
  "ff05::fb/128": "Multicast (mDNSv6)",
  "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
  "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
  "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
  "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
  "::/128": "Unspecified",
  "::1/128": "Loopback",
  "ff00::/8": "Multicast",
  "fe80::/10": "Link-local unicast"
};
constants$1.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
constants$1.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
constants$1.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
constants$1.RE_ZONE_STRING = /%.*$/;
constants$1.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
constants$1.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
var helpers$2 = {};
Object.defineProperty(helpers$2, "__esModule", { value: true });
helpers$2.simpleGroup = helpers$2.spanLeadingZeroes = helpers$2.spanAll = helpers$2.spanAllZeroes = void 0;
const sprintf_js_1$2 = sprintf;
function spanAllZeroes(s2) {
  return s2.replace(/(0+)/g, '<span class="zero">$1</span>');
}
helpers$2.spanAllZeroes = spanAllZeroes;
function spanAll(s2, offset = 0) {
  const letters = s2.split("");
  return letters.map(
    (n, i) => (0, sprintf_js_1$2.sprintf)('<span class="digit value-%s position-%d">%s</span>', n, i + offset, spanAllZeroes(n))
    // XXX Use #base-2 .value-0 instead?
  ).join("");
}
helpers$2.spanAll = spanAll;
function spanLeadingZeroesSimple(group) {
  return group.replace(/^(0+)/, '<span class="zero">$1</span>');
}
function spanLeadingZeroes(address) {
  const groups = address.split(":");
  return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
}
helpers$2.spanLeadingZeroes = spanLeadingZeroes;
function simpleGroup(addressString, offset = 0) {
  const groups = addressString.split(":");
  return groups.map((g, i) => {
    if (/group-v4/.test(g)) {
      return g;
    }
    return (0, sprintf_js_1$2.sprintf)('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
  });
}
helpers$2.simpleGroup = simpleGroup;
var regularExpressions = {};
var __createBinding$6 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$6 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$6 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$6(result, mod, k);
  }
  __setModuleDefault$6(result, mod);
  return result;
};
Object.defineProperty(regularExpressions, "__esModule", { value: true });
regularExpressions.possibleElisions = regularExpressions.simpleRegularExpression = regularExpressions.ADDRESS_BOUNDARY = regularExpressions.padGroup = regularExpressions.groupPossibilities = void 0;
const v6 = __importStar$6(constants$1);
const sprintf_js_1$1 = sprintf;
function groupPossibilities(possibilities) {
  return (0, sprintf_js_1$1.sprintf)("(%s)", possibilities.join("|"));
}
regularExpressions.groupPossibilities = groupPossibilities;
function padGroup(group) {
  if (group.length < 4) {
    return (0, sprintf_js_1$1.sprintf)("0{0,%d}%s", 4 - group.length, group);
  }
  return group;
}
regularExpressions.padGroup = padGroup;
regularExpressions.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
function simpleRegularExpression(groups) {
  const zeroIndexes = [];
  groups.forEach((group, i) => {
    const groupInteger = parseInt(group, 16);
    if (groupInteger === 0) {
      zeroIndexes.push(i);
    }
  });
  const possibilities = zeroIndexes.map((zeroIndex) => groups.map((group, i) => {
    if (i === zeroIndex) {
      const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
      return groupPossibilities([padGroup(group), elision]);
    }
    return padGroup(group);
  }).join(":"));
  possibilities.push(groups.map(padGroup).join(":"));
  return groupPossibilities(possibilities);
}
regularExpressions.simpleRegularExpression = simpleRegularExpression;
function possibleElisions(elidedGroups, moreLeft, moreRight) {
  const left = moreLeft ? "" : ":";
  const right = moreRight ? "" : ":";
  const possibilities = [];
  if (!moreLeft && !moreRight) {
    possibilities.push("::");
  }
  if (moreLeft && moreRight) {
    possibilities.push("");
  }
  if (moreRight && !moreLeft || !moreRight && moreLeft) {
    possibilities.push(":");
  }
  possibilities.push((0, sprintf_js_1$1.sprintf)("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
  possibilities.push((0, sprintf_js_1$1.sprintf)("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
  possibilities.push((0, sprintf_js_1$1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
  for (let groups = 1; groups < elidedGroups - 1; groups++) {
    for (let position = 1; position < elidedGroups - groups; position++) {
      possibilities.push((0, sprintf_js_1$1.sprintf)("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
    }
  }
  return groupPossibilities(possibilities);
}
regularExpressions.possibleElisions = possibleElisions;
var __createBinding$5 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$5 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$5 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$5(result, mod, k);
  }
  __setModuleDefault$5(result, mod);
  return result;
};
Object.defineProperty(ipv6, "__esModule", { value: true });
ipv6.Address6 = void 0;
const common$1 = __importStar$5(common$3);
const constants4 = __importStar$5(constants$3);
const constants6 = __importStar$5(constants$1);
const helpers$1 = __importStar$5(helpers$2);
const ipv4_1 = ipv4;
const regular_expressions_1 = regularExpressions;
const address_error_1 = addressError;
const jsbn_1 = jsbnExports;
const sprintf_js_1 = sprintf;
function assert(condition) {
  if (!condition) {
    throw new Error("Assertion failed.");
  }
}
function addCommas(number) {
  const r = /(\d+)(\d{3})/;
  while (r.test(number)) {
    number = number.replace(r, "$1,$2");
  }
  return number;
}
function spanLeadingZeroes4(n) {
  n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
  n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
  return n;
}
function compact(address, slice2) {
  const s1 = [];
  const s2 = [];
  let i;
  for (i = 0; i < address.length; i++) {
    if (i < slice2[0]) {
      s1.push(address[i]);
    } else if (i > slice2[1]) {
      s2.push(address[i]);
    }
  }
  return s1.concat(["compact"]).concat(s2);
}
function paddedHex(octet) {
  return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
}
function unsignByte(b) {
  return b & 255;
}
class Address6 {
  constructor(address, optionalGroups) {
    this.addressMinusSuffix = "";
    this.parsedSubnet = "";
    this.subnet = "/128";
    this.subnetMask = 128;
    this.v4 = false;
    this.zone = "";
    this.isInSubnet = common$1.isInSubnet;
    this.isCorrect = common$1.isCorrect(constants6.BITS);
    if (optionalGroups === void 0) {
      this.groups = constants6.GROUPS;
    } else {
      this.groups = optionalGroups;
    }
    this.address = address;
    const subnet = constants6.RE_SUBNET_STRING.exec(address);
    if (subnet) {
      this.parsedSubnet = subnet[0].replace("/", "");
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = `/${this.subnetMask}`;
      if (Number.isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
        throw new address_error_1.AddressError("Invalid subnet mask.");
      }
      address = address.replace(constants6.RE_SUBNET_STRING, "");
    } else if (/\//.test(address)) {
      throw new address_error_1.AddressError("Invalid subnet mask.");
    }
    const zone = constants6.RE_ZONE_STRING.exec(address);
    if (zone) {
      this.zone = zone[0];
      address = address.replace(constants6.RE_ZONE_STRING, "");
    }
    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(this.addressMinusSuffix);
  }
  static isValid(address) {
    try {
      new Address6(address);
      return true;
    } catch (e) {
      return false;
    }
  }
  /**
   * Convert a BigInteger to a v6 address object
   * @memberof Address6
   * @static
   * @param {BigInteger} bigInteger - a BigInteger to convert
   * @returns {Address6}
   * @example
   * var bigInteger = new BigInteger('1000000000000');
   * var address = Address6.fromBigInteger(bigInteger);
   * address.correctForm(); // '::e8:d4a5:1000'
   */
  static fromBigInteger(bigInteger) {
    const hex = bigInteger.toString(16).padStart(32, "0");
    const groups = [];
    let i;
    for (i = 0; i < constants6.GROUPS; i++) {
      groups.push(hex.slice(i * 4, (i + 1) * 4));
    }
    return new Address6(groups.join(":"));
  }
  /**
   * Convert a URL (with optional port number) to an address object
   * @memberof Address6
   * @static
   * @param {string} url - a URL with optional port number
   * @example
   * var addressAndPort = Address6.fromURL('http://[ffff::]:8080/foo/');
   * addressAndPort.address.correctForm(); // 'ffff::'
   * addressAndPort.port; // 8080
   */
  static fromURL(url2) {
    let host2;
    let port = null;
    let result;
    if (url2.indexOf("[") !== -1 && url2.indexOf("]:") !== -1) {
      result = constants6.RE_URL_WITH_PORT.exec(url2);
      if (result === null) {
        return {
          error: "failed to parse address with port",
          address: null,
          port: null
        };
      }
      host2 = result[1];
      port = result[2];
    } else if (url2.indexOf("/") !== -1) {
      url2 = url2.replace(/^[a-z0-9]+:\/\//, "");
      result = constants6.RE_URL.exec(url2);
      if (result === null) {
        return {
          error: "failed to parse address from URL",
          address: null,
          port: null
        };
      }
      host2 = result[1];
    } else {
      host2 = url2;
    }
    if (port) {
      port = parseInt(port, 10);
      if (port < 0 || port > 65536) {
        port = null;
      }
    } else {
      port = null;
    }
    return {
      address: new Address6(host2),
      port
    };
  }
  /**
   * Create an IPv6-mapped address given an IPv4 address
   * @memberof Address6
   * @static
   * @param {string} address - An IPv4 address string
   * @returns {Address6}
   * @example
   * var address = Address6.fromAddress4('192.168.0.1');
   * address.correctForm(); // '::ffff:c0a8:1'
   * address.to4in6(); // '::ffff:192.168.0.1'
   */
  static fromAddress4(address) {
    const address4 = new ipv4_1.Address4(address);
    const mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
    return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
  }
  /**
   * Return an address from ip6.arpa form
   * @memberof Address6
   * @static
   * @param {string} arpaFormAddress - an 'ip6.arpa' form address
   * @returns {Adress6}
   * @example
   * var address = Address6.fromArpa(e.f.f.f.3.c.2.6.f.f.f.e.6.6.8.e.1.0.6.7.9.4.e.c.0.0.0.0.1.0.0.2.ip6.arpa.)
   * address.correctForm(); // '2001:0:ce49:7601:e866:efff:62c3:fffe'
   */
  static fromArpa(arpaFormAddress) {
    let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
    const semicolonAmount = 7;
    if (address.length !== 63) {
      throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
    }
    const parts = address.split(".").reverse();
    for (let i = semicolonAmount; i > 0; i--) {
      const insertIndex = i * 4;
      parts.splice(insertIndex, 0, ":");
    }
    address = parts.join("");
    return new Address6(address);
  }
  /**
   * Return the Microsoft UNC transcription of the address
   * @memberof Address6
   * @instance
   * @returns {String} the Microsoft UNC transcription of the address
   */
  microsoftTranscription() {
    return (0, sprintf_js_1.sprintf)("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
  }
  /**
   * Return the first n bits of the address, defaulting to the subnet mask
   * @memberof Address6
   * @instance
   * @param {number} [mask=subnet] - the number of bits to mask
   * @returns {String} the first n bits of the address as a string
   */
  mask(mask = this.subnetMask) {
    return this.getBitsBase2(0, mask);
  }
  /**
   * Return the number of possible subnets of a given size in the address
   * @memberof Address6
   * @instance
   * @param {number} [size=128] - the subnet size
   * @returns {String}
   */
  // TODO: probably useful to have a numeric version of this too
  possibleSubnets(subnetSize = 128) {
    const availableBits = constants6.BITS - this.subnetMask;
    const subnetBits = Math.abs(subnetSize - constants6.BITS);
    const subnetPowers = availableBits - subnetBits;
    if (subnetPowers < 0) {
      return "0";
    }
    return addCommas(new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10));
  }
  /**
   * Helper function getting start address.
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  _startAddress() {
    return new jsbn_1.BigInteger(this.mask() + "0".repeat(constants6.BITS - this.subnetMask), 2);
  }
  /**
   * The first address in the range given by this address' subnet
   * Often referred to as the Network Address.
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  startAddress() {
    return Address6.fromBigInteger(this._startAddress());
  }
  /**
   * The first host address in the range given by this address's subnet ie
   * the first address after the Network Address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  startAddressExclusive() {
    const adjust = new jsbn_1.BigInteger("1");
    return Address6.fromBigInteger(this._startAddress().add(adjust));
  }
  /**
   * Helper function getting end address.
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  _endAddress() {
    return new jsbn_1.BigInteger(this.mask() + "1".repeat(constants6.BITS - this.subnetMask), 2);
  }
  /**
   * The last address in the range given by this address' subnet
   * Often referred to as the Broadcast
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  endAddress() {
    return Address6.fromBigInteger(this._endAddress());
  }
  /**
   * The last host address in the range given by this address's subnet ie
   * the last address prior to the Broadcast Address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  endAddressExclusive() {
    const adjust = new jsbn_1.BigInteger("1");
    return Address6.fromBigInteger(this._endAddress().subtract(adjust));
  }
  /**
   * Return the scope of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getScope() {
    let scope2 = constants6.SCOPES[this.getBits(12, 16).intValue()];
    if (this.getType() === "Global unicast" && scope2 !== "Link local") {
      scope2 = "Global";
    }
    return scope2 || "Unknown";
  }
  /**
   * Return the type of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getType() {
    for (const subnet of Object.keys(constants6.TYPES)) {
      if (this.isInSubnet(new Address6(subnet))) {
        return constants6.TYPES[subnet];
      }
    }
    return "Global unicast";
  }
  /**
   * Return the bits in the given range as a BigInteger
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  getBits(start, end) {
    return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
  }
  /**
   * Return the bits in the given range as a base-2 string
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsBase2(start, end) {
    return this.binaryZeroPad().slice(start, end);
  }
  /**
   * Return the bits in the given range as a base-16 string
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsBase16(start, end) {
    const length = end - start;
    if (length % 4 !== 0) {
      throw new Error("Length of bits to retrieve must be divisible by four");
    }
    return this.getBits(start, end).toString(16).padStart(length / 4, "0");
  }
  /**
   * Return the bits that are set past the subnet mask length
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  getBitsPastSubnet() {
    return this.getBitsBase2(this.subnetMask, constants6.BITS);
  }
  /**
   * Return the reversed ip6.arpa form of the address
   * @memberof Address6
   * @param {Object} options
   * @param {boolean} options.omitSuffix - omit the "ip6.arpa" suffix
   * @instance
   * @returns {String}
   */
  reverseForm(options) {
    if (!options) {
      options = {};
    }
    const characters = Math.floor(this.subnetMask / 4);
    const reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
    if (characters > 0) {
      if (options.omitSuffix) {
        return reversed;
      }
      return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
    }
    if (options.omitSuffix) {
      return "";
    }
    return "ip6.arpa.";
  }
  /**
   * Return the correct form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  correctForm() {
    let i;
    let groups = [];
    let zeroCounter = 0;
    const zeroes = [];
    for (i = 0; i < this.parsedAddress.length; i++) {
      const value2 = parseInt(this.parsedAddress[i], 16);
      if (value2 === 0) {
        zeroCounter++;
      }
      if (value2 !== 0 && zeroCounter > 0) {
        if (zeroCounter > 1) {
          zeroes.push([i - zeroCounter, i - 1]);
        }
        zeroCounter = 0;
      }
    }
    if (zeroCounter > 1) {
      zeroes.push([this.parsedAddress.length - zeroCounter, this.parsedAddress.length - 1]);
    }
    const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
    if (zeroes.length > 0) {
      const index2 = zeroLengths.indexOf(Math.max(...zeroLengths));
      groups = compact(this.parsedAddress, zeroes[index2]);
    } else {
      groups = this.parsedAddress;
    }
    for (i = 0; i < groups.length; i++) {
      if (groups[i] !== "compact") {
        groups[i] = parseInt(groups[i], 16).toString(16);
      }
    }
    let correct = groups.join(":");
    correct = correct.replace(/^compact$/, "::");
    correct = correct.replace(/^compact|compact$/, ":");
    correct = correct.replace(/compact/, "");
    return correct;
  }
  /**
   * Return a zero-padded base-2 string representation of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   * @example
   * var address = new Address6('2001:4860:4001:803::1011');
   * address.binaryZeroPad();
   * // '0010000000000001010010000110000001000000000000010000100000000011
   * //  0000000000000000000000000000000000000000000000000001000000010001'
   */
  binaryZeroPad() {
    return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
  }
  // TODO: Improve the semantics of this helper function
  parse4in6(address) {
    const groups = address.split(":");
    const lastGroup = groups.slice(-1)[0];
    const address4 = lastGroup.match(constants4.RE_ADDRESS);
    if (address4) {
      this.parsedAddress4 = address4[0];
      this.address4 = new ipv4_1.Address4(this.parsedAddress4);
      for (let i = 0; i < this.address4.groups; i++) {
        if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
          throw new address_error_1.AddressError("IPv4 addresses can't have leading zeroes.", address.replace(constants4.RE_ADDRESS, this.address4.parsedAddress.map(spanLeadingZeroes4).join(".")));
        }
      }
      this.v4 = true;
      groups[groups.length - 1] = this.address4.toGroup6();
      address = groups.join(":");
    }
    return address;
  }
  // TODO: Make private?
  parse(address) {
    address = this.parse4in6(address);
    const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
    if (badCharacters) {
      throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join("")), address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>'));
    }
    const badAddress = address.match(constants6.RE_BAD_ADDRESS);
    if (badAddress) {
      throw new address_error_1.AddressError((0, sprintf_js_1.sprintf)("Address failed regex: %s", badAddress.join("")), address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>'));
    }
    let groups = [];
    const halves = address.split("::");
    if (halves.length === 2) {
      let first2 = halves[0].split(":");
      let last = halves[1].split(":");
      if (first2.length === 1 && first2[0] === "") {
        first2 = [];
      }
      if (last.length === 1 && last[0] === "") {
        last = [];
      }
      const remaining = this.groups - (first2.length + last.length);
      if (!remaining) {
        throw new address_error_1.AddressError("Error parsing groups");
      }
      this.elidedGroups = remaining;
      this.elisionBegin = first2.length;
      this.elisionEnd = first2.length + this.elidedGroups;
      groups = groups.concat(first2);
      for (let i = 0; i < remaining; i++) {
        groups.push("0");
      }
      groups = groups.concat(last);
    } else if (halves.length === 1) {
      groups = address.split(":");
      this.elidedGroups = 0;
    } else {
      throw new address_error_1.AddressError("Too many :: groups found");
    }
    groups = groups.map((group) => (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)));
    if (groups.length !== this.groups) {
      throw new address_error_1.AddressError("Incorrect number of groups found");
    }
    return groups;
  }
  /**
   * Return the canonical form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  canonicalForm() {
    return this.parsedAddress.map(paddedHex).join(":");
  }
  /**
   * Return the decimal form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  decimal() {
    return this.parsedAddress.map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16))).join(":");
  }
  /**
   * Return the address as a BigInteger
   * @memberof Address6
   * @instance
   * @returns {BigInteger}
   */
  bigInteger() {
    return new jsbn_1.BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
  }
  /**
   * Return the last two groups of this address as an IPv4 address string
   * @memberof Address6
   * @instance
   * @returns {Address4}
   * @example
   * var address = new Address6('2001:4860:4001::1825:bf11');
   * address.to4().correctForm(); // '24.37.191.17'
   */
  to4() {
    const binary = this.binaryZeroPad().split("");
    return ipv4_1.Address4.fromHex(new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
  }
  /**
   * Return the v4-in-v6 form of the address
   * @memberof Address6
   * @instance
   * @returns {String}
   */
  to4in6() {
    const address4 = this.to4();
    const address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
    const correct = address6.correctForm();
    let infix = "";
    if (!/:$/.test(correct)) {
      infix = ":";
    }
    return correct + infix + address4.address;
  }
  /**
   * Return an object containing the Teredo properties of the address
   * @memberof Address6
   * @instance
   * @returns {Object}
   */
  inspectTeredo() {
    const prefix = this.getBitsBase16(0, 32);
    const udpPort = this.getBits(80, 96).xor(new jsbn_1.BigInteger("ffff", 16)).toString();
    const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
    const client4 = ipv4_1.Address4.fromHex(this.getBits(96, 128).xor(new jsbn_1.BigInteger("ffffffff", 16)).toString(16));
    const flags = this.getBits(64, 80);
    const flagsBase2 = this.getBitsBase2(64, 80);
    const coneNat = flags.testBit(15);
    const reserved = flags.testBit(14);
    const groupIndividual = flags.testBit(8);
    const universalLocal = flags.testBit(9);
    const nonce = new jsbn_1.BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
    return {
      prefix: (0, sprintf_js_1.sprintf)("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
      server4: server4.address,
      client4: client4.address,
      flags: flagsBase2,
      coneNat,
      microsoft: {
        reserved,
        universalLocal,
        groupIndividual,
        nonce
      },
      udpPort
    };
  }
  /**
   * Return an object containing the 6to4 properties of the address
   * @memberof Address6
   * @instance
   * @returns {Object}
   */
  inspect6to4() {
    const prefix = this.getBitsBase16(0, 16);
    const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
    return {
      prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
      gateway: gateway.address
    };
  }
  /**
   * Return a v6 6to4 address from a v6 v4inv6 address
   * @memberof Address6
   * @instance
   * @returns {Address6}
   */
  to6to4() {
    if (!this.is4()) {
      return null;
    }
    const addr6to4 = [
      "2002",
      this.getBitsBase16(96, 112),
      this.getBitsBase16(112, 128),
      "",
      "/16"
    ].join(":");
    return new Address6(addr6to4);
  }
  /**
   * Return a byte array
   * @memberof Address6
   * @instance
   * @returns {Array}
   */
  toByteArray() {
    const byteArray = this.bigInteger().toByteArray();
    if (byteArray.length === 17 && byteArray[0] === 0) {
      return byteArray.slice(1);
    }
    return byteArray;
  }
  /**
   * Return an unsigned byte array
   * @memberof Address6
   * @instance
   * @returns {Array}
   */
  toUnsignedByteArray() {
    return this.toByteArray().map(unsignByte);
  }
  /**
   * Convert a byte array to an Address6 object
   * @memberof Address6
   * @static
   * @returns {Address6}
   */
  static fromByteArray(bytes2) {
    return this.fromUnsignedByteArray(bytes2.map(unsignByte));
  }
  /**
   * Convert an unsigned byte array to an Address6 object
   * @memberof Address6
   * @static
   * @returns {Address6}
   */
  static fromUnsignedByteArray(bytes2) {
    const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
    let result = new jsbn_1.BigInteger("0", 10);
    let multiplier = new jsbn_1.BigInteger("1", 10);
    for (let i = bytes2.length - 1; i >= 0; i--) {
      result = result.add(multiplier.multiply(new jsbn_1.BigInteger(bytes2[i].toString(10), 10)));
      multiplier = multiplier.multiply(BYTE_MAX);
    }
    return Address6.fromBigInteger(result);
  }
  /**
   * Returns true if the address is in the canonical form, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isCanonical() {
    return this.addressMinusSuffix === this.canonicalForm();
  }
  /**
   * Returns true if the address is a link local address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isLinkLocal() {
    if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
      return true;
    }
    return false;
  }
  /**
   * Returns true if the address is a multicast address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isMulticast() {
    return this.getType() === "Multicast";
  }
  /**
   * Returns true if the address is a v4-in-v6 address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  is4() {
    return this.v4;
  }
  /**
   * Returns true if the address is a Teredo address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isTeredo() {
    return this.isInSubnet(new Address6("2001::/32"));
  }
  /**
   * Returns true if the address is a 6to4 address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  is6to4() {
    return this.isInSubnet(new Address6("2002::/16"));
  }
  /**
   * Returns true if the address is a loopback address, false otherwise
   * @memberof Address6
   * @instance
   * @returns {boolean}
   */
  isLoopback() {
    return this.getType() === "Loopback";
  }
  // #endregion
  // #region HTML
  /**
   * @returns {String} the address in link form with a default port of 80
   */
  href(optionalPort) {
    if (optionalPort === void 0) {
      optionalPort = "";
    } else {
      optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
    }
    return (0, sprintf_js_1.sprintf)("http://[%s]%s/", this.correctForm(), optionalPort);
  }
  /**
   * @returns {String} a link suitable for conveying the address via a URL hash
   */
  link(options) {
    if (!options) {
      options = {};
    }
    if (options.className === void 0) {
      options.className = "";
    }
    if (options.prefix === void 0) {
      options.prefix = "/#address=";
    }
    if (options.v4 === void 0) {
      options.v4 = false;
    }
    let formFunction = this.correctForm;
    if (options.v4) {
      formFunction = this.to4in6;
    }
    if (options.className) {
      return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
    }
    return (0, sprintf_js_1.sprintf)('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
  }
  /**
   * Groups an address
   * @returns {String}
   */
  group() {
    if (this.elidedGroups === 0) {
      return helpers$1.simpleGroup(this.address).join(":");
    }
    assert(typeof this.elidedGroups === "number");
    assert(typeof this.elisionBegin === "number");
    const output = [];
    const [left, right] = this.address.split("::");
    if (left.length) {
      output.push(...helpers$1.simpleGroup(left));
    } else {
      output.push("");
    }
    const classes = ["hover-group"];
    for (let i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
      classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
    }
    output.push((0, sprintf_js_1.sprintf)('<span class="%s"></span>', classes.join(" ")));
    if (right.length) {
      output.push(...helpers$1.simpleGroup(right, this.elisionEnd));
    } else {
      output.push("");
    }
    if (this.is4()) {
      assert(this.address4 instanceof ipv4_1.Address4);
      output.pop();
      output.push(this.address4.groupForV6());
    }
    return output.join(":");
  }
  // #endregion
  // #region Regular expressions
  /**
   * Generate a regular expression string that can be used to find or validate
   * all variations of this address
   * @memberof Address6
   * @instance
   * @param {boolean} substringSearch
   * @returns {string}
   */
  regularExpressionString(substringSearch = false) {
    let output = [];
    const address6 = new Address6(this.correctForm());
    if (address6.elidedGroups === 0) {
      output.push((0, regular_expressions_1.simpleRegularExpression)(address6.parsedAddress));
    } else if (address6.elidedGroups === constants6.GROUPS) {
      output.push((0, regular_expressions_1.possibleElisions)(constants6.GROUPS));
    } else {
      const halves = address6.address.split("::");
      if (halves[0].length) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(halves[0].split(":")));
      }
      assert(typeof address6.elidedGroups === "number");
      output.push((0, regular_expressions_1.possibleElisions)(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
      if (halves[1].length) {
        output.push((0, regular_expressions_1.simpleRegularExpression)(halves[1].split(":")));
      }
      output = [output.join(":")];
    }
    if (!substringSearch) {
      output = [
        "(?=^|",
        regular_expressions_1.ADDRESS_BOUNDARY,
        "|[^\\w\\:])(",
        ...output,
        ")(?=[^\\w\\:]|",
        regular_expressions_1.ADDRESS_BOUNDARY,
        "|$)"
      ];
    }
    return output.join("");
  }
  /**
   * Generate a regular expression that can be used to find or validate all
   * variations of this address.
   * @memberof Address6
   * @instance
   * @param {boolean} substringSearch
   * @returns {RegExp}
   */
  regularExpression(substringSearch = false) {
    return new RegExp(this.regularExpressionString(substringSearch), "i");
  }
}
ipv6.Address6 = Address6;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.v6 = exports.AddressError = exports.Address6 = exports.Address4 = void 0;
  const ipv4_12 = ipv4;
  Object.defineProperty(exports, "Address4", { enumerable: true, get: function() {
    return ipv4_12.Address4;
  } });
  const ipv6_1 = ipv6;
  Object.defineProperty(exports, "Address6", { enumerable: true, get: function() {
    return ipv6_1.Address6;
  } });
  const address_error_12 = addressError;
  Object.defineProperty(exports, "AddressError", { enumerable: true, get: function() {
    return address_error_12.AddressError;
  } });
  const helpers2 = __importStar2(helpers$2);
  exports.v6 = { helpers: helpers2 };
})(ipAddress);
Object.defineProperty(helpers$3, "__esModule", { value: true });
helpers$3.ipToBuffer = helpers$3.int32ToIpv4 = helpers$3.ipv4ToInt32 = helpers$3.validateSocksClientChainOptions = helpers$3.validateSocksClientOptions = void 0;
const util_1$7 = util$5;
const constants_1 = constants$4;
const stream2 = require$$1$4;
const ip_address_1 = ipAddress;
const net$1 = require$$0$6;
function validateSocksClientOptions(options, acceptedCommands = ["connect", "bind", "associate"]) {
  if (!constants_1.SocksCommand[options.command]) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksCommand, options);
  }
  if (acceptedCommands.indexOf(options.command) === -1) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksCommandForOperation, options);
  }
  if (!isValidSocksRemoteHost(options.destination)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
  }
  if (!isValidSocksProxy(options.proxy)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
  }
  validateCustomProxyAuth(options.proxy, options);
  if (options.timeout && !isValidTimeoutValue(options.timeout)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
  }
  if (options.existing_socket && !(options.existing_socket instanceof stream2.Duplex)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket, options);
  }
}
helpers$3.validateSocksClientOptions = validateSocksClientOptions;
function validateSocksClientChainOptions(options) {
  if (options.command !== "connect") {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksCommandChain, options);
  }
  if (!isValidSocksRemoteHost(options.destination)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsDestination, options);
  }
  if (!(options.proxies && Array.isArray(options.proxies) && options.proxies.length >= 2)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength, options);
  }
  options.proxies.forEach((proxy) => {
    if (!isValidSocksProxy(proxy)) {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsProxy, options);
    }
    validateCustomProxyAuth(proxy, options);
  });
  if (options.timeout && !isValidTimeoutValue(options.timeout)) {
    throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsTimeout, options);
  }
}
helpers$3.validateSocksClientChainOptions = validateSocksClientChainOptions;
function validateCustomProxyAuth(proxy, options) {
  if (proxy.custom_auth_method !== void 0) {
    if (proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START || proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END) {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange, options);
    }
    if (proxy.custom_auth_request_handler === void 0 || typeof proxy.custom_auth_request_handler !== "function") {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
    }
    if (proxy.custom_auth_response_size === void 0) {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
    }
    if (proxy.custom_auth_response_handler === void 0 || typeof proxy.custom_auth_response_handler !== "function") {
      throw new util_1$7.SocksClientError(constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions, options);
    }
  }
}
function isValidSocksRemoteHost(remoteHost) {
  return remoteHost && typeof remoteHost.host === "string" && typeof remoteHost.port === "number" && remoteHost.port >= 0 && remoteHost.port <= 65535;
}
function isValidSocksProxy(proxy) {
  return proxy && (typeof proxy.host === "string" || typeof proxy.ipaddress === "string") && typeof proxy.port === "number" && proxy.port >= 0 && proxy.port <= 65535 && (proxy.type === 4 || proxy.type === 5);
}
function isValidTimeoutValue(value2) {
  return typeof value2 === "number" && value2 > 0;
}
function ipv4ToInt32(ip3) {
  const address = new ip_address_1.Address4(ip3);
  return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
}
helpers$3.ipv4ToInt32 = ipv4ToInt32;
function int32ToIpv4(int32) {
  const octet1 = int32 >>> 24 & 255;
  const octet2 = int32 >>> 16 & 255;
  const octet3 = int32 >>> 8 & 255;
  const octet4 = int32 & 255;
  return [octet1, octet2, octet3, octet4].join(".");
}
helpers$3.int32ToIpv4 = int32ToIpv4;
function ipToBuffer(ip3) {
  if (net$1.isIPv4(ip3)) {
    const address = new ip_address_1.Address4(ip3);
    return Buffer.from(address.toArray());
  } else if (net$1.isIPv6(ip3)) {
    const address = new ip_address_1.Address6(ip3);
    return Buffer.from(address.canonicalForm().split(":").map((segment) => segment.padStart(4, "0")).join(""), "hex");
  } else {
    throw new Error("Invalid IP address format");
  }
}
helpers$3.ipToBuffer = ipToBuffer;
var receivebuffer = {};
Object.defineProperty(receivebuffer, "__esModule", { value: true });
receivebuffer.ReceiveBuffer = void 0;
class ReceiveBuffer {
  constructor(size = 4096) {
    this.buffer = Buffer.allocUnsafe(size);
    this.offset = 0;
    this.originalSize = size;
  }
  get length() {
    return this.offset;
  }
  append(data2) {
    if (!Buffer.isBuffer(data2)) {
      throw new Error("Attempted to append a non-buffer instance to ReceiveBuffer.");
    }
    if (this.offset + data2.length >= this.buffer.length) {
      const tmp = this.buffer;
      this.buffer = Buffer.allocUnsafe(Math.max(this.buffer.length + this.originalSize, this.buffer.length + data2.length));
      tmp.copy(this.buffer);
    }
    data2.copy(this.buffer, this.offset);
    return this.offset += data2.length;
  }
  peek(length) {
    if (length > this.offset) {
      throw new Error("Attempted to read beyond the bounds of the managed internal data.");
    }
    return this.buffer.slice(0, length);
  }
  get(length) {
    if (length > this.offset) {
      throw new Error("Attempted to read beyond the bounds of the managed internal data.");
    }
    const value2 = Buffer.allocUnsafe(length);
    this.buffer.slice(0, length).copy(value2);
    this.buffer.copyWithin(0, length, length + this.offset - length);
    this.offset -= length;
    return value2;
  }
}
receivebuffer.ReceiveBuffer = ReceiveBuffer;
(function(exports) {
  var __awaiter2 = commonjsGlobal && commonjsGlobal.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value2) {
      return value2 instanceof P ? value2 : new P(function(resolve3) {
        resolve3(value2);
      });
    }
    return new (P || (P = Promise))(function(resolve3, reject) {
      function fulfilled(value2) {
        try {
          step(generator.next(value2));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value2) {
        try {
          step(generator["throw"](value2));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SocksClientError = exports.SocksClient = void 0;
  const events_12 = require$$0$8;
  const net2 = require$$0$6;
  const smart_buffer_1 = smartbuffer;
  const constants_12 = constants$4;
  const helpers_1 = helpers$3;
  const receivebuffer_1 = receivebuffer;
  const util_12 = util$5;
  Object.defineProperty(exports, "SocksClientError", { enumerable: true, get: function() {
    return util_12.SocksClientError;
  } });
  const ip_address_12 = ipAddress;
  class SocksClient extends events_12.EventEmitter {
    constructor(options) {
      super();
      this.options = Object.assign({}, options);
      (0, helpers_1.validateSocksClientOptions)(options);
      this.setState(constants_12.SocksClientState.Created);
    }
    /**
     * Creates a new SOCKS connection.
     *
     * Note: Supports callbacks and promises. Only supports the connect command.
     * @param options { SocksClientOptions } Options.
     * @param callback { Function } An optional callback function.
     * @returns { Promise }
     */
    static createConnection(options, callback) {
      return new Promise((resolve3, reject) => {
        try {
          (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            return resolve3(err);
          } else {
            return reject(err);
          }
        }
        const client = new SocksClient(options);
        client.connect(options.existing_socket);
        client.once("established", (info) => {
          client.removeAllListeners();
          if (typeof callback === "function") {
            callback(null, info);
            resolve3(info);
          } else {
            resolve3(info);
          }
        });
        client.once("error", (err) => {
          client.removeAllListeners();
          if (typeof callback === "function") {
            callback(err);
            resolve3(err);
          } else {
            reject(err);
          }
        });
      });
    }
    /**
     * Creates a new SOCKS connection chain to a destination host through 2 or more SOCKS proxies.
     *
     * Note: Supports callbacks and promises. Only supports the connect method.
     * Note: Implemented via createConnection() factory function.
     * @param options { SocksClientChainOptions } Options
     * @param callback { Function } An optional callback function.
     * @returns { Promise }
     */
    static createConnectionChain(options, callback) {
      return new Promise((resolve3, reject) => __awaiter2(this, void 0, void 0, function* () {
        try {
          (0, helpers_1.validateSocksClientChainOptions)(options);
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            return resolve3(err);
          } else {
            return reject(err);
          }
        }
        if (options.randomizeChain) {
          (0, util_12.shuffleArray)(options.proxies);
        }
        try {
          let sock;
          for (let i = 0; i < options.proxies.length; i++) {
            const nextProxy = options.proxies[i];
            const nextDestination = i === options.proxies.length - 1 ? options.destination : {
              host: options.proxies[i + 1].host || options.proxies[i + 1].ipaddress,
              port: options.proxies[i + 1].port
            };
            const result = yield SocksClient.createConnection({
              command: "connect",
              proxy: nextProxy,
              destination: nextDestination,
              existing_socket: sock
            });
            sock = sock || result.socket;
          }
          if (typeof callback === "function") {
            callback(null, { socket: sock });
            resolve3({ socket: sock });
          } else {
            resolve3({ socket: sock });
          }
        } catch (err) {
          if (typeof callback === "function") {
            callback(err);
            resolve3(err);
          } else {
            reject(err);
          }
        }
      }));
    }
    /**
     * Creates a SOCKS UDP Frame.
     * @param options
     */
    static createUDPFrame(options) {
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt16BE(0);
      buff.writeUInt8(options.frameNumber || 0);
      if (net2.isIPv4(options.remoteHost.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv4);
        buff.writeUInt32BE((0, helpers_1.ipv4ToInt32)(options.remoteHost.host));
      } else if (net2.isIPv6(options.remoteHost.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(options.remoteHost.host));
      } else {
        buff.writeUInt8(constants_12.Socks5HostType.Hostname);
        buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
        buff.writeString(options.remoteHost.host);
      }
      buff.writeUInt16BE(options.remoteHost.port);
      buff.writeBuffer(options.data);
      return buff.toBuffer();
    }
    /**
     * Parses a SOCKS UDP frame.
     * @param data
     */
    static parseUDPFrame(data2) {
      const buff = smart_buffer_1.SmartBuffer.fromBuffer(data2);
      buff.readOffset = 2;
      const frameNumber = buff.readUInt8();
      const hostType = buff.readUInt8();
      let remoteHost;
      if (hostType === constants_12.Socks5HostType.IPv4) {
        remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
      } else if (hostType === constants_12.Socks5HostType.IPv6) {
        remoteHost = ip_address_12.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm();
      } else {
        remoteHost = buff.readString(buff.readUInt8());
      }
      const remotePort = buff.readUInt16BE();
      return {
        frameNumber,
        remoteHost: {
          host: remoteHost,
          port: remotePort
        },
        data: buff.readBuffer()
      };
    }
    /**
     * Internal state setter. If the SocksClient is in an error state, it cannot be changed to a non error state.
     */
    setState(newState) {
      if (this.state !== constants_12.SocksClientState.Error) {
        this.state = newState;
      }
    }
    /**
     * Starts the connection establishment to the proxy and destination.
     * @param existingSocket Connected socket to use instead of creating a new one (internal use).
     */
    connect(existingSocket) {
      this.onDataReceived = (data2) => this.onDataReceivedHandler(data2);
      this.onClose = () => this.onCloseHandler();
      this.onError = (err) => this.onErrorHandler(err);
      this.onConnect = () => this.onConnectHandler();
      const timer = setTimeout(() => this.onEstablishedTimeout(), this.options.timeout || constants_12.DEFAULT_TIMEOUT);
      if (timer.unref && typeof timer.unref === "function") {
        timer.unref();
      }
      if (existingSocket) {
        this.socket = existingSocket;
      } else {
        this.socket = new net2.Socket();
      }
      this.socket.once("close", this.onClose);
      this.socket.once("error", this.onError);
      this.socket.once("connect", this.onConnect);
      this.socket.on("data", this.onDataReceived);
      this.setState(constants_12.SocksClientState.Connecting);
      this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
      if (existingSocket) {
        this.socket.emit("connect");
      } else {
        this.socket.connect(this.getSocketOptions());
        if (this.options.set_tcp_nodelay !== void 0 && this.options.set_tcp_nodelay !== null) {
          this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
        }
      }
      this.prependOnceListener("established", (info) => {
        setImmediate(() => {
          if (this.receiveBuffer.length > 0) {
            const excessData = this.receiveBuffer.get(this.receiveBuffer.length);
            info.socket.emit("data", excessData);
          }
          info.socket.resume();
        });
      });
    }
    // Socket options (defaults host/port to options.proxy.host/options.proxy.port)
    getSocketOptions() {
      return Object.assign(Object.assign({}, this.options.socket_options), { host: this.options.proxy.host || this.options.proxy.ipaddress, port: this.options.proxy.port });
    }
    /**
     * Handles internal Socks timeout callback.
     * Note: If the Socks client is not BoundWaitingForConnection or Established, the connection will be closed.
     */
    onEstablishedTimeout() {
      if (this.state !== constants_12.SocksClientState.Established && this.state !== constants_12.SocksClientState.BoundWaitingForConnection) {
        this.closeSocket(constants_12.ERRORS.ProxyConnectionTimedOut);
      }
    }
    /**
     * Handles Socket connect event.
     */
    onConnectHandler() {
      this.setState(constants_12.SocksClientState.Connected);
      if (this.options.proxy.type === 4) {
        this.sendSocks4InitialHandshake();
      } else {
        this.sendSocks5InitialHandshake();
      }
      this.setState(constants_12.SocksClientState.SentInitialHandshake);
    }
    /**
     * Handles Socket data event.
     * @param data
     */
    onDataReceivedHandler(data2) {
      this.receiveBuffer.append(data2);
      this.processData();
    }
    /**
     * Handles processing of the data we have received.
     */
    processData() {
      while (this.state !== constants_12.SocksClientState.Established && this.state !== constants_12.SocksClientState.Error && this.receiveBuffer.length >= this.nextRequiredPacketBufferSize) {
        if (this.state === constants_12.SocksClientState.SentInitialHandshake) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4FinalHandshakeResponse();
          } else {
            this.handleInitialSocks5HandshakeResponse();
          }
        } else if (this.state === constants_12.SocksClientState.SentAuthentication) {
          this.handleInitialSocks5AuthenticationHandshakeResponse();
        } else if (this.state === constants_12.SocksClientState.SentFinalHandshake) {
          this.handleSocks5FinalHandshakeResponse();
        } else if (this.state === constants_12.SocksClientState.BoundWaitingForConnection) {
          if (this.options.proxy.type === 4) {
            this.handleSocks4IncomingConnectionResponse();
          } else {
            this.handleSocks5IncomingConnectionResponse();
          }
        } else {
          this.closeSocket(constants_12.ERRORS.InternalError);
          break;
        }
      }
    }
    /**
     * Handles Socket close event.
     * @param had_error
     */
    onCloseHandler() {
      this.closeSocket(constants_12.ERRORS.SocketClosed);
    }
    /**
     * Handles Socket error event.
     * @param err
     */
    onErrorHandler(err) {
      this.closeSocket(err.message);
    }
    /**
     * Removes internal event listeners on the underlying Socket.
     */
    removeInternalSocketHandlers() {
      this.socket.pause();
      this.socket.removeListener("data", this.onDataReceived);
      this.socket.removeListener("close", this.onClose);
      this.socket.removeListener("error", this.onError);
      this.socket.removeListener("connect", this.onConnect);
    }
    /**
     * Closes and destroys the underlying Socket. Emits an error event.
     * @param err { String } An error string to include in error event.
     */
    closeSocket(err) {
      if (this.state !== constants_12.SocksClientState.Error) {
        this.setState(constants_12.SocksClientState.Error);
        this.socket.destroy();
        this.removeInternalSocketHandlers();
        this.emit("error", new util_12.SocksClientError(err, this.options));
      }
    }
    /**
     * Sends initial Socks v4 handshake request.
     */
    sendSocks4InitialHandshake() {
      const userId = this.options.proxy.userId || "";
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(4);
      buff.writeUInt8(constants_12.SocksCommand[this.options.command]);
      buff.writeUInt16BE(this.options.destination.port);
      if (net2.isIPv4(this.options.destination.host)) {
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
        buff.writeStringNT(userId);
      } else {
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(0);
        buff.writeUInt8(1);
        buff.writeStringNT(userId);
        buff.writeStringNT(this.options.destination.host);
      }
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
      this.socket.write(buff.toBuffer());
    }
    /**
     * Handles Socks v4 handshake response.
     * @param data
     */
    handleSocks4FinalHandshakeResponse() {
      const data2 = this.receiveBuffer.get(8);
      if (data2[1] !== constants_12.Socks4Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.Socks4ProxyRejectedConnection} - (${constants_12.Socks4Response[data2[1]]})`);
      } else {
        if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.bind) {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data2);
          buff.readOffset = 2;
          const remoteHost = {
            port: buff.readUInt16BE(),
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
          this.setState(constants_12.SocksClientState.BoundWaitingForConnection);
          this.emit("bound", { remoteHost, socket: this.socket });
        } else {
          this.setState(constants_12.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { socket: this.socket });
        }
      }
    }
    /**
     * Handles Socks v4 incoming connection request (BIND)
     * @param data
     */
    handleSocks4IncomingConnectionResponse() {
      const data2 = this.receiveBuffer.get(8);
      if (data2[1] !== constants_12.Socks4Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_12.Socks4Response[data2[1]]})`);
      } else {
        const buff = smart_buffer_1.SmartBuffer.fromBuffer(data2);
        buff.readOffset = 2;
        const remoteHost = {
          port: buff.readUInt16BE(),
          host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE())
        };
        this.setState(constants_12.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    /**
     * Sends initial Socks v5 handshake request.
     */
    sendSocks5InitialHandshake() {
      const buff = new smart_buffer_1.SmartBuffer();
      const supportedAuthMethods = [constants_12.Socks5Auth.NoAuth];
      if (this.options.proxy.userId || this.options.proxy.password) {
        supportedAuthMethods.push(constants_12.Socks5Auth.UserPass);
      }
      if (this.options.proxy.custom_auth_method !== void 0) {
        supportedAuthMethods.push(this.options.proxy.custom_auth_method);
      }
      buff.writeUInt8(5);
      buff.writeUInt8(supportedAuthMethods.length);
      for (const authMethod of supportedAuthMethods) {
        buff.writeUInt8(authMethod);
      }
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_12.SocksClientState.SentInitialHandshake);
    }
    /**
     * Handles initial Socks v5 handshake response.
     * @param data
     */
    handleInitialSocks5HandshakeResponse() {
      const data2 = this.receiveBuffer.get(2);
      if (data2[0] !== 5) {
        this.closeSocket(constants_12.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion);
      } else if (data2[1] === constants_12.SOCKS5_NO_ACCEPTABLE_AUTH) {
        this.closeSocket(constants_12.ERRORS.InvalidSocks5InitialHandshakeNoAcceptedAuthType);
      } else {
        if (data2[1] === constants_12.Socks5Auth.NoAuth) {
          this.socks5ChosenAuthType = constants_12.Socks5Auth.NoAuth;
          this.sendSocks5CommandRequest();
        } else if (data2[1] === constants_12.Socks5Auth.UserPass) {
          this.socks5ChosenAuthType = constants_12.Socks5Auth.UserPass;
          this.sendSocks5UserPassAuthentication();
        } else if (data2[1] === this.options.proxy.custom_auth_method) {
          this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
          this.sendSocks5CustomAuthentication();
        } else {
          this.closeSocket(constants_12.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType);
        }
      }
    }
    /**
     * Sends Socks v5 user & password auth handshake.
     *
     * Note: No auth and user/pass are currently supported.
     */
    sendSocks5UserPassAuthentication() {
      const userId = this.options.proxy.userId || "";
      const password = this.options.proxy.password || "";
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(1);
      buff.writeUInt8(Buffer.byteLength(userId));
      buff.writeString(userId);
      buff.writeUInt8(Buffer.byteLength(password));
      buff.writeString(password);
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
      this.socket.write(buff.toBuffer());
      this.setState(constants_12.SocksClientState.SentAuthentication);
    }
    sendSocks5CustomAuthentication() {
      return __awaiter2(this, void 0, void 0, function* () {
        this.nextRequiredPacketBufferSize = this.options.proxy.custom_auth_response_size;
        this.socket.write(yield this.options.proxy.custom_auth_request_handler());
        this.setState(constants_12.SocksClientState.SentAuthentication);
      });
    }
    handleSocks5CustomAuthHandshakeResponse(data2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return yield this.options.proxy.custom_auth_response_handler(data2);
      });
    }
    handleSocks5AuthenticationNoAuthHandshakeResponse(data2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return data2[1] === 0;
      });
    }
    handleSocks5AuthenticationUserPassHandshakeResponse(data2) {
      return __awaiter2(this, void 0, void 0, function* () {
        return data2[1] === 0;
      });
    }
    /**
     * Handles Socks v5 auth handshake response.
     * @param data
     */
    handleInitialSocks5AuthenticationHandshakeResponse() {
      return __awaiter2(this, void 0, void 0, function* () {
        this.setState(constants_12.SocksClientState.ReceivedAuthenticationResponse);
        let authResult = false;
        if (this.socks5ChosenAuthType === constants_12.Socks5Auth.NoAuth) {
          authResult = yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === constants_12.Socks5Auth.UserPass) {
          authResult = yield this.handleSocks5AuthenticationUserPassHandshakeResponse(this.receiveBuffer.get(2));
        } else if (this.socks5ChosenAuthType === this.options.proxy.custom_auth_method) {
          authResult = yield this.handleSocks5CustomAuthHandshakeResponse(this.receiveBuffer.get(this.options.proxy.custom_auth_response_size));
        }
        if (!authResult) {
          this.closeSocket(constants_12.ERRORS.Socks5AuthenticationFailed);
        } else {
          this.sendSocks5CommandRequest();
        }
      });
    }
    /**
     * Sends Socks v5 final handshake request.
     */
    sendSocks5CommandRequest() {
      const buff = new smart_buffer_1.SmartBuffer();
      buff.writeUInt8(5);
      buff.writeUInt8(constants_12.SocksCommand[this.options.command]);
      buff.writeUInt8(0);
      if (net2.isIPv4(this.options.destination.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv4);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else if (net2.isIPv6(this.options.destination.host)) {
        buff.writeUInt8(constants_12.Socks5HostType.IPv6);
        buff.writeBuffer((0, helpers_1.ipToBuffer)(this.options.destination.host));
      } else {
        buff.writeUInt8(constants_12.Socks5HostType.Hostname);
        buff.writeUInt8(this.options.destination.host.length);
        buff.writeString(this.options.destination.host);
      }
      buff.writeUInt16BE(this.options.destination.port);
      this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
      this.socket.write(buff.toBuffer());
      this.setState(constants_12.SocksClientState.SentFinalHandshake);
    }
    /**
     * Handles Socks v5 final handshake response.
     * @param data
     */
    handleSocks5FinalHandshakeResponse() {
      const header3 = this.receiveBuffer.peek(5);
      if (header3[0] !== 5 || header3[1] !== constants_12.Socks5Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_12.Socks5Response[header3[1]]}`);
      } else {
        const addressType = header3[3];
        let remoteHost;
        let buff;
        if (addressType === constants_12.Socks5HostType.IPv4) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_12.Socks5HostType.Hostname) {
          const hostLength = header3[4];
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_12.Socks5HostType.IPv6) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip_address_12.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_12.SocksClientState.ReceivedFinalResponse);
        if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.connect) {
          this.setState(constants_12.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", { remoteHost, socket: this.socket });
        } else if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.bind) {
          this.setState(constants_12.SocksClientState.BoundWaitingForConnection);
          this.nextRequiredPacketBufferSize = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.emit("bound", { remoteHost, socket: this.socket });
        } else if (constants_12.SocksCommand[this.options.command] === constants_12.SocksCommand.associate) {
          this.setState(constants_12.SocksClientState.Established);
          this.removeInternalSocketHandlers();
          this.emit("established", {
            remoteHost,
            socket: this.socket
          });
        }
      }
    }
    /**
     * Handles Socks v5 incoming connection request (BIND).
     */
    handleSocks5IncomingConnectionResponse() {
      const header3 = this.receiveBuffer.peek(5);
      if (header3[0] !== 5 || header3[1] !== constants_12.Socks5Response.Granted) {
        this.closeSocket(`${constants_12.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_12.Socks5Response[header3[1]]}`);
      } else {
        const addressType = header3[3];
        let remoteHost;
        let buff;
        if (addressType === constants_12.Socks5HostType.IPv4) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            port: buff.readUInt16BE()
          };
          if (remoteHost.host === "0.0.0.0") {
            remoteHost.host = this.options.proxy.ipaddress;
          }
        } else if (addressType === constants_12.Socks5HostType.Hostname) {
          const hostLength = header3[4];
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(hostLength);
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(5));
          remoteHost = {
            host: buff.readString(hostLength),
            port: buff.readUInt16BE()
          };
        } else if (addressType === constants_12.Socks5HostType.IPv6) {
          const dataNeeded = constants_12.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
          if (this.receiveBuffer.length < dataNeeded) {
            this.nextRequiredPacketBufferSize = dataNeeded;
            return;
          }
          buff = smart_buffer_1.SmartBuffer.fromBuffer(this.receiveBuffer.get(dataNeeded).slice(4));
          remoteHost = {
            host: ip_address_12.Address6.fromByteArray(Array.from(buff.readBuffer(16))).canonicalForm(),
            port: buff.readUInt16BE()
          };
        }
        this.setState(constants_12.SocksClientState.Established);
        this.removeInternalSocketHandlers();
        this.emit("established", { remoteHost, socket: this.socket });
      }
    }
    get socksClientOptions() {
      return Object.assign({}, this.options);
    }
  }
  exports.SocksClient = SocksClient;
})(socksclient);
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(socksclient, exports);
})(build);
var dist$5 = {};
var helpers = {};
var __createBinding$4 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$4 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$4 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$4(result, mod, k);
  }
  __setModuleDefault$4(result, mod);
  return result;
};
Object.defineProperty(helpers, "__esModule", { value: true });
helpers.req = helpers.json = helpers.toBuffer = void 0;
const http$3 = __importStar$4(require$$0$a);
const https$4 = __importStar$4(require$$2$4);
async function toBuffer(stream3) {
  let length = 0;
  const chunks = [];
  for await (const chunk of stream3) {
    length += chunk.length;
    chunks.push(chunk);
  }
  return Buffer.concat(chunks, length);
}
helpers.toBuffer = toBuffer;
async function json$1(stream3) {
  const buf = await toBuffer(stream3);
  const str2 = buf.toString("utf8");
  try {
    return JSON.parse(str2);
  } catch (_err) {
    const err = _err;
    err.message += ` (input: ${str2})`;
    throw err;
  }
}
helpers.json = json$1;
function req(url2, opts = {}) {
  const href = typeof url2 === "string" ? url2 : url2.href;
  const req2 = (href.startsWith("https:") ? https$4 : http$3).request(url2, opts);
  const promise2 = new Promise((resolve3, reject) => {
    req2.once("response", resolve3).once("error", reject).end();
  });
  req2.then = promise2.then.bind(promise2);
  return req2;
}
helpers.req = req;
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
    }
    __setModuleDefault2(result, mod);
    return result;
  };
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Agent = void 0;
  const net2 = __importStar2(require$$0$6);
  const http2 = __importStar2(require$$0$a);
  const https_12 = require$$2$4;
  __exportStar2(helpers, exports);
  const INTERNAL = Symbol("AgentBaseInternalState");
  class Agent extends http2.Agent {
    constructor(opts) {
      super(opts);
      this[INTERNAL] = {};
    }
    /**
     * Determine whether this is an `http` or `https` request.
     */
    isSecureEndpoint(options) {
      if (options) {
        if (typeof options.secureEndpoint === "boolean") {
          return options.secureEndpoint;
        }
        if (typeof options.protocol === "string") {
          return options.protocol === "https:";
        }
      }
      const { stack } = new Error();
      if (typeof stack !== "string")
        return false;
      return stack.split("\n").some((l) => l.indexOf("(https.js:") !== -1 || l.indexOf("node:https:") !== -1);
    }
    // In order to support async signatures in `connect()` and Node's native
    // connection pooling in `http.Agent`, the array of sockets for each origin
    // has to be updated synchronously. This is so the length of the array is
    // accurate when `addRequest()` is next called. We achieve this by creating a
    // fake socket and adding it to `sockets[origin]` and incrementing
    // `totalSocketCount`.
    incrementSockets(name2) {
      if (this.maxSockets === Infinity && this.maxTotalSockets === Infinity) {
        return null;
      }
      if (!this.sockets[name2]) {
        this.sockets[name2] = [];
      }
      const fakeSocket = new net2.Socket({ writable: false });
      this.sockets[name2].push(fakeSocket);
      this.totalSocketCount++;
      return fakeSocket;
    }
    decrementSockets(name2, socket) {
      if (!this.sockets[name2] || socket === null) {
        return;
      }
      const sockets = this.sockets[name2];
      const index2 = sockets.indexOf(socket);
      if (index2 !== -1) {
        sockets.splice(index2, 1);
        this.totalSocketCount--;
        if (sockets.length === 0) {
          delete this.sockets[name2];
        }
      }
    }
    // In order to properly update the socket pool, we need to call `getName()` on
    // the core `https.Agent` if it is a secureEndpoint.
    getName(options) {
      const secureEndpoint = typeof options.secureEndpoint === "boolean" ? options.secureEndpoint : this.isSecureEndpoint(options);
      if (secureEndpoint) {
        return https_12.Agent.prototype.getName.call(this, options);
      }
      return super.getName(options);
    }
    createSocket(req2, options, cb) {
      const connectOpts = {
        ...options,
        secureEndpoint: this.isSecureEndpoint(options)
      };
      const name2 = this.getName(connectOpts);
      const fakeSocket = this.incrementSockets(name2);
      Promise.resolve().then(() => this.connect(req2, connectOpts)).then((socket) => {
        this.decrementSockets(name2, fakeSocket);
        if (socket instanceof http2.Agent) {
          return socket.addRequest(req2, connectOpts);
        }
        this[INTERNAL].currentSocket = socket;
        super.createSocket(req2, options, cb);
      }, (err) => {
        this.decrementSockets(name2, fakeSocket);
        cb(err);
      });
    }
    createConnection() {
      const socket = this[INTERNAL].currentSocket;
      this[INTERNAL].currentSocket = void 0;
      if (!socket) {
        throw new Error("No socket was returned in the `connect()` function");
      }
      return socket;
    }
    get defaultPort() {
      return this[INTERNAL].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].defaultPort = v;
      }
    }
    get protocol() {
      return this[INTERNAL].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:");
    }
    set protocol(v) {
      if (this[INTERNAL]) {
        this[INTERNAL].protocol = v;
      }
    }
  }
  exports.Agent = Agent;
})(dist$5);
var __createBinding$3 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$3 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$3 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$3(result, mod, k);
  }
  __setModuleDefault$3(result, mod);
  return result;
};
var __importDefault$7 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$6, "__esModule", { value: true });
dist$6.SocksProxyAgent = void 0;
const socks_1 = build;
const agent_base_1$1 = dist$5;
const debug_1$5 = __importDefault$7(srcExports);
const dns = __importStar$3(require$$3$4);
const tls$2 = __importStar$3(require$$1$6);
const url_1$2 = require$$5$2;
const debug$7 = (0, debug_1$5.default)("socks-proxy-agent");
function parseSocksURL(url2) {
  let lookup2 = false;
  let type3 = 5;
  const host2 = url2.hostname;
  const port = parseInt(url2.port, 10) || 1080;
  switch (url2.protocol.replace(":", "")) {
    case "socks4":
      lookup2 = true;
      type3 = 4;
      break;
    case "socks4a":
      type3 = 4;
      break;
    case "socks5":
      lookup2 = true;
      type3 = 5;
      break;
    case "socks":
      type3 = 5;
      break;
    case "socks5h":
      type3 = 5;
      break;
    default:
      throw new TypeError(`A "socks" protocol must be specified! Got: ${String(url2.protocol)}`);
  }
  const proxy = {
    host: host2,
    port,
    type: type3
  };
  if (url2.username) {
    Object.defineProperty(proxy, "userId", {
      value: decodeURIComponent(url2.username),
      enumerable: false
    });
  }
  if (url2.password != null) {
    Object.defineProperty(proxy, "password", {
      value: decodeURIComponent(url2.password),
      enumerable: false
    });
  }
  return { lookup: lookup2, proxy };
}
class SocksProxyAgent extends agent_base_1$1.Agent {
  constructor(uri2, opts) {
    super(opts);
    const url2 = typeof uri2 === "string" ? new url_1$2.URL(uri2) : uri2;
    const { proxy, lookup: lookup2 } = parseSocksURL(url2);
    this.shouldLookup = lookup2;
    this.proxy = proxy;
    this.timeout = (opts == null ? void 0 : opts.timeout) ?? null;
    this.socketOptions = (opts == null ? void 0 : opts.socketOptions) ?? null;
  }
  /**
   * Initiates a SOCKS connection to the specified SOCKS proxy server,
   * which in turn connects to the specified remote host and port.
   */
  async connect(req2, opts) {
    const { shouldLookup, proxy, timeout } = this;
    if (!opts.host) {
      throw new Error("No `host` defined!");
    }
    let { host: host2 } = opts;
    const { port, lookup: lookupFn = dns.lookup } = opts;
    if (shouldLookup) {
      host2 = await new Promise((resolve3, reject) => {
        lookupFn(host2, {}, (err, res2) => {
          if (err) {
            reject(err);
          } else {
            resolve3(res2);
          }
        });
      });
    }
    const socksOpts = {
      proxy,
      destination: {
        host: host2,
        port: typeof port === "number" ? port : parseInt(port, 10)
      },
      command: "connect",
      timeout: timeout ?? void 0,
      // @ts-expect-error the type supplied by socks for socket_options is wider
      // than necessary since socks will always override the host and port
      socket_options: this.socketOptions ?? void 0
    };
    const cleanup = (tlsSocket) => {
      req2.destroy();
      socket.destroy();
      if (tlsSocket)
        tlsSocket.destroy();
    };
    debug$7("Creating socks proxy connection: %o", socksOpts);
    const { socket } = await socks_1.SocksClient.createConnection(socksOpts);
    debug$7("Successfully created socks proxy connection");
    if (timeout !== null) {
      socket.setTimeout(timeout);
      socket.on("timeout", () => cleanup());
    }
    if (opts.secureEndpoint) {
      debug$7("Upgrading socket connection to TLS");
      const servername = opts.servername || opts.host;
      const tlsSocket = tls$2.connect({
        ...omit(opts, "host", "path", "port"),
        socket,
        servername
      });
      tlsSocket.once("error", (error2) => {
        debug$7("Socket TLS error", error2.message);
        cleanup(tlsSocket);
      });
      return tlsSocket;
    }
    return socket;
  }
}
SocksProxyAgent.protocols = [
  "socks",
  "socks4",
  "socks4a",
  "socks5",
  "socks5h"
];
dist$6.SocksProxyAgent = SocksProxyAgent;
function omit(obj, ...keys2) {
  const ret = {};
  let key;
  for (key in obj) {
    if (!keys2.includes(key)) {
      ret[key] = obj[key];
    }
  }
  return ret;
}
var dist$4 = {};
var data$1 = {};
var node = {};
var common = {};
Object.defineProperty(common, "__esModule", { value: true });
common.makeDataUriToBuffer = void 0;
const makeDataUriToBuffer = (convert) => (uri2) => {
  uri2 = String(uri2);
  if (!/^data:/i.test(uri2)) {
    throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
  }
  uri2 = uri2.replace(/\r?\n/g, "");
  const firstComma = uri2.indexOf(",");
  if (firstComma === -1 || firstComma <= 4) {
    throw new TypeError("malformed data: URI");
  }
  const meta = uri2.substring(5, firstComma).split(";");
  let charset3 = "";
  let base642 = false;
  const type3 = meta[0] || "text/plain";
  let typeFull = type3;
  for (let i = 1; i < meta.length; i++) {
    if (meta[i] === "base64") {
      base642 = true;
    } else if (meta[i]) {
      typeFull += `;${meta[i]}`;
      if (meta[i].indexOf("charset=") === 0) {
        charset3 = meta[i].substring(8);
      }
    }
  }
  if (!meta[0] && !charset3.length) {
    typeFull += ";charset=US-ASCII";
    charset3 = "US-ASCII";
  }
  const data2 = unescape(uri2.substring(firstComma + 1));
  const buffer = base642 ? convert.base64ToArrayBuffer(data2) : convert.stringToBuffer(data2);
  return {
    type: type3,
    typeFull,
    charset: charset3,
    buffer
  };
};
common.makeDataUriToBuffer = makeDataUriToBuffer;
Object.defineProperty(node, "__esModule", { value: true });
node.dataUriToBuffer = void 0;
const common_1 = common;
function nodeBuffertoArrayBuffer(nodeBuf) {
  if (nodeBuf.byteLength === nodeBuf.buffer.byteLength) {
    return nodeBuf.buffer;
  }
  const buffer = new ArrayBuffer(nodeBuf.byteLength);
  const view2 = new Uint8Array(buffer);
  view2.set(nodeBuf);
  return buffer;
}
function base64ToArrayBuffer(base642) {
  return nodeBuffertoArrayBuffer(Buffer.from(base642, "base64"));
}
function stringToBuffer(str2) {
  return nodeBuffertoArrayBuffer(Buffer.from(str2, "ascii"));
}
node.dataUriToBuffer = (0, common_1.makeDataUriToBuffer)({ stringToBuffer, base64ToArrayBuffer });
var notmodified = {};
Object.defineProperty(notmodified, "__esModule", { value: true });
class NotModifiedError extends Error {
  constructor(message) {
    super(message || 'Source has not been modified since the provied "cache", re-use previous results');
    this.code = "ENOTMODIFIED";
  }
}
notmodified.default = NotModifiedError;
var __importDefault$6 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(data$1, "__esModule", { value: true });
data$1.data = void 0;
const debug_1$4 = __importDefault$6(srcExports);
const stream_1$3 = require$$1$4;
const crypto_1 = require$$2$3;
const data_uri_to_buffer_1 = node;
const notmodified_1$2 = __importDefault$6(notmodified);
const debug$6 = (0, debug_1$4.default)("get-uri:data");
class DataReadable extends stream_1$3.Readable {
  constructor(hash2, buf) {
    super();
    this.push(buf);
    this.push(null);
    this.hash = hash2;
  }
}
const data = async ({ href: uri2 }, { cache: cache2 } = {}) => {
  const shasum = (0, crypto_1.createHash)("sha1");
  shasum.update(uri2);
  const hash2 = shasum.digest("hex");
  debug$6('generated SHA1 hash for "data:" URI: %o', hash2);
  if ((cache2 == null ? void 0 : cache2.hash) === hash2) {
    debug$6("got matching cache SHA1 hash: %o", hash2);
    throw new notmodified_1$2.default();
  } else {
    debug$6('creating Readable stream from "data:" URI buffer');
    const { buffer } = (0, data_uri_to_buffer_1.dataUriToBuffer)(uri2);
    return new DataReadable(hash2, Buffer.from(buffer));
  }
};
data$1.data = data;
var file$2 = {};
var fs$l = {};
var universalify$1 = {};
universalify$1.fromCallback = function(fn) {
  return Object.defineProperty(function(...args) {
    if (typeof args[args.length - 1] === "function") fn.apply(this, args);
    else {
      return new Promise((resolve3, reject) => {
        args.push((err, res2) => err != null ? reject(err) : resolve3(res2));
        fn.apply(this, args);
      });
    }
  }, "name", { value: fn.name });
};
universalify$1.fromPromise = function(fn) {
  return Object.defineProperty(function(...args) {
    const cb = args[args.length - 1];
    if (typeof cb !== "function") return fn.apply(this, args);
    else {
      args.pop();
      fn.apply(this, args).then((r) => cb(null, r), cb);
    }
  }, "name", { value: fn.name });
};
var constants = require$$0$c;
var origCwd = process.cwd;
var cwd = null;
var platform = process.env.GRACEFUL_FS_PLATFORM || process.platform;
process.cwd = function() {
  if (!cwd)
    cwd = origCwd.call(process);
  return cwd;
};
try {
  process.cwd();
} catch (er) {
}
if (typeof process.chdir === "function") {
  var chdir = process.chdir;
  process.chdir = function(d2) {
    cwd = null;
    chdir.call(process, d2);
  };
  if (Object.setPrototypeOf) Object.setPrototypeOf(process.chdir, chdir);
}
var polyfills$1 = patch$1;
function patch$1(fs2) {
  if (constants.hasOwnProperty("O_SYMLINK") && process.version.match(/^v0\.6\.[0-2]|^v0\.5\./)) {
    patchLchmod(fs2);
  }
  if (!fs2.lutimes) {
    patchLutimes(fs2);
  }
  fs2.chown = chownFix(fs2.chown);
  fs2.fchown = chownFix(fs2.fchown);
  fs2.lchown = chownFix(fs2.lchown);
  fs2.chmod = chmodFix(fs2.chmod);
  fs2.fchmod = chmodFix(fs2.fchmod);
  fs2.lchmod = chmodFix(fs2.lchmod);
  fs2.chownSync = chownFixSync(fs2.chownSync);
  fs2.fchownSync = chownFixSync(fs2.fchownSync);
  fs2.lchownSync = chownFixSync(fs2.lchownSync);
  fs2.chmodSync = chmodFixSync(fs2.chmodSync);
  fs2.fchmodSync = chmodFixSync(fs2.fchmodSync);
  fs2.lchmodSync = chmodFixSync(fs2.lchmodSync);
  fs2.stat = statFix(fs2.stat);
  fs2.fstat = statFix(fs2.fstat);
  fs2.lstat = statFix(fs2.lstat);
  fs2.statSync = statFixSync(fs2.statSync);
  fs2.fstatSync = statFixSync(fs2.fstatSync);
  fs2.lstatSync = statFixSync(fs2.lstatSync);
  if (fs2.chmod && !fs2.lchmod) {
    fs2.lchmod = function(path3, mode, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchmodSync = function() {
    };
  }
  if (fs2.chown && !fs2.lchown) {
    fs2.lchown = function(path3, uid, gid, cb) {
      if (cb) process.nextTick(cb);
    };
    fs2.lchownSync = function() {
    };
  }
  if (platform === "win32") {
    fs2.rename = typeof fs2.rename !== "function" ? fs2.rename : function(fs$rename) {
      function rename2(from2, to, cb) {
        var start = Date.now();
        var backoff = 0;
        fs$rename(from2, to, function CB(er) {
          if (er && (er.code === "EACCES" || er.code === "EPERM" || er.code === "EBUSY") && Date.now() - start < 6e4) {
            setTimeout(function() {
              fs2.stat(to, function(stater, st) {
                if (stater && stater.code === "ENOENT")
                  fs$rename(from2, to, CB);
                else
                  cb(er);
              });
            }, backoff);
            if (backoff < 100)
              backoff += 10;
            return;
          }
          if (cb) cb(er);
        });
      }
      if (Object.setPrototypeOf) Object.setPrototypeOf(rename2, fs$rename);
      return rename2;
    }(fs2.rename);
  }
  fs2.read = typeof fs2.read !== "function" ? fs2.read : function(fs$read) {
    function read(fd, buffer, offset, length, position, callback_) {
      var callback;
      if (callback_ && typeof callback_ === "function") {
        var eagCounter = 0;
        callback = function(er, _, __2) {
          if (er && er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
          }
          callback_.apply(this, arguments);
        };
      }
      return fs$read.call(fs2, fd, buffer, offset, length, position, callback);
    }
    if (Object.setPrototypeOf) Object.setPrototypeOf(read, fs$read);
    return read;
  }(fs2.read);
  fs2.readSync = typeof fs2.readSync !== "function" ? fs2.readSync : /* @__PURE__ */ function(fs$readSync) {
    return function(fd, buffer, offset, length, position) {
      var eagCounter = 0;
      while (true) {
        try {
          return fs$readSync.call(fs2, fd, buffer, offset, length, position);
        } catch (er) {
          if (er.code === "EAGAIN" && eagCounter < 10) {
            eagCounter++;
            continue;
          }
          throw er;
        }
      }
    };
  }(fs2.readSync);
  function patchLchmod(fs22) {
    fs22.lchmod = function(path3, mode, callback) {
      fs22.open(
        path3,
        constants.O_WRONLY | constants.O_SYMLINK,
        mode,
        function(err, fd) {
          if (err) {
            if (callback) callback(err);
            return;
          }
          fs22.fchmod(fd, mode, function(err2) {
            fs22.close(fd, function(err22) {
              if (callback) callback(err2 || err22);
            });
          });
        }
      );
    };
    fs22.lchmodSync = function(path3, mode) {
      var fd = fs22.openSync(path3, constants.O_WRONLY | constants.O_SYMLINK, mode);
      var threw = true;
      var ret;
      try {
        ret = fs22.fchmodSync(fd, mode);
        threw = false;
      } finally {
        if (threw) {
          try {
            fs22.closeSync(fd);
          } catch (er) {
          }
        } else {
          fs22.closeSync(fd);
        }
      }
      return ret;
    };
  }
  function patchLutimes(fs22) {
    if (constants.hasOwnProperty("O_SYMLINK") && fs22.futimes) {
      fs22.lutimes = function(path3, at, mt, cb) {
        fs22.open(path3, constants.O_SYMLINK, function(er, fd) {
          if (er) {
            if (cb) cb(er);
            return;
          }
          fs22.futimes(fd, at, mt, function(er2) {
            fs22.close(fd, function(er22) {
              if (cb) cb(er2 || er22);
            });
          });
        });
      };
      fs22.lutimesSync = function(path3, at, mt) {
        var fd = fs22.openSync(path3, constants.O_SYMLINK);
        var ret;
        var threw = true;
        try {
          ret = fs22.futimesSync(fd, at, mt);
          threw = false;
        } finally {
          if (threw) {
            try {
              fs22.closeSync(fd);
            } catch (er) {
            }
          } else {
            fs22.closeSync(fd);
          }
        }
        return ret;
      };
    } else if (fs22.futimes) {
      fs22.lutimes = function(_a, _b, _c, cb) {
        if (cb) process.nextTick(cb);
      };
      fs22.lutimesSync = function() {
      };
    }
  }
  function chmodFix(orig) {
    if (!orig) return orig;
    return function(target, mode, cb) {
      return orig.call(fs2, target, mode, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chmodFixSync(orig) {
    if (!orig) return orig;
    return function(target, mode) {
      try {
        return orig.call(fs2, target, mode);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function chownFix(orig) {
    if (!orig) return orig;
    return function(target, uid, gid, cb) {
      return orig.call(fs2, target, uid, gid, function(er) {
        if (chownErOk(er)) er = null;
        if (cb) cb.apply(this, arguments);
      });
    };
  }
  function chownFixSync(orig) {
    if (!orig) return orig;
    return function(target, uid, gid) {
      try {
        return orig.call(fs2, target, uid, gid);
      } catch (er) {
        if (!chownErOk(er)) throw er;
      }
    };
  }
  function statFix(orig) {
    if (!orig) return orig;
    return function(target, options, cb) {
      if (typeof options === "function") {
        cb = options;
        options = null;
      }
      function callback(er, stats) {
        if (stats) {
          if (stats.uid < 0) stats.uid += 4294967296;
          if (stats.gid < 0) stats.gid += 4294967296;
        }
        if (cb) cb.apply(this, arguments);
      }
      return options ? orig.call(fs2, target, options, callback) : orig.call(fs2, target, callback);
    };
  }
  function statFixSync(orig) {
    if (!orig) return orig;
    return function(target, options) {
      var stats = options ? orig.call(fs2, target, options) : orig.call(fs2, target);
      if (stats) {
        if (stats.uid < 0) stats.uid += 4294967296;
        if (stats.gid < 0) stats.gid += 4294967296;
      }
      return stats;
    };
  }
  function chownErOk(er) {
    if (!er)
      return true;
    if (er.code === "ENOSYS")
      return true;
    var nonroot = !process.getuid || process.getuid() !== 0;
    if (nonroot) {
      if (er.code === "EINVAL" || er.code === "EPERM")
        return true;
    }
    return false;
  }
}
var Stream = require$$1$4.Stream;
var legacyStreams = legacy$1;
function legacy$1(fs2) {
  return {
    ReadStream: ReadStream2,
    WriteStream
  };
  function ReadStream2(path3, options) {
    if (!(this instanceof ReadStream2)) return new ReadStream2(path3, options);
    Stream.call(this);
    var self3 = this;
    this.path = path3;
    this.fd = null;
    this.readable = true;
    this.paused = false;
    this.flags = "r";
    this.mode = 438;
    this.bufferSize = 64 * 1024;
    options = options || {};
    var keys2 = Object.keys(options);
    for (var index2 = 0, length = keys2.length; index2 < length; index2++) {
      var key = keys2[index2];
      this[key] = options[key];
    }
    if (this.encoding) this.setEncoding(this.encoding);
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if ("number" !== typeof this.end) {
        throw TypeError("end must be a Number");
      }
      if (this.start > this.end) {
        throw new Error("start must be <= end");
      }
      this.pos = this.start;
    }
    if (this.fd !== null) {
      process.nextTick(function() {
        self3._read();
      });
      return;
    }
    fs2.open(this.path, this.flags, this.mode, function(err, fd) {
      if (err) {
        self3.emit("error", err);
        self3.readable = false;
        return;
      }
      self3.fd = fd;
      self3.emit("open", fd);
      self3._read();
    });
  }
  function WriteStream(path3, options) {
    if (!(this instanceof WriteStream)) return new WriteStream(path3, options);
    Stream.call(this);
    this.path = path3;
    this.fd = null;
    this.writable = true;
    this.flags = "w";
    this.encoding = "binary";
    this.mode = 438;
    this.bytesWritten = 0;
    options = options || {};
    var keys2 = Object.keys(options);
    for (var index2 = 0, length = keys2.length; index2 < length; index2++) {
      var key = keys2[index2];
      this[key] = options[key];
    }
    if (this.start !== void 0) {
      if ("number" !== typeof this.start) {
        throw TypeError("start must be a Number");
      }
      if (this.start < 0) {
        throw new Error("start must be >= zero");
      }
      this.pos = this.start;
    }
    this.busy = false;
    this._queue = [];
    if (this.fd === null) {
      this._open = fs2.open;
      this._queue.push([this._open, this.path, this.flags, this.mode, void 0]);
      this.flush();
    }
  }
}
var clone_1 = clone$1;
var getPrototypeOf$2 = Object.getPrototypeOf || function(obj) {
  return obj.__proto__;
};
function clone$1(obj) {
  if (obj === null || typeof obj !== "object")
    return obj;
  if (obj instanceof Object)
    var copy2 = { __proto__: getPrototypeOf$2(obj) };
  else
    var copy2 = /* @__PURE__ */ Object.create(null);
  Object.getOwnPropertyNames(obj).forEach(function(key) {
    Object.defineProperty(copy2, key, Object.getOwnPropertyDescriptor(obj, key));
  });
  return copy2;
}
var fs$k = require$$0$7;
var polyfills = polyfills$1;
var legacy = legacyStreams;
var clone = clone_1;
var util$4 = require$$1$3;
var gracefulQueue;
var previousSymbol;
if (typeof Symbol === "function" && typeof Symbol.for === "function") {
  gracefulQueue = Symbol.for("graceful-fs.queue");
  previousSymbol = Symbol.for("graceful-fs.previous");
} else {
  gracefulQueue = "___graceful-fs.queue";
  previousSymbol = "___graceful-fs.previous";
}
function noop$3() {
}
function publishQueue(context2, queue2) {
  Object.defineProperty(context2, gracefulQueue, {
    get: function() {
      return queue2;
    }
  });
}
var debug$5 = noop$3;
if (util$4.debuglog)
  debug$5 = util$4.debuglog("gfs4");
else if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || ""))
  debug$5 = function() {
    var m2 = util$4.format.apply(util$4, arguments);
    m2 = "GFS4: " + m2.split(/\n/).join("\nGFS4: ");
    console.error(m2);
  };
if (!fs$k[gracefulQueue]) {
  var queue = commonjsGlobal[gracefulQueue] || [];
  publishQueue(fs$k, queue);
  fs$k.close = function(fs$close) {
    function close(fd, cb) {
      return fs$close.call(fs$k, fd, function(err) {
        if (!err) {
          resetQueue();
        }
        if (typeof cb === "function")
          cb.apply(this, arguments);
      });
    }
    Object.defineProperty(close, previousSymbol, {
      value: fs$close
    });
    return close;
  }(fs$k.close);
  fs$k.closeSync = function(fs$closeSync) {
    function closeSync(fd) {
      fs$closeSync.apply(fs$k, arguments);
      resetQueue();
    }
    Object.defineProperty(closeSync, previousSymbol, {
      value: fs$closeSync
    });
    return closeSync;
  }(fs$k.closeSync);
  if (/\bgfs4\b/i.test(process.env.NODE_DEBUG || "")) {
    process.on("exit", function() {
      debug$5(fs$k[gracefulQueue]);
      require$$5$3.equal(fs$k[gracefulQueue].length, 0);
    });
  }
}
if (!commonjsGlobal[gracefulQueue]) {
  publishQueue(commonjsGlobal, fs$k[gracefulQueue]);
}
var gracefulFs = patch(clone(fs$k));
if (process.env.TEST_GRACEFUL_FS_GLOBAL_PATCH && !fs$k.__patched) {
  gracefulFs = patch(fs$k);
  fs$k.__patched = true;
}
function patch(fs2) {
  polyfills(fs2);
  fs2.gracefulify = patch;
  fs2.createReadStream = createReadStream;
  fs2.createWriteStream = createWriteStream;
  var fs$readFile = fs2.readFile;
  fs2.readFile = readFile2;
  function readFile2(path3, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$readFile(path3, options, cb);
    function go$readFile(path22, options2, cb2, startTime) {
      return fs$readFile(path22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$readFile, [path22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$writeFile = fs2.writeFile;
  fs2.writeFile = writeFile2;
  function writeFile2(path3, data2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$writeFile(path3, data2, options, cb);
    function go$writeFile(path22, data22, options2, cb2, startTime) {
      return fs$writeFile(path22, data22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$writeFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$appendFile = fs2.appendFile;
  if (fs$appendFile)
    fs2.appendFile = appendFile;
  function appendFile(path3, data2, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    return go$appendFile(path3, data2, options, cb);
    function go$appendFile(path22, data22, options2, cb2, startTime) {
      return fs$appendFile(path22, data22, options2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$appendFile, [path22, data22, options2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$copyFile = fs2.copyFile;
  if (fs$copyFile)
    fs2.copyFile = copyFile2;
  function copyFile2(src2, dest, flags, cb) {
    if (typeof flags === "function") {
      cb = flags;
      flags = 0;
    }
    return go$copyFile(src2, dest, flags, cb);
    function go$copyFile(src22, dest2, flags2, cb2, startTime) {
      return fs$copyFile(src22, dest2, flags2, function(err) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$copyFile, [src22, dest2, flags2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  var fs$readdir = fs2.readdir;
  fs2.readdir = readdir;
  var noReaddirOptionVersions = /^v[0-5]\./;
  function readdir(path3, options, cb) {
    if (typeof options === "function")
      cb = options, options = null;
    var go$readdir = noReaddirOptionVersions.test(process.version) ? function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    } : function go$readdir2(path22, options2, cb2, startTime) {
      return fs$readdir(path22, options2, fs$readdirCallback(
        path22,
        options2,
        cb2,
        startTime
      ));
    };
    return go$readdir(path3, options, cb);
    function fs$readdirCallback(path22, options2, cb2, startTime) {
      return function(err, files2) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([
            go$readdir,
            [path22, options2, cb2],
            err,
            startTime || Date.now(),
            Date.now()
          ]);
        else {
          if (files2 && files2.sort)
            files2.sort();
          if (typeof cb2 === "function")
            cb2.call(this, err, files2);
        }
      };
    }
  }
  if (process.version.substr(0, 4) === "v0.8") {
    var legStreams = legacy(fs2);
    ReadStream2 = legStreams.ReadStream;
    WriteStream = legStreams.WriteStream;
  }
  var fs$ReadStream = fs2.ReadStream;
  if (fs$ReadStream) {
    ReadStream2.prototype = Object.create(fs$ReadStream.prototype);
    ReadStream2.prototype.open = ReadStream$open;
  }
  var fs$WriteStream = fs2.WriteStream;
  if (fs$WriteStream) {
    WriteStream.prototype = Object.create(fs$WriteStream.prototype);
    WriteStream.prototype.open = WriteStream$open;
  }
  Object.defineProperty(fs2, "ReadStream", {
    get: function() {
      return ReadStream2;
    },
    set: function(val) {
      ReadStream2 = val;
    },
    enumerable: true,
    configurable: true
  });
  Object.defineProperty(fs2, "WriteStream", {
    get: function() {
      return WriteStream;
    },
    set: function(val) {
      WriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileReadStream = ReadStream2;
  Object.defineProperty(fs2, "FileReadStream", {
    get: function() {
      return FileReadStream;
    },
    set: function(val) {
      FileReadStream = val;
    },
    enumerable: true,
    configurable: true
  });
  var FileWriteStream = WriteStream;
  Object.defineProperty(fs2, "FileWriteStream", {
    get: function() {
      return FileWriteStream;
    },
    set: function(val) {
      FileWriteStream = val;
    },
    enumerable: true,
    configurable: true
  });
  function ReadStream2(path3, options) {
    if (this instanceof ReadStream2)
      return fs$ReadStream.apply(this, arguments), this;
    else
      return ReadStream2.apply(Object.create(ReadStream2.prototype), arguments);
  }
  function ReadStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        if (that.autoClose)
          that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
        that.read();
      }
    });
  }
  function WriteStream(path3, options) {
    if (this instanceof WriteStream)
      return fs$WriteStream.apply(this, arguments), this;
    else
      return WriteStream.apply(Object.create(WriteStream.prototype), arguments);
  }
  function WriteStream$open() {
    var that = this;
    open(that.path, that.flags, that.mode, function(err, fd) {
      if (err) {
        that.destroy();
        that.emit("error", err);
      } else {
        that.fd = fd;
        that.emit("open", fd);
      }
    });
  }
  function createReadStream(path3, options) {
    return new fs2.ReadStream(path3, options);
  }
  function createWriteStream(path3, options) {
    return new fs2.WriteStream(path3, options);
  }
  var fs$open = fs2.open;
  fs2.open = open;
  function open(path3, flags, mode, cb) {
    if (typeof mode === "function")
      cb = mode, mode = null;
    return go$open(path3, flags, mode, cb);
    function go$open(path22, flags2, mode2, cb2, startTime) {
      return fs$open(path22, flags2, mode2, function(err, fd) {
        if (err && (err.code === "EMFILE" || err.code === "ENFILE"))
          enqueue([go$open, [path22, flags2, mode2, cb2], err, startTime || Date.now(), Date.now()]);
        else {
          if (typeof cb2 === "function")
            cb2.apply(this, arguments);
        }
      });
    }
  }
  return fs2;
}
function enqueue(elem) {
  debug$5("ENQUEUE", elem[0].name, elem[1]);
  fs$k[gracefulQueue].push(elem);
  retry();
}
var retryTimer;
function resetQueue() {
  var now = Date.now();
  for (var i = 0; i < fs$k[gracefulQueue].length; ++i) {
    if (fs$k[gracefulQueue][i].length > 2) {
      fs$k[gracefulQueue][i][3] = now;
      fs$k[gracefulQueue][i][4] = now;
    }
  }
  retry();
}
function retry() {
  clearTimeout(retryTimer);
  retryTimer = void 0;
  if (fs$k[gracefulQueue].length === 0)
    return;
  var elem = fs$k[gracefulQueue].shift();
  var fn = elem[0];
  var args = elem[1];
  var err = elem[2];
  var startTime = elem[3];
  var lastTime = elem[4];
  if (startTime === void 0) {
    debug$5("RETRY", fn.name, args);
    fn.apply(null, args);
  } else if (Date.now() - startTime >= 6e4) {
    debug$5("TIMEOUT", fn.name, args);
    var cb = args.pop();
    if (typeof cb === "function")
      cb.call(null, err);
  } else {
    var sinceAttempt = Date.now() - lastTime;
    var sinceStart = Math.max(lastTime - startTime, 1);
    var desiredDelay = Math.min(sinceStart * 1.2, 100);
    if (sinceAttempt >= desiredDelay) {
      debug$5("RETRY", fn.name, args);
      fn.apply(null, args.concat([startTime]));
    } else {
      fs$k[gracefulQueue].push(elem);
    }
  }
  if (retryTimer === void 0) {
    retryTimer = setTimeout(retry, 0);
  }
}
(function(exports) {
  const u2 = universalify$1.fromCallback;
  const fs2 = gracefulFs;
  const api2 = [
    "access",
    "appendFile",
    "chmod",
    "chown",
    "close",
    "copyFile",
    "fchmod",
    "fchown",
    "fdatasync",
    "fstat",
    "fsync",
    "ftruncate",
    "futimes",
    "lchmod",
    "lchown",
    "link",
    "lstat",
    "mkdir",
    "mkdtemp",
    "open",
    "opendir",
    "readdir",
    "readFile",
    "readlink",
    "realpath",
    "rename",
    "rm",
    "rmdir",
    "stat",
    "symlink",
    "truncate",
    "unlink",
    "utimes",
    "writeFile"
  ].filter((key) => {
    return typeof fs2[key] === "function";
  });
  Object.assign(exports, fs2);
  api2.forEach((method) => {
    exports[method] = u2(fs2[method]);
  });
  exports.exists = function(filename, callback) {
    if (typeof callback === "function") {
      return fs2.exists(filename, callback);
    }
    return new Promise((resolve3) => {
      return fs2.exists(filename, resolve3);
    });
  };
  exports.read = function(fd, buffer, offset, length, position, callback) {
    if (typeof callback === "function") {
      return fs2.read(fd, buffer, offset, length, position, callback);
    }
    return new Promise((resolve3, reject) => {
      fs2.read(fd, buffer, offset, length, position, (err, bytesRead, buffer2) => {
        if (err) return reject(err);
        resolve3({ bytesRead, buffer: buffer2 });
      });
    });
  };
  exports.write = function(fd, buffer, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.write(fd, buffer, ...args);
    }
    return new Promise((resolve3, reject) => {
      fs2.write(fd, buffer, ...args, (err, bytesWritten, buffer2) => {
        if (err) return reject(err);
        resolve3({ bytesWritten, buffer: buffer2 });
      });
    });
  };
  exports.readv = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.readv(fd, buffers, ...args);
    }
    return new Promise((resolve3, reject) => {
      fs2.readv(fd, buffers, ...args, (err, bytesRead, buffers2) => {
        if (err) return reject(err);
        resolve3({ bytesRead, buffers: buffers2 });
      });
    });
  };
  exports.writev = function(fd, buffers, ...args) {
    if (typeof args[args.length - 1] === "function") {
      return fs2.writev(fd, buffers, ...args);
    }
    return new Promise((resolve3, reject) => {
      fs2.writev(fd, buffers, ...args, (err, bytesWritten, buffers2) => {
        if (err) return reject(err);
        resolve3({ bytesWritten, buffers: buffers2 });
      });
    });
  };
  if (typeof fs2.realpath.native === "function") {
    exports.realpath.native = u2(fs2.realpath.native);
  } else {
    process.emitWarning(
      "fs.realpath.native is not a function. Is fs being monkey-patched?",
      "Warning",
      "fs-extra-WARN0003"
    );
  }
})(fs$l);
var makeDir$1 = {};
var utils$3 = {};
const path$h = require$$1$2;
utils$3.checkPath = function checkPath(pth) {
  if (process.platform === "win32") {
    const pathHasInvalidWinCharacters = /[<>:"|?*]/.test(pth.replace(path$h.parse(pth).root, ""));
    if (pathHasInvalidWinCharacters) {
      const error2 = new Error(`Path contains invalid characters: ${pth}`);
      error2.code = "EINVAL";
      throw error2;
    }
  }
};
const fs$j = fs$l;
const { checkPath: checkPath2 } = utils$3;
const getMode = (options) => {
  const defaults2 = { mode: 511 };
  if (typeof options === "number") return options;
  return { ...defaults2, ...options }.mode;
};
makeDir$1.makeDir = async (dir, options) => {
  checkPath2(dir);
  return fs$j.mkdir(dir, {
    mode: getMode(options),
    recursive: true
  });
};
makeDir$1.makeDirSync = (dir, options) => {
  checkPath2(dir);
  return fs$j.mkdirSync(dir, {
    mode: getMode(options),
    recursive: true
  });
};
const u$e = universalify$1.fromPromise;
const { makeDir: _makeDir, makeDirSync } = makeDir$1;
const makeDir = u$e(_makeDir);
var mkdirs$2 = {
  mkdirs: makeDir,
  mkdirsSync: makeDirSync,
  // alias
  mkdirp: makeDir,
  mkdirpSync: makeDirSync,
  ensureDir: makeDir,
  ensureDirSync: makeDirSync
};
const u$d = universalify$1.fromPromise;
const fs$i = fs$l;
function pathExists$6(path3) {
  return fs$i.access(path3).then(() => true).catch(() => false);
}
var pathExists_1 = {
  pathExists: u$d(pathExists$6),
  pathExistsSync: fs$i.existsSync
};
const fs$h = fs$l;
const u$c = universalify$1.fromPromise;
async function utimesMillis$1(path3, atime, mtime) {
  const fd = await fs$h.open(path3, "r+");
  let closeErr = null;
  try {
    await fs$h.futimes(fd, atime, mtime);
  } finally {
    try {
      await fs$h.close(fd);
    } catch (e) {
      closeErr = e;
    }
  }
  if (closeErr) {
    throw closeErr;
  }
}
function utimesMillisSync$1(path3, atime, mtime) {
  const fd = fs$h.openSync(path3, "r+");
  fs$h.futimesSync(fd, atime, mtime);
  return fs$h.closeSync(fd);
}
var utimes = {
  utimesMillis: u$c(utimesMillis$1),
  utimesMillisSync: utimesMillisSync$1
};
const fs$g = fs$l;
const path$g = require$$1$2;
const u$b = universalify$1.fromPromise;
function getStats$1(src2, dest, opts) {
  const statFunc = opts.dereference ? (file2) => fs$g.stat(file2, { bigint: true }) : (file2) => fs$g.lstat(file2, { bigint: true });
  return Promise.all([
    statFunc(src2),
    statFunc(dest).catch((err) => {
      if (err.code === "ENOENT") return null;
      throw err;
    })
  ]).then(([srcStat, destStat]) => ({ srcStat, destStat }));
}
function getStatsSync(src2, dest, opts) {
  let destStat;
  const statFunc = opts.dereference ? (file2) => fs$g.statSync(file2, { bigint: true }) : (file2) => fs$g.lstatSync(file2, { bigint: true });
  const srcStat = statFunc(src2);
  try {
    destStat = statFunc(dest);
  } catch (err) {
    if (err.code === "ENOENT") return { srcStat, destStat: null };
    throw err;
  }
  return { srcStat, destStat };
}
async function checkPaths(src2, dest, funcName, opts) {
  const { srcStat, destStat } = await getStats$1(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src2);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
function checkPathsSync(src2, dest, funcName, opts) {
  const { srcStat, destStat } = getStatsSync(src2, dest, opts);
  if (destStat) {
    if (areIdentical$2(srcStat, destStat)) {
      const srcBaseName = path$g.basename(src2);
      const destBaseName = path$g.basename(dest);
      if (funcName === "move" && srcBaseName !== destBaseName && srcBaseName.toLowerCase() === destBaseName.toLowerCase()) {
        return { srcStat, destStat, isChangingCase: true };
      }
      throw new Error("Source and destination must not be the same.");
    }
    if (srcStat.isDirectory() && !destStat.isDirectory()) {
      throw new Error(`Cannot overwrite non-directory '${dest}' with directory '${src2}'.`);
    }
    if (!srcStat.isDirectory() && destStat.isDirectory()) {
      throw new Error(`Cannot overwrite directory '${dest}' with non-directory '${src2}'.`);
    }
  }
  if (srcStat.isDirectory() && isSrcSubdir(src2, dest)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return { srcStat, destStat };
}
async function checkParentPaths(src2, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src2));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root) return;
  let destStat;
  try {
    destStat = await fs$g.stat(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT") return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPaths(src2, srcStat, destParent, funcName);
}
function checkParentPathsSync(src2, srcStat, dest, funcName) {
  const srcParent = path$g.resolve(path$g.dirname(src2));
  const destParent = path$g.resolve(path$g.dirname(dest));
  if (destParent === srcParent || destParent === path$g.parse(destParent).root) return;
  let destStat;
  try {
    destStat = fs$g.statSync(destParent, { bigint: true });
  } catch (err) {
    if (err.code === "ENOENT") return;
    throw err;
  }
  if (areIdentical$2(srcStat, destStat)) {
    throw new Error(errMsg(src2, dest, funcName));
  }
  return checkParentPathsSync(src2, srcStat, destParent, funcName);
}
function areIdentical$2(srcStat, destStat) {
  return destStat.ino && destStat.dev && destStat.ino === srcStat.ino && destStat.dev === srcStat.dev;
}
function isSrcSubdir(src2, dest) {
  const srcArr = path$g.resolve(src2).split(path$g.sep).filter((i) => i);
  const destArr = path$g.resolve(dest).split(path$g.sep).filter((i) => i);
  return srcArr.every((cur, i) => destArr[i] === cur);
}
function errMsg(src2, dest, funcName) {
  return `Cannot ${funcName} '${src2}' to a subdirectory of itself, '${dest}'.`;
}
var stat$4 = {
  // checkPaths
  checkPaths: u$b(checkPaths),
  checkPathsSync,
  // checkParent
  checkParentPaths: u$b(checkParentPaths),
  checkParentPathsSync,
  // Misc
  isSrcSubdir,
  areIdentical: areIdentical$2
};
const fs$f = fs$l;
const path$f = require$$1$2;
const { mkdirs: mkdirs$1 } = mkdirs$2;
const { pathExists: pathExists$5 } = pathExists_1;
const { utimesMillis } = utimes;
const stat$3 = stat$4;
async function copy$3(src2, dest, opts = {}) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0001"
    );
  }
  const { srcStat, destStat } = await stat$3.checkPaths(src2, dest, "copy", opts);
  await stat$3.checkParentPaths(src2, srcStat, dest, "copy");
  const include = await runFilter(src2, dest, opts);
  if (!include) return;
  const destParent = path$f.dirname(dest);
  const dirExists = await pathExists$5(destParent);
  if (!dirExists) {
    await mkdirs$1(destParent);
  }
  await getStatsAndPerformCopy(destStat, src2, dest, opts);
}
async function runFilter(src2, dest, opts) {
  if (!opts.filter) return true;
  return opts.filter(src2, dest);
}
async function getStatsAndPerformCopy(destStat, src2, dest, opts) {
  const statFn = opts.dereference ? fs$f.stat : fs$f.lstat;
  const srcStat = await statFn(src2);
  if (srcStat.isDirectory()) return onDir$1(srcStat, destStat, src2, dest, opts);
  if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile$1(srcStat, destStat, src2, dest, opts);
  if (srcStat.isSymbolicLink()) return onLink$1(destStat, src2, dest, opts);
  if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
  if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
async function onFile$1(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return copyFile$2(srcStat, src2, dest, opts);
  if (opts.overwrite) {
    await fs$f.unlink(dest);
    return copyFile$2(srcStat, src2, dest, opts);
  }
  if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
async function copyFile$2(srcStat, src2, dest, opts) {
  await fs$f.copyFile(src2, dest);
  if (opts.preserveTimestamps) {
    if (fileIsNotWritable$1(srcStat.mode)) {
      await makeFileWritable$1(dest, srcStat.mode);
    }
    const updatedSrcStat = await fs$f.stat(src2);
    await utimesMillis(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
  }
  return fs$f.chmod(dest, srcStat.mode);
}
function fileIsNotWritable$1(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable$1(dest, srcMode) {
  return fs$f.chmod(dest, srcMode | 128);
}
async function onDir$1(srcStat, destStat, src2, dest, opts) {
  if (!destStat) {
    await fs$f.mkdir(dest);
  }
  const items = await fs$f.readdir(src2);
  await Promise.all(items.map(async (item) => {
    const srcItem = path$f.join(src2, item);
    const destItem = path$f.join(dest, item);
    const include = await runFilter(srcItem, destItem, opts);
    if (!include) return;
    const { destStat: destStat2 } = await stat$3.checkPaths(srcItem, destItem, "copy", opts);
    return getStatsAndPerformCopy(destStat2, srcItem, destItem, opts);
  }));
  if (!destStat) {
    await fs$f.chmod(dest, srcStat.mode);
  }
}
async function onLink$1(destStat, src2, dest, opts) {
  let resolvedSrc = await fs$f.readlink(src2);
  if (opts.dereference) {
    resolvedSrc = path$f.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$f.symlink(resolvedSrc, dest);
  }
  let resolvedDest = null;
  try {
    resolvedDest = await fs$f.readlink(dest);
  } catch (e) {
    if (e.code === "EINVAL" || e.code === "UNKNOWN") return fs$f.symlink(resolvedSrc, dest);
    throw e;
  }
  if (opts.dereference) {
    resolvedDest = path$f.resolve(process.cwd(), resolvedDest);
  }
  if (stat$3.isSrcSubdir(resolvedSrc, resolvedDest)) {
    throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
  }
  if (stat$3.isSrcSubdir(resolvedDest, resolvedSrc)) {
    throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
  }
  await fs$f.unlink(dest);
  return fs$f.symlink(resolvedSrc, dest);
}
var copy_1 = copy$3;
const fs$e = gracefulFs;
const path$e = require$$1$2;
const mkdirsSync$1 = mkdirs$2.mkdirsSync;
const utimesMillisSync = utimes.utimesMillisSync;
const stat$2 = stat$4;
function copySync$1(src2, dest, opts) {
  if (typeof opts === "function") {
    opts = { filter: opts };
  }
  opts = opts || {};
  opts.clobber = "clobber" in opts ? !!opts.clobber : true;
  opts.overwrite = "overwrite" in opts ? !!opts.overwrite : opts.clobber;
  if (opts.preserveTimestamps && process.arch === "ia32") {
    process.emitWarning(
      "Using the preserveTimestamps option in 32-bit node is not recommended;\n\n	see https://github.com/jprichardson/node-fs-extra/issues/269",
      "Warning",
      "fs-extra-WARN0002"
    );
  }
  const { srcStat, destStat } = stat$2.checkPathsSync(src2, dest, "copy", opts);
  stat$2.checkParentPathsSync(src2, srcStat, dest, "copy");
  if (opts.filter && !opts.filter(src2, dest)) return;
  const destParent = path$e.dirname(dest);
  if (!fs$e.existsSync(destParent)) mkdirsSync$1(destParent);
  return getStats(destStat, src2, dest, opts);
}
function getStats(destStat, src2, dest, opts) {
  const statSync = opts.dereference ? fs$e.statSync : fs$e.lstatSync;
  const srcStat = statSync(src2);
  if (srcStat.isDirectory()) return onDir(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isFile() || srcStat.isCharacterDevice() || srcStat.isBlockDevice()) return onFile(srcStat, destStat, src2, dest, opts);
  else if (srcStat.isSymbolicLink()) return onLink(destStat, src2, dest, opts);
  else if (srcStat.isSocket()) throw new Error(`Cannot copy a socket file: ${src2}`);
  else if (srcStat.isFIFO()) throw new Error(`Cannot copy a FIFO pipe: ${src2}`);
  throw new Error(`Unknown file: ${src2}`);
}
function onFile(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return copyFile$1(srcStat, src2, dest, opts);
  return mayCopyFile(srcStat, src2, dest, opts);
}
function mayCopyFile(srcStat, src2, dest, opts) {
  if (opts.overwrite) {
    fs$e.unlinkSync(dest);
    return copyFile$1(srcStat, src2, dest, opts);
  } else if (opts.errorOnExist) {
    throw new Error(`'${dest}' already exists`);
  }
}
function copyFile$1(srcStat, src2, dest, opts) {
  fs$e.copyFileSync(src2, dest);
  if (opts.preserveTimestamps) handleTimestamps(srcStat.mode, src2, dest);
  return setDestMode(dest, srcStat.mode);
}
function handleTimestamps(srcMode, src2, dest) {
  if (fileIsNotWritable(srcMode)) makeFileWritable(dest, srcMode);
  return setDestTimestamps(src2, dest);
}
function fileIsNotWritable(srcMode) {
  return (srcMode & 128) === 0;
}
function makeFileWritable(dest, srcMode) {
  return setDestMode(dest, srcMode | 128);
}
function setDestMode(dest, srcMode) {
  return fs$e.chmodSync(dest, srcMode);
}
function setDestTimestamps(src2, dest) {
  const updatedSrcStat = fs$e.statSync(src2);
  return utimesMillisSync(dest, updatedSrcStat.atime, updatedSrcStat.mtime);
}
function onDir(srcStat, destStat, src2, dest, opts) {
  if (!destStat) return mkDirAndCopy(srcStat.mode, src2, dest, opts);
  return copyDir(src2, dest, opts);
}
function mkDirAndCopy(srcMode, src2, dest, opts) {
  fs$e.mkdirSync(dest);
  copyDir(src2, dest, opts);
  return setDestMode(dest, srcMode);
}
function copyDir(src2, dest, opts) {
  fs$e.readdirSync(src2).forEach((item) => copyDirItem(item, src2, dest, opts));
}
function copyDirItem(item, src2, dest, opts) {
  const srcItem = path$e.join(src2, item);
  const destItem = path$e.join(dest, item);
  if (opts.filter && !opts.filter(srcItem, destItem)) return;
  const { destStat } = stat$2.checkPathsSync(srcItem, destItem, "copy", opts);
  return getStats(destStat, srcItem, destItem, opts);
}
function onLink(destStat, src2, dest, opts) {
  let resolvedSrc = fs$e.readlinkSync(src2);
  if (opts.dereference) {
    resolvedSrc = path$e.resolve(process.cwd(), resolvedSrc);
  }
  if (!destStat) {
    return fs$e.symlinkSync(resolvedSrc, dest);
  } else {
    let resolvedDest;
    try {
      resolvedDest = fs$e.readlinkSync(dest);
    } catch (err) {
      if (err.code === "EINVAL" || err.code === "UNKNOWN") return fs$e.symlinkSync(resolvedSrc, dest);
      throw err;
    }
    if (opts.dereference) {
      resolvedDest = path$e.resolve(process.cwd(), resolvedDest);
    }
    if (stat$2.isSrcSubdir(resolvedSrc, resolvedDest)) {
      throw new Error(`Cannot copy '${resolvedSrc}' to a subdirectory of itself, '${resolvedDest}'.`);
    }
    if (stat$2.isSrcSubdir(resolvedDest, resolvedSrc)) {
      throw new Error(`Cannot overwrite '${resolvedDest}' with '${resolvedSrc}'.`);
    }
    return copyLink(resolvedSrc, dest);
  }
}
function copyLink(resolvedSrc, dest) {
  fs$e.unlinkSync(dest);
  return fs$e.symlinkSync(resolvedSrc, dest);
}
var copySync_1 = copySync$1;
const u$a = universalify$1.fromPromise;
var copy$2 = {
  copy: u$a(copy_1),
  copySync: copySync_1
};
const fs$d = gracefulFs;
const u$9 = universalify$1.fromCallback;
function remove$2(path3, callback) {
  fs$d.rm(path3, { recursive: true, force: true }, callback);
}
function removeSync$1(path3) {
  fs$d.rmSync(path3, { recursive: true, force: true });
}
var remove_1 = {
  remove: u$9(remove$2),
  removeSync: removeSync$1
};
const u$8 = universalify$1.fromPromise;
const fs$c = fs$l;
const path$d = require$$1$2;
const mkdir$3 = mkdirs$2;
const remove$1 = remove_1;
const emptyDir = u$8(async function emptyDir2(dir) {
  let items;
  try {
    items = await fs$c.readdir(dir);
  } catch {
    return mkdir$3.mkdirs(dir);
  }
  return Promise.all(items.map((item) => remove$1.remove(path$d.join(dir, item))));
});
function emptyDirSync(dir) {
  let items;
  try {
    items = fs$c.readdirSync(dir);
  } catch {
    return mkdir$3.mkdirsSync(dir);
  }
  items.forEach((item) => {
    item = path$d.join(dir, item);
    remove$1.removeSync(item);
  });
}
var empty = {
  emptyDirSync,
  emptydirSync: emptyDirSync,
  emptyDir,
  emptydir: emptyDir
};
const u$7 = universalify$1.fromPromise;
const path$c = require$$1$2;
const fs$b = fs$l;
const mkdir$2 = mkdirs$2;
async function createFile$1(file2) {
  let stats;
  try {
    stats = await fs$b.stat(file2);
  } catch {
  }
  if (stats && stats.isFile()) return;
  const dir = path$c.dirname(file2);
  let dirStats = null;
  try {
    dirStats = await fs$b.stat(dir);
  } catch (err) {
    if (err.code === "ENOENT") {
      await mkdir$2.mkdirs(dir);
      await fs$b.writeFile(file2, "");
      return;
    } else {
      throw err;
    }
  }
  if (dirStats.isDirectory()) {
    await fs$b.writeFile(file2, "");
  } else {
    await fs$b.readdir(dir);
  }
}
function createFileSync$1(file2) {
  let stats;
  try {
    stats = fs$b.statSync(file2);
  } catch {
  }
  if (stats && stats.isFile()) return;
  const dir = path$c.dirname(file2);
  try {
    if (!fs$b.statSync(dir).isDirectory()) {
      fs$b.readdirSync(dir);
    }
  } catch (err) {
    if (err && err.code === "ENOENT") mkdir$2.mkdirsSync(dir);
    else throw err;
  }
  fs$b.writeFileSync(file2, "");
}
var file$1 = {
  createFile: u$7(createFile$1),
  createFileSync: createFileSync$1
};
const u$6 = universalify$1.fromPromise;
const path$b = require$$1$2;
const fs$a = fs$l;
const mkdir$1 = mkdirs$2;
const { pathExists: pathExists$4 } = pathExists_1;
const { areIdentical: areIdentical$1 } = stat$4;
async function createLink$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = await fs$a.lstat(dstpath);
  } catch {
  }
  let srcStat;
  try {
    srcStat = await fs$a.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  if (dstStat && areIdentical$1(srcStat, dstStat)) return;
  const dir = path$b.dirname(dstpath);
  const dirExists = await pathExists$4(dir);
  if (!dirExists) {
    await mkdir$1.mkdirs(dir);
  }
  await fs$a.link(srcpath, dstpath);
}
function createLinkSync$1(srcpath, dstpath) {
  let dstStat;
  try {
    dstStat = fs$a.lstatSync(dstpath);
  } catch {
  }
  try {
    const srcStat = fs$a.lstatSync(srcpath);
    if (dstStat && areIdentical$1(srcStat, dstStat)) return;
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureLink");
    throw err;
  }
  const dir = path$b.dirname(dstpath);
  const dirExists = fs$a.existsSync(dir);
  if (dirExists) return fs$a.linkSync(srcpath, dstpath);
  mkdir$1.mkdirsSync(dir);
  return fs$a.linkSync(srcpath, dstpath);
}
var link = {
  createLink: u$6(createLink$1),
  createLinkSync: createLinkSync$1
};
const path$a = require$$1$2;
const fs$9 = fs$l;
const { pathExists: pathExists$3 } = pathExists_1;
const u$5 = universalify$1.fromPromise;
async function symlinkPaths$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    try {
      await fs$9.lstat(srcpath);
    } catch (err) {
      err.message = err.message.replace("lstat", "ensureSymlink");
      throw err;
    }
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = await pathExists$3(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  try {
    await fs$9.lstat(srcpath);
  } catch (err) {
    err.message = err.message.replace("lstat", "ensureSymlink");
    throw err;
  }
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
function symlinkPathsSync$1(srcpath, dstpath) {
  if (path$a.isAbsolute(srcpath)) {
    const exists2 = fs$9.existsSync(srcpath);
    if (!exists2) throw new Error("absolute srcpath does not exist");
    return {
      toCwd: srcpath,
      toDst: srcpath
    };
  }
  const dstdir = path$a.dirname(dstpath);
  const relativeToDst = path$a.join(dstdir, srcpath);
  const exists = fs$9.existsSync(relativeToDst);
  if (exists) {
    return {
      toCwd: relativeToDst,
      toDst: srcpath
    };
  }
  const srcExists = fs$9.existsSync(srcpath);
  if (!srcExists) throw new Error("relative srcpath does not exist");
  return {
    toCwd: srcpath,
    toDst: path$a.relative(dstdir, srcpath)
  };
}
var symlinkPaths_1 = {
  symlinkPaths: u$5(symlinkPaths$1),
  symlinkPathsSync: symlinkPathsSync$1
};
const fs$8 = fs$l;
const u$4 = universalify$1.fromPromise;
async function symlinkType$1(srcpath, type3) {
  if (type3) return type3;
  let stats;
  try {
    stats = await fs$8.lstat(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
function symlinkTypeSync$1(srcpath, type3) {
  if (type3) return type3;
  let stats;
  try {
    stats = fs$8.lstatSync(srcpath);
  } catch {
    return "file";
  }
  return stats && stats.isDirectory() ? "dir" : "file";
}
var symlinkType_1 = {
  symlinkType: u$4(symlinkType$1),
  symlinkTypeSync: symlinkTypeSync$1
};
const u$3 = universalify$1.fromPromise;
const path$9 = require$$1$2;
const fs$7 = fs$l;
const { mkdirs, mkdirsSync } = mkdirs$2;
const { symlinkPaths, symlinkPathsSync } = symlinkPaths_1;
const { symlinkType, symlinkTypeSync } = symlinkType_1;
const { pathExists: pathExists$2 } = pathExists_1;
const { areIdentical } = stat$4;
async function createSymlink$1(srcpath, dstpath, type3) {
  let stats;
  try {
    stats = await fs$7.lstat(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const [srcStat, dstStat] = await Promise.all([
      fs$7.stat(srcpath),
      fs$7.stat(dstpath)
    ]);
    if (areIdentical(srcStat, dstStat)) return;
  }
  const relative2 = await symlinkPaths(srcpath, dstpath);
  srcpath = relative2.toDst;
  const toType = await symlinkType(relative2.toCwd, type3);
  const dir = path$9.dirname(dstpath);
  if (!await pathExists$2(dir)) {
    await mkdirs(dir);
  }
  return fs$7.symlink(srcpath, dstpath, toType);
}
function createSymlinkSync$1(srcpath, dstpath, type3) {
  let stats;
  try {
    stats = fs$7.lstatSync(dstpath);
  } catch {
  }
  if (stats && stats.isSymbolicLink()) {
    const srcStat = fs$7.statSync(srcpath);
    const dstStat = fs$7.statSync(dstpath);
    if (areIdentical(srcStat, dstStat)) return;
  }
  const relative2 = symlinkPathsSync(srcpath, dstpath);
  srcpath = relative2.toDst;
  type3 = symlinkTypeSync(relative2.toCwd, type3);
  const dir = path$9.dirname(dstpath);
  const exists = fs$7.existsSync(dir);
  if (exists) return fs$7.symlinkSync(srcpath, dstpath, type3);
  mkdirsSync(dir);
  return fs$7.symlinkSync(srcpath, dstpath, type3);
}
var symlink = {
  createSymlink: u$3(createSymlink$1),
  createSymlinkSync: createSymlinkSync$1
};
const { createFile, createFileSync } = file$1;
const { createLink, createLinkSync } = link;
const { createSymlink, createSymlinkSync } = symlink;
var ensure$2 = {
  // file
  createFile,
  createFileSync,
  ensureFile: createFile,
  ensureFileSync: createFileSync,
  // link
  createLink,
  createLinkSync,
  ensureLink: createLink,
  ensureLinkSync: createLinkSync,
  // symlink
  createSymlink,
  createSymlinkSync,
  ensureSymlink: createSymlink,
  ensureSymlinkSync: createSymlinkSync
};
function stringify$3(obj, { EOL = "\n", finalEOL = true, replacer = null, spaces } = {}) {
  const EOF = finalEOL ? EOL : "";
  const str2 = JSON.stringify(obj, replacer, spaces);
  return str2.replace(/\n/g, EOL) + EOF;
}
function stripBom$1(content) {
  if (Buffer.isBuffer(content)) content = content.toString("utf8");
  return content.replace(/^\uFEFF/, "");
}
var utils$2 = { stringify: stringify$3, stripBom: stripBom$1 };
let _fs;
try {
  _fs = gracefulFs;
} catch (_) {
  _fs = require$$0$7;
}
const universalify = universalify$1;
const { stringify: stringify$2, stripBom } = utils$2;
async function _readFile(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  let data2 = await universalify.fromCallback(fs2.readFile)(file2, options);
  data2 = stripBom(data2);
  let obj;
  try {
    obj = JSON.parse(data2, options ? options.reviver : null);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
  return obj;
}
const readFile = universalify.fromPromise(_readFile);
function readFileSync(file2, options = {}) {
  if (typeof options === "string") {
    options = { encoding: options };
  }
  const fs2 = options.fs || _fs;
  const shouldThrow = "throws" in options ? options.throws : true;
  try {
    let content = fs2.readFileSync(file2, options);
    content = stripBom(content);
    return JSON.parse(content, options.reviver);
  } catch (err) {
    if (shouldThrow) {
      err.message = `${file2}: ${err.message}`;
      throw err;
    } else {
      return null;
    }
  }
}
async function _writeFile(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$2(obj, options);
  await universalify.fromCallback(fs2.writeFile)(file2, str2, options);
}
const writeFile = universalify.fromPromise(_writeFile);
function writeFileSync(file2, obj, options = {}) {
  const fs2 = options.fs || _fs;
  const str2 = stringify$2(obj, options);
  return fs2.writeFileSync(file2, str2, options);
}
const jsonfile$1 = {
  readFile,
  readFileSync,
  writeFile,
  writeFileSync
};
var jsonfile_1 = jsonfile$1;
const jsonFile$1 = jsonfile_1;
var jsonfile = {
  // jsonfile exports
  readJson: jsonFile$1.readFile,
  readJsonSync: jsonFile$1.readFileSync,
  writeJson: jsonFile$1.writeFile,
  writeJsonSync: jsonFile$1.writeFileSync
};
const u$2 = universalify$1.fromPromise;
const fs$6 = fs$l;
const path$8 = require$$1$2;
const mkdir = mkdirs$2;
const pathExists$1 = pathExists_1.pathExists;
async function outputFile$1(file2, data2, encoding3 = "utf-8") {
  const dir = path$8.dirname(file2);
  if (!await pathExists$1(dir)) {
    await mkdir.mkdirs(dir);
  }
  return fs$6.writeFile(file2, data2, encoding3);
}
function outputFileSync$1(file2, ...args) {
  const dir = path$8.dirname(file2);
  if (!fs$6.existsSync(dir)) {
    mkdir.mkdirsSync(dir);
  }
  fs$6.writeFileSync(file2, ...args);
}
var outputFile_1 = {
  outputFile: u$2(outputFile$1),
  outputFileSync: outputFileSync$1
};
const { stringify: stringify$1 } = utils$2;
const { outputFile } = outputFile_1;
async function outputJson(file2, data2, options = {}) {
  const str2 = stringify$1(data2, options);
  await outputFile(file2, str2, options);
}
var outputJson_1 = outputJson;
const { stringify } = utils$2;
const { outputFileSync } = outputFile_1;
function outputJsonSync(file2, data2, options) {
  const str2 = stringify(data2, options);
  outputFileSync(file2, str2, options);
}
var outputJsonSync_1 = outputJsonSync;
const u$1 = universalify$1.fromPromise;
const jsonFile = jsonfile;
jsonFile.outputJson = u$1(outputJson_1);
jsonFile.outputJsonSync = outputJsonSync_1;
jsonFile.outputJSON = jsonFile.outputJson;
jsonFile.outputJSONSync = jsonFile.outputJsonSync;
jsonFile.writeJSON = jsonFile.writeJson;
jsonFile.writeJSONSync = jsonFile.writeJsonSync;
jsonFile.readJSON = jsonFile.readJson;
jsonFile.readJSONSync = jsonFile.readJsonSync;
var json2 = jsonFile;
const fs$5 = fs$l;
const path$7 = require$$1$2;
const { copy: copy$1 } = copy$2;
const { remove } = remove_1;
const { mkdirp } = mkdirs$2;
const { pathExists } = pathExists_1;
const stat$1 = stat$4;
async function move$2(src2, dest, opts = {}) {
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = await stat$1.checkPaths(src2, dest, "move", opts);
  await stat$1.checkParentPaths(src2, srcStat, dest, "move");
  const destParent = path$7.dirname(dest);
  const parsedParentPath = path$7.parse(destParent);
  if (parsedParentPath.root !== destParent) {
    await mkdirp(destParent);
  }
  return doRename$1(src2, dest, overwrite, isChangingCase);
}
async function doRename$1(src2, dest, overwrite, isChangingCase) {
  if (!isChangingCase) {
    if (overwrite) {
      await remove(dest);
    } else if (await pathExists(dest)) {
      throw new Error("dest already exists.");
    }
  }
  try {
    await fs$5.rename(src2, dest);
  } catch (err) {
    if (err.code !== "EXDEV") {
      throw err;
    }
    await moveAcrossDevice$1(src2, dest, overwrite);
  }
}
async function moveAcrossDevice$1(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  await copy$1(src2, dest, opts);
  return remove(src2);
}
var move_1 = move$2;
const fs$4 = gracefulFs;
const path$6 = require$$1$2;
const copySync = copy$2.copySync;
const removeSync = remove_1.removeSync;
const mkdirpSync = mkdirs$2.mkdirpSync;
const stat = stat$4;
function moveSync(src2, dest, opts) {
  opts = opts || {};
  const overwrite = opts.overwrite || opts.clobber || false;
  const { srcStat, isChangingCase = false } = stat.checkPathsSync(src2, dest, "move", opts);
  stat.checkParentPathsSync(src2, srcStat, dest, "move");
  if (!isParentRoot(dest)) mkdirpSync(path$6.dirname(dest));
  return doRename(src2, dest, overwrite, isChangingCase);
}
function isParentRoot(dest) {
  const parent = path$6.dirname(dest);
  const parsedPath = path$6.parse(parent);
  return parsedPath.root === parent;
}
function doRename(src2, dest, overwrite, isChangingCase) {
  if (isChangingCase) return rename(src2, dest, overwrite);
  if (overwrite) {
    removeSync(dest);
    return rename(src2, dest, overwrite);
  }
  if (fs$4.existsSync(dest)) throw new Error("dest already exists.");
  return rename(src2, dest, overwrite);
}
function rename(src2, dest, overwrite) {
  try {
    fs$4.renameSync(src2, dest);
  } catch (err) {
    if (err.code !== "EXDEV") throw err;
    return moveAcrossDevice(src2, dest, overwrite);
  }
}
function moveAcrossDevice(src2, dest, overwrite) {
  const opts = {
    overwrite,
    errorOnExist: true,
    preserveTimestamps: true
  };
  copySync(src2, dest, opts);
  return removeSync(src2);
}
var moveSync_1 = moveSync;
const u = universalify$1.fromPromise;
var move$1 = {
  move: u(move_1),
  moveSync: moveSync_1
};
var lib$2 = {
  // Export promiseified graceful-fs:
  ...fs$l,
  // Export extra methods:
  ...copy$2,
  ...empty,
  ...ensure$2,
  ...json2,
  ...mkdirs$2,
  ...move$1,
  ...outputFile_1,
  ...pathExists_1,
  ...remove_1
};
var notfound = {};
Object.defineProperty(notfound, "__esModule", { value: true });
class NotFoundError extends Error {
  constructor(message) {
    super(message || "File does not exist at the specified endpoint");
    this.code = "ENOTFOUND";
  }
}
notfound.default = NotFoundError;
var __importDefault$5 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(file$2, "__esModule", { value: true });
file$2.file = void 0;
const debug_1$3 = __importDefault$5(srcExports);
const fs_1$1 = require$$0$7;
const fs_extra_1 = lib$2;
const notfound_1$1 = __importDefault$5(notfound);
const notmodified_1$1 = __importDefault$5(notmodified);
const url_1$1 = require$$5$2;
const debug$4 = (0, debug_1$3.default)("get-uri:file");
const file = async ({ href: uri2 }, opts = {}) => {
  const {
    cache: cache2,
    flags = "r",
    mode = 438
    // =0666
  } = opts;
  try {
    const filepath = (0, url_1$1.fileURLToPath)(uri2);
    debug$4("Normalized pathname: %o", filepath);
    const fd = await (0, fs_extra_1.open)(filepath, flags, mode);
    const stat2 = await (0, fs_extra_1.fstat)(fd);
    if (cache2 && cache2.stat && stat2 && isNotModified(cache2.stat, stat2)) {
      throw new notmodified_1$1.default();
    }
    const rs = (0, fs_1$1.createReadStream)(null, {
      autoClose: true,
      ...opts,
      fd
    });
    rs.stat = stat2;
    return rs;
  } catch (err) {
    if (err.code === "ENOENT") {
      throw new notfound_1$1.default();
    }
    throw err;
  }
};
file$2.file = file;
function isNotModified(prev, curr) {
  return +prev.mtime === +curr.mtime;
}
var ftp$1 = {};
var dist$3 = {};
var Client$1 = {};
var FtpContext = {};
var parseControlResponse$1 = {};
Object.defineProperty(parseControlResponse$1, "__esModule", { value: true });
parseControlResponse$1.positiveIntermediate = parseControlResponse$1.positiveCompletion = parseControlResponse$1.isMultiline = parseControlResponse$1.isSingleLine = parseControlResponse$1.parseControlResponse = void 0;
const LF = "\n";
function parseControlResponse(text) {
  const lines = text.split(/\r?\n/).filter(isNotBlank$1);
  const messages = [];
  let startAt = 0;
  let tokenRegex;
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (!tokenRegex) {
      if (isMultiline(line)) {
        const token = line.substr(0, 3);
        tokenRegex = new RegExp(`^${token}(?:$| )`);
        startAt = i;
      } else if (isSingleLine(line)) {
        messages.push(line);
      }
    } else if (tokenRegex.test(line)) {
      tokenRegex = void 0;
      messages.push(lines.slice(startAt, i + 1).join(LF));
    }
  }
  const rest = tokenRegex ? lines.slice(startAt).join(LF) + LF : "";
  return { messages, rest };
}
parseControlResponse$1.parseControlResponse = parseControlResponse;
function isSingleLine(line) {
  return /^\d\d\d(?:$| )/.test(line);
}
parseControlResponse$1.isSingleLine = isSingleLine;
function isMultiline(line) {
  return /^\d\d\d-/.test(line);
}
parseControlResponse$1.isMultiline = isMultiline;
function positiveCompletion(code2) {
  return code2 >= 200 && code2 < 300;
}
parseControlResponse$1.positiveCompletion = positiveCompletion;
function positiveIntermediate(code2) {
  return code2 >= 300 && code2 < 400;
}
parseControlResponse$1.positiveIntermediate = positiveIntermediate;
function isNotBlank$1(str2) {
  return str2.trim() !== "";
}
Object.defineProperty(FtpContext, "__esModule", { value: true });
FtpContext.FTPContext = FtpContext.FTPError = void 0;
const net_1$1 = require$$0$6;
const parseControlResponse_1$2 = parseControlResponse$1;
class FTPError extends Error {
  constructor(res2) {
    super(res2.message);
    this.name = this.constructor.name;
    this.code = res2.code;
  }
}
FtpContext.FTPError = FTPError;
function doNothing() {
}
class FTPContext {
  /**
   * Instantiate an FTP context.
   *
   * @param timeout - Timeout in milliseconds to apply to control and data connections. Use 0 for no timeout.
   * @param encoding - Encoding to use for control connection. UTF-8 by default. Use "latin1" for older servers.
   */
  constructor(timeout = 0, encoding3 = "utf8") {
    this.timeout = timeout;
    this.verbose = false;
    this.ipFamily = void 0;
    this.tlsOptions = {};
    this._partialResponse = "";
    this._encoding = encoding3;
    this._socket = this.socket = this._newSocket();
    this._dataSocket = void 0;
  }
  /**
   * Close the context.
   */
  close() {
    const message = this._task ? "User closed client during task" : "User closed client";
    const err = new Error(message);
    this.closeWithError(err);
  }
  /**
   * Close the context with an error.
   */
  closeWithError(err) {
    if (this._closingError) {
      return;
    }
    this._closingError = err;
    this._closeControlSocket();
    this._closeSocket(this._dataSocket);
    this._passToHandler(err);
    this._stopTrackingTask();
  }
  /**
   * Returns true if this context has been closed or hasn't been connected yet. You can reopen it with `access`.
   */
  get closed() {
    return this.socket.remoteAddress === void 0 || this._closingError !== void 0;
  }
  /**
   * Reset this contex and all of its state.
   */
  reset() {
    this.socket = this._newSocket();
  }
  /**
   * Get the FTP control socket.
   */
  get socket() {
    return this._socket;
  }
  /**
   * Set the socket for the control connection. This will only close the current control socket
   * if the new one is not an upgrade to the current one.
   */
  set socket(socket) {
    this.dataSocket = void 0;
    this.tlsOptions = {};
    this._partialResponse = "";
    if (this._socket) {
      const newSocketUpgradesExisting = socket.localPort === this._socket.localPort;
      if (newSocketUpgradesExisting) {
        this._removeSocketListeners(this.socket);
      } else {
        this._closeControlSocket();
      }
    }
    if (socket) {
      this._closingError = void 0;
      socket.setTimeout(0);
      socket.setEncoding(this._encoding);
      socket.setKeepAlive(true);
      socket.on("data", (data2) => this._onControlSocketData(data2));
      socket.on("end", () => this.closeWithError(new Error("Server sent FIN packet unexpectedly, closing connection.")));
      socket.on("close", (hadError) => {
        if (!hadError)
          this.closeWithError(new Error("Server closed connection unexpectedly."));
      });
      this._setupDefaultErrorHandlers(socket, "control socket");
    }
    this._socket = socket;
  }
  /**
   * Get the current FTP data connection if present.
   */
  get dataSocket() {
    return this._dataSocket;
  }
  /**
   * Set the socket for the data connection. This will automatically close the former data socket.
   */
  set dataSocket(socket) {
    this._closeSocket(this._dataSocket);
    if (socket) {
      socket.setTimeout(0);
      this._setupDefaultErrorHandlers(socket, "data socket");
    }
    this._dataSocket = socket;
  }
  /**
   * Get the currently used encoding.
   */
  get encoding() {
    return this._encoding;
  }
  /**
   * Set the encoding used for the control socket.
   *
   * See https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings for what encodings
   * are supported by Node.
   */
  set encoding(encoding3) {
    this._encoding = encoding3;
    if (this.socket) {
      this.socket.setEncoding(encoding3);
    }
  }
  /**
   * Send an FTP command without waiting for or handling the result.
   */
  send(command) {
    const containsPassword = command.startsWith("PASS");
    const message = containsPassword ? "> PASS ###" : `> ${command}`;
    this.log(message);
    this._socket.write(command + "\r\n", this.encoding);
  }
  /**
   * Send an FTP command and handle the first response. Use this if you have a simple
   * request-response situation.
   */
  request(command) {
    return this.handle(command, (res2, task) => {
      if (res2 instanceof Error) {
        task.reject(res2);
      } else {
        task.resolve(res2);
      }
    });
  }
  /**
   * Send an FTP command and handle any response until you resolve/reject. Use this if you expect multiple responses
   * to a request. This returns a Promise that will hold whatever the response handler passed on when resolving/rejecting its task.
   */
  handle(command, responseHandler) {
    if (this._task) {
      const err = new Error("User launched a task while another one is still running. Forgot to use 'await' or '.then()'?");
      err.stack += `
Running task launched at: ${this._task.stack}`;
      this.closeWithError(err);
    }
    return new Promise((resolveTask, rejectTask) => {
      this._task = {
        stack: new Error().stack || "Unknown call stack",
        responseHandler,
        resolver: {
          resolve: (arg) => {
            this._stopTrackingTask();
            resolveTask(arg);
          },
          reject: (err) => {
            this._stopTrackingTask();
            rejectTask(err);
          }
        }
      };
      if (this._closingError) {
        const err = new Error(`Client is closed because ${this._closingError.message}`);
        err.stack += `
Closing reason: ${this._closingError.stack}`;
        err.code = this._closingError.code !== void 0 ? this._closingError.code : "0";
        this._passToHandler(err);
        return;
      }
      this.socket.setTimeout(this.timeout);
      if (command) {
        this.send(command);
      }
    });
  }
  /**
   * Log message if set to be verbose.
   */
  log(message) {
    if (this.verbose) {
      console.log(message);
    }
  }
  /**
   * Return true if the control socket is using TLS. This does not mean that a session
   * has already been negotiated.
   */
  get hasTLS() {
    return "encrypted" in this._socket;
  }
  /**
   * Removes reference to current task and handler. This won't resolve or reject the task.
   * @protected
   */
  _stopTrackingTask() {
    this.socket.setTimeout(0);
    this._task = void 0;
  }
  /**
   * Handle incoming data on the control socket. The chunk is going to be of type `string`
   * because we let `socket` handle encoding with `setEncoding`.
   * @protected
   */
  _onControlSocketData(chunk) {
    this.log(`< ${chunk}`);
    const completeResponse = this._partialResponse + chunk;
    const parsed = (0, parseControlResponse_1$2.parseControlResponse)(completeResponse);
    this._partialResponse = parsed.rest;
    for (const message of parsed.messages) {
      const code2 = parseInt(message.substr(0, 3), 10);
      const response2 = { code: code2, message };
      const err = code2 >= 400 ? new FTPError(response2) : void 0;
      this._passToHandler(err ? err : response2);
    }
  }
  /**
   * Send the current handler a response. This is usually a control socket response
   * or a socket event, like an error or timeout.
   * @protected
   */
  _passToHandler(response2) {
    if (this._task) {
      this._task.responseHandler(response2, this._task.resolver);
    }
  }
  /**
   * Setup all error handlers for a socket.
   * @protected
   */
  _setupDefaultErrorHandlers(socket, identifier) {
    socket.once("error", (error2) => {
      error2.message += ` (${identifier})`;
      this.closeWithError(error2);
    });
    socket.once("close", (hadError) => {
      if (hadError) {
        this.closeWithError(new Error(`Socket closed due to transmission error (${identifier})`));
      }
    });
    socket.once("timeout", () => {
      socket.destroy();
      this.closeWithError(new Error(`Timeout (${identifier})`));
    });
  }
  /**
   * Close the control socket. Sends QUIT, then FIN, and ignores any response or error.
   */
  _closeControlSocket() {
    this._removeSocketListeners(this._socket);
    this._socket.on("error", doNothing);
    this.send("QUIT");
    this._closeSocket(this._socket);
  }
  /**
   * Close a socket, ignores any error.
   * @protected
   */
  _closeSocket(socket) {
    if (socket) {
      this._removeSocketListeners(socket);
      socket.on("error", doNothing);
      socket.destroy();
    }
  }
  /**
   * Remove all default listeners for socket.
   * @protected
   */
  _removeSocketListeners(socket) {
    socket.removeAllListeners();
    socket.removeAllListeners("timeout");
    socket.removeAllListeners("data");
    socket.removeAllListeners("end");
    socket.removeAllListeners("error");
    socket.removeAllListeners("close");
    socket.removeAllListeners("connect");
  }
  /**
   * Provide a new socket instance.
   *
   * Internal use only, replaced for unit tests.
   */
  _newSocket() {
    return new net_1$1.Socket();
  }
}
FtpContext.FTPContext = FTPContext;
var parseList$1 = {};
var parseListDOS = {};
var FileInfo$1 = {};
Object.defineProperty(FileInfo$1, "__esModule", { value: true });
FileInfo$1.FileInfo = FileInfo$1.FileType = void 0;
var FileType;
(function(FileType2) {
  FileType2[FileType2["Unknown"] = 0] = "Unknown";
  FileType2[FileType2["File"] = 1] = "File";
  FileType2[FileType2["Directory"] = 2] = "Directory";
  FileType2[FileType2["SymbolicLink"] = 3] = "SymbolicLink";
})(FileType || (FileInfo$1.FileType = FileType = {}));
class FileInfo {
  constructor(name2) {
    this.name = name2;
    this.type = FileType.Unknown;
    this.size = 0;
    this.rawModifiedAt = "";
    this.modifiedAt = void 0;
    this.permissions = void 0;
    this.hardLinkCount = void 0;
    this.link = void 0;
    this.group = void 0;
    this.user = void 0;
    this.uniqueID = void 0;
    this.name = name2;
  }
  get isDirectory() {
    return this.type === FileType.Directory;
  }
  get isSymbolicLink() {
    return this.type === FileType.SymbolicLink;
  }
  get isFile() {
    return this.type === FileType.File;
  }
  /**
   * Deprecated, legacy API. Use `rawModifiedAt` instead.
   * @deprecated
   */
  get date() {
    return this.rawModifiedAt;
  }
  set date(rawModifiedAt) {
    this.rawModifiedAt = rawModifiedAt;
  }
}
FileInfo$1.FileInfo = FileInfo;
FileInfo.UnixPermission = {
  Read: 4,
  Write: 2,
  Execute: 1
};
Object.defineProperty(parseListDOS, "__esModule", { value: true });
parseListDOS.transformList = parseListDOS.parseLine = parseListDOS.testLine = void 0;
const FileInfo_1$2 = FileInfo$1;
const RE_LINE$1 = new RegExp(
  "(\\S+)\\s+(\\S+)\\s+(?:(<DIR>)|([0-9]+))\\s+(\\S.*)"
  // First non-space followed by rest of line (name)
);
function testLine$2(line) {
  return /^\d{2}/.test(line) && RE_LINE$1.test(line);
}
parseListDOS.testLine = testLine$2;
function parseLine$2(line) {
  const groups = line.match(RE_LINE$1);
  if (groups === null) {
    return void 0;
  }
  const name2 = groups[5];
  if (name2 === "." || name2 === "..") {
    return void 0;
  }
  const file2 = new FileInfo_1$2.FileInfo(name2);
  const fileType = groups[3];
  if (fileType === "<DIR>") {
    file2.type = FileInfo_1$2.FileType.Directory;
    file2.size = 0;
  } else {
    file2.type = FileInfo_1$2.FileType.File;
    file2.size = parseInt(groups[4], 10);
  }
  file2.rawModifiedAt = groups[1] + " " + groups[2];
  return file2;
}
parseListDOS.parseLine = parseLine$2;
function transformList$2(files2) {
  return files2;
}
parseListDOS.transformList = transformList$2;
var parseListUnix = {};
Object.defineProperty(parseListUnix, "__esModule", { value: true });
parseListUnix.transformList = parseListUnix.parseLine = parseListUnix.testLine = void 0;
const FileInfo_1$1 = FileInfo$1;
const JA_MONTH = "æœˆ";
const JA_DAY = "æ—¥";
const JA_YEAR = "å¹´";
const RE_LINE = new RegExp("([bcdelfmpSs-])(((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]))((r|-)(w|-)([xsStTL-]?)))\\+?\\s*(\\d+)\\s+(?:(\\S+(?:\\s\\S+)*?)\\s+)?(?:(\\S+(?:\\s\\S+)*)\\s+)?(\\d+(?:,\\s*\\d+)?)\\s+((?:\\d+[-/]\\d+[-/]\\d+)|(?:\\S{3}\\s+\\d{1,2})|(?:\\d{1,2}\\s+\\S{3})|(?:\\d{1,2}" + JA_MONTH + "\\s+\\d{1,2}" + JA_DAY + "))\\s+((?:\\d+(?::\\d+)?)|(?:\\d{4}" + JA_YEAR + "))\\s(.*)");
function testLine$1(line) {
  return RE_LINE.test(line);
}
parseListUnix.testLine = testLine$1;
function parseLine$1(line) {
  const groups = line.match(RE_LINE);
  if (groups === null) {
    return void 0;
  }
  const name2 = groups[21];
  if (name2 === "." || name2 === "..") {
    return void 0;
  }
  const file2 = new FileInfo_1$1.FileInfo(name2);
  file2.size = parseInt(groups[18], 10);
  file2.user = groups[16];
  file2.group = groups[17];
  file2.hardLinkCount = parseInt(groups[15], 10);
  file2.rawModifiedAt = groups[19] + " " + groups[20];
  file2.permissions = {
    user: parseMode(groups[4], groups[5], groups[6]),
    group: parseMode(groups[8], groups[9], groups[10]),
    world: parseMode(groups[12], groups[13], groups[14])
  };
  switch (groups[1].charAt(0)) {
    case "d":
      file2.type = FileInfo_1$1.FileType.Directory;
      break;
    case "e":
      file2.type = FileInfo_1$1.FileType.SymbolicLink;
      break;
    case "l":
      file2.type = FileInfo_1$1.FileType.SymbolicLink;
      break;
    case "b":
    case "c":
      file2.type = FileInfo_1$1.FileType.File;
      break;
    case "f":
    case "-":
      file2.type = FileInfo_1$1.FileType.File;
      break;
    default:
      file2.type = FileInfo_1$1.FileType.Unknown;
  }
  if (file2.isSymbolicLink) {
    const end = name2.indexOf(" -> ");
    if (end !== -1) {
      file2.name = name2.substring(0, end);
      file2.link = name2.substring(end + 4);
    }
  }
  return file2;
}
parseListUnix.parseLine = parseLine$1;
function transformList$1(files2) {
  return files2;
}
parseListUnix.transformList = transformList$1;
function parseMode(r, w2, x) {
  let value2 = 0;
  if (r !== "-") {
    value2 += FileInfo_1$1.FileInfo.UnixPermission.Read;
  }
  if (w2 !== "-") {
    value2 += FileInfo_1$1.FileInfo.UnixPermission.Write;
  }
  const execToken = x.charAt(0);
  if (execToken !== "-" && execToken.toUpperCase() !== execToken) {
    value2 += FileInfo_1$1.FileInfo.UnixPermission.Execute;
  }
  return value2;
}
var parseListMLSD = {};
Object.defineProperty(parseListMLSD, "__esModule", { value: true });
parseListMLSD.parseMLSxDate = parseListMLSD.transformList = parseListMLSD.parseLine = parseListMLSD.testLine = void 0;
const FileInfo_1 = FileInfo$1;
function parseSize(value2, info) {
  info.size = parseInt(value2, 10);
}
const factHandlersByName = {
  "size": parseSize,
  // File size
  "sizd": parseSize,
  // Directory size
  "unique": (value2, info) => {
    info.uniqueID = value2;
  },
  "modify": (value2, info) => {
    info.modifiedAt = parseMLSxDate(value2);
    info.rawModifiedAt = info.modifiedAt.toISOString();
  },
  "type": (value2, info) => {
    if (value2.startsWith("OS.unix=slink")) {
      info.type = FileInfo_1.FileType.SymbolicLink;
      info.link = value2.substr(value2.indexOf(":") + 1);
      return 1;
    }
    switch (value2) {
      case "file":
        info.type = FileInfo_1.FileType.File;
        break;
      case "dir":
        info.type = FileInfo_1.FileType.Directory;
        break;
      case "OS.unix=symlink":
        info.type = FileInfo_1.FileType.SymbolicLink;
        break;
      case "cdir":
      case "pdir":
        return 2;
      default:
        info.type = FileInfo_1.FileType.Unknown;
    }
    return 1;
  },
  "unix.mode": (value2, info) => {
    const digits = value2.substr(-3);
    info.permissions = {
      user: parseInt(digits[0], 10),
      group: parseInt(digits[1], 10),
      world: parseInt(digits[2], 10)
    };
  },
  "unix.ownername": (value2, info) => {
    info.user = value2;
  },
  "unix.owner": (value2, info) => {
    if (info.user === void 0)
      info.user = value2;
  },
  get "unix.uid"() {
    return this["unix.owner"];
  },
  "unix.groupname": (value2, info) => {
    info.group = value2;
  },
  "unix.group": (value2, info) => {
    if (info.group === void 0)
      info.group = value2;
  },
  get "unix.gid"() {
    return this["unix.group"];
  }
  // Regarding the fact "perm":
  // We don't handle permission information stored in "perm" because its information is conceptually
  // different from what users of FTP clients usually associate with "permissions". Those that have
  // some expectations (and probably want to edit them with a SITE command) often unknowingly expect
  // the Unix permission system. The information passed by "perm" describes what FTP commands can be
  // executed with a file/directory. But even this can be either incomplete or just meant as a "guide"
  // as the spec mentions. From https://tools.ietf.org/html/rfc3659#section-7.5.5: "The permissions are
  // described here as they apply to FTP commands. They may not map easily into particular permissions
  // available on the server's operating system." The parser by Apache Commons tries to translate these
  // to Unix permissions â€“ this is misleading users and might not even be correct.
};
function splitStringOnce(str2, delimiter) {
  const pos = str2.indexOf(delimiter);
  const a = str2.substr(0, pos);
  const b = str2.substr(pos + delimiter.length);
  return [a, b];
}
function testLine(line) {
  return /^\S+=\S+;/.test(line) || line.startsWith(" ");
}
parseListMLSD.testLine = testLine;
function parseLine(line) {
  const [packedFacts, name2] = splitStringOnce(line, " ");
  if (name2 === "" || name2 === "." || name2 === "..") {
    return void 0;
  }
  const info = new FileInfo_1.FileInfo(name2);
  const facts = packedFacts.split(";");
  for (const fact of facts) {
    const [factName, factValue] = splitStringOnce(fact, "=");
    if (!factValue) {
      continue;
    }
    const factHandler = factHandlersByName[factName.toLowerCase()];
    if (!factHandler) {
      continue;
    }
    const result = factHandler(factValue, info);
    if (result === 2) {
      return void 0;
    }
  }
  return info;
}
parseListMLSD.parseLine = parseLine;
function transformList(files2) {
  const nonLinksByID = /* @__PURE__ */ new Map();
  for (const file2 of files2) {
    if (!file2.isSymbolicLink && file2.uniqueID !== void 0) {
      nonLinksByID.set(file2.uniqueID, file2);
    }
  }
  const resolvedFiles = [];
  for (const file2 of files2) {
    if (file2.isSymbolicLink && file2.uniqueID !== void 0 && file2.link === void 0) {
      const target = nonLinksByID.get(file2.uniqueID);
      if (target !== void 0) {
        file2.link = target.name;
      }
    }
    const isPartOfDirectory = !file2.name.includes("/");
    if (isPartOfDirectory) {
      resolvedFiles.push(file2);
    }
  }
  return resolvedFiles;
}
parseListMLSD.transformList = transformList;
function parseMLSxDate(fact) {
  return new Date(Date.UTC(
    +fact.slice(0, 4),
    // Year
    +fact.slice(4, 6) - 1,
    // Month
    +fact.slice(6, 8),
    // Date
    +fact.slice(8, 10),
    // Hours
    +fact.slice(10, 12),
    // Minutes
    +fact.slice(12, 14),
    // Seconds
    +fact.slice(15, 18)
    // Milliseconds
  ));
}
parseListMLSD.parseMLSxDate = parseMLSxDate;
var __createBinding$2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault$2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar$2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$2(result, mod, k);
  }
  __setModuleDefault$2(result, mod);
  return result;
};
Object.defineProperty(parseList$1, "__esModule", { value: true });
parseList$1.parseList = void 0;
const dosParser = __importStar$2(parseListDOS);
const unixParser = __importStar$2(parseListUnix);
const mlsdParser = __importStar$2(parseListMLSD);
const availableParsers = [
  dosParser,
  unixParser,
  mlsdParser
  // Keep MLSD last, may accept filename only
];
function firstCompatibleParser(line, parsers) {
  return parsers.find((parser) => parser.testLine(line) === true);
}
function isNotBlank(str2) {
  return str2.trim() !== "";
}
function isNotMeta(str2) {
  return !str2.startsWith("total");
}
const REGEX_NEWLINE = /\r?\n/;
function parseList(rawList) {
  const lines = rawList.split(REGEX_NEWLINE).filter(isNotBlank).filter(isNotMeta);
  if (lines.length === 0) {
    return [];
  }
  const testLine2 = lines[lines.length - 1];
  const parser = firstCompatibleParser(testLine2, availableParsers);
  if (!parser) {
    throw new Error("This library only supports MLSD, Unix- or DOS-style directory listing. Your FTP server seems to be using another format. You can see the transmitted listing when setting `client.ftp.verbose = true`. You can then provide a custom parser to `client.parseList`, see the documentation for details.");
  }
  const files2 = lines.map(parser.parseLine).filter((info) => info !== void 0);
  return parser.transformList(files2);
}
parseList$1.parseList = parseList;
var ProgressTracker$1 = {};
Object.defineProperty(ProgressTracker$1, "__esModule", { value: true });
ProgressTracker$1.ProgressTracker = void 0;
class ProgressTracker {
  constructor() {
    this.bytesOverall = 0;
    this.intervalMs = 500;
    this.onStop = noop$2;
    this.onHandle = noop$2;
  }
  /**
   * Register a new handler for progress info. Use `undefined` to disable reporting.
   */
  reportTo(onHandle = noop$2) {
    this.onHandle = onHandle;
  }
  /**
   * Start tracking transfer progress of a socket.
   *
   * @param socket  The socket to observe.
   * @param name  A name associated with this progress tracking, e.g. a filename.
   * @param type  The type of the transfer, typically "upload" or "download".
   */
  start(socket, name2, type3) {
    let lastBytes = 0;
    this.onStop = poll(this.intervalMs, () => {
      const bytes2 = socket.bytesRead + socket.bytesWritten;
      this.bytesOverall += bytes2 - lastBytes;
      lastBytes = bytes2;
      this.onHandle({
        name: name2,
        type: type3,
        bytes: bytes2,
        bytesOverall: this.bytesOverall
      });
    });
  }
  /**
   * Stop tracking transfer progress.
   */
  stop() {
    this.onStop(false);
  }
  /**
   * Call the progress handler one more time, then stop tracking.
   */
  updateAndStop() {
    this.onStop(true);
  }
}
ProgressTracker$1.ProgressTracker = ProgressTracker;
function poll(intervalMs, updateFunc) {
  const id = setInterval(updateFunc, intervalMs);
  const stopFunc = (stopWithUpdate) => {
    clearInterval(id);
    if (stopWithUpdate) {
      updateFunc();
    }
    updateFunc = noop$2;
  };
  updateFunc();
  return stopFunc;
}
function noop$2() {
}
var StringWriter$1 = {};
Object.defineProperty(StringWriter$1, "__esModule", { value: true });
StringWriter$1.StringWriter = void 0;
const stream_1$2 = require$$1$4;
class StringWriter extends stream_1$2.Writable {
  constructor() {
    super(...arguments);
    this.buf = Buffer.alloc(0);
  }
  _write(chunk, _, callback) {
    if (chunk instanceof Buffer) {
      this.buf = Buffer.concat([this.buf, chunk]);
      callback(null);
    } else {
      callback(new Error("StringWriter expects chunks of type 'Buffer'."));
    }
  }
  getText(encoding3) {
    return this.buf.toString(encoding3);
  }
}
StringWriter$1.StringWriter = StringWriter;
var netUtils = {};
Object.defineProperty(netUtils, "__esModule", { value: true });
netUtils.ipIsPrivateV4Address = netUtils.upgradeSocket = netUtils.describeAddress = netUtils.describeTLS = void 0;
const tls_1$2 = require$$1$6;
function describeTLS(socket) {
  if (socket instanceof tls_1$2.TLSSocket) {
    const protocol2 = socket.getProtocol();
    return protocol2 ? protocol2 : "Server socket or disconnected client socket";
  }
  return "No encryption";
}
netUtils.describeTLS = describeTLS;
function describeAddress(socket) {
  if (socket.remoteFamily === "IPv6") {
    return `[${socket.remoteAddress}]:${socket.remotePort}`;
  }
  return `${socket.remoteAddress}:${socket.remotePort}`;
}
netUtils.describeAddress = describeAddress;
function upgradeSocket(socket, options) {
  return new Promise((resolve3, reject) => {
    const tlsOptions = Object.assign({}, options, {
      socket
    });
    const tlsSocket = (0, tls_1$2.connect)(tlsOptions, () => {
      const expectCertificate = tlsOptions.rejectUnauthorized !== false;
      if (expectCertificate && !tlsSocket.authorized) {
        reject(tlsSocket.authorizationError);
      } else {
        tlsSocket.removeAllListeners("error");
        resolve3(tlsSocket);
      }
    }).once("error", (error2) => {
      reject(error2);
    });
  });
}
netUtils.upgradeSocket = upgradeSocket;
function ipIsPrivateV4Address(ip3 = "") {
  if (ip3.startsWith("::ffff:")) {
    ip3 = ip3.substr(7);
  }
  const octets = ip3.split(".").map((o) => parseInt(o, 10));
  return octets[0] === 10 || octets[0] === 172 && octets[1] >= 16 && octets[1] <= 31 || octets[0] === 192 && octets[1] === 168 || ip3 === "127.0.0.1";
}
netUtils.ipIsPrivateV4Address = ipIsPrivateV4Address;
var transfer = {};
Object.defineProperty(transfer, "__esModule", { value: true });
transfer.downloadTo = transfer.uploadFrom = transfer.connectForPassiveTransfer = transfer.parsePasvResponse = transfer.enterPassiveModeIPv4 = transfer.parseEpsvResponse = transfer.enterPassiveModeIPv6 = void 0;
const netUtils_1$1 = netUtils;
const stream_1$1 = require$$1$4;
const tls_1$1 = require$$1$6;
const parseControlResponse_1$1 = parseControlResponse$1;
async function enterPassiveModeIPv6(ftp2) {
  const res2 = await ftp2.request("EPSV");
  const port = parseEpsvResponse(res2.message);
  if (!port) {
    throw new Error("Can't parse EPSV response: " + res2.message);
  }
  const controlHost = ftp2.socket.remoteAddress;
  if (controlHost === void 0) {
    throw new Error("Control socket is disconnected, can't get remote address.");
  }
  await connectForPassiveTransfer(controlHost, port, ftp2);
  return res2;
}
transfer.enterPassiveModeIPv6 = enterPassiveModeIPv6;
function parseEpsvResponse(message) {
  const groups = message.match(/[|!]{3}(.+)[|!]/);
  if (groups === null || groups[1] === void 0) {
    throw new Error(`Can't parse response to 'EPSV': ${message}`);
  }
  const port = parseInt(groups[1], 10);
  if (Number.isNaN(port)) {
    throw new Error(`Can't parse response to 'EPSV', port is not a number: ${message}`);
  }
  return port;
}
transfer.parseEpsvResponse = parseEpsvResponse;
async function enterPassiveModeIPv4(ftp2) {
  const res2 = await ftp2.request("PASV");
  const target = parsePasvResponse(res2.message);
  if (!target) {
    throw new Error("Can't parse PASV response: " + res2.message);
  }
  const controlHost = ftp2.socket.remoteAddress;
  if ((0, netUtils_1$1.ipIsPrivateV4Address)(target.host) && controlHost && !(0, netUtils_1$1.ipIsPrivateV4Address)(controlHost)) {
    target.host = controlHost;
  }
  await connectForPassiveTransfer(target.host, target.port, ftp2);
  return res2;
}
transfer.enterPassiveModeIPv4 = enterPassiveModeIPv4;
function parsePasvResponse(message) {
  const groups = message.match(/([-\d]+,[-\d]+,[-\d]+,[-\d]+),([-\d]+),([-\d]+)/);
  if (groups === null || groups.length !== 4) {
    throw new Error(`Can't parse response to 'PASV': ${message}`);
  }
  return {
    host: groups[1].replace(/,/g, "."),
    port: (parseInt(groups[2], 10) & 255) * 256 + (parseInt(groups[3], 10) & 255)
  };
}
transfer.parsePasvResponse = parsePasvResponse;
function connectForPassiveTransfer(host2, port, ftp2) {
  return new Promise((resolve3, reject) => {
    let socket = ftp2._newSocket();
    const handleConnErr = function(err) {
      err.message = "Can't open data connection in passive mode: " + err.message;
      reject(err);
    };
    const handleTimeout = function() {
      socket.destroy();
      reject(new Error(`Timeout when trying to open data connection to ${host2}:${port}`));
    };
    socket.setTimeout(ftp2.timeout);
    socket.on("error", handleConnErr);
    socket.on("timeout", handleTimeout);
    socket.connect({ port, host: host2, family: ftp2.ipFamily }, () => {
      if (ftp2.socket instanceof tls_1$1.TLSSocket) {
        socket = (0, tls_1$1.connect)(Object.assign({}, ftp2.tlsOptions, {
          socket,
          // Reuse the TLS session negotiated earlier when the control connection
          // was upgraded. Servers expect this because it provides additional
          // security: If a completely new session would be negotiated, a hacker
          // could guess the port and connect to the new data connection before we do
          // by just starting his/her own TLS session.
          session: ftp2.socket.getSession()
        }));
      }
      socket.removeListener("error", handleConnErr);
      socket.removeListener("timeout", handleTimeout);
      ftp2.dataSocket = socket;
      resolve3();
    });
  });
}
transfer.connectForPassiveTransfer = connectForPassiveTransfer;
class TransferResolver {
  /**
   * Instantiate a TransferResolver
   */
  constructor(ftp2, progress) {
    this.ftp = ftp2;
    this.progress = progress;
    this.response = void 0;
    this.dataTransferDone = false;
  }
  /**
   * Mark the beginning of a transfer.
   *
   * @param name - Name of the transfer, usually the filename.
   * @param type - Type of transfer, usually "upload" or "download".
   */
  onDataStart(name2, type3) {
    if (this.ftp.dataSocket === void 0) {
      throw new Error("Data transfer should start but there is no data connection.");
    }
    this.ftp.socket.setTimeout(0);
    this.ftp.dataSocket.setTimeout(this.ftp.timeout);
    this.progress.start(this.ftp.dataSocket, name2, type3);
  }
  /**
   * The data connection has finished the transfer.
   */
  onDataDone(task) {
    this.progress.updateAndStop();
    this.ftp.socket.setTimeout(this.ftp.timeout);
    if (this.ftp.dataSocket) {
      this.ftp.dataSocket.setTimeout(0);
    }
    this.dataTransferDone = true;
    this.tryResolve(task);
  }
  /**
   * The control connection reports the transfer as finished.
   */
  onControlDone(task, response2) {
    this.response = response2;
    this.tryResolve(task);
  }
  /**
   * An error has been reported and the task should be rejected.
   */
  onError(task, err) {
    this.progress.updateAndStop();
    this.ftp.socket.setTimeout(this.ftp.timeout);
    this.ftp.dataSocket = void 0;
    task.reject(err);
  }
  /**
   * Control connection sent an unexpected request requiring a response from our part. We
   * can't provide that (because unknown) and have to close the contrext with an error because
   * the FTP server is now caught up in a state we can't resolve.
   */
  onUnexpectedRequest(response2) {
    const err = new Error(`Unexpected FTP response is requesting an answer: ${response2.message}`);
    this.ftp.closeWithError(err);
  }
  tryResolve(task) {
    const canResolve = this.dataTransferDone && this.response !== void 0;
    if (canResolve) {
      this.ftp.dataSocket = void 0;
      task.resolve(this.response);
    }
  }
}
function uploadFrom(source, config) {
  const resolver = new TransferResolver(config.ftp, config.tracker);
  const fullCommand = `${config.command} ${config.remotePath}`;
  return config.ftp.handle(fullCommand, (res2, task) => {
    if (res2 instanceof Error) {
      resolver.onError(task, res2);
    } else if (res2.code === 150 || res2.code === 125) {
      const dataSocket = config.ftp.dataSocket;
      if (!dataSocket) {
        resolver.onError(task, new Error("Upload should begin but no data connection is available."));
        return;
      }
      const canUpload = "getCipher" in dataSocket ? dataSocket.getCipher() !== void 0 : true;
      onConditionOrEvent(canUpload, dataSocket, "secureConnect", () => {
        config.ftp.log(`Uploading to ${(0, netUtils_1$1.describeAddress)(dataSocket)} (${(0, netUtils_1$1.describeTLS)(dataSocket)})`);
        resolver.onDataStart(config.remotePath, config.type);
        (0, stream_1$1.pipeline)(source, dataSocket, (err) => {
          if (err) {
            resolver.onError(task, err);
          } else {
            resolver.onDataDone(task);
          }
        });
      });
    } else if ((0, parseControlResponse_1$1.positiveCompletion)(res2.code)) {
      resolver.onControlDone(task, res2);
    } else if ((0, parseControlResponse_1$1.positiveIntermediate)(res2.code)) {
      resolver.onUnexpectedRequest(res2);
    }
  });
}
transfer.uploadFrom = uploadFrom;
function downloadTo(destination, config) {
  if (!config.ftp.dataSocket) {
    throw new Error("Download will be initiated but no data connection is available.");
  }
  const resolver = new TransferResolver(config.ftp, config.tracker);
  return config.ftp.handle(config.command, (res2, task) => {
    if (res2 instanceof Error) {
      resolver.onError(task, res2);
    } else if (res2.code === 150 || res2.code === 125) {
      const dataSocket = config.ftp.dataSocket;
      if (!dataSocket) {
        resolver.onError(task, new Error("Download should begin but no data connection is available."));
        return;
      }
      config.ftp.log(`Downloading from ${(0, netUtils_1$1.describeAddress)(dataSocket)} (${(0, netUtils_1$1.describeTLS)(dataSocket)})`);
      resolver.onDataStart(config.remotePath, config.type);
      (0, stream_1$1.pipeline)(dataSocket, destination, (err) => {
        if (err) {
          resolver.onError(task, err);
        } else {
          resolver.onDataDone(task);
        }
      });
    } else if (res2.code === 350) {
      config.ftp.send("RETR " + config.remotePath);
    } else if ((0, parseControlResponse_1$1.positiveCompletion)(res2.code)) {
      resolver.onControlDone(task, res2);
    } else if ((0, parseControlResponse_1$1.positiveIntermediate)(res2.code)) {
      resolver.onUnexpectedRequest(res2);
    }
  });
}
transfer.downloadTo = downloadTo;
function onConditionOrEvent(condition, emitter, eventName, action) {
  if (condition === true) {
    action();
  } else {
    emitter.once(eventName, () => action());
  }
}
Object.defineProperty(Client$1, "__esModule", { value: true });
Client$1.Client = void 0;
const fs_1 = require$$0$7;
const path_1$1 = require$$1$2;
const tls_1 = require$$1$6;
const util_1$6 = require$$1$3;
const FtpContext_1 = FtpContext;
const parseList_1 = parseList$1;
const ProgressTracker_1 = ProgressTracker$1;
const StringWriter_1 = StringWriter$1;
const parseListMLSD_1 = parseListMLSD;
const netUtils_1 = netUtils;
const transfer_1 = transfer;
const parseControlResponse_1 = parseControlResponse$1;
const fsReadDir = (0, util_1$6.promisify)(fs_1.readdir);
const fsMkDir = (0, util_1$6.promisify)(fs_1.mkdir);
const fsStat = (0, util_1$6.promisify)(fs_1.stat);
const fsOpen = (0, util_1$6.promisify)(fs_1.open);
const fsClose = (0, util_1$6.promisify)(fs_1.close);
const fsUnlink = (0, util_1$6.promisify)(fs_1.unlink);
const LIST_COMMANDS_DEFAULT = () => ["LIST -a", "LIST"];
const LIST_COMMANDS_MLSD = () => ["MLSD", "LIST -a", "LIST"];
class Client {
  /**
   * Instantiate an FTP client.
   *
   * @param timeout  Timeout in milliseconds, use 0 for no timeout. Optional, default is 30 seconds.
   */
  constructor(timeout = 3e4) {
    this.availableListCommands = LIST_COMMANDS_DEFAULT();
    this.ftp = new FtpContext_1.FTPContext(timeout);
    this.prepareTransfer = this._enterFirstCompatibleMode([transfer_1.enterPassiveModeIPv6, transfer_1.enterPassiveModeIPv4]);
    this.parseList = parseList_1.parseList;
    this._progressTracker = new ProgressTracker_1.ProgressTracker();
  }
  /**
   * Close the client and all open socket connections.
   *
   * Close the client and all open socket connections. The client canâ€™t be used anymore after calling this method,
   * you have to either reconnect with `access` or `connect` or instantiate a new instance to continue any work.
   * A client is also closed automatically if any timeout or connection error occurs.
   */
  close() {
    this.ftp.close();
    this._progressTracker.stop();
  }
  /**
   * Returns true if the client is closed and can't be used anymore.
   */
  get closed() {
    return this.ftp.closed;
  }
  /**
   * Connect (or reconnect) to an FTP server.
   *
   * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
   * instance. Whenever you do, the client is reset with a new control connection. This also implies that
   * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
   * method. In fact, reconnecting is the only way to continue using a closed `Client`.
   *
   * @param host  Host the client should connect to. Optional, default is "localhost".
   * @param port  Port the client should connect to. Optional, default is 21.
   */
  connect(host2 = "localhost", port = 21) {
    this.ftp.reset();
    this.ftp.socket.connect({
      host: host2,
      port,
      family: this.ftp.ipFamily
    }, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
    return this._handleConnectResponse();
  }
  /**
   * As `connect` but using implicit TLS. Implicit TLS is not an FTP standard and has been replaced by
   * explicit TLS. There are still FTP servers that support only implicit TLS, though.
   */
  connectImplicitTLS(host2 = "localhost", port = 21, tlsOptions = {}) {
    this.ftp.reset();
    this.ftp.socket = (0, tls_1.connect)(port, host2, tlsOptions, () => this.ftp.log(`Connected to ${(0, netUtils_1.describeAddress)(this.ftp.socket)} (${(0, netUtils_1.describeTLS)(this.ftp.socket)})`));
    this.ftp.tlsOptions = tlsOptions;
    return this._handleConnectResponse();
  }
  /**
   * Handles the first reponse by an FTP server after the socket connection has been established.
   */
  _handleConnectResponse() {
    return this.ftp.handle(void 0, (res2, task) => {
      if (res2 instanceof Error) {
        task.reject(res2);
      } else if ((0, parseControlResponse_1.positiveCompletion)(res2.code)) {
        task.resolve(res2);
      } else {
        task.reject(new FtpContext_1.FTPError(res2));
      }
    });
  }
  /**
   * Send an FTP command and handle the first response.
   */
  send(command, ignoreErrorCodesDEPRECATED = false) {
    if (ignoreErrorCodesDEPRECATED) {
      this.ftp.log("Deprecated call using send(command, flag) with boolean flag to ignore errors. Use sendIgnoringError(command).");
      return this.sendIgnoringError(command);
    }
    return this.ftp.request(command);
  }
  /**
   * Send an FTP command and ignore an FTP error response. Any other kind of error or timeout will still reject the Promise.
   *
   * @param command
   */
  sendIgnoringError(command) {
    return this.ftp.handle(command, (res2, task) => {
      if (res2 instanceof FtpContext_1.FTPError) {
        task.resolve({ code: res2.code, message: res2.message });
      } else if (res2 instanceof Error) {
        task.reject(res2);
      } else {
        task.resolve(res2);
      }
    });
  }
  /**
   * Upgrade the current socket connection to TLS.
   *
   * @param options  TLS options as in `tls.connect(options)`, optional.
   * @param command  Set the authentication command. Optional, default is "AUTH TLS".
   */
  async useTLS(options = {}, command = "AUTH TLS") {
    const ret = await this.send(command);
    this.ftp.socket = await (0, netUtils_1.upgradeSocket)(this.ftp.socket, options);
    this.ftp.tlsOptions = options;
    this.ftp.log(`Control socket is using: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
    return ret;
  }
  /**
   * Login a user with a password.
   *
   * @param user  Username to use for login. Optional, default is "anonymous".
   * @param password  Password to use for login. Optional, default is "guest".
   */
  login(user = "anonymous", password = "guest") {
    this.ftp.log(`Login security: ${(0, netUtils_1.describeTLS)(this.ftp.socket)}`);
    return this.ftp.handle("USER " + user, (res2, task) => {
      if (res2 instanceof Error) {
        task.reject(res2);
      } else if ((0, parseControlResponse_1.positiveCompletion)(res2.code)) {
        task.resolve(res2);
      } else if (res2.code === 331) {
        this.ftp.send("PASS " + password);
      } else {
        task.reject(new FtpContext_1.FTPError(res2));
      }
    });
  }
  /**
   * Set the usual default settings.
   *
   * Settings used:
   * * Binary mode (TYPE I)
   * * File structure (STRU F)
   * * Additional settings for FTPS (PBSZ 0, PROT P)
   */
  async useDefaultSettings() {
    const features = await this.features();
    const supportsMLSD = features.has("MLST");
    this.availableListCommands = supportsMLSD ? LIST_COMMANDS_MLSD() : LIST_COMMANDS_DEFAULT();
    await this.send("TYPE I");
    await this.sendIgnoringError("STRU F");
    await this.sendIgnoringError("OPTS UTF8 ON");
    if (supportsMLSD) {
      await this.sendIgnoringError("OPTS MLST type;size;modify;unique;unix.mode;unix.owner;unix.group;unix.ownername;unix.groupname;");
    }
    if (this.ftp.hasTLS) {
      await this.sendIgnoringError("PBSZ 0");
      await this.sendIgnoringError("PROT P");
    }
  }
  /**
   * Convenience method that calls `connect`, `useTLS`, `login` and `useDefaultSettings`.
   *
   * This is an instance method and thus can be called multiple times during the lifecycle of a `Client`
   * instance. Whenever you do, the client is reset with a new control connection. This also implies that
   * you can reopen a `Client` instance that has been closed due to an error when reconnecting with this
   * method. In fact, reconnecting is the only way to continue using a closed `Client`.
   */
  async access(options = {}) {
    var _a, _b;
    const useExplicitTLS = options.secure === true;
    const useImplicitTLS = options.secure === "implicit";
    let welcome;
    if (useImplicitTLS) {
      welcome = await this.connectImplicitTLS(options.host, options.port, options.secureOptions);
    } else {
      welcome = await this.connect(options.host, options.port);
    }
    if (useExplicitTLS) {
      const secureOptions = (_a = options.secureOptions) !== null && _a !== void 0 ? _a : {};
      secureOptions.host = (_b = secureOptions.host) !== null && _b !== void 0 ? _b : options.host;
      await this.useTLS(secureOptions);
    }
    await this.sendIgnoringError("OPTS UTF8 ON");
    await this.login(options.user, options.password);
    await this.useDefaultSettings();
    return welcome;
  }
  /**
   * Get the current working directory.
   */
  async pwd() {
    const res2 = await this.send("PWD");
    const parsed = res2.message.match(/"(.+)"/);
    if (parsed === null || parsed[1] === void 0) {
      throw new Error(`Can't parse response to command 'PWD': ${res2.message}`);
    }
    return parsed[1];
  }
  /**
   * Get a description of supported features.
   *
   * This sends the FEAT command and parses the result into a Map where keys correspond to available commands
   * and values hold further information. Be aware that your FTP servers might not support this
   * command in which case this method will not throw an exception but just return an empty Map.
   */
  async features() {
    const res2 = await this.sendIgnoringError("FEAT");
    const features = /* @__PURE__ */ new Map();
    if (res2.code < 400 && (0, parseControlResponse_1.isMultiline)(res2.message)) {
      res2.message.split("\n").slice(1, -1).forEach((line) => {
        const entry = line.trim().split(" ");
        features.set(entry[0], entry[1] || "");
      });
    }
    return features;
  }
  /**
   * Set the working directory.
   */
  async cd(path3) {
    const validPath = await this.protectWhitespace(path3);
    return this.send("CWD " + validPath);
  }
  /**
   * Switch to the parent directory of the working directory.
   */
  async cdup() {
    return this.send("CDUP");
  }
  /**
   * Get the last modified time of a file. This is not supported by every FTP server, in which case
   * calling this method will throw an exception.
   */
  async lastMod(path3) {
    const validPath = await this.protectWhitespace(path3);
    const res2 = await this.send(`MDTM ${validPath}`);
    const date = res2.message.slice(4);
    return (0, parseListMLSD_1.parseMLSxDate)(date);
  }
  /**
   * Get the size of a file.
   */
  async size(path3) {
    const validPath = await this.protectWhitespace(path3);
    const command = `SIZE ${validPath}`;
    const res2 = await this.send(command);
    const size = parseInt(res2.message.slice(4), 10);
    if (Number.isNaN(size)) {
      throw new Error(`Can't parse response to command '${command}' as a numerical value: ${res2.message}`);
    }
    return size;
  }
  /**
   * Rename a file.
   *
   * Depending on the FTP server this might also be used to move a file from one
   * directory to another by providing full paths.
   */
  async rename(srcPath, destPath) {
    const validSrc = await this.protectWhitespace(srcPath);
    const validDest = await this.protectWhitespace(destPath);
    await this.send("RNFR " + validSrc);
    return this.send("RNTO " + validDest);
  }
  /**
   * Remove a file from the current working directory.
   *
   * You can ignore FTP error return codes which won't throw an exception if e.g.
   * the file doesn't exist.
   */
  async remove(path3, ignoreErrorCodes = false) {
    const validPath = await this.protectWhitespace(path3);
    if (ignoreErrorCodes) {
      return this.sendIgnoringError(`DELE ${validPath}`);
    }
    return this.send(`DELE ${validPath}`);
  }
  /**
   * Report transfer progress for any upload or download to a given handler.
   *
   * This will also reset the overall transfer counter that can be used for multiple transfers. You can
   * also call the function without a handler to stop reporting to an earlier one.
   *
   * @param handler  Handler function to call on transfer progress.
   */
  trackProgress(handler) {
    this._progressTracker.bytesOverall = 0;
    this._progressTracker.reportTo(handler);
  }
  /**
   * Upload data from a readable stream or a local file to a remote file.
   *
   * @param source  Readable stream or path to a local file.
   * @param toRemotePath  Path to a remote file to write to.
   */
  async uploadFrom(source, toRemotePath, options = {}) {
    return this._uploadWithCommand(source, toRemotePath, "STOR", options);
  }
  /**
   * Upload data from a readable stream or a local file by appending it to an existing file. If the file doesn't
   * exist the FTP server should create it.
   *
   * @param source  Readable stream or path to a local file.
   * @param toRemotePath  Path to a remote file to write to.
   */
  async appendFrom(source, toRemotePath, options = {}) {
    return this._uploadWithCommand(source, toRemotePath, "APPE", options);
  }
  /**
   * @protected
   */
  async _uploadWithCommand(source, remotePath, command, options) {
    if (typeof source === "string") {
      return this._uploadLocalFile(source, remotePath, command, options);
    }
    return this._uploadFromStream(source, remotePath, command);
  }
  /**
   * @protected
   */
  async _uploadLocalFile(localPath, remotePath, command, options) {
    const fd = await fsOpen(localPath, "r");
    const source = (0, fs_1.createReadStream)("", {
      fd,
      start: options.localStart,
      end: options.localEndInclusive,
      autoClose: false
    });
    try {
      return await this._uploadFromStream(source, remotePath, command);
    } finally {
      await ignoreError(() => fsClose(fd));
    }
  }
  /**
   * @protected
   */
  async _uploadFromStream(source, remotePath, command) {
    const onError = (err) => this.ftp.closeWithError(err);
    source.once("error", onError);
    try {
      const validPath = await this.protectWhitespace(remotePath);
      await this.prepareTransfer(this.ftp);
      return await (0, transfer_1.uploadFrom)(source, {
        ftp: this.ftp,
        tracker: this._progressTracker,
        command,
        remotePath: validPath,
        type: "upload"
      });
    } finally {
      source.removeListener("error", onError);
    }
  }
  /**
   * Download a remote file and pipe its data to a writable stream or to a local file.
   *
   * You can optionally define at which position of the remote file you'd like to start
   * downloading. If the destination you provide is a file, the offset will be applied
   * to it as well. For example: To resume a failed download, you'd request the size of
   * the local, partially downloaded file and use that as the offset. Assuming the size
   * is 23, you'd download the rest using `downloadTo("local.txt", "remote.txt", 23)`.
   *
   * @param destination  Stream or path for a local file to write to.
   * @param fromRemotePath  Path of the remote file to read from.
   * @param startAt  Position within the remote file to start downloading at. If the destination is a file, this offset is also applied to it.
   */
  async downloadTo(destination, fromRemotePath, startAt = 0) {
    if (typeof destination === "string") {
      return this._downloadToFile(destination, fromRemotePath, startAt);
    }
    return this._downloadToStream(destination, fromRemotePath, startAt);
  }
  /**
   * @protected
   */
  async _downloadToFile(localPath, remotePath, startAt) {
    const appendingToLocalFile = startAt > 0;
    const fileSystemFlags = appendingToLocalFile ? "r+" : "w";
    const fd = await fsOpen(localPath, fileSystemFlags);
    const destination = (0, fs_1.createWriteStream)("", {
      fd,
      start: startAt,
      autoClose: false
    });
    try {
      return await this._downloadToStream(destination, remotePath, startAt);
    } catch (err) {
      const localFileStats = await ignoreError(() => fsStat(localPath));
      const hasDownloadedData = localFileStats && localFileStats.size > 0;
      const shouldRemoveLocalFile = !appendingToLocalFile && !hasDownloadedData;
      if (shouldRemoveLocalFile) {
        await ignoreError(() => fsUnlink(localPath));
      }
      throw err;
    } finally {
      await ignoreError(() => fsClose(fd));
    }
  }
  /**
   * @protected
   */
  async _downloadToStream(destination, remotePath, startAt) {
    const onError = (err) => this.ftp.closeWithError(err);
    destination.once("error", onError);
    try {
      const validPath = await this.protectWhitespace(remotePath);
      await this.prepareTransfer(this.ftp);
      return await (0, transfer_1.downloadTo)(destination, {
        ftp: this.ftp,
        tracker: this._progressTracker,
        command: startAt > 0 ? `REST ${startAt}` : `RETR ${validPath}`,
        remotePath: validPath,
        type: "download"
      });
    } finally {
      destination.removeListener("error", onError);
      destination.end();
    }
  }
  /**
   * List files and directories in the current working directory, or from `path` if specified.
   *
   * @param [path]  Path to remote file or directory.
   */
  async list(path3 = "") {
    const validPath = await this.protectWhitespace(path3);
    let lastError;
    for (const candidate of this.availableListCommands) {
      const command = validPath === "" ? candidate : `${candidate} ${validPath}`;
      await this.prepareTransfer(this.ftp);
      try {
        const parsedList = await this._requestListWithCommand(command);
        this.availableListCommands = [candidate];
        return parsedList;
      } catch (err) {
        const shouldTryNext = err instanceof FtpContext_1.FTPError;
        if (!shouldTryNext) {
          throw err;
        }
        lastError = err;
      }
    }
    throw lastError;
  }
  /**
   * @protected
   */
  async _requestListWithCommand(command) {
    const buffer = new StringWriter_1.StringWriter();
    await (0, transfer_1.downloadTo)(buffer, {
      ftp: this.ftp,
      tracker: this._progressTracker,
      command,
      remotePath: "",
      type: "list"
    });
    const text = buffer.getText(this.ftp.encoding);
    this.ftp.log(text);
    return this.parseList(text);
  }
  /**
   * Remove a directory and all of its content.
   *
   * @param remoteDirPath  The path of the remote directory to delete.
   * @example client.removeDir("foo") // Remove directory 'foo' using a relative path.
   * @example client.removeDir("foo/bar") // Remove directory 'bar' using a relative path.
   * @example client.removeDir("/foo/bar") // Remove directory 'bar' using an absolute path.
   * @example client.removeDir("/") // Remove everything.
   */
  async removeDir(remoteDirPath) {
    return this._exitAtCurrentDirectory(async () => {
      await this.cd(remoteDirPath);
      const absoluteDirPath = await this.pwd();
      await this.clearWorkingDir();
      const dirIsRoot = absoluteDirPath === "/";
      if (!dirIsRoot) {
        await this.cdup();
        await this.removeEmptyDir(absoluteDirPath);
      }
    });
  }
  /**
   * Remove all files and directories in the working directory without removing
   * the working directory itself.
   */
  async clearWorkingDir() {
    for (const file2 of await this.list()) {
      if (file2.isDirectory) {
        await this.cd(file2.name);
        await this.clearWorkingDir();
        await this.cdup();
        await this.removeEmptyDir(file2.name);
      } else {
        await this.remove(file2.name);
      }
    }
  }
  /**
   * Upload the contents of a local directory to the remote working directory.
   *
   * This will overwrite existing files with the same names and reuse existing directories.
   * Unrelated files and directories will remain untouched. You can optionally provide a `remoteDirPath`
   * to put the contents inside a directory which will be created if necessary including all
   * intermediate directories. If you did provide a remoteDirPath the working directory will stay
   * the same as before calling this method.
   *
   * @param localDirPath  Local path, e.g. "foo/bar" or "../test"
   * @param [remoteDirPath]  Remote path of a directory to upload to. Working directory if undefined.
   */
  async uploadFromDir(localDirPath, remoteDirPath) {
    return this._exitAtCurrentDirectory(async () => {
      if (remoteDirPath) {
        await this.ensureDir(remoteDirPath);
      }
      return await this._uploadToWorkingDir(localDirPath);
    });
  }
  /**
   * @protected
   */
  async _uploadToWorkingDir(localDirPath) {
    const files2 = await fsReadDir(localDirPath);
    for (const file2 of files2) {
      const fullPath = (0, path_1$1.join)(localDirPath, file2);
      const stats = await fsStat(fullPath);
      if (stats.isFile()) {
        await this.uploadFrom(fullPath, file2);
      } else if (stats.isDirectory()) {
        await this._openDir(file2);
        await this._uploadToWorkingDir(fullPath);
        await this.cdup();
      }
    }
  }
  /**
   * Download all files and directories of the working directory to a local directory.
   *
   * @param localDirPath  The local directory to download to.
   * @param remoteDirPath  Remote directory to download. Current working directory if not specified.
   */
  async downloadToDir(localDirPath, remoteDirPath) {
    return this._exitAtCurrentDirectory(async () => {
      if (remoteDirPath) {
        await this.cd(remoteDirPath);
      }
      return await this._downloadFromWorkingDir(localDirPath);
    });
  }
  /**
   * @protected
   */
  async _downloadFromWorkingDir(localDirPath) {
    await ensureLocalDirectory(localDirPath);
    for (const file2 of await this.list()) {
      const localPath = (0, path_1$1.join)(localDirPath, file2.name);
      if (file2.isDirectory) {
        await this.cd(file2.name);
        await this._downloadFromWorkingDir(localPath);
        await this.cdup();
      } else if (file2.isFile) {
        await this.downloadTo(localPath, file2.name);
      }
    }
  }
  /**
   * Make sure a given remote path exists, creating all directories as necessary.
   * This function also changes the current working directory to the given path.
   */
  async ensureDir(remoteDirPath) {
    if (remoteDirPath.startsWith("/")) {
      await this.cd("/");
    }
    const names = remoteDirPath.split("/").filter((name2) => name2 !== "");
    for (const name2 of names) {
      await this._openDir(name2);
    }
  }
  /**
   * Try to create a directory and enter it. This will not raise an exception if the directory
   * couldn't be created if for example it already exists.
   * @protected
   */
  async _openDir(dirName) {
    await this.sendIgnoringError("MKD " + dirName);
    await this.cd(dirName);
  }
  /**
   * Remove an empty directory, will fail if not empty.
   */
  async removeEmptyDir(path3) {
    const validPath = await this.protectWhitespace(path3);
    return this.send(`RMD ${validPath}`);
  }
  /**
   * FTP servers can't handle filenames that have leading whitespace. This method transforms
   * a given path to fix that issue for most cases.
   */
  async protectWhitespace(path3) {
    if (!path3.startsWith(" ")) {
      return path3;
    }
    const pwd = await this.pwd();
    const absolutePathPrefix = pwd.endsWith("/") ? pwd : pwd + "/";
    return absolutePathPrefix + path3;
  }
  async _exitAtCurrentDirectory(func) {
    const userDir = await this.pwd();
    try {
      return await func();
    } finally {
      if (!this.closed) {
        await ignoreError(() => this.cd(userDir));
      }
    }
  }
  /**
   * Try all available transfer strategies and pick the first one that works. Update `client` to
   * use the working strategy for all successive transfer requests.
   *
   * @returns a function that will try the provided strategies.
   */
  _enterFirstCompatibleMode(strategies) {
    return async (ftp2) => {
      ftp2.log("Trying to find optimal transfer strategy...");
      let lastError = void 0;
      for (const strategy of strategies) {
        try {
          const res2 = await strategy(ftp2);
          ftp2.log("Optimal transfer strategy found.");
          this.prepareTransfer = strategy;
          return res2;
        } catch (err) {
          lastError = err;
        }
      }
      throw new Error(`None of the available transfer strategies work. Last error response was '${lastError}'.`);
    };
  }
  /**
   * DEPRECATED, use `uploadFrom`.
   * @deprecated
   */
  async upload(source, toRemotePath, options = {}) {
    this.ftp.log("Warning: upload() has been deprecated, use uploadFrom().");
    return this.uploadFrom(source, toRemotePath, options);
  }
  /**
   * DEPRECATED, use `appendFrom`.
   * @deprecated
   */
  async append(source, toRemotePath, options = {}) {
    this.ftp.log("Warning: append() has been deprecated, use appendFrom().");
    return this.appendFrom(source, toRemotePath, options);
  }
  /**
   * DEPRECATED, use `downloadTo`.
   * @deprecated
   */
  async download(destination, fromRemotePath, startAt = 0) {
    this.ftp.log("Warning: download() has been deprecated, use downloadTo().");
    return this.downloadTo(destination, fromRemotePath, startAt);
  }
  /**
   * DEPRECATED, use `uploadFromDir`.
   * @deprecated
   */
  async uploadDir(localDirPath, remoteDirPath) {
    this.ftp.log("Warning: uploadDir() has been deprecated, use uploadFromDir().");
    return this.uploadFromDir(localDirPath, remoteDirPath);
  }
  /**
   * DEPRECATED, use `downloadToDir`.
   * @deprecated
   */
  async downloadDir(localDirPath) {
    this.ftp.log("Warning: downloadDir() has been deprecated, use downloadToDir().");
    return this.downloadToDir(localDirPath);
  }
}
Client$1.Client = Client;
async function ensureLocalDirectory(path3) {
  try {
    await fsStat(path3);
  } catch (err) {
    await fsMkDir(path3, { recursive: true });
  }
}
async function ignoreError(func) {
  try {
    return await func();
  } catch (err) {
    return void 0;
  }
}
var StringEncoding = {};
Object.defineProperty(StringEncoding, "__esModule", { value: true });
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.enterPassiveModeIPv6 = exports.enterPassiveModeIPv4 = void 0;
  __exportStar2(Client$1, exports);
  __exportStar2(FtpContext, exports);
  __exportStar2(FileInfo$1, exports);
  __exportStar2(parseList$1, exports);
  __exportStar2(StringEncoding, exports);
  var transfer_12 = transfer;
  Object.defineProperty(exports, "enterPassiveModeIPv4", { enumerable: true, get: function() {
    return transfer_12.enterPassiveModeIPv4;
  } });
  Object.defineProperty(exports, "enterPassiveModeIPv6", { enumerable: true, get: function() {
    return transfer_12.enterPassiveModeIPv6;
  } });
})(dist$3);
var __importDefault$4 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(ftp$1, "__esModule", { value: true });
ftp$1.ftp = void 0;
const basic_ftp_1 = dist$3;
const stream_1 = require$$1$4;
const path_1 = require$$1$2;
const debug_1$2 = __importDefault$4(srcExports);
const notfound_1 = __importDefault$4(notfound);
const notmodified_1 = __importDefault$4(notmodified);
const debug$3 = (0, debug_1$2.default)("get-uri:ftp");
const ftp = async (url2, opts = {}) => {
  const { cache: cache2 } = opts;
  const filepath = decodeURIComponent(url2.pathname);
  let lastModified;
  if (!filepath) {
    throw new TypeError('No "pathname"!');
  }
  const client = new basic_ftp_1.Client();
  try {
    const host2 = url2.hostname || url2.host || "localhost";
    const port = parseInt(url2.port || "0", 10) || 21;
    const user = url2.username ? decodeURIComponent(url2.username) : void 0;
    const password = url2.password ? decodeURIComponent(url2.password) : void 0;
    await client.access({
      host: host2,
      port,
      user,
      password,
      ...opts
    });
    try {
      lastModified = await client.lastMod(filepath);
    } catch (err) {
      if (err.code === 550) {
        throw new notfound_1.default();
      }
    }
    if (!lastModified) {
      const list = await client.list((0, path_1.dirname)(filepath));
      const name2 = (0, path_1.basename)(filepath);
      const entry = list.find((e) => e.name === name2);
      if (entry) {
        lastModified = entry.modifiedAt;
      }
    }
    if (lastModified) {
      if (isNotModified2()) {
        throw new notmodified_1.default();
      }
    } else {
      throw new notfound_1.default();
    }
    const stream3 = new stream_1.PassThrough();
    const rs = stream3;
    client.downloadTo(stream3, filepath).then((result) => {
      debug$3(result.message);
      client.close();
    });
    rs.lastModified = lastModified;
    return rs;
  } catch (err) {
    client.close();
    throw err;
  }
  function isNotModified2() {
    if ((cache2 == null ? void 0 : cache2.lastModified) && lastModified) {
      return +cache2.lastModified === +lastModified;
    }
    return false;
  }
};
ftp$1.ftp = ftp;
var http$2 = {};
var httpError = {};
Object.defineProperty(httpError, "__esModule", { value: true });
const http_1$1 = require$$0$a;
class HTTPError extends Error {
  constructor(statusCode, message = http_1$1.STATUS_CODES[statusCode]) {
    super(message);
    this.statusCode = statusCode;
    this.code = `E${String(message).toUpperCase().replace(/\s+/g, "")}`;
  }
}
httpError.default = HTTPError;
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.http = void 0;
  const http_12 = __importDefault2(require$$0$a);
  const https_12 = __importDefault2(require$$2$4);
  const events_12 = require$$0$8;
  const debug_12 = __importDefault2(srcExports);
  const http_error_1 = __importDefault2(httpError);
  const notfound_12 = __importDefault2(notfound);
  const notmodified_12 = __importDefault2(notmodified);
  const debug2 = (0, debug_12.default)("get-uri:http");
  const http2 = async (url2, opts = {}) => {
    debug2("GET %o", url2.href);
    const cache2 = getCache(url2, opts.cache);
    if (cache2 && isFresh2(cache2) && typeof cache2.statusCode === "number") {
      const type4 = cache2.statusCode / 100 | 0;
      if (type4 === 3 && cache2.headers.location) {
        debug2("cached redirect");
        throw new Error("TODO: implement cached redirects!");
      }
      throw new notmodified_12.default();
    }
    const maxRedirects = typeof opts.maxRedirects === "number" ? opts.maxRedirects : 5;
    debug2("allowing %o max redirects", maxRedirects);
    let mod;
    if (opts.http) {
      mod = opts.http;
      debug2("using secure `https` core module");
    } else {
      mod = http_12.default;
      debug2("using `http` core module");
    }
    const options = { ...opts };
    if (cache2) {
      if (!options.headers) {
        options.headers = {};
      }
      const lastModified = cache2.headers["last-modified"];
      if (lastModified) {
        options.headers["If-Modified-Since"] = lastModified;
        debug2('added "If-Modified-Since" request header: %o', lastModified);
      }
      const etag3 = cache2.headers.etag;
      if (etag3) {
        options.headers["If-None-Match"] = etag3;
        debug2('added "If-None-Match" request header: %o', etag3);
      }
    }
    const req2 = mod.get(url2, options);
    const [res2] = await (0, events_12.once)(req2, "response");
    const code2 = res2.statusCode || 0;
    res2.date = Date.now();
    res2.parsed = url2;
    debug2("got %o response status code", code2);
    const type3 = code2 / 100 | 0;
    const location2 = res2.headers.location;
    if (type3 === 3 && location2) {
      if (!opts.redirects)
        opts.redirects = [];
      const redirects = opts.redirects;
      if (redirects.length < maxRedirects) {
        debug2('got a "redirect" status code with Location: %o', location2);
        res2.resume();
        redirects.push(res2);
        const newUri = new URL(location2, url2.href);
        debug2("resolved redirect URL: %o", newUri.href);
        const left = maxRedirects - redirects.length;
        debug2("%o more redirects allowed after this one", left);
        if (newUri.protocol !== url2.protocol) {
          opts.http = newUri.protocol === "https:" ? https_12.default : void 0;
        }
        return (0, exports.http)(newUri, opts);
      }
    }
    if (type3 !== 2) {
      res2.resume();
      if (code2 === 304) {
        throw new notmodified_12.default();
      } else if (code2 === 404) {
        throw new notfound_12.default();
      }
      throw new http_error_1.default(code2);
    }
    if (opts.redirects) {
      res2.redirects = opts.redirects;
    }
    return res2;
  };
  exports.http = http2;
  function isFresh2(cache2) {
    let fresh2 = false;
    let expires = parseInt(cache2.headers.expires || "", 10);
    const cacheControl = cache2.headers["cache-control"];
    if (cacheControl) {
      debug2("Cache-Control: %o", cacheControl);
      const parts = cacheControl.split(/,\s*?\b/);
      for (let i = 0; i < parts.length; i++) {
        const part = parts[i];
        const subparts = part.split("=");
        const name2 = subparts[0];
        switch (name2) {
          case "max-age":
            expires = (cache2.date || 0) + parseInt(subparts[1], 10) * 1e3;
            fresh2 = Date.now() < expires;
            if (fresh2) {
              debug2('cache is "fresh" due to previous %o Cache-Control param', part);
            }
            return fresh2;
          case "must-revalidate":
            break;
          case "no-cache":
          case "no-store":
            debug2('cache is "stale" due to explicit %o Cache-Control param', name2);
            return false;
        }
      }
    } else if (expires) {
      debug2("Expires: %o", expires);
      fresh2 = Date.now() < expires;
      if (fresh2) {
        debug2('cache is "fresh" due to previous Expires response header');
      }
      return fresh2;
    }
    return false;
  }
  function getCache(url2, cache2) {
    if (cache2) {
      if (cache2.parsed && cache2.parsed.href === url2.href) {
        return cache2;
      }
      if (cache2.redirects) {
        for (let i = 0; i < cache2.redirects.length; i++) {
          const c = getCache(url2, cache2.redirects[i]);
          if (c) {
            return c;
          }
        }
      }
    }
    return null;
  }
})(http$2);
var https$3 = {};
var __importDefault$3 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(https$3, "__esModule", { value: true });
https$3.https = void 0;
const https_1 = __importDefault$3(require$$2$4);
const http_1 = http$2;
const https$2 = (url2, opts) => {
  return (0, http_1.http)(url2, { ...opts, http: https_1.default });
};
https$3.https = https$2;
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getUri = exports.isValidProtocol = exports.protocols = void 0;
  const debug_12 = __importDefault2(srcExports);
  const data_1 = data$1;
  const file_1 = file$2;
  const ftp_1 = ftp$1;
  const http_12 = http$2;
  const https_12 = https$3;
  const debug2 = (0, debug_12.default)("get-uri");
  exports.protocols = {
    data: data_1.data,
    file: file_1.file,
    ftp: ftp_1.ftp,
    http: http_12.http,
    https: https_12.https
  };
  const VALID_PROTOCOLS = new Set(Object.keys(exports.protocols));
  function isValidProtocol(p) {
    return VALID_PROTOCOLS.has(p);
  }
  exports.isValidProtocol = isValidProtocol;
  async function getUri(uri2, opts) {
    debug2("getUri(%o)", uri2);
    if (!uri2) {
      throw new TypeError('Must pass in a URI to "getUri()"');
    }
    const url2 = typeof uri2 === "string" ? new URL(uri2) : uri2;
    const protocol2 = url2.protocol.replace(/:$/, "");
    if (!isValidProtocol(protocol2)) {
      throw new TypeError(`Unsupported protocol "${protocol2}" specified in URI: "${uri2}"`);
    }
    const getter = exports.protocols[protocol2];
    return getter(url2, opts);
  }
  exports.getUri = getUri;
})(dist$4);
var dist$2 = {};
var dist$1 = {};
var degenerator$1 = {};
var escodegen = {};
var estraverse = {};
(function(exports) {
  (function clone2(exports2) {
    var Syntax, VisitorOption, VisitorKeys, BREAK, SKIP, REMOVE;
    function deepCopy(obj) {
      var ret = {}, key, val;
      for (key in obj) {
        if (obj.hasOwnProperty(key)) {
          val = obj[key];
          if (typeof val === "object" && val !== null) {
            ret[key] = deepCopy(val);
          } else {
            ret[key] = val;
          }
        }
      }
      return ret;
    }
    function upperBound(array2, func) {
      var diff, len, i, current;
      len = array2.length;
      i = 0;
      while (len) {
        diff = len >>> 1;
        current = i + diff;
        if (func(array2[current])) {
          len = diff;
        } else {
          i = current + 1;
          len -= diff + 1;
        }
      }
      return i;
    }
    Syntax = {
      AssignmentExpression: "AssignmentExpression",
      AssignmentPattern: "AssignmentPattern",
      ArrayExpression: "ArrayExpression",
      ArrayPattern: "ArrayPattern",
      ArrowFunctionExpression: "ArrowFunctionExpression",
      AwaitExpression: "AwaitExpression",
      // CAUTION: It's deferred to ES7.
      BlockStatement: "BlockStatement",
      BinaryExpression: "BinaryExpression",
      BreakStatement: "BreakStatement",
      CallExpression: "CallExpression",
      CatchClause: "CatchClause",
      ChainExpression: "ChainExpression",
      ClassBody: "ClassBody",
      ClassDeclaration: "ClassDeclaration",
      ClassExpression: "ClassExpression",
      ComprehensionBlock: "ComprehensionBlock",
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: "ComprehensionExpression",
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: "ConditionalExpression",
      ContinueStatement: "ContinueStatement",
      DebuggerStatement: "DebuggerStatement",
      DirectiveStatement: "DirectiveStatement",
      DoWhileStatement: "DoWhileStatement",
      EmptyStatement: "EmptyStatement",
      ExportAllDeclaration: "ExportAllDeclaration",
      ExportDefaultDeclaration: "ExportDefaultDeclaration",
      ExportNamedDeclaration: "ExportNamedDeclaration",
      ExportSpecifier: "ExportSpecifier",
      ExpressionStatement: "ExpressionStatement",
      ForStatement: "ForStatement",
      ForInStatement: "ForInStatement",
      ForOfStatement: "ForOfStatement",
      FunctionDeclaration: "FunctionDeclaration",
      FunctionExpression: "FunctionExpression",
      GeneratorExpression: "GeneratorExpression",
      // CAUTION: It's deferred to ES7.
      Identifier: "Identifier",
      IfStatement: "IfStatement",
      ImportExpression: "ImportExpression",
      ImportDeclaration: "ImportDeclaration",
      ImportDefaultSpecifier: "ImportDefaultSpecifier",
      ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
      ImportSpecifier: "ImportSpecifier",
      Literal: "Literal",
      LabeledStatement: "LabeledStatement",
      LogicalExpression: "LogicalExpression",
      MemberExpression: "MemberExpression",
      MetaProperty: "MetaProperty",
      MethodDefinition: "MethodDefinition",
      ModuleSpecifier: "ModuleSpecifier",
      NewExpression: "NewExpression",
      ObjectExpression: "ObjectExpression",
      ObjectPattern: "ObjectPattern",
      PrivateIdentifier: "PrivateIdentifier",
      Program: "Program",
      Property: "Property",
      PropertyDefinition: "PropertyDefinition",
      RestElement: "RestElement",
      ReturnStatement: "ReturnStatement",
      SequenceExpression: "SequenceExpression",
      SpreadElement: "SpreadElement",
      Super: "Super",
      SwitchStatement: "SwitchStatement",
      SwitchCase: "SwitchCase",
      TaggedTemplateExpression: "TaggedTemplateExpression",
      TemplateElement: "TemplateElement",
      TemplateLiteral: "TemplateLiteral",
      ThisExpression: "ThisExpression",
      ThrowStatement: "ThrowStatement",
      TryStatement: "TryStatement",
      UnaryExpression: "UnaryExpression",
      UpdateExpression: "UpdateExpression",
      VariableDeclaration: "VariableDeclaration",
      VariableDeclarator: "VariableDeclarator",
      WhileStatement: "WhileStatement",
      WithStatement: "WithStatement",
      YieldExpression: "YieldExpression"
    };
    VisitorKeys = {
      AssignmentExpression: ["left", "right"],
      AssignmentPattern: ["left", "right"],
      ArrayExpression: ["elements"],
      ArrayPattern: ["elements"],
      ArrowFunctionExpression: ["params", "body"],
      AwaitExpression: ["argument"],
      // CAUTION: It's deferred to ES7.
      BlockStatement: ["body"],
      BinaryExpression: ["left", "right"],
      BreakStatement: ["label"],
      CallExpression: ["callee", "arguments"],
      CatchClause: ["param", "body"],
      ChainExpression: ["expression"],
      ClassBody: ["body"],
      ClassDeclaration: ["id", "superClass", "body"],
      ClassExpression: ["id", "superClass", "body"],
      ComprehensionBlock: ["left", "right"],
      // CAUTION: It's deferred to ES7.
      ComprehensionExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      ConditionalExpression: ["test", "consequent", "alternate"],
      ContinueStatement: ["label"],
      DebuggerStatement: [],
      DirectiveStatement: [],
      DoWhileStatement: ["body", "test"],
      EmptyStatement: [],
      ExportAllDeclaration: ["source"],
      ExportDefaultDeclaration: ["declaration"],
      ExportNamedDeclaration: ["declaration", "specifiers", "source"],
      ExportSpecifier: ["exported", "local"],
      ExpressionStatement: ["expression"],
      ForStatement: ["init", "test", "update", "body"],
      ForInStatement: ["left", "right", "body"],
      ForOfStatement: ["left", "right", "body"],
      FunctionDeclaration: ["id", "params", "body"],
      FunctionExpression: ["id", "params", "body"],
      GeneratorExpression: ["blocks", "filter", "body"],
      // CAUTION: It's deferred to ES7.
      Identifier: [],
      IfStatement: ["test", "consequent", "alternate"],
      ImportExpression: ["source"],
      ImportDeclaration: ["specifiers", "source"],
      ImportDefaultSpecifier: ["local"],
      ImportNamespaceSpecifier: ["local"],
      ImportSpecifier: ["imported", "local"],
      Literal: [],
      LabeledStatement: ["label", "body"],
      LogicalExpression: ["left", "right"],
      MemberExpression: ["object", "property"],
      MetaProperty: ["meta", "property"],
      MethodDefinition: ["key", "value"],
      ModuleSpecifier: [],
      NewExpression: ["callee", "arguments"],
      ObjectExpression: ["properties"],
      ObjectPattern: ["properties"],
      PrivateIdentifier: [],
      Program: ["body"],
      Property: ["key", "value"],
      PropertyDefinition: ["key", "value"],
      RestElement: ["argument"],
      ReturnStatement: ["argument"],
      SequenceExpression: ["expressions"],
      SpreadElement: ["argument"],
      Super: [],
      SwitchStatement: ["discriminant", "cases"],
      SwitchCase: ["test", "consequent"],
      TaggedTemplateExpression: ["tag", "quasi"],
      TemplateElement: [],
      TemplateLiteral: ["quasis", "expressions"],
      ThisExpression: [],
      ThrowStatement: ["argument"],
      TryStatement: ["block", "handler", "finalizer"],
      UnaryExpression: ["argument"],
      UpdateExpression: ["argument"],
      VariableDeclaration: ["declarations"],
      VariableDeclarator: ["id", "init"],
      WhileStatement: ["test", "body"],
      WithStatement: ["object", "body"],
      YieldExpression: ["argument"]
    };
    BREAK = {};
    SKIP = {};
    REMOVE = {};
    VisitorOption = {
      Break: BREAK,
      Skip: SKIP,
      Remove: REMOVE
    };
    function Reference(parent, key) {
      this.parent = parent;
      this.key = key;
    }
    Reference.prototype.replace = function replace2(node2) {
      this.parent[this.key] = node2;
    };
    Reference.prototype.remove = function remove2() {
      if (Array.isArray(this.parent)) {
        this.parent.splice(this.key, 1);
        return true;
      } else {
        this.replace(null);
        return false;
      }
    };
    function Element(node2, path3, wrap2, ref2) {
      this.node = node2;
      this.path = path3;
      this.wrap = wrap2;
      this.ref = ref2;
    }
    function Controller() {
    }
    Controller.prototype.path = function path3() {
      var i, iz, j2, jz, result, element;
      function addToPath(result2, path4) {
        if (Array.isArray(path4)) {
          for (j2 = 0, jz = path4.length; j2 < jz; ++j2) {
            result2.push(path4[j2]);
          }
        } else {
          result2.push(path4);
        }
      }
      if (!this.__current.path) {
        return null;
      }
      result = [];
      for (i = 2, iz = this.__leavelist.length; i < iz; ++i) {
        element = this.__leavelist[i];
        addToPath(result, element.path);
      }
      addToPath(result, this.__current.path);
      return result;
    };
    Controller.prototype.type = function() {
      var node2 = this.current();
      return node2.type || this.__current.wrap;
    };
    Controller.prototype.parents = function parents() {
      var i, iz, result;
      result = [];
      for (i = 1, iz = this.__leavelist.length; i < iz; ++i) {
        result.push(this.__leavelist[i].node);
      }
      return result;
    };
    Controller.prototype.current = function current() {
      return this.__current.node;
    };
    Controller.prototype.__execute = function __execute(callback, element) {
      var previous, result;
      result = void 0;
      previous = this.__current;
      this.__current = element;
      this.__state = null;
      if (callback) {
        result = callback.call(this, element.node, this.__leavelist[this.__leavelist.length - 1].node);
      }
      this.__current = previous;
      return result;
    };
    Controller.prototype.notify = function notify(flag) {
      this.__state = flag;
    };
    Controller.prototype.skip = function() {
      this.notify(SKIP);
    };
    Controller.prototype["break"] = function() {
      this.notify(BREAK);
    };
    Controller.prototype.remove = function() {
      this.notify(REMOVE);
    };
    Controller.prototype.__initialize = function(root2, visitor) {
      this.visitor = visitor;
      this.root = root2;
      this.__worklist = [];
      this.__leavelist = [];
      this.__current = null;
      this.__state = null;
      this.__fallback = null;
      if (visitor.fallback === "iteration") {
        this.__fallback = Object.keys;
      } else if (typeof visitor.fallback === "function") {
        this.__fallback = visitor.fallback;
      }
      this.__keys = VisitorKeys;
      if (visitor.keys) {
        this.__keys = Object.assign(Object.create(this.__keys), visitor.keys);
      }
    };
    function isNode(node2) {
      if (node2 == null) {
        return false;
      }
      return typeof node2 === "object" && typeof node2.type === "string";
    }
    function isProperty(nodeType, key) {
      return (nodeType === Syntax.ObjectExpression || nodeType === Syntax.ObjectPattern) && "properties" === key;
    }
    function candidateExistsInLeaveList(leavelist, candidate) {
      for (var i = leavelist.length - 1; i >= 0; --i) {
        if (leavelist[i].node === candidate) {
          return true;
        }
      }
      return false;
    }
    Controller.prototype.traverse = function traverse2(root2, visitor) {
      var worklist, leavelist, element, node2, nodeType, ret, key, current, current2, candidates, candidate, sentinel;
      this.__initialize(root2, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      worklist.push(new Element(root2, null, null, null));
      leavelist.push(new Element(null, null, null, null));
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          ret = this.__execute(visitor.leave, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          continue;
        }
        if (element.node) {
          ret = this.__execute(visitor.enter, element);
          if (this.__state === BREAK || ret === BREAK) {
            return;
          }
          worklist.push(sentinel);
          leavelist.push(element);
          if (this.__state === SKIP || ret === SKIP) {
            continue;
          }
          node2 = element.node;
          nodeType = node2.type || element.wrap;
          candidates = this.__keys[nodeType];
          if (!candidates) {
            if (this.__fallback) {
              candidates = this.__fallback(node2);
            } else {
              throw new Error("Unknown node type " + nodeType + ".");
            }
          }
          current = candidates.length;
          while ((current -= 1) >= 0) {
            key = candidates[current];
            candidate = node2[key];
            if (!candidate) {
              continue;
            }
            if (Array.isArray(candidate)) {
              current2 = candidate.length;
              while ((current2 -= 1) >= 0) {
                if (!candidate[current2]) {
                  continue;
                }
                if (candidateExistsInLeaveList(leavelist, candidate[current2])) {
                  continue;
                }
                if (isProperty(nodeType, candidates[current])) {
                  element = new Element(candidate[current2], [key, current2], "Property", null);
                } else if (isNode(candidate[current2])) {
                  element = new Element(candidate[current2], [key, current2], null, null);
                } else {
                  continue;
                }
                worklist.push(element);
              }
            } else if (isNode(candidate)) {
              if (candidateExistsInLeaveList(leavelist, candidate)) {
                continue;
              }
              worklist.push(new Element(candidate, key, null, null));
            }
          }
        }
      }
    };
    Controller.prototype.replace = function replace2(root2, visitor) {
      var worklist, leavelist, node2, nodeType, target, element, current, current2, candidates, candidate, sentinel, outer, key;
      function removeElem(element2) {
        var i, key2, nextElem, parent;
        if (element2.ref.remove()) {
          key2 = element2.ref.key;
          parent = element2.ref.parent;
          i = worklist.length;
          while (i--) {
            nextElem = worklist[i];
            if (nextElem.ref && nextElem.ref.parent === parent) {
              if (nextElem.ref.key < key2) {
                break;
              }
              --nextElem.ref.key;
            }
          }
        }
      }
      this.__initialize(root2, visitor);
      sentinel = {};
      worklist = this.__worklist;
      leavelist = this.__leavelist;
      outer = {
        root: root2
      };
      element = new Element(root2, null, null, new Reference(outer, "root"));
      worklist.push(element);
      leavelist.push(element);
      while (worklist.length) {
        element = worklist.pop();
        if (element === sentinel) {
          element = leavelist.pop();
          target = this.__execute(visitor.leave, element);
          if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
            element.ref.replace(target);
          }
          if (this.__state === REMOVE || target === REMOVE) {
            removeElem(element);
          }
          if (this.__state === BREAK || target === BREAK) {
            return outer.root;
          }
          continue;
        }
        target = this.__execute(visitor.enter, element);
        if (target !== void 0 && target !== BREAK && target !== SKIP && target !== REMOVE) {
          element.ref.replace(target);
          element.node = target;
        }
        if (this.__state === REMOVE || target === REMOVE) {
          removeElem(element);
          element.node = null;
        }
        if (this.__state === BREAK || target === BREAK) {
          return outer.root;
        }
        node2 = element.node;
        if (!node2) {
          continue;
        }
        worklist.push(sentinel);
        leavelist.push(element);
        if (this.__state === SKIP || target === SKIP) {
          continue;
        }
        nodeType = node2.type || element.wrap;
        candidates = this.__keys[nodeType];
        if (!candidates) {
          if (this.__fallback) {
            candidates = this.__fallback(node2);
          } else {
            throw new Error("Unknown node type " + nodeType + ".");
          }
        }
        current = candidates.length;
        while ((current -= 1) >= 0) {
          key = candidates[current];
          candidate = node2[key];
          if (!candidate) {
            continue;
          }
          if (Array.isArray(candidate)) {
            current2 = candidate.length;
            while ((current2 -= 1) >= 0) {
              if (!candidate[current2]) {
                continue;
              }
              if (isProperty(nodeType, candidates[current])) {
                element = new Element(candidate[current2], [key, current2], "Property", new Reference(candidate, current2));
              } else if (isNode(candidate[current2])) {
                element = new Element(candidate[current2], [key, current2], null, new Reference(candidate, current2));
              } else {
                continue;
              }
              worklist.push(element);
            }
          } else if (isNode(candidate)) {
            worklist.push(new Element(candidate, key, null, new Reference(node2, key)));
          }
        }
      }
      return outer.root;
    };
    function traverse(root2, visitor) {
      var controller = new Controller();
      return controller.traverse(root2, visitor);
    }
    function replace(root2, visitor) {
      var controller = new Controller();
      return controller.replace(root2, visitor);
    }
    function extendCommentRange(comment, tokens) {
      var target;
      target = upperBound(tokens, function search(token) {
        return token.range[0] > comment.range[0];
      });
      comment.extendedRange = [comment.range[0], comment.range[1]];
      if (target !== tokens.length) {
        comment.extendedRange[1] = tokens[target].range[0];
      }
      target -= 1;
      if (target >= 0) {
        comment.extendedRange[0] = tokens[target].range[1];
      }
      return comment;
    }
    function attachComments(tree, providedComments, tokens) {
      var comments = [], comment, len, i, cursor;
      if (!tree.range) {
        throw new Error("attachComments needs range information");
      }
      if (!tokens.length) {
        if (providedComments.length) {
          for (i = 0, len = providedComments.length; i < len; i += 1) {
            comment = deepCopy(providedComments[i]);
            comment.extendedRange = [0, tree.range[0]];
            comments.push(comment);
          }
          tree.leadingComments = comments;
        }
        return tree;
      }
      for (i = 0, len = providedComments.length; i < len; i += 1) {
        comments.push(extendCommentRange(deepCopy(providedComments[i]), tokens));
      }
      cursor = 0;
      traverse(tree, {
        enter: function(node2) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (comment2.extendedRange[1] > node2.range[0]) {
              break;
            }
            if (comment2.extendedRange[1] === node2.range[0]) {
              if (!node2.leadingComments) {
                node2.leadingComments = [];
              }
              node2.leadingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node2.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      cursor = 0;
      traverse(tree, {
        leave: function(node2) {
          var comment2;
          while (cursor < comments.length) {
            comment2 = comments[cursor];
            if (node2.range[1] < comment2.extendedRange[0]) {
              break;
            }
            if (node2.range[1] === comment2.extendedRange[0]) {
              if (!node2.trailingComments) {
                node2.trailingComments = [];
              }
              node2.trailingComments.push(comment2);
              comments.splice(cursor, 1);
            } else {
              cursor += 1;
            }
          }
          if (cursor === comments.length) {
            return VisitorOption.Break;
          }
          if (comments[cursor].extendedRange[0] > node2.range[1]) {
            return VisitorOption.Skip;
          }
        }
      });
      return tree;
    }
    exports2.Syntax = Syntax;
    exports2.traverse = traverse;
    exports2.replace = replace;
    exports2.attachComments = attachComments;
    exports2.VisitorKeys = VisitorKeys;
    exports2.VisitorOption = VisitorOption;
    exports2.Controller = Controller;
    exports2.cloneEnvironment = function() {
      return clone2({});
    };
    return exports2;
  })(exports);
})(estraverse);
var utils$1 = {};
var ast = { exports: {} };
(function() {
  function isExpression(node2) {
    if (node2 == null) {
      return false;
    }
    switch (node2.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "Literal":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
        return true;
    }
    return false;
  }
  function isIterationStatement(node2) {
    if (node2 == null) {
      return false;
    }
    switch (node2.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
        return true;
    }
    return false;
  }
  function isStatement(node2) {
    if (node2 == null) {
      return false;
    }
    switch (node2.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
        return true;
    }
    return false;
  }
  function isSourceElement(node2) {
    return isStatement(node2) || node2 != null && node2.type === "FunctionDeclaration";
  }
  function trailingStatement(node2) {
    switch (node2.type) {
      case "IfStatement":
        if (node2.alternate != null) {
          return node2.alternate;
        }
        return node2.consequent;
      case "LabeledStatement":
      case "ForStatement":
      case "ForInStatement":
      case "WhileStatement":
      case "WithStatement":
        return node2.body;
    }
    return null;
  }
  function isProblematicIfStatement(node2) {
    var current;
    if (node2.type !== "IfStatement") {
      return false;
    }
    if (node2.alternate == null) {
      return false;
    }
    current = node2.consequent;
    do {
      if (current.type === "IfStatement") {
        if (current.alternate == null) {
          return true;
        }
      }
      current = trailingStatement(current);
    } while (current);
    return false;
  }
  ast.exports = {
    isExpression,
    isStatement,
    isIterationStatement,
    isSourceElement,
    isProblematicIfStatement,
    trailingStatement
  };
})();
var astExports = ast.exports;
var code = { exports: {} };
(function() {
  var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch;
  ES5Regex = {
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
    // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
  };
  ES6Regex = {
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
    // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
  };
  function isDecimalDigit(ch2) {
    return 48 <= ch2 && ch2 <= 57;
  }
  function isHexDigit(ch2) {
    return 48 <= ch2 && ch2 <= 57 || // 0..9
    97 <= ch2 && ch2 <= 102 || // a..f
    65 <= ch2 && ch2 <= 70;
  }
  function isOctalDigit(ch2) {
    return ch2 >= 48 && ch2 <= 55;
  }
  NON_ASCII_WHITESPACES = [
    5760,
    8192,
    8193,
    8194,
    8195,
    8196,
    8197,
    8198,
    8199,
    8200,
    8201,
    8202,
    8239,
    8287,
    12288,
    65279
  ];
  function isWhiteSpace(ch2) {
    return ch2 === 32 || ch2 === 9 || ch2 === 11 || ch2 === 12 || ch2 === 160 || ch2 >= 5760 && NON_ASCII_WHITESPACES.indexOf(ch2) >= 0;
  }
  function isLineTerminator(ch2) {
    return ch2 === 10 || ch2 === 13 || ch2 === 8232 || ch2 === 8233;
  }
  function fromCodePoint(cp) {
    if (cp <= 65535) {
      return String.fromCharCode(cp);
    }
    var cu1 = String.fromCharCode(Math.floor((cp - 65536) / 1024) + 55296);
    var cu2 = String.fromCharCode((cp - 65536) % 1024 + 56320);
    return cu1 + cu2;
  }
  IDENTIFIER_START = new Array(128);
  for (ch = 0; ch < 128; ++ch) {
    IDENTIFIER_START[ch] = ch >= 97 && ch <= 122 || // a..z
    ch >= 65 && ch <= 90 || // A..Z
    ch === 36 || ch === 95;
  }
  IDENTIFIER_PART = new Array(128);
  for (ch = 0; ch < 128; ++ch) {
    IDENTIFIER_PART[ch] = ch >= 97 && ch <= 122 || // a..z
    ch >= 65 && ch <= 90 || // A..Z
    ch >= 48 && ch <= 57 || // 0..9
    ch === 36 || ch === 95;
  }
  function isIdentifierStartES5(ch2) {
    return ch2 < 128 ? IDENTIFIER_START[ch2] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
  }
  function isIdentifierPartES5(ch2) {
    return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
  }
  function isIdentifierStartES6(ch2) {
    return ch2 < 128 ? IDENTIFIER_START[ch2] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch2));
  }
  function isIdentifierPartES6(ch2) {
    return ch2 < 128 ? IDENTIFIER_PART[ch2] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch2));
  }
  code.exports = {
    isDecimalDigit,
    isHexDigit,
    isOctalDigit,
    isWhiteSpace,
    isLineTerminator,
    isIdentifierStartES5,
    isIdentifierPartES5,
    isIdentifierStartES6,
    isIdentifierPartES6
  };
})();
var codeExports = code.exports;
var keyword = { exports: {} };
(function() {
  var code2 = codeExports;
  function isStrictModeReservedWordES6(id) {
    switch (id) {
      case "implements":
      case "interface":
      case "package":
      case "private":
      case "protected":
      case "public":
      case "static":
      case "let":
        return true;
      default:
        return false;
    }
  }
  function isKeywordES5(id, strict) {
    if (!strict && id === "yield") {
      return false;
    }
    return isKeywordES6(id, strict);
  }
  function isKeywordES6(id, strict) {
    if (strict && isStrictModeReservedWordES6(id)) {
      return true;
    }
    switch (id.length) {
      case 2:
        return id === "if" || id === "in" || id === "do";
      case 3:
        return id === "var" || id === "for" || id === "new" || id === "try";
      case 4:
        return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
      case 5:
        return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
      case 6:
        return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
      case 7:
        return id === "default" || id === "finally" || id === "extends";
      case 8:
        return id === "function" || id === "continue" || id === "debugger";
      case 10:
        return id === "instanceof";
      default:
        return false;
    }
  }
  function isReservedWordES5(id, strict) {
    return id === "null" || id === "true" || id === "false" || isKeywordES5(id, strict);
  }
  function isReservedWordES6(id, strict) {
    return id === "null" || id === "true" || id === "false" || isKeywordES6(id, strict);
  }
  function isRestrictedWord(id) {
    return id === "eval" || id === "arguments";
  }
  function isIdentifierNameES5(id) {
    var i, iz, ch;
    if (id.length === 0) {
      return false;
    }
    ch = id.charCodeAt(0);
    if (!code2.isIdentifierStartES5(ch)) {
      return false;
    }
    for (i = 1, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);
      if (!code2.isIdentifierPartES5(ch)) {
        return false;
      }
    }
    return true;
  }
  function decodeUtf16(lead, trail) {
    return (lead - 55296) * 1024 + (trail - 56320) + 65536;
  }
  function isIdentifierNameES6(id) {
    var i, iz, ch, lowCh, check;
    if (id.length === 0) {
      return false;
    }
    check = code2.isIdentifierStartES6;
    for (i = 0, iz = id.length; i < iz; ++i) {
      ch = id.charCodeAt(i);
      if (55296 <= ch && ch <= 56319) {
        ++i;
        if (i >= iz) {
          return false;
        }
        lowCh = id.charCodeAt(i);
        if (!(56320 <= lowCh && lowCh <= 57343)) {
          return false;
        }
        ch = decodeUtf16(ch, lowCh);
      }
      if (!check(ch)) {
        return false;
      }
      check = code2.isIdentifierPartES6;
    }
    return true;
  }
  function isIdentifierES5(id, strict) {
    return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
  }
  function isIdentifierES6(id, strict) {
    return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
  }
  keyword.exports = {
    isKeywordES5,
    isKeywordES6,
    isReservedWordES5,
    isReservedWordES6,
    isRestrictedWord,
    isIdentifierNameES5,
    isIdentifierNameES6,
    isIdentifierES5,
    isIdentifierES6
  };
})();
var keywordExports = keyword.exports;
(function() {
  utils$1.ast = astExports;
  utils$1.code = codeExports;
  utils$1.keyword = keywordExports;
})();
var sourceMap = {};
var sourceMapGenerator = {};
var base64Vlq = {};
var base64 = {};
var hasRequiredBase64;
function requireBase64() {
  if (hasRequiredBase64) return base64;
  hasRequiredBase64 = 1;
  var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
  base64.encode = function(number) {
    if (0 <= number && number < intToCharMap.length) {
      return intToCharMap[number];
    }
    throw new TypeError("Must be between 0 and 63: " + number);
  };
  base64.decode = function(charCode) {
    var bigA = 65;
    var bigZ = 90;
    var littleA = 97;
    var littleZ = 122;
    var zero = 48;
    var nine = 57;
    var plus = 43;
    var slash = 47;
    var littleOffset = 26;
    var numberOffset = 52;
    if (bigA <= charCode && charCode <= bigZ) {
      return charCode - bigA;
    }
    if (littleA <= charCode && charCode <= littleZ) {
      return charCode - littleA + littleOffset;
    }
    if (zero <= charCode && charCode <= nine) {
      return charCode - zero + numberOffset;
    }
    if (charCode == plus) {
      return 62;
    }
    if (charCode == slash) {
      return 63;
    }
    return -1;
  };
  return base64;
}
var hasRequiredBase64Vlq;
function requireBase64Vlq() {
  if (hasRequiredBase64Vlq) return base64Vlq;
  hasRequiredBase64Vlq = 1;
  var base642 = requireBase64();
  var VLQ_BASE_SHIFT = 5;
  var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
  var VLQ_BASE_MASK = VLQ_BASE - 1;
  var VLQ_CONTINUATION_BIT = VLQ_BASE;
  function toVLQSigned(aValue) {
    return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
  }
  function fromVLQSigned(aValue) {
    var isNegative = (aValue & 1) === 1;
    var shifted = aValue >> 1;
    return isNegative ? -shifted : shifted;
  }
  base64Vlq.encode = function base64VLQ_encode(aValue) {
    var encoded = "";
    var digit;
    var vlq = toVLQSigned(aValue);
    do {
      digit = vlq & VLQ_BASE_MASK;
      vlq >>>= VLQ_BASE_SHIFT;
      if (vlq > 0) {
        digit |= VLQ_CONTINUATION_BIT;
      }
      encoded += base642.encode(digit);
    } while (vlq > 0);
    return encoded;
  };
  base64Vlq.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
    var strLen = aStr.length;
    var result = 0;
    var shift = 0;
    var continuation, digit;
    do {
      if (aIndex >= strLen) {
        throw new Error("Expected more digits in base 64 VLQ value.");
      }
      digit = base642.decode(aStr.charCodeAt(aIndex++));
      if (digit === -1) {
        throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
      }
      continuation = !!(digit & VLQ_CONTINUATION_BIT);
      digit &= VLQ_BASE_MASK;
      result = result + (digit << shift);
      shift += VLQ_BASE_SHIFT;
    } while (continuation);
    aOutParam.value = fromVLQSigned(result);
    aOutParam.rest = aIndex;
  };
  return base64Vlq;
}
var util$3 = {};
var hasRequiredUtil;
function requireUtil() {
  if (hasRequiredUtil) return util$3;
  hasRequiredUtil = 1;
  (function(exports) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match2 = aUrl.match(urlRegexp);
      if (!match2) {
        return null;
      }
      return {
        scheme: match2[1],
        auth: match2[2],
        host: match2[3],
        port: match2[4],
        path: match2[5]
      };
    }
    exports.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url2 = "";
      if (aParsedUrl.scheme) {
        url2 += aParsedUrl.scheme + ":";
      }
      url2 += "//";
      if (aParsedUrl.auth) {
        url2 += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url2 += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url2 += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url2 += aParsedUrl.path;
      }
      return url2;
    }
    exports.urlGenerate = urlGenerate;
    function normalize2(aPath) {
      var path3 = aPath;
      var url2 = urlParse(aPath);
      if (url2) {
        if (!url2.path) {
          return aPath;
        }
        path3 = url2.path;
      }
      var isAbsolute2 = exports.isAbsolute(path3);
      var parts = path3.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path3 = parts.join("/");
      if (path3 === "") {
        path3 = isAbsolute2 ? "/" : ".";
      }
      if (url2) {
        url2.path = path3;
        return urlGenerate(url2);
      }
      return path3;
    }
    exports.normalize = normalize2;
    function join2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize2(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports.join = join2;
    exports.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative2(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index2 = aRoot.lastIndexOf("/");
        if (index2 < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index2);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports.relative = relative2;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s2) {
      return s2;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s2) {
      if (!s2) {
        return false;
      }
      var length = s2.length;
      if (length < 9) {
        return false;
      }
      if (s2.charCodeAt(length - 1) !== 95 || s2.charCodeAt(length - 2) !== 95 || s2.charCodeAt(length - 3) !== 111 || s2.charCodeAt(length - 4) !== 116 || s2.charCodeAt(length - 5) !== 111 || s2.charCodeAt(length - 6) !== 114 || s2.charCodeAt(length - 7) !== 112 || s2.charCodeAt(length - 8) !== 95 || s2.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s2.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str2) {
      return JSON.parse(str2.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index2 = parsed.path.lastIndexOf("/");
          if (index2 >= 0) {
            parsed.path = parsed.path.substring(0, index2 + 1);
          }
        }
        sourceURL = join2(urlGenerate(parsed), sourceURL);
      }
      return normalize2(sourceURL);
    }
    exports.computeSourceURL = computeSourceURL;
  })(util$3);
  return util$3;
}
var arraySet = {};
var hasRequiredArraySet;
function requireArraySet() {
  if (hasRequiredArraySet) return arraySet;
  hasRequiredArraySet = 1;
  var util2 = requireUtil();
  var has = Object.prototype.hasOwnProperty;
  var hasNativeMap = typeof Map !== "undefined";
  function ArraySet() {
    this._array = [];
    this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
  }
  ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
    var set = new ArraySet();
    for (var i = 0, len = aArray.length; i < len; i++) {
      set.add(aArray[i], aAllowDuplicates);
    }
    return set;
  };
  ArraySet.prototype.size = function ArraySet_size() {
    return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
  };
  ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
    var sStr = hasNativeMap ? aStr : util2.toSetString(aStr);
    var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
    var idx = this._array.length;
    if (!isDuplicate || aAllowDuplicates) {
      this._array.push(aStr);
    }
    if (!isDuplicate) {
      if (hasNativeMap) {
        this._set.set(aStr, idx);
      } else {
        this._set[sStr] = idx;
      }
    }
  };
  ArraySet.prototype.has = function ArraySet_has(aStr) {
    if (hasNativeMap) {
      return this._set.has(aStr);
    } else {
      var sStr = util2.toSetString(aStr);
      return has.call(this._set, sStr);
    }
  };
  ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
    if (hasNativeMap) {
      var idx = this._set.get(aStr);
      if (idx >= 0) {
        return idx;
      }
    } else {
      var sStr = util2.toSetString(aStr);
      if (has.call(this._set, sStr)) {
        return this._set[sStr];
      }
    }
    throw new Error('"' + aStr + '" is not in the set.');
  };
  ArraySet.prototype.at = function ArraySet_at(aIdx) {
    if (aIdx >= 0 && aIdx < this._array.length) {
      return this._array[aIdx];
    }
    throw new Error("No element indexed by " + aIdx);
  };
  ArraySet.prototype.toArray = function ArraySet_toArray() {
    return this._array.slice();
  };
  arraySet.ArraySet = ArraySet;
  return arraySet;
}
var mappingList = {};
var hasRequiredMappingList;
function requireMappingList() {
  if (hasRequiredMappingList) return mappingList;
  hasRequiredMappingList = 1;
  var util2 = requireUtil();
  function generatedPositionAfter(mappingA, mappingB) {
    var lineA = mappingA.generatedLine;
    var lineB = mappingB.generatedLine;
    var columnA = mappingA.generatedColumn;
    var columnB = mappingB.generatedColumn;
    return lineB > lineA || lineB == lineA && columnB >= columnA || util2.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
  }
  function MappingList() {
    this._array = [];
    this._sorted = true;
    this._last = { generatedLine: -1, generatedColumn: 0 };
  }
  MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };
  MappingList.prototype.add = function MappingList_add(aMapping) {
    if (generatedPositionAfter(this._last, aMapping)) {
      this._last = aMapping;
      this._array.push(aMapping);
    } else {
      this._sorted = false;
      this._array.push(aMapping);
    }
  };
  MappingList.prototype.toArray = function MappingList_toArray() {
    if (!this._sorted) {
      this._array.sort(util2.compareByGeneratedPositionsInflated);
      this._sorted = true;
    }
    return this._array;
  };
  mappingList.MappingList = MappingList;
  return mappingList;
}
var hasRequiredSourceMapGenerator;
function requireSourceMapGenerator() {
  if (hasRequiredSourceMapGenerator) return sourceMapGenerator;
  hasRequiredSourceMapGenerator = 1;
  var base64VLQ = requireBase64Vlq();
  var util2 = requireUtil();
  var ArraySet = requireArraySet().ArraySet;
  var MappingList = requireMappingList().MappingList;
  function SourceMapGenerator(aArgs) {
    if (!aArgs) {
      aArgs = {};
    }
    this._file = util2.getArg(aArgs, "file", null);
    this._sourceRoot = util2.getArg(aArgs, "sourceRoot", null);
    this._skipValidation = util2.getArg(aArgs, "skipValidation", false);
    this._sources = new ArraySet();
    this._names = new ArraySet();
    this._mappings = new MappingList();
    this._sourcesContents = null;
  }
  SourceMapGenerator.prototype._version = 3;
  SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot
    });
    aSourceMapConsumer.eachMapping(function(mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };
      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util2.relative(sourceRoot, newMapping.source);
        }
        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };
        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }
      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util2.relative(sourceRoot, sourceFile);
      }
      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };
  SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
    var generated = util2.getArg(aArgs, "generated");
    var original = util2.getArg(aArgs, "original", null);
    var source = util2.getArg(aArgs, "source", null);
    var name2 = util2.getArg(aArgs, "name", null);
    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name2);
    }
    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }
    if (name2 != null) {
      name2 = String(name2);
      if (!this._names.has(name2)) {
        this._names.add(name2);
      }
    }
    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source,
      name: name2
    });
  };
  SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util2.relative(this._sourceRoot, source);
    }
    if (aSourceContent != null) {
      if (!this._sourcesContents) {
        this._sourcesContents = /* @__PURE__ */ Object.create(null);
      }
      this._sourcesContents[util2.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      delete this._sourcesContents[util2.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };
  SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    if (sourceRoot != null) {
      sourceFile = util2.relative(sourceRoot, sourceFile);
    }
    var newSources = new ArraySet();
    var newNames = new ArraySet();
    this._mappings.unsortedForEach(function(mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util2.join(aSourceMapPath, mapping.source);
          }
          if (sourceRoot != null) {
            mapping.source = util2.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }
      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }
      var name2 = mapping.name;
      if (name2 != null && !newNames.has(name2)) {
        newNames.add(name2);
      }
    }, this);
    this._sources = newSources;
    this._names = newNames;
    aSourceMapConsumer.sources.forEach(function(sourceFile2) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile2 = util2.join(aSourceMapPath, sourceFile2);
        }
        if (sourceRoot != null) {
          sourceFile2 = util2.relative(sourceRoot, sourceFile2);
        }
        this.setSourceContent(sourceFile2, content);
      }
    }, this);
  };
  SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
    if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
      throw new Error(
        "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
      );
    }
    if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
      return;
    } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
      return;
    } else {
      throw new Error("Invalid mapping: " + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };
  SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = "";
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;
    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = "";
      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ";";
          previousGeneratedLine++;
        }
      } else {
        if (i > 0) {
          if (!util2.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ",";
        }
      }
      next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;
      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;
        next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;
        next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;
        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }
      result += next;
    }
    return result;
  };
  SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function(source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util2.relative(aSourceRoot, source);
      }
      var key = util2.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
    }, this);
  };
  SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
    var map2 = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map2.file = this._file;
    }
    if (this._sourceRoot != null) {
      map2.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map2.sourcesContent = this._generateSourcesContent(map2.sources, map2.sourceRoot);
    }
    return map2;
  };
  SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };
  sourceMapGenerator.SourceMapGenerator = SourceMapGenerator;
  return sourceMapGenerator;
}
var sourceMapConsumer = {};
var binarySearch = {};
var hasRequiredBinarySearch;
function requireBinarySearch() {
  if (hasRequiredBinarySearch) return binarySearch;
  hasRequiredBinarySearch = 1;
  (function(exports) {
    exports.GREATEST_LOWER_BOUND = 1;
    exports.LEAST_UPPER_BOUND = 2;
    function recursiveSearch(aLow, aHigh, aNeedle, aHaystack, aCompare, aBias) {
      var mid = Math.floor((aHigh - aLow) / 2) + aLow;
      var cmp = aCompare(aNeedle, aHaystack[mid], true);
      if (cmp === 0) {
        return mid;
      } else if (cmp > 0) {
        if (aHigh - mid > 1) {
          return recursiveSearch(mid, aHigh, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return aHigh < aHaystack.length ? aHigh : -1;
        } else {
          return mid;
        }
      } else {
        if (mid - aLow > 1) {
          return recursiveSearch(aLow, mid, aNeedle, aHaystack, aCompare, aBias);
        }
        if (aBias == exports.LEAST_UPPER_BOUND) {
          return mid;
        } else {
          return aLow < 0 ? -1 : aLow;
        }
      }
    }
    exports.search = function search(aNeedle, aHaystack, aCompare, aBias) {
      if (aHaystack.length === 0) {
        return -1;
      }
      var index2 = recursiveSearch(
        -1,
        aHaystack.length,
        aNeedle,
        aHaystack,
        aCompare,
        aBias || exports.GREATEST_LOWER_BOUND
      );
      if (index2 < 0) {
        return -1;
      }
      while (index2 - 1 >= 0) {
        if (aCompare(aHaystack[index2], aHaystack[index2 - 1], true) !== 0) {
          break;
        }
        --index2;
      }
      return index2;
    };
  })(binarySearch);
  return binarySearch;
}
var quickSort = {};
var hasRequiredQuickSort;
function requireQuickSort() {
  if (hasRequiredQuickSort) return quickSort;
  hasRequiredQuickSort = 1;
  function swap(ary, x, y2) {
    var temp = ary[x];
    ary[x] = ary[y2];
    ary[y2] = temp;
  }
  function randomIntInRange(low, high) {
    return Math.round(low + Math.random() * (high - low));
  }
  function doQuickSort(ary, comparator, p, r) {
    if (p < r) {
      var pivotIndex = randomIntInRange(p, r);
      var i = p - 1;
      swap(ary, pivotIndex, r);
      var pivot = ary[r];
      for (var j2 = p; j2 < r; j2++) {
        if (comparator(ary[j2], pivot) <= 0) {
          i += 1;
          swap(ary, i, j2);
        }
      }
      swap(ary, i + 1, j2);
      var q = i + 1;
      doQuickSort(ary, comparator, p, q - 1);
      doQuickSort(ary, comparator, q + 1, r);
    }
  }
  quickSort.quickSort = function(ary, comparator) {
    doQuickSort(ary, comparator, 0, ary.length - 1);
  };
  return quickSort;
}
var hasRequiredSourceMapConsumer;
function requireSourceMapConsumer() {
  if (hasRequiredSourceMapConsumer) return sourceMapConsumer;
  hasRequiredSourceMapConsumer = 1;
  var util2 = requireUtil();
  var binarySearch2 = requireBinarySearch();
  var ArraySet = requireArraySet().ArraySet;
  var base64VLQ = requireBase64Vlq();
  var quickSort2 = requireQuickSort().quickSort;
  function SourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    return sourceMap2.sections != null ? new IndexedSourceMapConsumer(sourceMap2, aSourceMapURL) : new BasicSourceMapConsumer(sourceMap2, aSourceMapURL);
  }
  SourceMapConsumer.fromSourceMap = function(aSourceMap, aSourceMapURL) {
    return BasicSourceMapConsumer.fromSourceMap(aSourceMap, aSourceMapURL);
  };
  SourceMapConsumer.prototype._version = 3;
  SourceMapConsumer.prototype.__generatedMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_generatedMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__generatedMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__generatedMappings;
    }
  });
  SourceMapConsumer.prototype.__originalMappings = null;
  Object.defineProperty(SourceMapConsumer.prototype, "_originalMappings", {
    configurable: true,
    enumerable: true,
    get: function() {
      if (!this.__originalMappings) {
        this._parseMappings(this._mappings, this.sourceRoot);
      }
      return this.__originalMappings;
    }
  });
  SourceMapConsumer.prototype._charIsMappingSeparator = function SourceMapConsumer_charIsMappingSeparator(aStr, index2) {
    var c = aStr.charAt(index2);
    return c === ";" || c === ",";
  };
  SourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    throw new Error("Subclasses must implement _parseMappings");
  };
  SourceMapConsumer.GENERATED_ORDER = 1;
  SourceMapConsumer.ORIGINAL_ORDER = 2;
  SourceMapConsumer.GREATEST_LOWER_BOUND = 1;
  SourceMapConsumer.LEAST_UPPER_BOUND = 2;
  SourceMapConsumer.prototype.eachMapping = function SourceMapConsumer_eachMapping(aCallback, aContext, aOrder) {
    var context2 = aContext || null;
    var order = aOrder || SourceMapConsumer.GENERATED_ORDER;
    var mappings;
    switch (order) {
      case SourceMapConsumer.GENERATED_ORDER:
        mappings = this._generatedMappings;
        break;
      case SourceMapConsumer.ORIGINAL_ORDER:
        mappings = this._originalMappings;
        break;
      default:
        throw new Error("Unknown order of iteration.");
    }
    var sourceRoot = this.sourceRoot;
    mappings.map(function(mapping) {
      var source = mapping.source === null ? null : this._sources.at(mapping.source);
      source = util2.computeSourceURL(sourceRoot, source, this._sourceMapURL);
      return {
        source,
        generatedLine: mapping.generatedLine,
        generatedColumn: mapping.generatedColumn,
        originalLine: mapping.originalLine,
        originalColumn: mapping.originalColumn,
        name: mapping.name === null ? null : this._names.at(mapping.name)
      };
    }, this).forEach(aCallback, context2);
  };
  SourceMapConsumer.prototype.allGeneratedPositionsFor = function SourceMapConsumer_allGeneratedPositionsFor(aArgs) {
    var line = util2.getArg(aArgs, "line");
    var needle = {
      source: util2.getArg(aArgs, "source"),
      originalLine: line,
      originalColumn: util2.getArg(aArgs, "column", 0)
    };
    needle.source = this._findSourceIndex(needle.source);
    if (needle.source < 0) {
      return [];
    }
    var mappings = [];
    var index2 = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      binarySearch2.LEAST_UPPER_BOUND
    );
    if (index2 >= 0) {
      var mapping = this._originalMappings[index2];
      if (aArgs.column === void 0) {
        var originalLine = mapping.originalLine;
        while (mapping && mapping.originalLine === originalLine) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index2];
        }
      } else {
        var originalColumn = mapping.originalColumn;
        while (mapping && mapping.originalLine === line && mapping.originalColumn == originalColumn) {
          mappings.push({
            line: util2.getArg(mapping, "generatedLine", null),
            column: util2.getArg(mapping, "generatedColumn", null),
            lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
          });
          mapping = this._originalMappings[++index2];
        }
      }
    }
    return mappings;
  };
  sourceMapConsumer.SourceMapConsumer = SourceMapConsumer;
  function BasicSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap2, "version");
    var sources = util2.getArg(sourceMap2, "sources");
    var names = util2.getArg(sourceMap2, "names", []);
    var sourceRoot = util2.getArg(sourceMap2, "sourceRoot", null);
    var sourcesContent = util2.getArg(sourceMap2, "sourcesContent", null);
    var mappings = util2.getArg(sourceMap2, "mappings");
    var file2 = util2.getArg(sourceMap2, "file", null);
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    if (sourceRoot) {
      sourceRoot = util2.normalize(sourceRoot);
    }
    sources = sources.map(String).map(util2.normalize).map(function(source) {
      return sourceRoot && util2.isAbsolute(sourceRoot) && util2.isAbsolute(source) ? util2.relative(sourceRoot, source) : source;
    });
    this._names = ArraySet.fromArray(names.map(String), true);
    this._sources = ArraySet.fromArray(sources, true);
    this._absoluteSources = this._sources.toArray().map(function(s2) {
      return util2.computeSourceURL(sourceRoot, s2, aSourceMapURL);
    });
    this.sourceRoot = sourceRoot;
    this.sourcesContent = sourcesContent;
    this._mappings = mappings;
    this._sourceMapURL = aSourceMapURL;
    this.file = file2;
  }
  BasicSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  BasicSourceMapConsumer.prototype.consumer = SourceMapConsumer;
  BasicSourceMapConsumer.prototype._findSourceIndex = function(aSource) {
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    if (this._sources.has(relativeSource)) {
      return this._sources.indexOf(relativeSource);
    }
    var i;
    for (i = 0; i < this._absoluteSources.length; ++i) {
      if (this._absoluteSources[i] == aSource) {
        return i;
      }
    }
    return -1;
  };
  BasicSourceMapConsumer.fromSourceMap = function SourceMapConsumer_fromSourceMap(aSourceMap, aSourceMapURL) {
    var smc = Object.create(BasicSourceMapConsumer.prototype);
    var names = smc._names = ArraySet.fromArray(aSourceMap._names.toArray(), true);
    var sources = smc._sources = ArraySet.fromArray(aSourceMap._sources.toArray(), true);
    smc.sourceRoot = aSourceMap._sourceRoot;
    smc.sourcesContent = aSourceMap._generateSourcesContent(
      smc._sources.toArray(),
      smc.sourceRoot
    );
    smc.file = aSourceMap._file;
    smc._sourceMapURL = aSourceMapURL;
    smc._absoluteSources = smc._sources.toArray().map(function(s2) {
      return util2.computeSourceURL(smc.sourceRoot, s2, aSourceMapURL);
    });
    var generatedMappings = aSourceMap._mappings.toArray().slice();
    var destGeneratedMappings = smc.__generatedMappings = [];
    var destOriginalMappings = smc.__originalMappings = [];
    for (var i = 0, length = generatedMappings.length; i < length; i++) {
      var srcMapping = generatedMappings[i];
      var destMapping = new Mapping();
      destMapping.generatedLine = srcMapping.generatedLine;
      destMapping.generatedColumn = srcMapping.generatedColumn;
      if (srcMapping.source) {
        destMapping.source = sources.indexOf(srcMapping.source);
        destMapping.originalLine = srcMapping.originalLine;
        destMapping.originalColumn = srcMapping.originalColumn;
        if (srcMapping.name) {
          destMapping.name = names.indexOf(srcMapping.name);
        }
        destOriginalMappings.push(destMapping);
      }
      destGeneratedMappings.push(destMapping);
    }
    quickSort2(smc.__originalMappings, util2.compareByOriginalPositions);
    return smc;
  };
  BasicSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(BasicSourceMapConsumer.prototype, "sources", {
    get: function() {
      return this._absoluteSources.slice();
    }
  });
  function Mapping() {
    this.generatedLine = 0;
    this.generatedColumn = 0;
    this.source = null;
    this.originalLine = null;
    this.originalColumn = null;
    this.name = null;
  }
  BasicSourceMapConsumer.prototype._parseMappings = function SourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    var generatedLine = 1;
    var previousGeneratedColumn = 0;
    var previousOriginalLine = 0;
    var previousOriginalColumn = 0;
    var previousSource = 0;
    var previousName = 0;
    var length = aStr.length;
    var index2 = 0;
    var cachedSegments = {};
    var temp = {};
    var originalMappings = [];
    var generatedMappings = [];
    var mapping, str2, segment, end, value2;
    while (index2 < length) {
      if (aStr.charAt(index2) === ";") {
        generatedLine++;
        index2++;
        previousGeneratedColumn = 0;
      } else if (aStr.charAt(index2) === ",") {
        index2++;
      } else {
        mapping = new Mapping();
        mapping.generatedLine = generatedLine;
        for (end = index2; end < length; end++) {
          if (this._charIsMappingSeparator(aStr, end)) {
            break;
          }
        }
        str2 = aStr.slice(index2, end);
        segment = cachedSegments[str2];
        if (segment) {
          index2 += str2.length;
        } else {
          segment = [];
          while (index2 < end) {
            base64VLQ.decode(aStr, index2, temp);
            value2 = temp.value;
            index2 = temp.rest;
            segment.push(value2);
          }
          if (segment.length === 2) {
            throw new Error("Found a source, but no line and column");
          }
          if (segment.length === 3) {
            throw new Error("Found a source and line, but no column");
          }
          cachedSegments[str2] = segment;
        }
        mapping.generatedColumn = previousGeneratedColumn + segment[0];
        previousGeneratedColumn = mapping.generatedColumn;
        if (segment.length > 1) {
          mapping.source = previousSource + segment[1];
          previousSource += segment[1];
          mapping.originalLine = previousOriginalLine + segment[2];
          previousOriginalLine = mapping.originalLine;
          mapping.originalLine += 1;
          mapping.originalColumn = previousOriginalColumn + segment[3];
          previousOriginalColumn = mapping.originalColumn;
          if (segment.length > 4) {
            mapping.name = previousName + segment[4];
            previousName += segment[4];
          }
        }
        generatedMappings.push(mapping);
        if (typeof mapping.originalLine === "number") {
          originalMappings.push(mapping);
        }
      }
    }
    quickSort2(generatedMappings, util2.compareByGeneratedPositionsDeflated);
    this.__generatedMappings = generatedMappings;
    quickSort2(originalMappings, util2.compareByOriginalPositions);
    this.__originalMappings = originalMappings;
  };
  BasicSourceMapConsumer.prototype._findMapping = function SourceMapConsumer_findMapping(aNeedle, aMappings, aLineName, aColumnName, aComparator, aBias) {
    if (aNeedle[aLineName] <= 0) {
      throw new TypeError("Line must be greater than or equal to 1, got " + aNeedle[aLineName]);
    }
    if (aNeedle[aColumnName] < 0) {
      throw new TypeError("Column must be greater than or equal to 0, got " + aNeedle[aColumnName]);
    }
    return binarySearch2.search(aNeedle, aMappings, aComparator, aBias);
  };
  BasicSourceMapConsumer.prototype.computeColumnSpans = function SourceMapConsumer_computeColumnSpans() {
    for (var index2 = 0; index2 < this._generatedMappings.length; ++index2) {
      var mapping = this._generatedMappings[index2];
      if (index2 + 1 < this._generatedMappings.length) {
        var nextMapping = this._generatedMappings[index2 + 1];
        if (mapping.generatedLine === nextMapping.generatedLine) {
          mapping.lastGeneratedColumn = nextMapping.generatedColumn - 1;
          continue;
        }
      }
      mapping.lastGeneratedColumn = Infinity;
    }
  };
  BasicSourceMapConsumer.prototype.originalPositionFor = function SourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var index2 = this._findMapping(
      needle,
      this._generatedMappings,
      "generatedLine",
      "generatedColumn",
      util2.compareByGeneratedPositionsDeflated,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index2 >= 0) {
      var mapping = this._generatedMappings[index2];
      if (mapping.generatedLine === needle.generatedLine) {
        var source = util2.getArg(mapping, "source", null);
        if (source !== null) {
          source = this._sources.at(source);
          source = util2.computeSourceURL(this.sourceRoot, source, this._sourceMapURL);
        }
        var name2 = util2.getArg(mapping, "name", null);
        if (name2 !== null) {
          name2 = this._names.at(name2);
        }
        return {
          source,
          line: util2.getArg(mapping, "originalLine", null),
          column: util2.getArg(mapping, "originalColumn", null),
          name: name2
        };
      }
    }
    return {
      source: null,
      line: null,
      column: null,
      name: null
    };
  };
  BasicSourceMapConsumer.prototype.hasContentsOfAllSources = function BasicSourceMapConsumer_hasContentsOfAllSources() {
    if (!this.sourcesContent) {
      return false;
    }
    return this.sourcesContent.length >= this._sources.size() && !this.sourcesContent.some(function(sc) {
      return sc == null;
    });
  };
  BasicSourceMapConsumer.prototype.sourceContentFor = function SourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    if (!this.sourcesContent) {
      return null;
    }
    var index2 = this._findSourceIndex(aSource);
    if (index2 >= 0) {
      return this.sourcesContent[index2];
    }
    var relativeSource = aSource;
    if (this.sourceRoot != null) {
      relativeSource = util2.relative(this.sourceRoot, relativeSource);
    }
    var url2;
    if (this.sourceRoot != null && (url2 = util2.urlParse(this.sourceRoot))) {
      var fileUriAbsPath = relativeSource.replace(/^file:\/\//, "");
      if (url2.scheme == "file" && this._sources.has(fileUriAbsPath)) {
        return this.sourcesContent[this._sources.indexOf(fileUriAbsPath)];
      }
      if ((!url2.path || url2.path == "/") && this._sources.has("/" + relativeSource)) {
        return this.sourcesContent[this._sources.indexOf("/" + relativeSource)];
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + relativeSource + '" is not in the SourceMap.');
    }
  };
  BasicSourceMapConsumer.prototype.generatedPositionFor = function SourceMapConsumer_generatedPositionFor(aArgs) {
    var source = util2.getArg(aArgs, "source");
    source = this._findSourceIndex(source);
    if (source < 0) {
      return {
        line: null,
        column: null,
        lastColumn: null
      };
    }
    var needle = {
      source,
      originalLine: util2.getArg(aArgs, "line"),
      originalColumn: util2.getArg(aArgs, "column")
    };
    var index2 = this._findMapping(
      needle,
      this._originalMappings,
      "originalLine",
      "originalColumn",
      util2.compareByOriginalPositions,
      util2.getArg(aArgs, "bias", SourceMapConsumer.GREATEST_LOWER_BOUND)
    );
    if (index2 >= 0) {
      var mapping = this._originalMappings[index2];
      if (mapping.source === needle.source) {
        return {
          line: util2.getArg(mapping, "generatedLine", null),
          column: util2.getArg(mapping, "generatedColumn", null),
          lastColumn: util2.getArg(mapping, "lastGeneratedColumn", null)
        };
      }
    }
    return {
      line: null,
      column: null,
      lastColumn: null
    };
  };
  sourceMapConsumer.BasicSourceMapConsumer = BasicSourceMapConsumer;
  function IndexedSourceMapConsumer(aSourceMap, aSourceMapURL) {
    var sourceMap2 = aSourceMap;
    if (typeof aSourceMap === "string") {
      sourceMap2 = util2.parseSourceMapInput(aSourceMap);
    }
    var version2 = util2.getArg(sourceMap2, "version");
    var sections = util2.getArg(sourceMap2, "sections");
    if (version2 != this._version) {
      throw new Error("Unsupported version: " + version2);
    }
    this._sources = new ArraySet();
    this._names = new ArraySet();
    var lastOffset = {
      line: -1,
      column: 0
    };
    this._sections = sections.map(function(s2) {
      if (s2.url) {
        throw new Error("Support for url field in sections not implemented.");
      }
      var offset = util2.getArg(s2, "offset");
      var offsetLine = util2.getArg(offset, "line");
      var offsetColumn = util2.getArg(offset, "column");
      if (offsetLine < lastOffset.line || offsetLine === lastOffset.line && offsetColumn < lastOffset.column) {
        throw new Error("Section offsets must be ordered and non-overlapping.");
      }
      lastOffset = offset;
      return {
        generatedOffset: {
          // The offset fields are 0-based, but we use 1-based indices when
          // encoding/decoding from VLQ.
          generatedLine: offsetLine + 1,
          generatedColumn: offsetColumn + 1
        },
        consumer: new SourceMapConsumer(util2.getArg(s2, "map"), aSourceMapURL)
      };
    });
  }
  IndexedSourceMapConsumer.prototype = Object.create(SourceMapConsumer.prototype);
  IndexedSourceMapConsumer.prototype.constructor = SourceMapConsumer;
  IndexedSourceMapConsumer.prototype._version = 3;
  Object.defineProperty(IndexedSourceMapConsumer.prototype, "sources", {
    get: function() {
      var sources = [];
      for (var i = 0; i < this._sections.length; i++) {
        for (var j2 = 0; j2 < this._sections[i].consumer.sources.length; j2++) {
          sources.push(this._sections[i].consumer.sources[j2]);
        }
      }
      return sources;
    }
  });
  IndexedSourceMapConsumer.prototype.originalPositionFor = function IndexedSourceMapConsumer_originalPositionFor(aArgs) {
    var needle = {
      generatedLine: util2.getArg(aArgs, "line"),
      generatedColumn: util2.getArg(aArgs, "column")
    };
    var sectionIndex = binarySearch2.search(
      needle,
      this._sections,
      function(needle2, section2) {
        var cmp = needle2.generatedLine - section2.generatedOffset.generatedLine;
        if (cmp) {
          return cmp;
        }
        return needle2.generatedColumn - section2.generatedOffset.generatedColumn;
      }
    );
    var section = this._sections[sectionIndex];
    if (!section) {
      return {
        source: null,
        line: null,
        column: null,
        name: null
      };
    }
    return section.consumer.originalPositionFor({
      line: needle.generatedLine - (section.generatedOffset.generatedLine - 1),
      column: needle.generatedColumn - (section.generatedOffset.generatedLine === needle.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
      bias: aArgs.bias
    });
  };
  IndexedSourceMapConsumer.prototype.hasContentsOfAllSources = function IndexedSourceMapConsumer_hasContentsOfAllSources() {
    return this._sections.every(function(s2) {
      return s2.consumer.hasContentsOfAllSources();
    });
  };
  IndexedSourceMapConsumer.prototype.sourceContentFor = function IndexedSourceMapConsumer_sourceContentFor(aSource, nullOnMissing) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var content = section.consumer.sourceContentFor(aSource, true);
      if (content) {
        return content;
      }
    }
    if (nullOnMissing) {
      return null;
    } else {
      throw new Error('"' + aSource + '" is not in the SourceMap.');
    }
  };
  IndexedSourceMapConsumer.prototype.generatedPositionFor = function IndexedSourceMapConsumer_generatedPositionFor(aArgs) {
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      if (section.consumer._findSourceIndex(util2.getArg(aArgs, "source")) === -1) {
        continue;
      }
      var generatedPosition = section.consumer.generatedPositionFor(aArgs);
      if (generatedPosition) {
        var ret = {
          line: generatedPosition.line + (section.generatedOffset.generatedLine - 1),
          column: generatedPosition.column + (section.generatedOffset.generatedLine === generatedPosition.line ? section.generatedOffset.generatedColumn - 1 : 0)
        };
        return ret;
      }
    }
    return {
      line: null,
      column: null
    };
  };
  IndexedSourceMapConsumer.prototype._parseMappings = function IndexedSourceMapConsumer_parseMappings(aStr, aSourceRoot) {
    this.__generatedMappings = [];
    this.__originalMappings = [];
    for (var i = 0; i < this._sections.length; i++) {
      var section = this._sections[i];
      var sectionMappings = section.consumer._generatedMappings;
      for (var j2 = 0; j2 < sectionMappings.length; j2++) {
        var mapping = sectionMappings[j2];
        var source = section.consumer._sources.at(mapping.source);
        source = util2.computeSourceURL(section.consumer.sourceRoot, source, this._sourceMapURL);
        this._sources.add(source);
        source = this._sources.indexOf(source);
        var name2 = null;
        if (mapping.name) {
          name2 = section.consumer._names.at(mapping.name);
          this._names.add(name2);
          name2 = this._names.indexOf(name2);
        }
        var adjustedMapping = {
          source,
          generatedLine: mapping.generatedLine + (section.generatedOffset.generatedLine - 1),
          generatedColumn: mapping.generatedColumn + (section.generatedOffset.generatedLine === mapping.generatedLine ? section.generatedOffset.generatedColumn - 1 : 0),
          originalLine: mapping.originalLine,
          originalColumn: mapping.originalColumn,
          name: name2
        };
        this.__generatedMappings.push(adjustedMapping);
        if (typeof adjustedMapping.originalLine === "number") {
          this.__originalMappings.push(adjustedMapping);
        }
      }
    }
    quickSort2(this.__generatedMappings, util2.compareByGeneratedPositionsDeflated);
    quickSort2(this.__originalMappings, util2.compareByOriginalPositions);
  };
  sourceMapConsumer.IndexedSourceMapConsumer = IndexedSourceMapConsumer;
  return sourceMapConsumer;
}
var sourceNode = {};
var hasRequiredSourceNode;
function requireSourceNode() {
  if (hasRequiredSourceNode) return sourceNode;
  hasRequiredSourceNode = 1;
  var SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  var util2 = requireUtil();
  var REGEX_NEWLINE2 = /(\r?\n)/;
  var NEWLINE_CODE = 10;
  var isSourceNode = "$$$isSourceNode$$$";
  function SourceNode(aLine, aColumn, aSource, aChunks, aName) {
    this.children = [];
    this.sourceContents = {};
    this.line = aLine == null ? null : aLine;
    this.column = aColumn == null ? null : aColumn;
    this.source = aSource == null ? null : aSource;
    this.name = aName == null ? null : aName;
    this[isSourceNode] = true;
    if (aChunks != null) this.add(aChunks);
  }
  SourceNode.fromStringWithSourceMap = function SourceNode_fromStringWithSourceMap(aGeneratedCode, aSourceMapConsumer, aRelativePath) {
    var node2 = new SourceNode();
    var remainingLines = aGeneratedCode.split(REGEX_NEWLINE2);
    var remainingLinesIndex = 0;
    var shiftNextLine = function() {
      var lineContents = getNextLine();
      var newLine = getNextLine() || "";
      return lineContents + newLine;
      function getNextLine() {
        return remainingLinesIndex < remainingLines.length ? remainingLines[remainingLinesIndex++] : void 0;
      }
    };
    var lastGeneratedLine = 1, lastGeneratedColumn = 0;
    var lastMapping = null;
    aSourceMapConsumer.eachMapping(function(mapping) {
      if (lastMapping !== null) {
        if (lastGeneratedLine < mapping.generatedLine) {
          addMappingWithCode(lastMapping, shiftNextLine());
          lastGeneratedLine++;
          lastGeneratedColumn = 0;
        } else {
          var nextLine = remainingLines[remainingLinesIndex] || "";
          var code2 = nextLine.substr(0, mapping.generatedColumn - lastGeneratedColumn);
          remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn - lastGeneratedColumn);
          lastGeneratedColumn = mapping.generatedColumn;
          addMappingWithCode(lastMapping, code2);
          lastMapping = mapping;
          return;
        }
      }
      while (lastGeneratedLine < mapping.generatedLine) {
        node2.add(shiftNextLine());
        lastGeneratedLine++;
      }
      if (lastGeneratedColumn < mapping.generatedColumn) {
        var nextLine = remainingLines[remainingLinesIndex] || "";
        node2.add(nextLine.substr(0, mapping.generatedColumn));
        remainingLines[remainingLinesIndex] = nextLine.substr(mapping.generatedColumn);
        lastGeneratedColumn = mapping.generatedColumn;
      }
      lastMapping = mapping;
    }, this);
    if (remainingLinesIndex < remainingLines.length) {
      if (lastMapping) {
        addMappingWithCode(lastMapping, shiftNextLine());
      }
      node2.add(remainingLines.splice(remainingLinesIndex).join(""));
    }
    aSourceMapConsumer.sources.forEach(function(sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aRelativePath != null) {
          sourceFile = util2.join(aRelativePath, sourceFile);
        }
        node2.setSourceContent(sourceFile, content);
      }
    });
    return node2;
    function addMappingWithCode(mapping, code2) {
      if (mapping === null || mapping.source === void 0) {
        node2.add(code2);
      } else {
        var source = aRelativePath ? util2.join(aRelativePath, mapping.source) : mapping.source;
        node2.add(new SourceNode(
          mapping.originalLine,
          mapping.originalColumn,
          source,
          code2,
          mapping.name
        ));
      }
    }
  };
  SourceNode.prototype.add = function SourceNode_add(aChunk) {
    if (Array.isArray(aChunk)) {
      aChunk.forEach(function(chunk) {
        this.add(chunk);
      }, this);
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      if (aChunk) {
        this.children.push(aChunk);
      }
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.prepend = function SourceNode_prepend(aChunk) {
    if (Array.isArray(aChunk)) {
      for (var i = aChunk.length - 1; i >= 0; i--) {
        this.prepend(aChunk[i]);
      }
    } else if (aChunk[isSourceNode] || typeof aChunk === "string") {
      this.children.unshift(aChunk);
    } else {
      throw new TypeError(
        "Expected a SourceNode, string, or an array of SourceNodes and strings. Got " + aChunk
      );
    }
    return this;
  };
  SourceNode.prototype.walk = function SourceNode_walk(aFn) {
    var chunk;
    for (var i = 0, len = this.children.length; i < len; i++) {
      chunk = this.children[i];
      if (chunk[isSourceNode]) {
        chunk.walk(aFn);
      } else {
        if (chunk !== "") {
          aFn(chunk, {
            source: this.source,
            line: this.line,
            column: this.column,
            name: this.name
          });
        }
      }
    }
  };
  SourceNode.prototype.join = function SourceNode_join(aSep) {
    var newChildren;
    var i;
    var len = this.children.length;
    if (len > 0) {
      newChildren = [];
      for (i = 0; i < len - 1; i++) {
        newChildren.push(this.children[i]);
        newChildren.push(aSep);
      }
      newChildren.push(this.children[i]);
      this.children = newChildren;
    }
    return this;
  };
  SourceNode.prototype.replaceRight = function SourceNode_replaceRight(aPattern, aReplacement) {
    var lastChild = this.children[this.children.length - 1];
    if (lastChild[isSourceNode]) {
      lastChild.replaceRight(aPattern, aReplacement);
    } else if (typeof lastChild === "string") {
      this.children[this.children.length - 1] = lastChild.replace(aPattern, aReplacement);
    } else {
      this.children.push("".replace(aPattern, aReplacement));
    }
    return this;
  };
  SourceNode.prototype.setSourceContent = function SourceNode_setSourceContent(aSourceFile, aSourceContent) {
    this.sourceContents[util2.toSetString(aSourceFile)] = aSourceContent;
  };
  SourceNode.prototype.walkSourceContents = function SourceNode_walkSourceContents(aFn) {
    for (var i = 0, len = this.children.length; i < len; i++) {
      if (this.children[i][isSourceNode]) {
        this.children[i].walkSourceContents(aFn);
      }
    }
    var sources = Object.keys(this.sourceContents);
    for (var i = 0, len = sources.length; i < len; i++) {
      aFn(util2.fromSetString(sources[i]), this.sourceContents[sources[i]]);
    }
  };
  SourceNode.prototype.toString = function SourceNode_toString() {
    var str2 = "";
    this.walk(function(chunk) {
      str2 += chunk;
    });
    return str2;
  };
  SourceNode.prototype.toStringWithSourceMap = function SourceNode_toStringWithSourceMap(aArgs) {
    var generated = {
      code: "",
      line: 1,
      column: 0
    };
    var map2 = new SourceMapGenerator(aArgs);
    var sourceMappingActive = false;
    var lastOriginalSource = null;
    var lastOriginalLine = null;
    var lastOriginalColumn = null;
    var lastOriginalName = null;
    this.walk(function(chunk, original) {
      generated.code += chunk;
      if (original.source !== null && original.line !== null && original.column !== null) {
        if (lastOriginalSource !== original.source || lastOriginalLine !== original.line || lastOriginalColumn !== original.column || lastOriginalName !== original.name) {
          map2.addMapping({
            source: original.source,
            original: {
              line: original.line,
              column: original.column
            },
            generated: {
              line: generated.line,
              column: generated.column
            },
            name: original.name
          });
        }
        lastOriginalSource = original.source;
        lastOriginalLine = original.line;
        lastOriginalColumn = original.column;
        lastOriginalName = original.name;
        sourceMappingActive = true;
      } else if (sourceMappingActive) {
        map2.addMapping({
          generated: {
            line: generated.line,
            column: generated.column
          }
        });
        lastOriginalSource = null;
        sourceMappingActive = false;
      }
      for (var idx = 0, length = chunk.length; idx < length; idx++) {
        if (chunk.charCodeAt(idx) === NEWLINE_CODE) {
          generated.line++;
          generated.column = 0;
          if (idx + 1 === length) {
            lastOriginalSource = null;
            sourceMappingActive = false;
          } else if (sourceMappingActive) {
            map2.addMapping({
              source: original.source,
              original: {
                line: original.line,
                column: original.column
              },
              generated: {
                line: generated.line,
                column: generated.column
              },
              name: original.name
            });
          }
        } else {
          generated.column++;
        }
      }
    });
    this.walkSourceContents(function(sourceFile, sourceContent) {
      map2.setSourceContent(sourceFile, sourceContent);
    });
    return { code: generated.code, map: map2 };
  };
  sourceNode.SourceNode = SourceNode;
  return sourceNode;
}
var hasRequiredSourceMap;
function requireSourceMap() {
  if (hasRequiredSourceMap) return sourceMap;
  hasRequiredSourceMap = 1;
  sourceMap.SourceMapGenerator = requireSourceMapGenerator().SourceMapGenerator;
  sourceMap.SourceMapConsumer = requireSourceMapConsumer().SourceMapConsumer;
  sourceMap.SourceNode = requireSourceNode().SourceNode;
  return sourceMap;
}
const name$1 = "escodegen";
const description$1 = "ECMAScript code generator";
const homepage = "http://github.com/estools/escodegen";
const main$2 = "escodegen.js";
const bin$1 = {
  esgenerate: "./bin/esgenerate.js",
  escodegen: "./bin/escodegen.js"
};
const files$1 = [
  "LICENSE.BSD",
  "README.md",
  "bin",
  "escodegen.js",
  "package.json"
];
const version$1 = "2.1.0";
const engines$1 = {
  node: ">=6.0"
};
const maintainers = [
  {
    name: "Yusuke Suzuki",
    email: "utatane.tea@gmail.com",
    web: "http://github.com/Constellation"
  }
];
const repository = {
  type: "git",
  url: "http://github.com/estools/escodegen.git"
};
const dependencies$1 = {
  estraverse: "^5.2.0",
  esutils: "^2.0.2",
  esprima: "^4.0.1"
};
const optionalDependencies = {
  "source-map": "~0.6.1"
};
const devDependencies$1 = {
  acorn: "^8.0.4",
  bluebird: "^3.4.7",
  "bower-registry-client": "^1.0.0",
  chai: "^4.2.0",
  "chai-exclude": "^2.0.2",
  "commonjs-everywhere": "^0.9.7",
  gulp: "^4.0.2",
  "gulp-eslint": "^6.0.0",
  "gulp-mocha": "^7.0.2",
  minimist: "^1.2.5",
  optionator: "^0.9.1",
  semver: "^7.3.4"
};
const license$1 = "BSD-2-Clause";
const scripts$1 = {
  test: "gulp travis",
  "unit-test": "gulp test",
  lint: "gulp lint",
  release: "node tools/release.js",
  "build-min": "./node_modules/.bin/cjsify -ma path: tools/entry-point.js > escodegen.browser.min.js",
  build: "./node_modules/.bin/cjsify -a path: tools/entry-point.js > escodegen.browser.js"
};
const require$$3 = {
  name: name$1,
  description: description$1,
  homepage,
  main: main$2,
  bin: bin$1,
  files: files$1,
  version: version$1,
  engines: engines$1,
  maintainers,
  repository,
  dependencies: dependencies$1,
  optionalDependencies,
  devDependencies: devDependencies$1,
  license: license$1,
  scripts: scripts$1
};
(function(exports) {
  (function() {
    var Syntax, Precedence, BinaryPrecedence, SourceNode, estraverse$1, esutils, base, indent, json3, renumber, hexadecimal, quotes, escapeless, newline, space, parentheses, semicolons, safeConcatenation, directive, extra, parse2, sourceMap2, sourceCode, preserveBlankLines, FORMAT_MINIFY, FORMAT_DEFAULTS;
    estraverse$1 = estraverse;
    esutils = utils$1;
    Syntax = estraverse$1.Syntax;
    function isExpression(node2) {
      return CodeGenerator.Expression.hasOwnProperty(node2.type);
    }
    function isStatement(node2) {
      return CodeGenerator.Statement.hasOwnProperty(node2.type);
    }
    Precedence = {
      Sequence: 0,
      Yield: 1,
      Assignment: 1,
      Conditional: 2,
      ArrowFunction: 2,
      Coalesce: 3,
      LogicalOR: 4,
      LogicalAND: 5,
      BitwiseOR: 6,
      BitwiseXOR: 7,
      BitwiseAND: 8,
      Equality: 9,
      Relational: 10,
      BitwiseSHIFT: 11,
      Additive: 12,
      Multiplicative: 13,
      Exponentiation: 14,
      Await: 15,
      Unary: 15,
      Postfix: 16,
      OptionalChaining: 17,
      Call: 18,
      New: 19,
      TaggedTemplate: 20,
      Member: 21,
      Primary: 22
    };
    BinaryPrecedence = {
      "??": Precedence.Coalesce,
      "||": Precedence.LogicalOR,
      "&&": Precedence.LogicalAND,
      "|": Precedence.BitwiseOR,
      "^": Precedence.BitwiseXOR,
      "&": Precedence.BitwiseAND,
      "==": Precedence.Equality,
      "!=": Precedence.Equality,
      "===": Precedence.Equality,
      "!==": Precedence.Equality,
      "is": Precedence.Equality,
      "isnt": Precedence.Equality,
      "<": Precedence.Relational,
      ">": Precedence.Relational,
      "<=": Precedence.Relational,
      ">=": Precedence.Relational,
      "in": Precedence.Relational,
      "instanceof": Precedence.Relational,
      "<<": Precedence.BitwiseSHIFT,
      ">>": Precedence.BitwiseSHIFT,
      ">>>": Precedence.BitwiseSHIFT,
      "+": Precedence.Additive,
      "-": Precedence.Additive,
      "*": Precedence.Multiplicative,
      "%": Precedence.Multiplicative,
      "/": Precedence.Multiplicative,
      "**": Precedence.Exponentiation
    };
    var F_ALLOW_IN = 1, F_ALLOW_CALL = 1 << 1, F_ALLOW_UNPARATH_NEW = 1 << 2, F_FUNC_BODY = 1 << 3, F_DIRECTIVE_CTX = 1 << 4, F_SEMICOLON_OPT = 1 << 5, F_FOUND_COALESCE = 1 << 6;
    var E_FTT = F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TTF = F_ALLOW_IN | F_ALLOW_CALL, E_TTT = F_ALLOW_IN | F_ALLOW_CALL | F_ALLOW_UNPARATH_NEW, E_TFF = F_ALLOW_IN, E_FFT = F_ALLOW_UNPARATH_NEW, E_TFT = F_ALLOW_IN | F_ALLOW_UNPARATH_NEW;
    var S_TFFF = F_ALLOW_IN, S_TFFT = F_ALLOW_IN | F_SEMICOLON_OPT, S_FFFF = 0, S_TFTF = F_ALLOW_IN | F_DIRECTIVE_CTX, S_TTFF = F_ALLOW_IN | F_FUNC_BODY;
    function getDefaultOptions() {
      return {
        indent: null,
        base: null,
        parse: null,
        comment: false,
        format: {
          indent: {
            style: "    ",
            base: 0,
            adjustMultilineComment: false
          },
          newline: "\n",
          space: " ",
          json: false,
          renumber: false,
          hexadecimal: false,
          quotes: "single",
          escapeless: false,
          compact: false,
          parentheses: true,
          semicolons: true,
          safeConcatenation: false,
          preserveBlankLines: false
        },
        moz: {
          comprehensionExpressionStartsWithAssignment: false,
          starlessGenerator: false
        },
        sourceMap: null,
        sourceMapRoot: null,
        sourceMapWithCode: false,
        directive: false,
        raw: true,
        verbatim: null,
        sourceCode: null
      };
    }
    function stringRepeat(str2, num) {
      var result = "";
      for (num |= 0; num > 0; num >>>= 1, str2 += str2) {
        if (num & 1) {
          result += str2;
        }
      }
      return result;
    }
    function hasLineTerminator(str2) {
      return /[\r\n]/g.test(str2);
    }
    function endsWithLineTerminator(str2) {
      var len = str2.length;
      return len && esutils.code.isLineTerminator(str2.charCodeAt(len - 1));
    }
    function merge2(target, override) {
      var key;
      for (key in override) {
        if (override.hasOwnProperty(key)) {
          target[key] = override[key];
        }
      }
      return target;
    }
    function updateDeeply(target, override) {
      var key, val;
      function isHashObject(target2) {
        return typeof target2 === "object" && target2 instanceof Object && !(target2 instanceof RegExp);
      }
      for (key in override) {
        if (override.hasOwnProperty(key)) {
          val = override[key];
          if (isHashObject(val)) {
            if (isHashObject(target[key])) {
              updateDeeply(target[key], val);
            } else {
              target[key] = updateDeeply({}, val);
            }
          } else {
            target[key] = val;
          }
        }
      }
      return target;
    }
    function generateNumber(value2) {
      var result, point, temp, exponent, pos;
      if (value2 !== value2) {
        throw new Error("Numeric literal whose value is NaN");
      }
      if (value2 < 0 || value2 === 0 && 1 / value2 < 0) {
        throw new Error("Numeric literal whose value is negative");
      }
      if (value2 === 1 / 0) {
        return json3 ? "null" : renumber ? "1e400" : "1e+400";
      }
      result = "" + value2;
      if (!renumber || result.length < 3) {
        return result;
      }
      point = result.indexOf(".");
      if (!json3 && result.charCodeAt(0) === 48 && point === 1) {
        point = 0;
        result = result.slice(1);
      }
      temp = result;
      result = result.replace("e+", "e");
      exponent = 0;
      if ((pos = temp.indexOf("e")) > 0) {
        exponent = +temp.slice(pos + 1);
        temp = temp.slice(0, pos);
      }
      if (point >= 0) {
        exponent -= temp.length - point - 1;
        temp = +(temp.slice(0, point) + temp.slice(point + 1)) + "";
      }
      pos = 0;
      while (temp.charCodeAt(temp.length + pos - 1) === 48) {
        --pos;
      }
      if (pos !== 0) {
        exponent -= pos;
        temp = temp.slice(0, pos);
      }
      if (exponent !== 0) {
        temp += "e" + exponent;
      }
      if ((temp.length < result.length || hexadecimal && value2 > 1e12 && Math.floor(value2) === value2 && (temp = "0x" + value2.toString(16)).length < result.length) && +temp === value2) {
        result = temp;
      }
      return result;
    }
    function escapeRegExpCharacter(ch, previousIsBackslash) {
      if ((ch & ~1) === 8232) {
        return (previousIsBackslash ? "u" : "\\u") + (ch === 8232 ? "2028" : "2029");
      } else if (ch === 10 || ch === 13) {
        return (previousIsBackslash ? "" : "\\") + (ch === 10 ? "n" : "r");
      }
      return String.fromCharCode(ch);
    }
    function generateRegExp(reg) {
      var match2, result, flags, i, iz, ch, characterInBrack, previousIsBackslash;
      result = reg.toString();
      if (reg.source) {
        match2 = result.match(/\/([^/]*)$/);
        if (!match2) {
          return result;
        }
        flags = match2[1];
        result = "";
        characterInBrack = false;
        previousIsBackslash = false;
        for (i = 0, iz = reg.source.length; i < iz; ++i) {
          ch = reg.source.charCodeAt(i);
          if (!previousIsBackslash) {
            if (characterInBrack) {
              if (ch === 93) {
                characterInBrack = false;
              }
            } else {
              if (ch === 47) {
                result += "\\";
              } else if (ch === 91) {
                characterInBrack = true;
              }
            }
            result += escapeRegExpCharacter(ch, previousIsBackslash);
            previousIsBackslash = ch === 92;
          } else {
            result += escapeRegExpCharacter(ch, previousIsBackslash);
            previousIsBackslash = false;
          }
        }
        return "/" + result + "/" + flags;
      }
      return result;
    }
    function escapeAllowedCharacter(code2, next) {
      var hex;
      if (code2 === 8) {
        return "\\b";
      }
      if (code2 === 12) {
        return "\\f";
      }
      if (code2 === 9) {
        return "\\t";
      }
      hex = code2.toString(16).toUpperCase();
      if (json3 || code2 > 255) {
        return "\\u" + "0000".slice(hex.length) + hex;
      } else if (code2 === 0 && !esutils.code.isDecimalDigit(next)) {
        return "\\0";
      } else if (code2 === 11) {
        return "\\x0B";
      } else {
        return "\\x" + "00".slice(hex.length) + hex;
      }
    }
    function escapeDisallowedCharacter(code2) {
      if (code2 === 92) {
        return "\\\\";
      }
      if (code2 === 10) {
        return "\\n";
      }
      if (code2 === 13) {
        return "\\r";
      }
      if (code2 === 8232) {
        return "\\u2028";
      }
      if (code2 === 8233) {
        return "\\u2029";
      }
      throw new Error("Incorrectly classified character");
    }
    function escapeDirective(str2) {
      var i, iz, code2, quote;
      quote = quotes === "double" ? '"' : "'";
      for (i = 0, iz = str2.length; i < iz; ++i) {
        code2 = str2.charCodeAt(i);
        if (code2 === 39) {
          quote = '"';
          break;
        } else if (code2 === 34) {
          quote = "'";
          break;
        } else if (code2 === 92) {
          ++i;
        }
      }
      return quote + str2 + quote;
    }
    function escapeString(str2) {
      var result = "", i, len, code2, singleQuotes = 0, doubleQuotes = 0, single, quote;
      for (i = 0, len = str2.length; i < len; ++i) {
        code2 = str2.charCodeAt(i);
        if (code2 === 39) {
          ++singleQuotes;
        } else if (code2 === 34) {
          ++doubleQuotes;
        } else if (code2 === 47 && json3) {
          result += "\\";
        } else if (esutils.code.isLineTerminator(code2) || code2 === 92) {
          result += escapeDisallowedCharacter(code2);
          continue;
        } else if (!esutils.code.isIdentifierPartES5(code2) && (json3 && code2 < 32 || !json3 && !escapeless && (code2 < 32 || code2 > 126))) {
          result += escapeAllowedCharacter(code2, str2.charCodeAt(i + 1));
          continue;
        }
        result += String.fromCharCode(code2);
      }
      single = !(quotes === "double" || quotes === "auto" && doubleQuotes < singleQuotes);
      quote = single ? "'" : '"';
      if (!(single ? singleQuotes : doubleQuotes)) {
        return quote + result + quote;
      }
      str2 = result;
      result = quote;
      for (i = 0, len = str2.length; i < len; ++i) {
        code2 = str2.charCodeAt(i);
        if (code2 === 39 && single || code2 === 34 && !single) {
          result += "\\";
        }
        result += String.fromCharCode(code2);
      }
      return result + quote;
    }
    function flattenToString(arr) {
      var i, iz, elem, result = "";
      for (i = 0, iz = arr.length; i < iz; ++i) {
        elem = arr[i];
        result += Array.isArray(elem) ? flattenToString(elem) : elem;
      }
      return result;
    }
    function toSourceNodeWhenNeeded(generated, node2) {
      if (!sourceMap2) {
        if (Array.isArray(generated)) {
          return flattenToString(generated);
        } else {
          return generated;
        }
      }
      if (node2 == null) {
        if (generated instanceof SourceNode) {
          return generated;
        } else {
          node2 = {};
        }
      }
      if (node2.loc == null) {
        return new SourceNode(null, null, sourceMap2, generated, node2.name || null);
      }
      return new SourceNode(node2.loc.start.line, node2.loc.start.column, sourceMap2 === true ? node2.loc.source || null : sourceMap2, generated, node2.name || null);
    }
    function noEmptySpace() {
      return space ? space : " ";
    }
    function join2(left, right) {
      var leftSource, rightSource, leftCharCode, rightCharCode;
      leftSource = toSourceNodeWhenNeeded(left).toString();
      if (leftSource.length === 0) {
        return [right];
      }
      rightSource = toSourceNodeWhenNeeded(right).toString();
      if (rightSource.length === 0) {
        return [left];
      }
      leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
      rightCharCode = rightSource.charCodeAt(0);
      if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode) || leftCharCode === 47 && rightCharCode === 105) {
        return [left, noEmptySpace(), right];
      } else if (esutils.code.isWhiteSpace(leftCharCode) || esutils.code.isLineTerminator(leftCharCode) || esutils.code.isWhiteSpace(rightCharCode) || esutils.code.isLineTerminator(rightCharCode)) {
        return [left, right];
      }
      return [left, space, right];
    }
    function addIndent(stmt) {
      return [base, stmt];
    }
    function withIndent(fn) {
      var previousBase;
      previousBase = base;
      base += indent;
      fn(base);
      base = previousBase;
    }
    function calculateSpaces(str2) {
      var i;
      for (i = str2.length - 1; i >= 0; --i) {
        if (esutils.code.isLineTerminator(str2.charCodeAt(i))) {
          break;
        }
      }
      return str2.length - 1 - i;
    }
    function adjustMultilineComment(value2, specialBase) {
      var array2, i, len, line, j2, spaces, previousBase, sn;
      array2 = value2.split(/\r\n|[\r\n]/);
      spaces = Number.MAX_VALUE;
      for (i = 1, len = array2.length; i < len; ++i) {
        line = array2[i];
        j2 = 0;
        while (j2 < line.length && esutils.code.isWhiteSpace(line.charCodeAt(j2))) {
          ++j2;
        }
        if (spaces > j2) {
          spaces = j2;
        }
      }
      if (typeof specialBase !== "undefined") {
        previousBase = base;
        if (array2[1][spaces] === "*") {
          specialBase += " ";
        }
        base = specialBase;
      } else {
        if (spaces & 1) {
          --spaces;
        }
        previousBase = base;
      }
      for (i = 1, len = array2.length; i < len; ++i) {
        sn = toSourceNodeWhenNeeded(addIndent(array2[i].slice(spaces)));
        array2[i] = sourceMap2 ? sn.join("") : sn;
      }
      base = previousBase;
      return array2.join("\n");
    }
    function generateComment(comment, specialBase) {
      if (comment.type === "Line") {
        if (endsWithLineTerminator(comment.value)) {
          return "//" + comment.value;
        } else {
          var result = "//" + comment.value;
          if (!preserveBlankLines) {
            result += "\n";
          }
          return result;
        }
      }
      if (extra.format.indent.adjustMultilineComment && /[\n\r]/.test(comment.value)) {
        return adjustMultilineComment("/*" + comment.value + "*/", specialBase);
      }
      return "/*" + comment.value + "*/";
    }
    function addComments(stmt, result) {
      var i, len, comment, save, tailingToStatement, specialBase, fragment, extRange, range3, prevRange, prefix, infix, suffix, count;
      if (stmt.leadingComments && stmt.leadingComments.length > 0) {
        save = result;
        if (preserveBlankLines) {
          comment = stmt.leadingComments[0];
          result = [];
          extRange = comment.extendedRange;
          range3 = comment.range;
          prefix = sourceCode.substring(extRange[0], range3[0]);
          count = (prefix.match(/\n/g) || []).length;
          if (count > 0) {
            result.push(stringRepeat("\n", count));
            result.push(addIndent(generateComment(comment)));
          } else {
            result.push(prefix);
            result.push(generateComment(comment));
          }
          prevRange = range3;
          for (i = 1, len = stmt.leadingComments.length; i < len; i++) {
            comment = stmt.leadingComments[i];
            range3 = comment.range;
            infix = sourceCode.substring(prevRange[1], range3[0]);
            count = (infix.match(/\n/g) || []).length;
            result.push(stringRepeat("\n", count));
            result.push(addIndent(generateComment(comment)));
            prevRange = range3;
          }
          suffix = sourceCode.substring(range3[1], extRange[1]);
          count = (suffix.match(/\n/g) || []).length;
          result.push(stringRepeat("\n", count));
        } else {
          comment = stmt.leadingComments[0];
          result = [];
          if (safeConcatenation && stmt.type === Syntax.Program && stmt.body.length === 0) {
            result.push("\n");
          }
          result.push(generateComment(comment));
          if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push("\n");
          }
          for (i = 1, len = stmt.leadingComments.length; i < len; ++i) {
            comment = stmt.leadingComments[i];
            fragment = [generateComment(comment)];
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              fragment.push("\n");
            }
            result.push(addIndent(fragment));
          }
        }
        result.push(addIndent(save));
      }
      if (stmt.trailingComments) {
        if (preserveBlankLines) {
          comment = stmt.trailingComments[0];
          extRange = comment.extendedRange;
          range3 = comment.range;
          prefix = sourceCode.substring(extRange[0], range3[0]);
          count = (prefix.match(/\n/g) || []).length;
          if (count > 0) {
            result.push(stringRepeat("\n", count));
            result.push(addIndent(generateComment(comment)));
          } else {
            result.push(prefix);
            result.push(generateComment(comment));
          }
        } else {
          tailingToStatement = !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
          specialBase = stringRepeat(" ", calculateSpaces(toSourceNodeWhenNeeded([base, result, indent]).toString()));
          for (i = 0, len = stmt.trailingComments.length; i < len; ++i) {
            comment = stmt.trailingComments[i];
            if (tailingToStatement) {
              if (i === 0) {
                result = [result, indent];
              } else {
                result = [result, specialBase];
              }
              result.push(generateComment(comment, specialBase));
            } else {
              result = [result, addIndent(generateComment(comment))];
            }
            if (i !== len - 1 && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result = [result, "\n"];
            }
          }
        }
      }
      return result;
    }
    function generateBlankLines(start, end, result) {
      var j2, newlineCount = 0;
      for (j2 = start; j2 < end; j2++) {
        if (sourceCode[j2] === "\n") {
          newlineCount++;
        }
      }
      for (j2 = 1; j2 < newlineCount; j2++) {
        result.push(newline);
      }
    }
    function parenthesize(text, current, should) {
      if (current < should) {
        return ["(", text, ")"];
      }
      return text;
    }
    function generateVerbatimString(string2) {
      var i, iz, result;
      result = string2.split(/\r\n|\n/);
      for (i = 1, iz = result.length; i < iz; i++) {
        result[i] = newline + base + result[i];
      }
      return result;
    }
    function generateVerbatim(expr, precedence) {
      var verbatim, result, prec;
      verbatim = expr[extra.verbatim];
      if (typeof verbatim === "string") {
        result = parenthesize(generateVerbatimString(verbatim), Precedence.Sequence, precedence);
      } else {
        result = generateVerbatimString(verbatim.content);
        prec = verbatim.precedence != null ? verbatim.precedence : Precedence.Sequence;
        result = parenthesize(result, prec, precedence);
      }
      return toSourceNodeWhenNeeded(result, expr);
    }
    function CodeGenerator() {
    }
    CodeGenerator.prototype.maybeBlock = function(stmt, flags) {
      var result, noLeadingComment, that = this;
      noLeadingComment = !extra.comment || !stmt.leadingComments;
      if (stmt.type === Syntax.BlockStatement && noLeadingComment) {
        return [space, this.generateStatement(stmt, flags)];
      }
      if (stmt.type === Syntax.EmptyStatement && noLeadingComment) {
        return ";";
      }
      withIndent(function() {
        result = [
          newline,
          addIndent(that.generateStatement(stmt, flags))
        ];
      });
      return result;
    };
    CodeGenerator.prototype.maybeBlockSuffix = function(stmt, result) {
      var ends = endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString());
      if (stmt.type === Syntax.BlockStatement && (!extra.comment || !stmt.leadingComments) && !ends) {
        return [result, space];
      }
      if (ends) {
        return [result, base];
      }
      return [result, newline, base];
    };
    function generateIdentifier(node2) {
      return toSourceNodeWhenNeeded(node2.name, node2);
    }
    function generateAsyncPrefix(node2, spaceRequired) {
      return node2.async ? "async" + (spaceRequired ? noEmptySpace() : space) : "";
    }
    function generateStarSuffix(node2) {
      var isGenerator = node2.generator && !extra.moz.starlessGenerator;
      return isGenerator ? "*" + space : "";
    }
    function generateMethodPrefix(prop) {
      var func = prop.value, prefix = "";
      if (func.async) {
        prefix += generateAsyncPrefix(func, !prop.computed);
      }
      if (func.generator) {
        prefix += generateStarSuffix(func) ? "*" : "";
      }
      return prefix;
    }
    CodeGenerator.prototype.generatePattern = function(node2, precedence, flags) {
      if (node2.type === Syntax.Identifier) {
        return generateIdentifier(node2);
      }
      return this.generateExpression(node2, precedence, flags);
    };
    CodeGenerator.prototype.generateFunctionParams = function(node2) {
      var i, iz, result, hasDefault;
      hasDefault = false;
      if (node2.type === Syntax.ArrowFunctionExpression && !node2.rest && (!node2.defaults || node2.defaults.length === 0) && node2.params.length === 1 && node2.params[0].type === Syntax.Identifier) {
        result = [generateAsyncPrefix(node2, true), generateIdentifier(node2.params[0])];
      } else {
        result = node2.type === Syntax.ArrowFunctionExpression ? [generateAsyncPrefix(node2, false)] : [];
        result.push("(");
        if (node2.defaults) {
          hasDefault = true;
        }
        for (i = 0, iz = node2.params.length; i < iz; ++i) {
          if (hasDefault && node2.defaults[i]) {
            result.push(this.generateAssignment(node2.params[i], node2.defaults[i], "=", Precedence.Assignment, E_TTT));
          } else {
            result.push(this.generatePattern(node2.params[i], Precedence.Assignment, E_TTT));
          }
          if (i + 1 < iz) {
            result.push("," + space);
          }
        }
        if (node2.rest) {
          if (node2.params.length) {
            result.push("," + space);
          }
          result.push("...");
          result.push(generateIdentifier(node2.rest));
        }
        result.push(")");
      }
      return result;
    };
    CodeGenerator.prototype.generateFunctionBody = function(node2) {
      var result, expr;
      result = this.generateFunctionParams(node2);
      if (node2.type === Syntax.ArrowFunctionExpression) {
        result.push(space);
        result.push("=>");
      }
      if (node2.expression) {
        result.push(space);
        expr = this.generateExpression(node2.body, Precedence.Assignment, E_TTT);
        if (expr.toString().charAt(0) === "{") {
          expr = ["(", expr, ")"];
        }
        result.push(expr);
      } else {
        result.push(this.maybeBlock(node2.body, S_TTFF));
      }
      return result;
    };
    CodeGenerator.prototype.generateIterationForStatement = function(operator, stmt, flags) {
      var result = ["for" + (stmt.await ? noEmptySpace() + "await" : "") + space + "("], that = this;
      withIndent(function() {
        if (stmt.left.type === Syntax.VariableDeclaration) {
          withIndent(function() {
            result.push(stmt.left.kind + noEmptySpace());
            result.push(that.generateStatement(stmt.left.declarations[0], S_FFFF));
          });
        } else {
          result.push(that.generateExpression(stmt.left, Precedence.Call, E_TTT));
        }
        result = join2(result, operator);
        result = [join2(
          result,
          that.generateExpression(stmt.right, Precedence.Assignment, E_TTT)
        ), ")"];
      });
      result.push(this.maybeBlock(stmt.body, flags));
      return result;
    };
    CodeGenerator.prototype.generatePropertyKey = function(expr, computed) {
      var result = [];
      if (computed) {
        result.push("[");
      }
      result.push(this.generateExpression(expr, Precedence.Assignment, E_TTT));
      if (computed) {
        result.push("]");
      }
      return result;
    };
    CodeGenerator.prototype.generateAssignment = function(left, right, operator, precedence, flags) {
      if (Precedence.Assignment < precedence) {
        flags |= F_ALLOW_IN;
      }
      return parenthesize(
        [
          this.generateExpression(left, Precedence.Call, flags),
          space + operator + space,
          this.generateExpression(right, Precedence.Assignment, flags)
        ],
        Precedence.Assignment,
        precedence
      );
    };
    CodeGenerator.prototype.semicolon = function(flags) {
      if (!semicolons && flags & F_SEMICOLON_OPT) {
        return "";
      }
      return ";";
    };
    CodeGenerator.Statement = {
      BlockStatement: function(stmt, flags) {
        var range3, content, result = ["{", newline], that = this;
        withIndent(function() {
          if (stmt.body.length === 0 && preserveBlankLines) {
            range3 = stmt.range;
            if (range3[1] - range3[0] > 2) {
              content = sourceCode.substring(range3[0] + 1, range3[1] - 1);
              if (content[0] === "\n") {
                result = ["{"];
              }
              result.push(content);
            }
          }
          var i, iz, fragment, bodyFlags;
          bodyFlags = S_TFFF;
          if (flags & F_FUNC_BODY) {
            bodyFlags |= F_DIRECTIVE_CTX;
          }
          for (i = 0, iz = stmt.body.length; i < iz; ++i) {
            if (preserveBlankLines) {
              if (i === 0) {
                if (stmt.body[0].leadingComments) {
                  range3 = stmt.body[0].leadingComments[0].extendedRange;
                  content = sourceCode.substring(range3[0], range3[1]);
                  if (content[0] === "\n") {
                    result = ["{"];
                  }
                }
                if (!stmt.body[0].leadingComments) {
                  generateBlankLines(stmt.range[0], stmt.body[0].range[0], result);
                }
              }
              if (i > 0) {
                if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                  generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
                }
              }
            }
            if (i === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            if (stmt.body[i].leadingComments && preserveBlankLines) {
              fragment = that.generateStatement(stmt.body[i], bodyFlags);
            } else {
              fragment = addIndent(that.generateStatement(stmt.body[i], bodyFlags));
            }
            result.push(fragment);
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              if (preserveBlankLines && i < iz - 1) {
                if (!stmt.body[i + 1].leadingComments) {
                  result.push(newline);
                }
              } else {
                result.push(newline);
              }
            }
            if (preserveBlankLines) {
              if (i === iz - 1) {
                if (!stmt.body[i].trailingComments) {
                  generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
                }
              }
            }
          }
        });
        result.push(addIndent("}"));
        return result;
      },
      BreakStatement: function(stmt, flags) {
        if (stmt.label) {
          return "break " + stmt.label.name + this.semicolon(flags);
        }
        return "break" + this.semicolon(flags);
      },
      ContinueStatement: function(stmt, flags) {
        if (stmt.label) {
          return "continue " + stmt.label.name + this.semicolon(flags);
        }
        return "continue" + this.semicolon(flags);
      },
      ClassBody: function(stmt, flags) {
        var result = ["{", newline], that = this;
        withIndent(function(indent2) {
          var i, iz;
          for (i = 0, iz = stmt.body.length; i < iz; ++i) {
            result.push(indent2);
            result.push(that.generateExpression(stmt.body[i], Precedence.Sequence, E_TTT));
            if (i + 1 < iz) {
              result.push(newline);
            }
          }
        });
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(base);
        result.push("}");
        return result;
      },
      ClassDeclaration: function(stmt, flags) {
        var result, fragment;
        result = ["class"];
        if (stmt.id) {
          result = join2(result, this.generateExpression(stmt.id, Precedence.Sequence, E_TTT));
        }
        if (stmt.superClass) {
          fragment = join2("extends", this.generateExpression(stmt.superClass, Precedence.Unary, E_TTT));
          result = join2(result, fragment);
        }
        result.push(space);
        result.push(this.generateStatement(stmt.body, S_TFFT));
        return result;
      },
      DirectiveStatement: function(stmt, flags) {
        if (extra.raw && stmt.raw) {
          return stmt.raw + this.semicolon(flags);
        }
        return escapeDirective(stmt.directive) + this.semicolon(flags);
      },
      DoWhileStatement: function(stmt, flags) {
        var result = join2("do", this.maybeBlock(stmt.body, S_TFFF));
        result = this.maybeBlockSuffix(stmt.body, result);
        return join2(result, [
          "while" + space + "(",
          this.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
          ")" + this.semicolon(flags)
        ]);
      },
      CatchClause: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          var guard;
          if (stmt.param) {
            result = [
              "catch" + space + "(",
              that.generateExpression(stmt.param, Precedence.Sequence, E_TTT),
              ")"
            ];
            if (stmt.guard) {
              guard = that.generateExpression(stmt.guard, Precedence.Sequence, E_TTT);
              result.splice(2, 0, " if ", guard);
            }
          } else {
            result = ["catch"];
          }
        });
        result.push(this.maybeBlock(stmt.body, S_TFFF));
        return result;
      },
      DebuggerStatement: function(stmt, flags) {
        return "debugger" + this.semicolon(flags);
      },
      EmptyStatement: function(stmt, flags) {
        return ";";
      },
      ExportDefaultDeclaration: function(stmt, flags) {
        var result = ["export"], bodyFlags;
        bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
        result = join2(result, "default");
        if (isStatement(stmt.declaration)) {
          result = join2(result, this.generateStatement(stmt.declaration, bodyFlags));
        } else {
          result = join2(result, this.generateExpression(stmt.declaration, Precedence.Assignment, E_TTT) + this.semicolon(flags));
        }
        return result;
      },
      ExportNamedDeclaration: function(stmt, flags) {
        var result = ["export"], bodyFlags, that = this;
        bodyFlags = flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF;
        if (stmt.declaration) {
          return join2(result, this.generateStatement(stmt.declaration, bodyFlags));
        }
        if (stmt.specifiers) {
          if (stmt.specifiers.length === 0) {
            result = join2(result, "{" + space + "}");
          } else if (stmt.specifiers[0].type === Syntax.ExportBatchSpecifier) {
            result = join2(result, this.generateExpression(stmt.specifiers[0], Precedence.Sequence, E_TTT));
          } else {
            result = join2(result, "{");
            withIndent(function(indent2) {
              var i, iz;
              result.push(newline);
              for (i = 0, iz = stmt.specifiers.length; i < iz; ++i) {
                result.push(indent2);
                result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                if (i + 1 < iz) {
                  result.push("," + newline);
                }
              }
            });
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
              result.push(newline);
            }
            result.push(base + "}");
          }
          if (stmt.source) {
            result = join2(result, [
              "from" + space,
              // ModuleSpecifier
              this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
              this.semicolon(flags)
            ]);
          } else {
            result.push(this.semicolon(flags));
          }
        }
        return result;
      },
      ExportAllDeclaration: function(stmt, flags) {
        return [
          "export" + space,
          "*" + space,
          "from" + space,
          // ModuleSpecifier
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ];
      },
      ExpressionStatement: function(stmt, flags) {
        var result, fragment;
        function isClassPrefixed(fragment2) {
          var code2;
          if (fragment2.slice(0, 5) !== "class") {
            return false;
          }
          code2 = fragment2.charCodeAt(5);
          return code2 === 123 || esutils.code.isWhiteSpace(code2) || esutils.code.isLineTerminator(code2);
        }
        function isFunctionPrefixed(fragment2) {
          var code2;
          if (fragment2.slice(0, 8) !== "function") {
            return false;
          }
          code2 = fragment2.charCodeAt(8);
          return code2 === 40 || esutils.code.isWhiteSpace(code2) || code2 === 42 || esutils.code.isLineTerminator(code2);
        }
        function isAsyncPrefixed(fragment2) {
          var code2, i, iz;
          if (fragment2.slice(0, 5) !== "async") {
            return false;
          }
          if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(5))) {
            return false;
          }
          for (i = 6, iz = fragment2.length; i < iz; ++i) {
            if (!esutils.code.isWhiteSpace(fragment2.charCodeAt(i))) {
              break;
            }
          }
          if (i === iz) {
            return false;
          }
          if (fragment2.slice(i, i + 8) !== "function") {
            return false;
          }
          code2 = fragment2.charCodeAt(i + 8);
          return code2 === 40 || esutils.code.isWhiteSpace(code2) || code2 === 42 || esutils.code.isLineTerminator(code2);
        }
        result = [this.generateExpression(stmt.expression, Precedence.Sequence, E_TTT)];
        fragment = toSourceNodeWhenNeeded(result).toString();
        if (fragment.charCodeAt(0) === 123 || // ObjectExpression
        isClassPrefixed(fragment) || isFunctionPrefixed(fragment) || isAsyncPrefixed(fragment) || directive && flags & F_DIRECTIVE_CTX && stmt.expression.type === Syntax.Literal && typeof stmt.expression.value === "string") {
          result = ["(", result, ")" + this.semicolon(flags)];
        } else {
          result.push(this.semicolon(flags));
        }
        return result;
      },
      ImportDeclaration: function(stmt, flags) {
        var result, cursor, that = this;
        if (stmt.specifiers.length === 0) {
          return [
            "import",
            space,
            // ModuleSpecifier
            this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
            this.semicolon(flags)
          ];
        }
        result = [
          "import"
        ];
        cursor = 0;
        if (stmt.specifiers[cursor].type === Syntax.ImportDefaultSpecifier) {
          result = join2(result, [
            this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
          ]);
          ++cursor;
        }
        if (stmt.specifiers[cursor]) {
          if (cursor !== 0) {
            result.push(",");
          }
          if (stmt.specifiers[cursor].type === Syntax.ImportNamespaceSpecifier) {
            result = join2(result, [
              space,
              this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT)
            ]);
          } else {
            result.push(space + "{");
            if (stmt.specifiers.length - cursor === 1) {
              result.push(space);
              result.push(this.generateExpression(stmt.specifiers[cursor], Precedence.Sequence, E_TTT));
              result.push(space + "}" + space);
            } else {
              withIndent(function(indent2) {
                var i, iz;
                result.push(newline);
                for (i = cursor, iz = stmt.specifiers.length; i < iz; ++i) {
                  result.push(indent2);
                  result.push(that.generateExpression(stmt.specifiers[i], Precedence.Sequence, E_TTT));
                  if (i + 1 < iz) {
                    result.push("," + newline);
                  }
                }
              });
              if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
                result.push(newline);
              }
              result.push(base + "}" + space);
            }
          }
        }
        result = join2(result, [
          "from" + space,
          // ModuleSpecifier
          this.generateExpression(stmt.source, Precedence.Sequence, E_TTT),
          this.semicolon(flags)
        ]);
        return result;
      },
      VariableDeclarator: function(stmt, flags) {
        var itemFlags = flags & F_ALLOW_IN ? E_TTT : E_FTT;
        if (stmt.init) {
          return [
            this.generateExpression(stmt.id, Precedence.Assignment, itemFlags),
            space,
            "=",
            space,
            this.generateExpression(stmt.init, Precedence.Assignment, itemFlags)
          ];
        }
        return this.generatePattern(stmt.id, Precedence.Assignment, itemFlags);
      },
      VariableDeclaration: function(stmt, flags) {
        var result, i, iz, node2, bodyFlags, that = this;
        result = [stmt.kind];
        bodyFlags = flags & F_ALLOW_IN ? S_TFFF : S_FFFF;
        function block() {
          node2 = stmt.declarations[0];
          if (extra.comment && node2.leadingComments) {
            result.push("\n");
            result.push(addIndent(that.generateStatement(node2, bodyFlags)));
          } else {
            result.push(noEmptySpace());
            result.push(that.generateStatement(node2, bodyFlags));
          }
          for (i = 1, iz = stmt.declarations.length; i < iz; ++i) {
            node2 = stmt.declarations[i];
            if (extra.comment && node2.leadingComments) {
              result.push("," + newline);
              result.push(addIndent(that.generateStatement(node2, bodyFlags)));
            } else {
              result.push("," + space);
              result.push(that.generateStatement(node2, bodyFlags));
            }
          }
        }
        if (stmt.declarations.length > 1) {
          withIndent(block);
        } else {
          block();
        }
        result.push(this.semicolon(flags));
        return result;
      },
      ThrowStatement: function(stmt, flags) {
        return [join2(
          "throw",
          this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
        ), this.semicolon(flags)];
      },
      TryStatement: function(stmt, flags) {
        var result, i, iz, guardedHandlers;
        result = ["try", this.maybeBlock(stmt.block, S_TFFF)];
        result = this.maybeBlockSuffix(stmt.block, result);
        if (stmt.handlers) {
          for (i = 0, iz = stmt.handlers.length; i < iz; ++i) {
            result = join2(result, this.generateStatement(stmt.handlers[i], S_TFFF));
            if (stmt.finalizer || i + 1 !== iz) {
              result = this.maybeBlockSuffix(stmt.handlers[i].body, result);
            }
          }
        } else {
          guardedHandlers = stmt.guardedHandlers || [];
          for (i = 0, iz = guardedHandlers.length; i < iz; ++i) {
            result = join2(result, this.generateStatement(guardedHandlers[i], S_TFFF));
            if (stmt.finalizer || i + 1 !== iz) {
              result = this.maybeBlockSuffix(guardedHandlers[i].body, result);
            }
          }
          if (stmt.handler) {
            if (Array.isArray(stmt.handler)) {
              for (i = 0, iz = stmt.handler.length; i < iz; ++i) {
                result = join2(result, this.generateStatement(stmt.handler[i], S_TFFF));
                if (stmt.finalizer || i + 1 !== iz) {
                  result = this.maybeBlockSuffix(stmt.handler[i].body, result);
                }
              }
            } else {
              result = join2(result, this.generateStatement(stmt.handler, S_TFFF));
              if (stmt.finalizer) {
                result = this.maybeBlockSuffix(stmt.handler.body, result);
              }
            }
          }
        }
        if (stmt.finalizer) {
          result = join2(result, ["finally", this.maybeBlock(stmt.finalizer, S_TFFF)]);
        }
        return result;
      },
      SwitchStatement: function(stmt, flags) {
        var result, fragment, i, iz, bodyFlags, that = this;
        withIndent(function() {
          result = [
            "switch" + space + "(",
            that.generateExpression(stmt.discriminant, Precedence.Sequence, E_TTT),
            ")" + space + "{" + newline
          ];
        });
        if (stmt.cases) {
          bodyFlags = S_TFFF;
          for (i = 0, iz = stmt.cases.length; i < iz; ++i) {
            if (i === iz - 1) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            fragment = addIndent(this.generateStatement(stmt.cases[i], bodyFlags));
            result.push(fragment);
            if (!endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
        }
        result.push(addIndent("}"));
        return result;
      },
      SwitchCase: function(stmt, flags) {
        var result, fragment, i, iz, bodyFlags, that = this;
        withIndent(function() {
          if (stmt.test) {
            result = [
              join2("case", that.generateExpression(stmt.test, Precedence.Sequence, E_TTT)),
              ":"
            ];
          } else {
            result = ["default:"];
          }
          i = 0;
          iz = stmt.consequent.length;
          if (iz && stmt.consequent[0].type === Syntax.BlockStatement) {
            fragment = that.maybeBlock(stmt.consequent[0], S_TFFF);
            result.push(fragment);
            i = 1;
          }
          if (i !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
            result.push(newline);
          }
          bodyFlags = S_TFFF;
          for (; i < iz; ++i) {
            if (i === iz - 1 && flags & F_SEMICOLON_OPT) {
              bodyFlags |= F_SEMICOLON_OPT;
            }
            fragment = addIndent(that.generateStatement(stmt.consequent[i], bodyFlags));
            result.push(fragment);
            if (i + 1 !== iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
              result.push(newline);
            }
          }
        });
        return result;
      },
      IfStatement: function(stmt, flags) {
        var result, bodyFlags, semicolonOptional, that = this;
        withIndent(function() {
          result = [
            "if" + space + "(",
            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        semicolonOptional = flags & F_SEMICOLON_OPT;
        bodyFlags = S_TFFF;
        if (semicolonOptional) {
          bodyFlags |= F_SEMICOLON_OPT;
        }
        if (stmt.alternate) {
          result.push(this.maybeBlock(stmt.consequent, S_TFFF));
          result = this.maybeBlockSuffix(stmt.consequent, result);
          if (stmt.alternate.type === Syntax.IfStatement) {
            result = join2(result, ["else ", this.generateStatement(stmt.alternate, bodyFlags)]);
          } else {
            result = join2(result, join2("else", this.maybeBlock(stmt.alternate, bodyFlags)));
          }
        } else {
          result.push(this.maybeBlock(stmt.consequent, bodyFlags));
        }
        return result;
      },
      ForStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = ["for" + space + "("];
          if (stmt.init) {
            if (stmt.init.type === Syntax.VariableDeclaration) {
              result.push(that.generateStatement(stmt.init, S_FFFF));
            } else {
              result.push(that.generateExpression(stmt.init, Precedence.Sequence, E_FTT));
              result.push(";");
            }
          } else {
            result.push(";");
          }
          if (stmt.test) {
            result.push(space);
            result.push(that.generateExpression(stmt.test, Precedence.Sequence, E_TTT));
            result.push(";");
          } else {
            result.push(";");
          }
          if (stmt.update) {
            result.push(space);
            result.push(that.generateExpression(stmt.update, Precedence.Sequence, E_TTT));
            result.push(")");
          } else {
            result.push(")");
          }
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      },
      ForInStatement: function(stmt, flags) {
        return this.generateIterationForStatement("in", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      },
      ForOfStatement: function(stmt, flags) {
        return this.generateIterationForStatement("of", stmt, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF);
      },
      LabeledStatement: function(stmt, flags) {
        return [stmt.label.name + ":", this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF)];
      },
      Program: function(stmt, flags) {
        var result, fragment, i, iz, bodyFlags;
        iz = stmt.body.length;
        result = [safeConcatenation && iz > 0 ? "\n" : ""];
        bodyFlags = S_TFTF;
        for (i = 0; i < iz; ++i) {
          if (!safeConcatenation && i === iz - 1) {
            bodyFlags |= F_SEMICOLON_OPT;
          }
          if (preserveBlankLines) {
            if (i === 0) {
              if (!stmt.body[0].leadingComments) {
                generateBlankLines(stmt.range[0], stmt.body[i].range[0], result);
              }
            }
            if (i > 0) {
              if (!stmt.body[i - 1].trailingComments && !stmt.body[i].leadingComments) {
                generateBlankLines(stmt.body[i - 1].range[1], stmt.body[i].range[0], result);
              }
            }
          }
          fragment = addIndent(this.generateStatement(stmt.body[i], bodyFlags));
          result.push(fragment);
          if (i + 1 < iz && !endsWithLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            if (preserveBlankLines) {
              if (!stmt.body[i + 1].leadingComments) {
                result.push(newline);
              }
            } else {
              result.push(newline);
            }
          }
          if (preserveBlankLines) {
            if (i === iz - 1) {
              if (!stmt.body[i].trailingComments) {
                generateBlankLines(stmt.body[i].range[1], stmt.range[1], result);
              }
            }
          }
        }
        return result;
      },
      FunctionDeclaration: function(stmt, flags) {
        return [
          generateAsyncPrefix(stmt, true),
          "function",
          generateStarSuffix(stmt) || noEmptySpace(),
          stmt.id ? generateIdentifier(stmt.id) : "",
          this.generateFunctionBody(stmt)
        ];
      },
      ReturnStatement: function(stmt, flags) {
        if (stmt.argument) {
          return [join2(
            "return",
            this.generateExpression(stmt.argument, Precedence.Sequence, E_TTT)
          ), this.semicolon(flags)];
        }
        return ["return" + this.semicolon(flags)];
      },
      WhileStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = [
            "while" + space + "(",
            that.generateExpression(stmt.test, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      },
      WithStatement: function(stmt, flags) {
        var result, that = this;
        withIndent(function() {
          result = [
            "with" + space + "(",
            that.generateExpression(stmt.object, Precedence.Sequence, E_TTT),
            ")"
          ];
        });
        result.push(this.maybeBlock(stmt.body, flags & F_SEMICOLON_OPT ? S_TFFT : S_TFFF));
        return result;
      }
    };
    merge2(CodeGenerator.prototype, CodeGenerator.Statement);
    CodeGenerator.Expression = {
      SequenceExpression: function(expr, precedence, flags) {
        var result, i, iz;
        if (Precedence.Sequence < precedence) {
          flags |= F_ALLOW_IN;
        }
        result = [];
        for (i = 0, iz = expr.expressions.length; i < iz; ++i) {
          result.push(this.generateExpression(expr.expressions[i], Precedence.Assignment, flags));
          if (i + 1 < iz) {
            result.push("," + space);
          }
        }
        return parenthesize(result, Precedence.Sequence, precedence);
      },
      AssignmentExpression: function(expr, precedence, flags) {
        return this.generateAssignment(expr.left, expr.right, expr.operator, precedence, flags);
      },
      ArrowFunctionExpression: function(expr, precedence, flags) {
        return parenthesize(this.generateFunctionBody(expr), Precedence.ArrowFunction, precedence);
      },
      ConditionalExpression: function(expr, precedence, flags) {
        if (Precedence.Conditional < precedence) {
          flags |= F_ALLOW_IN;
        }
        return parenthesize(
          [
            this.generateExpression(expr.test, Precedence.Coalesce, flags),
            space + "?" + space,
            this.generateExpression(expr.consequent, Precedence.Assignment, flags),
            space + ":" + space,
            this.generateExpression(expr.alternate, Precedence.Assignment, flags)
          ],
          Precedence.Conditional,
          precedence
        );
      },
      LogicalExpression: function(expr, precedence, flags) {
        if (expr.operator === "??") {
          flags |= F_FOUND_COALESCE;
        }
        return this.BinaryExpression(expr, precedence, flags);
      },
      BinaryExpression: function(expr, precedence, flags) {
        var result, leftPrecedence, rightPrecedence, currentPrecedence, fragment, leftSource;
        currentPrecedence = BinaryPrecedence[expr.operator];
        leftPrecedence = expr.operator === "**" ? Precedence.Postfix : currentPrecedence;
        rightPrecedence = expr.operator === "**" ? currentPrecedence : currentPrecedence + 1;
        if (currentPrecedence < precedence) {
          flags |= F_ALLOW_IN;
        }
        fragment = this.generateExpression(expr.left, leftPrecedence, flags);
        leftSource = fragment.toString();
        if (leftSource.charCodeAt(leftSource.length - 1) === 47 && esutils.code.isIdentifierPartES5(expr.operator.charCodeAt(0))) {
          result = [fragment, noEmptySpace(), expr.operator];
        } else {
          result = join2(fragment, expr.operator);
        }
        fragment = this.generateExpression(expr.right, rightPrecedence, flags);
        if (expr.operator === "/" && fragment.toString().charAt(0) === "/" || expr.operator.slice(-1) === "<" && fragment.toString().slice(0, 3) === "!--") {
          result.push(noEmptySpace());
          result.push(fragment);
        } else {
          result = join2(result, fragment);
        }
        if (expr.operator === "in" && !(flags & F_ALLOW_IN)) {
          return ["(", result, ")"];
        }
        if ((expr.operator === "||" || expr.operator === "&&") && flags & F_FOUND_COALESCE) {
          return ["(", result, ")"];
        }
        return parenthesize(result, currentPrecedence, precedence);
      },
      CallExpression: function(expr, precedence, flags) {
        var result, i, iz;
        result = [this.generateExpression(expr.callee, Precedence.Call, E_TTF)];
        if (expr.optional) {
          result.push("?.");
        }
        result.push("(");
        for (i = 0, iz = expr["arguments"].length; i < iz; ++i) {
          result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
          if (i + 1 < iz) {
            result.push("," + space);
          }
        }
        result.push(")");
        if (!(flags & F_ALLOW_CALL)) {
          return ["(", result, ")"];
        }
        return parenthesize(result, Precedence.Call, precedence);
      },
      ChainExpression: function(expr, precedence, flags) {
        if (Precedence.OptionalChaining < precedence) {
          flags |= F_ALLOW_CALL;
        }
        var result = this.generateExpression(expr.expression, Precedence.OptionalChaining, flags);
        return parenthesize(result, Precedence.OptionalChaining, precedence);
      },
      NewExpression: function(expr, precedence, flags) {
        var result, length, i, iz, itemFlags;
        length = expr["arguments"].length;
        itemFlags = flags & F_ALLOW_UNPARATH_NEW && !parentheses && length === 0 ? E_TFT : E_TFF;
        result = join2(
          "new",
          this.generateExpression(expr.callee, Precedence.New, itemFlags)
        );
        if (!(flags & F_ALLOW_UNPARATH_NEW) || parentheses || length > 0) {
          result.push("(");
          for (i = 0, iz = length; i < iz; ++i) {
            result.push(this.generateExpression(expr["arguments"][i], Precedence.Assignment, E_TTT));
            if (i + 1 < iz) {
              result.push("," + space);
            }
          }
          result.push(")");
        }
        return parenthesize(result, Precedence.New, precedence);
      },
      MemberExpression: function(expr, precedence, flags) {
        var result, fragment;
        result = [this.generateExpression(expr.object, Precedence.Call, flags & F_ALLOW_CALL ? E_TTF : E_TFF)];
        if (expr.computed) {
          if (expr.optional) {
            result.push("?.");
          }
          result.push("[");
          result.push(this.generateExpression(expr.property, Precedence.Sequence, flags & F_ALLOW_CALL ? E_TTT : E_TFT));
          result.push("]");
        } else {
          if (!expr.optional && expr.object.type === Syntax.Literal && typeof expr.object.value === "number") {
            fragment = toSourceNodeWhenNeeded(result).toString();
            if (fragment.indexOf(".") < 0 && !/[eExX]/.test(fragment) && esutils.code.isDecimalDigit(fragment.charCodeAt(fragment.length - 1)) && !(fragment.length >= 2 && fragment.charCodeAt(0) === 48)) {
              result.push(" ");
            }
          }
          result.push(expr.optional ? "?." : ".");
          result.push(generateIdentifier(expr.property));
        }
        return parenthesize(result, Precedence.Member, precedence);
      },
      MetaProperty: function(expr, precedence, flags) {
        var result;
        result = [];
        result.push(typeof expr.meta === "string" ? expr.meta : generateIdentifier(expr.meta));
        result.push(".");
        result.push(typeof expr.property === "string" ? expr.property : generateIdentifier(expr.property));
        return parenthesize(result, Precedence.Member, precedence);
      },
      UnaryExpression: function(expr, precedence, flags) {
        var result, fragment, rightCharCode, leftSource, leftCharCode;
        fragment = this.generateExpression(expr.argument, Precedence.Unary, E_TTT);
        if (space === "") {
          result = join2(expr.operator, fragment);
        } else {
          result = [expr.operator];
          if (expr.operator.length > 2) {
            result = join2(result, fragment);
          } else {
            leftSource = toSourceNodeWhenNeeded(result).toString();
            leftCharCode = leftSource.charCodeAt(leftSource.length - 1);
            rightCharCode = fragment.toString().charCodeAt(0);
            if ((leftCharCode === 43 || leftCharCode === 45) && leftCharCode === rightCharCode || esutils.code.isIdentifierPartES5(leftCharCode) && esutils.code.isIdentifierPartES5(rightCharCode)) {
              result.push(noEmptySpace());
              result.push(fragment);
            } else {
              result.push(fragment);
            }
          }
        }
        return parenthesize(result, Precedence.Unary, precedence);
      },
      YieldExpression: function(expr, precedence, flags) {
        var result;
        if (expr.delegate) {
          result = "yield*";
        } else {
          result = "yield";
        }
        if (expr.argument) {
          result = join2(
            result,
            this.generateExpression(expr.argument, Precedence.Yield, E_TTT)
          );
        }
        return parenthesize(result, Precedence.Yield, precedence);
      },
      AwaitExpression: function(expr, precedence, flags) {
        var result = join2(
          expr.all ? "await*" : "await",
          this.generateExpression(expr.argument, Precedence.Await, E_TTT)
        );
        return parenthesize(result, Precedence.Await, precedence);
      },
      UpdateExpression: function(expr, precedence, flags) {
        if (expr.prefix) {
          return parenthesize(
            [
              expr.operator,
              this.generateExpression(expr.argument, Precedence.Unary, E_TTT)
            ],
            Precedence.Unary,
            precedence
          );
        }
        return parenthesize(
          [
            this.generateExpression(expr.argument, Precedence.Postfix, E_TTT),
            expr.operator
          ],
          Precedence.Postfix,
          precedence
        );
      },
      FunctionExpression: function(expr, precedence, flags) {
        var result = [
          generateAsyncPrefix(expr, true),
          "function"
        ];
        if (expr.id) {
          result.push(generateStarSuffix(expr) || noEmptySpace());
          result.push(generateIdentifier(expr.id));
        } else {
          result.push(generateStarSuffix(expr) || space);
        }
        result.push(this.generateFunctionBody(expr));
        return result;
      },
      ArrayPattern: function(expr, precedence, flags) {
        return this.ArrayExpression(expr, precedence, flags, true);
      },
      ArrayExpression: function(expr, precedence, flags, isPattern) {
        var result, multiline, that = this;
        if (!expr.elements.length) {
          return "[]";
        }
        multiline = isPattern ? false : expr.elements.length > 1;
        result = ["[", multiline ? newline : ""];
        withIndent(function(indent2) {
          var i, iz;
          for (i = 0, iz = expr.elements.length; i < iz; ++i) {
            if (!expr.elements[i]) {
              if (multiline) {
                result.push(indent2);
              }
              if (i + 1 === iz) {
                result.push(",");
              }
            } else {
              result.push(multiline ? indent2 : "");
              result.push(that.generateExpression(expr.elements[i], Precedence.Assignment, E_TTT));
            }
            if (i + 1 < iz) {
              result.push("," + (multiline ? newline : space));
            }
          }
        });
        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(multiline ? base : "");
        result.push("]");
        return result;
      },
      RestElement: function(expr, precedence, flags) {
        return "..." + this.generatePattern(expr.argument);
      },
      ClassExpression: function(expr, precedence, flags) {
        var result, fragment;
        result = ["class"];
        if (expr.id) {
          result = join2(result, this.generateExpression(expr.id, Precedence.Sequence, E_TTT));
        }
        if (expr.superClass) {
          fragment = join2("extends", this.generateExpression(expr.superClass, Precedence.Unary, E_TTT));
          result = join2(result, fragment);
        }
        result.push(space);
        result.push(this.generateStatement(expr.body, S_TFFT));
        return result;
      },
      MethodDefinition: function(expr, precedence, flags) {
        var result, fragment;
        if (expr["static"]) {
          result = ["static" + space];
        } else {
          result = [];
        }
        if (expr.kind === "get" || expr.kind === "set") {
          fragment = [
            join2(expr.kind, this.generatePropertyKey(expr.key, expr.computed)),
            this.generateFunctionBody(expr.value)
          ];
        } else {
          fragment = [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        return join2(result, fragment);
      },
      Property: function(expr, precedence, flags) {
        if (expr.kind === "get" || expr.kind === "set") {
          return [
            expr.kind,
            noEmptySpace(),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        if (expr.shorthand) {
          if (expr.value.type === "AssignmentPattern") {
            return this.AssignmentPattern(expr.value, Precedence.Sequence, E_TTT);
          }
          return this.generatePropertyKey(expr.key, expr.computed);
        }
        if (expr.method) {
          return [
            generateMethodPrefix(expr),
            this.generatePropertyKey(expr.key, expr.computed),
            this.generateFunctionBody(expr.value)
          ];
        }
        return [
          this.generatePropertyKey(expr.key, expr.computed),
          ":" + space,
          this.generateExpression(expr.value, Precedence.Assignment, E_TTT)
        ];
      },
      ObjectExpression: function(expr, precedence, flags) {
        var multiline, result, fragment, that = this;
        if (!expr.properties.length) {
          return "{}";
        }
        multiline = expr.properties.length > 1;
        withIndent(function() {
          fragment = that.generateExpression(expr.properties[0], Precedence.Sequence, E_TTT);
        });
        if (!multiline) {
          if (!hasLineTerminator(toSourceNodeWhenNeeded(fragment).toString())) {
            return ["{", space, fragment, space, "}"];
          }
        }
        withIndent(function(indent2) {
          var i, iz;
          result = ["{", newline, indent2, fragment];
          if (multiline) {
            result.push("," + newline);
            for (i = 1, iz = expr.properties.length; i < iz; ++i) {
              result.push(indent2);
              result.push(that.generateExpression(expr.properties[i], Precedence.Sequence, E_TTT));
              if (i + 1 < iz) {
                result.push("," + newline);
              }
            }
          }
        });
        if (!endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(base);
        result.push("}");
        return result;
      },
      AssignmentPattern: function(expr, precedence, flags) {
        return this.generateAssignment(expr.left, expr.right, "=", precedence, flags);
      },
      ObjectPattern: function(expr, precedence, flags) {
        var result, i, iz, multiline, property, that = this;
        if (!expr.properties.length) {
          return "{}";
        }
        multiline = false;
        if (expr.properties.length === 1) {
          property = expr.properties[0];
          if (property.type === Syntax.Property && property.value.type !== Syntax.Identifier) {
            multiline = true;
          }
        } else {
          for (i = 0, iz = expr.properties.length; i < iz; ++i) {
            property = expr.properties[i];
            if (property.type === Syntax.Property && !property.shorthand) {
              multiline = true;
              break;
            }
          }
        }
        result = ["{", multiline ? newline : ""];
        withIndent(function(indent2) {
          var i2, iz2;
          for (i2 = 0, iz2 = expr.properties.length; i2 < iz2; ++i2) {
            result.push(multiline ? indent2 : "");
            result.push(that.generateExpression(expr.properties[i2], Precedence.Sequence, E_TTT));
            if (i2 + 1 < iz2) {
              result.push("," + (multiline ? newline : space));
            }
          }
        });
        if (multiline && !endsWithLineTerminator(toSourceNodeWhenNeeded(result).toString())) {
          result.push(newline);
        }
        result.push(multiline ? base : "");
        result.push("}");
        return result;
      },
      ThisExpression: function(expr, precedence, flags) {
        return "this";
      },
      Super: function(expr, precedence, flags) {
        return "super";
      },
      Identifier: function(expr, precedence, flags) {
        return generateIdentifier(expr);
      },
      ImportDefaultSpecifier: function(expr, precedence, flags) {
        return generateIdentifier(expr.id || expr.local);
      },
      ImportNamespaceSpecifier: function(expr, precedence, flags) {
        var result = ["*"];
        var id = expr.id || expr.local;
        if (id) {
          result.push(space + "as" + noEmptySpace() + generateIdentifier(id));
        }
        return result;
      },
      ImportSpecifier: function(expr, precedence, flags) {
        var imported = expr.imported;
        var result = [imported.name];
        var local = expr.local;
        if (local && local.name !== imported.name) {
          result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(local));
        }
        return result;
      },
      ExportSpecifier: function(expr, precedence, flags) {
        var local = expr.local;
        var result = [local.name];
        var exported = expr.exported;
        if (exported && exported.name !== local.name) {
          result.push(noEmptySpace() + "as" + noEmptySpace() + generateIdentifier(exported));
        }
        return result;
      },
      Literal: function(expr, precedence, flags) {
        var raw;
        if (expr.hasOwnProperty("raw") && parse2 && extra.raw) {
          try {
            raw = parse2(expr.raw).body[0].expression;
            if (raw.type === Syntax.Literal) {
              if (raw.value === expr.value) {
                return expr.raw;
              }
            }
          } catch (e) {
          }
        }
        if (expr.regex) {
          return "/" + expr.regex.pattern + "/" + expr.regex.flags;
        }
        if (typeof expr.value === "bigint") {
          return expr.value.toString() + "n";
        }
        if (expr.bigint) {
          return expr.bigint + "n";
        }
        if (expr.value === null) {
          return "null";
        }
        if (typeof expr.value === "string") {
          return escapeString(expr.value);
        }
        if (typeof expr.value === "number") {
          return generateNumber(expr.value);
        }
        if (typeof expr.value === "boolean") {
          return expr.value ? "true" : "false";
        }
        return generateRegExp(expr.value);
      },
      GeneratorExpression: function(expr, precedence, flags) {
        return this.ComprehensionExpression(expr, precedence, flags);
      },
      ComprehensionExpression: function(expr, precedence, flags) {
        var result, i, iz, fragment, that = this;
        result = expr.type === Syntax.GeneratorExpression ? ["("] : ["["];
        if (extra.moz.comprehensionExpressionStartsWithAssignment) {
          fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
          result.push(fragment);
        }
        if (expr.blocks) {
          withIndent(function() {
            for (i = 0, iz = expr.blocks.length; i < iz; ++i) {
              fragment = that.generateExpression(expr.blocks[i], Precedence.Sequence, E_TTT);
              if (i > 0 || extra.moz.comprehensionExpressionStartsWithAssignment) {
                result = join2(result, fragment);
              } else {
                result.push(fragment);
              }
            }
          });
        }
        if (expr.filter) {
          result = join2(result, "if" + space);
          fragment = this.generateExpression(expr.filter, Precedence.Sequence, E_TTT);
          result = join2(result, ["(", fragment, ")"]);
        }
        if (!extra.moz.comprehensionExpressionStartsWithAssignment) {
          fragment = this.generateExpression(expr.body, Precedence.Assignment, E_TTT);
          result = join2(result, fragment);
        }
        result.push(expr.type === Syntax.GeneratorExpression ? ")" : "]");
        return result;
      },
      ComprehensionBlock: function(expr, precedence, flags) {
        var fragment;
        if (expr.left.type === Syntax.VariableDeclaration) {
          fragment = [
            expr.left.kind,
            noEmptySpace(),
            this.generateStatement(expr.left.declarations[0], S_FFFF)
          ];
        } else {
          fragment = this.generateExpression(expr.left, Precedence.Call, E_TTT);
        }
        fragment = join2(fragment, expr.of ? "of" : "in");
        fragment = join2(fragment, this.generateExpression(expr.right, Precedence.Sequence, E_TTT));
        return ["for" + space + "(", fragment, ")"];
      },
      SpreadElement: function(expr, precedence, flags) {
        return [
          "...",
          this.generateExpression(expr.argument, Precedence.Assignment, E_TTT)
        ];
      },
      TaggedTemplateExpression: function(expr, precedence, flags) {
        var itemFlags = E_TTF;
        if (!(flags & F_ALLOW_CALL)) {
          itemFlags = E_TFF;
        }
        var result = [
          this.generateExpression(expr.tag, Precedence.Call, itemFlags),
          this.generateExpression(expr.quasi, Precedence.Primary, E_FFT)
        ];
        return parenthesize(result, Precedence.TaggedTemplate, precedence);
      },
      TemplateElement: function(expr, precedence, flags) {
        return expr.value.raw;
      },
      TemplateLiteral: function(expr, precedence, flags) {
        var result, i, iz;
        result = ["`"];
        for (i = 0, iz = expr.quasis.length; i < iz; ++i) {
          result.push(this.generateExpression(expr.quasis[i], Precedence.Primary, E_TTT));
          if (i + 1 < iz) {
            result.push("${" + space);
            result.push(this.generateExpression(expr.expressions[i], Precedence.Sequence, E_TTT));
            result.push(space + "}");
          }
        }
        result.push("`");
        return result;
      },
      ModuleSpecifier: function(expr, precedence, flags) {
        return this.Literal(expr, precedence, flags);
      },
      ImportExpression: function(expr, precedence, flag) {
        return parenthesize([
          "import(",
          this.generateExpression(expr.source, Precedence.Assignment, E_TTT),
          ")"
        ], Precedence.Call, precedence);
      }
    };
    merge2(CodeGenerator.prototype, CodeGenerator.Expression);
    CodeGenerator.prototype.generateExpression = function(expr, precedence, flags) {
      var result, type3;
      type3 = expr.type || Syntax.Property;
      if (extra.verbatim && expr.hasOwnProperty(extra.verbatim)) {
        return generateVerbatim(expr, precedence);
      }
      result = this[type3](expr, precedence, flags);
      if (extra.comment) {
        result = addComments(expr, result);
      }
      return toSourceNodeWhenNeeded(result, expr);
    };
    CodeGenerator.prototype.generateStatement = function(stmt, flags) {
      var result, fragment;
      result = this[stmt.type](stmt, flags);
      if (extra.comment) {
        result = addComments(stmt, result);
      }
      fragment = toSourceNodeWhenNeeded(result).toString();
      if (stmt.type === Syntax.Program && !safeConcatenation && newline === "" && fragment.charAt(fragment.length - 1) === "\n") {
        result = sourceMap2 ? toSourceNodeWhenNeeded(result).replaceRight(/\s+$/, "") : fragment.replace(/\s+$/, "");
      }
      return toSourceNodeWhenNeeded(result, stmt);
    };
    function generateInternal(node2) {
      var codegen;
      codegen = new CodeGenerator();
      if (isStatement(node2)) {
        return codegen.generateStatement(node2, S_TFFF);
      }
      if (isExpression(node2)) {
        return codegen.generateExpression(node2, Precedence.Sequence, E_TTT);
      }
      throw new Error("Unknown node type: " + node2.type);
    }
    function generate2(node2, options) {
      var defaultOptions = getDefaultOptions(), result, pair;
      if (options != null) {
        if (typeof options.indent === "string") {
          defaultOptions.format.indent.style = options.indent;
        }
        if (typeof options.base === "number") {
          defaultOptions.format.indent.base = options.base;
        }
        options = updateDeeply(defaultOptions, options);
        indent = options.format.indent.style;
        if (typeof options.base === "string") {
          base = options.base;
        } else {
          base = stringRepeat(indent, options.format.indent.base);
        }
      } else {
        options = defaultOptions;
        indent = options.format.indent.style;
        base = stringRepeat(indent, options.format.indent.base);
      }
      json3 = options.format.json;
      renumber = options.format.renumber;
      hexadecimal = json3 ? false : options.format.hexadecimal;
      quotes = json3 ? "double" : options.format.quotes;
      escapeless = options.format.escapeless;
      newline = options.format.newline;
      space = options.format.space;
      if (options.format.compact) {
        newline = space = indent = base = "";
      }
      parentheses = options.format.parentheses;
      semicolons = options.format.semicolons;
      safeConcatenation = options.format.safeConcatenation;
      directive = options.directive;
      parse2 = json3 ? null : options.parse;
      sourceMap2 = options.sourceMap;
      sourceCode = options.sourceCode;
      preserveBlankLines = options.format.preserveBlankLines && sourceCode !== null;
      extra = options;
      if (sourceMap2) {
        if (!exports.browser) {
          SourceNode = requireSourceMap().SourceNode;
        } else {
          SourceNode = commonjsGlobal.sourceMap.SourceNode;
        }
      }
      result = generateInternal(node2);
      if (!sourceMap2) {
        pair = { code: result.toString(), map: null };
        return options.sourceMapWithCode ? pair : pair.code;
      }
      pair = result.toStringWithSourceMap({
        file: options.file,
        sourceRoot: options.sourceMapRoot
      });
      if (options.sourceContent) {
        pair.map.setSourceContent(
          options.sourceMap,
          options.sourceContent
        );
      }
      if (options.sourceMapWithCode) {
        return pair;
      }
      return pair.map.toString();
    }
    FORMAT_MINIFY = {
      indent: {
        style: "",
        base: 0
      },
      renumber: true,
      hexadecimal: true,
      quotes: "auto",
      escapeless: true,
      compact: true,
      parentheses: false,
      semicolons: false
    };
    FORMAT_DEFAULTS = getDefaultOptions().format;
    exports.version = require$$3.version;
    exports.generate = generate2;
    exports.attachComments = estraverse$1.attachComments;
    exports.Precedence = updateDeeply({}, Precedence);
    exports.browser = false;
    exports.FORMAT_MINIFY = FORMAT_MINIFY;
    exports.FORMAT_DEFAULTS = FORMAT_DEFAULTS;
  })();
})(escodegen);
var esprima$1 = { exports: {} };
(function(module2, exports) {
  (function webpackUniversalModuleDefinition(root2, factory) {
    module2.exports = factory();
  })(commonjsGlobal, function() {
    return (
      /******/
      function(modules) {
        var installedModules = {};
        function __webpack_require__(moduleId) {
          if (installedModules[moduleId])
            return installedModules[moduleId].exports;
          var module3 = installedModules[moduleId] = {
            /******/
            exports: {},
            /******/
            id: moduleId,
            /******/
            loaded: false
            /******/
          };
          modules[moduleId].call(module3.exports, module3, module3.exports, __webpack_require__);
          module3.loaded = true;
          return module3.exports;
        }
        __webpack_require__.m = modules;
        __webpack_require__.c = installedModules;
        __webpack_require__.p = "";
        return __webpack_require__(0);
      }([
        /* 0 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var comment_handler_1 = __webpack_require__(1);
          var jsx_parser_1 = __webpack_require__(3);
          var parser_1 = __webpack_require__(8);
          var tokenizer_1 = __webpack_require__(15);
          function parse2(code2, options, delegate) {
            var commentHandler = null;
            var proxyDelegate = function(node2, metadata) {
              if (delegate) {
                delegate(node2, metadata);
              }
              if (commentHandler) {
                commentHandler.visit(node2, metadata);
              }
            };
            var parserDelegate = typeof delegate === "function" ? proxyDelegate : null;
            var collectComment = false;
            if (options) {
              collectComment = typeof options.comment === "boolean" && options.comment;
              var attachComment = typeof options.attachComment === "boolean" && options.attachComment;
              if (collectComment || attachComment) {
                commentHandler = new comment_handler_1.CommentHandler();
                commentHandler.attach = attachComment;
                options.comment = true;
                parserDelegate = proxyDelegate;
              }
            }
            var isModule = false;
            if (options && typeof options.sourceType === "string") {
              isModule = options.sourceType === "module";
            }
            var parser;
            if (options && typeof options.jsx === "boolean" && options.jsx) {
              parser = new jsx_parser_1.JSXParser(code2, options, parserDelegate);
            } else {
              parser = new parser_1.Parser(code2, options, parserDelegate);
            }
            var program = isModule ? parser.parseModule() : parser.parseScript();
            var ast2 = program;
            if (collectComment && commentHandler) {
              ast2.comments = commentHandler.comments;
            }
            if (parser.config.tokens) {
              ast2.tokens = parser.tokens;
            }
            if (parser.config.tolerant) {
              ast2.errors = parser.errorHandler.errors;
            }
            return ast2;
          }
          exports2.parse = parse2;
          function parseModule(code2, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "module";
            return parse2(code2, parsingOptions, delegate);
          }
          exports2.parseModule = parseModule;
          function parseScript(code2, options, delegate) {
            var parsingOptions = options || {};
            parsingOptions.sourceType = "script";
            return parse2(code2, parsingOptions, delegate);
          }
          exports2.parseScript = parseScript;
          function tokenize(code2, options, delegate) {
            var tokenizer = new tokenizer_1.Tokenizer(code2, options);
            var tokens;
            tokens = [];
            try {
              while (true) {
                var token = tokenizer.getNextToken();
                if (!token) {
                  break;
                }
                if (delegate) {
                  token = delegate(token);
                }
                tokens.push(token);
              }
            } catch (e) {
              tokenizer.errorHandler.tolerate(e);
            }
            if (tokenizer.errorHandler.tolerant) {
              tokens.errors = tokenizer.errors();
            }
            return tokens;
          }
          exports2.tokenize = tokenize;
          var syntax_1 = __webpack_require__(2);
          exports2.Syntax = syntax_1.Syntax;
          exports2.version = "4.0.1";
        },
        /* 1 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var CommentHandler = function() {
            function CommentHandler2() {
              this.attach = false;
              this.comments = [];
              this.stack = [];
              this.leading = [];
              this.trailing = [];
            }
            CommentHandler2.prototype.insertInnerComments = function(node2, metadata) {
              if (node2.type === syntax_1.Syntax.BlockStatement && node2.body.length === 0) {
                var innerComments = [];
                for (var i = this.leading.length - 1; i >= 0; --i) {
                  var entry = this.leading[i];
                  if (metadata.end.offset >= entry.start) {
                    innerComments.unshift(entry.comment);
                    this.leading.splice(i, 1);
                    this.trailing.splice(i, 1);
                  }
                }
                if (innerComments.length) {
                  node2.innerComments = innerComments;
                }
              }
            };
            CommentHandler2.prototype.findTrailingComments = function(metadata) {
              var trailingComments = [];
              if (this.trailing.length > 0) {
                for (var i = this.trailing.length - 1; i >= 0; --i) {
                  var entry_1 = this.trailing[i];
                  if (entry_1.start >= metadata.end.offset) {
                    trailingComments.unshift(entry_1.comment);
                  }
                }
                this.trailing.length = 0;
                return trailingComments;
              }
              var entry = this.stack[this.stack.length - 1];
              if (entry && entry.node.trailingComments) {
                var firstComment = entry.node.trailingComments[0];
                if (firstComment && firstComment.range[0] >= metadata.end.offset) {
                  trailingComments = entry.node.trailingComments;
                  delete entry.node.trailingComments;
                }
              }
              return trailingComments;
            };
            CommentHandler2.prototype.findLeadingComments = function(metadata) {
              var leadingComments = [];
              var target;
              while (this.stack.length > 0) {
                var entry = this.stack[this.stack.length - 1];
                if (entry && entry.start >= metadata.start.offset) {
                  target = entry.node;
                  this.stack.pop();
                } else {
                  break;
                }
              }
              if (target) {
                var count = target.leadingComments ? target.leadingComments.length : 0;
                for (var i = count - 1; i >= 0; --i) {
                  var comment = target.leadingComments[i];
                  if (comment.range[1] <= metadata.start.offset) {
                    leadingComments.unshift(comment);
                    target.leadingComments.splice(i, 1);
                  }
                }
                if (target.leadingComments && target.leadingComments.length === 0) {
                  delete target.leadingComments;
                }
                return leadingComments;
              }
              for (var i = this.leading.length - 1; i >= 0; --i) {
                var entry = this.leading[i];
                if (entry.start <= metadata.start.offset) {
                  leadingComments.unshift(entry.comment);
                  this.leading.splice(i, 1);
                }
              }
              return leadingComments;
            };
            CommentHandler2.prototype.visitNode = function(node2, metadata) {
              if (node2.type === syntax_1.Syntax.Program && node2.body.length > 0) {
                return;
              }
              this.insertInnerComments(node2, metadata);
              var trailingComments = this.findTrailingComments(metadata);
              var leadingComments = this.findLeadingComments(metadata);
              if (leadingComments.length > 0) {
                node2.leadingComments = leadingComments;
              }
              if (trailingComments.length > 0) {
                node2.trailingComments = trailingComments;
              }
              this.stack.push({
                node: node2,
                start: metadata.start.offset
              });
            };
            CommentHandler2.prototype.visitComment = function(node2, metadata) {
              var type3 = node2.type[0] === "L" ? "Line" : "Block";
              var comment = {
                type: type3,
                value: node2.value
              };
              if (node2.range) {
                comment.range = node2.range;
              }
              if (node2.loc) {
                comment.loc = node2.loc;
              }
              this.comments.push(comment);
              if (this.attach) {
                var entry = {
                  comment: {
                    type: type3,
                    value: node2.value,
                    range: [metadata.start.offset, metadata.end.offset]
                  },
                  start: metadata.start.offset
                };
                if (node2.loc) {
                  entry.comment.loc = node2.loc;
                }
                node2.type = type3;
                this.leading.push(entry);
                this.trailing.push(entry);
              }
            };
            CommentHandler2.prototype.visit = function(node2, metadata) {
              if (node2.type === "LineComment") {
                this.visitComment(node2, metadata);
              } else if (node2.type === "BlockComment") {
                this.visitComment(node2, metadata);
              } else if (this.attach) {
                this.visitNode(node2, metadata);
              }
            };
            return CommentHandler2;
          }();
          exports2.CommentHandler = CommentHandler;
        },
        /* 2 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Syntax = {
            AssignmentExpression: "AssignmentExpression",
            AssignmentPattern: "AssignmentPattern",
            ArrayExpression: "ArrayExpression",
            ArrayPattern: "ArrayPattern",
            ArrowFunctionExpression: "ArrowFunctionExpression",
            AwaitExpression: "AwaitExpression",
            BlockStatement: "BlockStatement",
            BinaryExpression: "BinaryExpression",
            BreakStatement: "BreakStatement",
            CallExpression: "CallExpression",
            CatchClause: "CatchClause",
            ClassBody: "ClassBody",
            ClassDeclaration: "ClassDeclaration",
            ClassExpression: "ClassExpression",
            ConditionalExpression: "ConditionalExpression",
            ContinueStatement: "ContinueStatement",
            DoWhileStatement: "DoWhileStatement",
            DebuggerStatement: "DebuggerStatement",
            EmptyStatement: "EmptyStatement",
            ExportAllDeclaration: "ExportAllDeclaration",
            ExportDefaultDeclaration: "ExportDefaultDeclaration",
            ExportNamedDeclaration: "ExportNamedDeclaration",
            ExportSpecifier: "ExportSpecifier",
            ExpressionStatement: "ExpressionStatement",
            ForStatement: "ForStatement",
            ForOfStatement: "ForOfStatement",
            ForInStatement: "ForInStatement",
            FunctionDeclaration: "FunctionDeclaration",
            FunctionExpression: "FunctionExpression",
            Identifier: "Identifier",
            IfStatement: "IfStatement",
            ImportDeclaration: "ImportDeclaration",
            ImportDefaultSpecifier: "ImportDefaultSpecifier",
            ImportNamespaceSpecifier: "ImportNamespaceSpecifier",
            ImportSpecifier: "ImportSpecifier",
            Literal: "Literal",
            LabeledStatement: "LabeledStatement",
            LogicalExpression: "LogicalExpression",
            MemberExpression: "MemberExpression",
            MetaProperty: "MetaProperty",
            MethodDefinition: "MethodDefinition",
            NewExpression: "NewExpression",
            ObjectExpression: "ObjectExpression",
            ObjectPattern: "ObjectPattern",
            Program: "Program",
            Property: "Property",
            RestElement: "RestElement",
            ReturnStatement: "ReturnStatement",
            SequenceExpression: "SequenceExpression",
            SpreadElement: "SpreadElement",
            Super: "Super",
            SwitchCase: "SwitchCase",
            SwitchStatement: "SwitchStatement",
            TaggedTemplateExpression: "TaggedTemplateExpression",
            TemplateElement: "TemplateElement",
            TemplateLiteral: "TemplateLiteral",
            ThisExpression: "ThisExpression",
            ThrowStatement: "ThrowStatement",
            TryStatement: "TryStatement",
            UnaryExpression: "UnaryExpression",
            UpdateExpression: "UpdateExpression",
            VariableDeclaration: "VariableDeclaration",
            VariableDeclarator: "VariableDeclarator",
            WhileStatement: "WhileStatement",
            WithStatement: "WithStatement",
            YieldExpression: "YieldExpression"
          };
        },
        /* 3 */
        /***/
        function(module3, exports2, __webpack_require__) {
          var __extends2 = this && this.__extends || function() {
            var extendStatics2 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b) {
              d2.__proto__ = b;
            } || function(d2, b) {
              for (var p in b) if (b.hasOwnProperty(p)) d2[p] = b[p];
            };
            return function(d2, b) {
              extendStatics2(d2, b);
              function __2() {
                this.constructor = d2;
              }
              d2.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
            };
          }();
          Object.defineProperty(exports2, "__esModule", { value: true });
          var character_1 = __webpack_require__(4);
          var JSXNode = __webpack_require__(5);
          var jsx_syntax_1 = __webpack_require__(6);
          var Node = __webpack_require__(7);
          var parser_1 = __webpack_require__(8);
          var token_1 = __webpack_require__(13);
          var xhtml_entities_1 = __webpack_require__(14);
          token_1.TokenName[
            100
            /* Identifier */
          ] = "JSXIdentifier";
          token_1.TokenName[
            101
            /* Text */
          ] = "JSXText";
          function getQualifiedElementName(elementName) {
            var qualifiedName;
            switch (elementName.type) {
              case jsx_syntax_1.JSXSyntax.JSXIdentifier:
                var id = elementName;
                qualifiedName = id.name;
                break;
              case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
                var ns = elementName;
                qualifiedName = getQualifiedElementName(ns.namespace) + ":" + getQualifiedElementName(ns.name);
                break;
              case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
                var expr = elementName;
                qualifiedName = getQualifiedElementName(expr.object) + "." + getQualifiedElementName(expr.property);
                break;
            }
            return qualifiedName;
          }
          var JSXParser = function(_super) {
            __extends2(JSXParser2, _super);
            function JSXParser2(code2, options, delegate) {
              return _super.call(this, code2, options, delegate) || this;
            }
            JSXParser2.prototype.parsePrimaryExpression = function() {
              return this.match("<") ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
            };
            JSXParser2.prototype.startJSX = function() {
              this.scanner.index = this.startMarker.index;
              this.scanner.lineNumber = this.startMarker.line;
              this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
            };
            JSXParser2.prototype.finishJSX = function() {
              this.nextToken();
            };
            JSXParser2.prototype.reenterJSX = function() {
              this.startJSX();
              this.expectJSX("}");
              if (this.config.tokens) {
                this.tokens.pop();
              }
            };
            JSXParser2.prototype.createJSXNode = function() {
              this.collectComments();
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.createJSXChildNode = function() {
              return {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            };
            JSXParser2.prototype.scanXHTMLEntity = function(quote) {
              var result = "&";
              var valid = true;
              var terminated = false;
              var numeric = false;
              var hex = false;
              while (!this.scanner.eof() && valid && !terminated) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === quote) {
                  break;
                }
                terminated = ch === ";";
                result += ch;
                ++this.scanner.index;
                if (!terminated) {
                  switch (result.length) {
                    case 2:
                      numeric = ch === "#";
                      break;
                    case 3:
                      if (numeric) {
                        hex = ch === "x";
                        valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
                        numeric = numeric && !hex;
                      }
                      break;
                    default:
                      valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
                      valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
                      break;
                  }
                }
              }
              if (valid && terminated && result.length > 2) {
                var str2 = result.substr(1, result.length - 2);
                if (numeric && str2.length > 1) {
                  result = String.fromCharCode(parseInt(str2.substr(1), 10));
                } else if (hex && str2.length > 2) {
                  result = String.fromCharCode(parseInt("0" + str2.substr(1), 16));
                } else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str2]) {
                  result = xhtml_entities_1.XHTMLEntities[str2];
                }
              }
              return result;
            };
            JSXParser2.prototype.lexJSX = function() {
              var cp = this.scanner.source.charCodeAt(this.scanner.index);
              if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
                var value2 = this.scanner.source[this.scanner.index++];
                return {
                  type: 7,
                  value: value2,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index - 1,
                  end: this.scanner.index
                };
              }
              if (cp === 34 || cp === 39) {
                var start = this.scanner.index;
                var quote = this.scanner.source[this.scanner.index++];
                var str2 = "";
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source[this.scanner.index++];
                  if (ch === quote) {
                    break;
                  } else if (ch === "&") {
                    str2 += this.scanXHTMLEntity(quote);
                  } else {
                    str2 += ch;
                  }
                }
                return {
                  type: 8,
                  value: str2,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 46) {
                var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
                var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
                var value2 = n1 === 46 && n2 === 46 ? "..." : ".";
                var start = this.scanner.index;
                this.scanner.index += value2.length;
                return {
                  type: 7,
                  value: value2,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              if (cp === 96) {
                return {
                  type: 10,
                  value: "",
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start: this.scanner.index,
                  end: this.scanner.index
                };
              }
              if (character_1.Character.isIdentifierStart(cp) && cp !== 92) {
                var start = this.scanner.index;
                ++this.scanner.index;
                while (!this.scanner.eof()) {
                  var ch = this.scanner.source.charCodeAt(this.scanner.index);
                  if (character_1.Character.isIdentifierPart(ch) && ch !== 92) {
                    ++this.scanner.index;
                  } else if (ch === 45) {
                    ++this.scanner.index;
                  } else {
                    break;
                  }
                }
                var id = this.scanner.source.slice(start, this.scanner.index);
                return {
                  type: 100,
                  value: id,
                  lineNumber: this.scanner.lineNumber,
                  lineStart: this.scanner.lineStart,
                  start,
                  end: this.scanner.index
                };
              }
              return this.scanner.lex();
            };
            JSXParser2.prototype.nextJSXToken = function() {
              this.collectComments();
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = this.lexJSX();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              if (this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.nextJSXText = function() {
              this.startMarker.index = this.scanner.index;
              this.startMarker.line = this.scanner.lineNumber;
              this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              var start = this.scanner.index;
              var text = "";
              while (!this.scanner.eof()) {
                var ch = this.scanner.source[this.scanner.index];
                if (ch === "{" || ch === "<") {
                  break;
                }
                ++this.scanner.index;
                text += ch;
                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.scanner.lineNumber;
                  if (ch === "\r" && this.scanner.source[this.scanner.index] === "\n") {
                    ++this.scanner.index;
                  }
                  this.scanner.lineStart = this.scanner.index;
                }
              }
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              var token = {
                type: 101,
                value: text,
                lineNumber: this.scanner.lineNumber,
                lineStart: this.scanner.lineStart,
                start,
                end: this.scanner.index
              };
              if (text.length > 0 && this.config.tokens) {
                this.tokens.push(this.convertToken(token));
              }
              return token;
            };
            JSXParser2.prototype.peekJSXToken = function() {
              var state2 = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.lexJSX();
              this.scanner.restoreState(state2);
              return next;
            };
            JSXParser2.prototype.expectJSX = function(value2) {
              var token = this.nextJSXToken();
              if (token.type !== 7 || token.value !== value2) {
                this.throwUnexpectedToken(token);
              }
            };
            JSXParser2.prototype.matchJSX = function(value2) {
              var next = this.peekJSXToken();
              return next.type === 7 && next.value === value2;
            };
            JSXParser2.prototype.parseJSXIdentifier = function() {
              var node2 = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 100) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node2, new JSXNode.JSXIdentifier(token.value));
            };
            JSXParser2.prototype.parseJSXElementName = function() {
              var node2 = this.createJSXNode();
              var elementName = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = elementName;
                this.expectJSX(":");
                var name_1 = this.parseJSXIdentifier();
                elementName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_1));
              } else if (this.matchJSX(".")) {
                while (this.matchJSX(".")) {
                  var object = elementName;
                  this.expectJSX(".");
                  var property = this.parseJSXIdentifier();
                  elementName = this.finalize(node2, new JSXNode.JSXMemberExpression(object, property));
                }
              }
              return elementName;
            };
            JSXParser2.prototype.parseJSXAttributeName = function() {
              var node2 = this.createJSXNode();
              var attributeName;
              var identifier = this.parseJSXIdentifier();
              if (this.matchJSX(":")) {
                var namespace = identifier;
                this.expectJSX(":");
                var name_2 = this.parseJSXIdentifier();
                attributeName = this.finalize(node2, new JSXNode.JSXNamespacedName(namespace, name_2));
              } else {
                attributeName = identifier;
              }
              return attributeName;
            };
            JSXParser2.prototype.parseJSXStringLiteralAttribute = function() {
              var node2 = this.createJSXNode();
              var token = this.nextJSXToken();
              if (token.type !== 8) {
                this.throwUnexpectedToken(token);
              }
              var raw = this.getTokenRaw(token);
              return this.finalize(node2, new Node.Literal(token.value, raw));
            };
            JSXParser2.prototype.parseJSXExpressionAttribute = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("{");
              this.finishJSX();
              if (this.match("}")) {
                this.tolerateError("JSX attributes must only be assigned a non-empty expression");
              }
              var expression = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXAttributeValue = function() {
              return this.matchJSX("{") ? this.parseJSXExpressionAttribute() : this.matchJSX("<") ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
            };
            JSXParser2.prototype.parseJSXNameValueAttribute = function() {
              var node2 = this.createJSXNode();
              var name2 = this.parseJSXAttributeName();
              var value2 = null;
              if (this.matchJSX("=")) {
                this.expectJSX("=");
                value2 = this.parseJSXAttributeValue();
              }
              return this.finalize(node2, new JSXNode.JSXAttribute(name2, value2));
            };
            JSXParser2.prototype.parseJSXSpreadAttribute = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("{");
              this.expectJSX("...");
              this.finishJSX();
              var argument = this.parseAssignmentExpression();
              this.reenterJSX();
              return this.finalize(node2, new JSXNode.JSXSpreadAttribute(argument));
            };
            JSXParser2.prototype.parseJSXAttributes = function() {
              var attributes = [];
              while (!this.matchJSX("/") && !this.matchJSX(">")) {
                var attribute = this.matchJSX("{") ? this.parseJSXSpreadAttribute() : this.parseJSXNameValueAttribute();
                attributes.push(attribute);
              }
              return attributes;
            };
            JSXParser2.prototype.parseJSXOpeningElement = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("<");
              var name2 = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXBoundaryElement = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("<");
              if (this.matchJSX("/")) {
                this.expectJSX("/");
                var name_3 = this.parseJSXElementName();
                this.expectJSX(">");
                return this.finalize(node2, new JSXNode.JSXClosingElement(name_3));
              }
              var name2 = this.parseJSXElementName();
              var attributes = this.parseJSXAttributes();
              var selfClosing = this.matchJSX("/");
              if (selfClosing) {
                this.expectJSX("/");
              }
              this.expectJSX(">");
              return this.finalize(node2, new JSXNode.JSXOpeningElement(name2, selfClosing, attributes));
            };
            JSXParser2.prototype.parseJSXEmptyExpression = function() {
              var node2 = this.createJSXChildNode();
              this.collectComments();
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              return this.finalize(node2, new JSXNode.JSXEmptyExpression());
            };
            JSXParser2.prototype.parseJSXExpressionContainer = function() {
              var node2 = this.createJSXNode();
              this.expectJSX("{");
              var expression;
              if (this.matchJSX("}")) {
                expression = this.parseJSXEmptyExpression();
                this.expectJSX("}");
              } else {
                this.finishJSX();
                expression = this.parseAssignmentExpression();
                this.reenterJSX();
              }
              return this.finalize(node2, new JSXNode.JSXExpressionContainer(expression));
            };
            JSXParser2.prototype.parseJSXChildren = function() {
              var children = [];
              while (!this.scanner.eof()) {
                var node2 = this.createJSXChildNode();
                var token = this.nextJSXText();
                if (token.start < token.end) {
                  var raw = this.getTokenRaw(token);
                  var child = this.finalize(node2, new JSXNode.JSXText(token.value, raw));
                  children.push(child);
                }
                if (this.scanner.source[this.scanner.index] === "{") {
                  var container = this.parseJSXExpressionContainer();
                  children.push(container);
                } else {
                  break;
                }
              }
              return children;
            };
            JSXParser2.prototype.parseComplexJSXElement = function(el) {
              var stack = [];
              while (!this.scanner.eof()) {
                el.children = el.children.concat(this.parseJSXChildren());
                var node2 = this.createJSXChildNode();
                var element = this.parseJSXBoundaryElement();
                if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
                  var opening = element;
                  if (opening.selfClosing) {
                    var child = this.finalize(node2, new JSXNode.JSXElement(opening, [], null));
                    el.children.push(child);
                  } else {
                    stack.push(el);
                    el = { node: node2, opening, closing: null, children: [] };
                  }
                }
                if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
                  el.closing = element;
                  var open_1 = getQualifiedElementName(el.opening.name);
                  var close_1 = getQualifiedElementName(el.closing.name);
                  if (open_1 !== close_1) {
                    this.tolerateError("Expected corresponding JSX closing tag for %0", open_1);
                  }
                  if (stack.length > 0) {
                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
                    el = stack[stack.length - 1];
                    el.children.push(child);
                    stack.pop();
                  } else {
                    break;
                  }
                }
              }
              return el;
            };
            JSXParser2.prototype.parseJSXElement = function() {
              var node2 = this.createJSXNode();
              var opening = this.parseJSXOpeningElement();
              var children = [];
              var closing = null;
              if (!opening.selfClosing) {
                var el = this.parseComplexJSXElement({ node: node2, opening, closing, children });
                children = el.children;
                closing = el.closing;
              }
              return this.finalize(node2, new JSXNode.JSXElement(opening, children, closing));
            };
            JSXParser2.prototype.parseJSXRoot = function() {
              if (this.config.tokens) {
                this.tokens.pop();
              }
              this.startJSX();
              var element = this.parseJSXElement();
              this.finishJSX();
              return element;
            };
            JSXParser2.prototype.isStartOfExpression = function() {
              return _super.prototype.isStartOfExpression.call(this) || this.match("<");
            };
            return JSXParser2;
          }(parser_1.Parser);
          exports2.JSXParser = JSXParser;
        },
        /* 4 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var Regex = {
            // Unicode v8.0.0 NonAsciiIdentifierStart:
            NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
            // Unicode v8.0.0 NonAsciiIdentifierPart:
            NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
          };
          exports2.Character = {
            /* tslint:disable:no-bitwise */
            fromCodePoint: function(cp) {
              return cp < 65536 ? String.fromCharCode(cp) : String.fromCharCode(55296 + (cp - 65536 >> 10)) + String.fromCharCode(56320 + (cp - 65536 & 1023));
            },
            // https://tc39.github.io/ecma262/#sec-white-space
            isWhiteSpace: function(cp) {
              return cp === 32 || cp === 9 || cp === 11 || cp === 12 || cp === 160 || cp >= 5760 && [5760, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8199, 8200, 8201, 8202, 8239, 8287, 12288, 65279].indexOf(cp) >= 0;
            },
            // https://tc39.github.io/ecma262/#sec-line-terminators
            isLineTerminator: function(cp) {
              return cp === 10 || cp === 13 || cp === 8232 || cp === 8233;
            },
            // https://tc39.github.io/ecma262/#sec-names-and-keywords
            isIdentifierStart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierStart.test(exports2.Character.fromCodePoint(cp));
            },
            isIdentifierPart: function(cp) {
              return cp === 36 || cp === 95 || cp >= 65 && cp <= 90 || cp >= 97 && cp <= 122 || cp >= 48 && cp <= 57 || cp === 92 || cp >= 128 && Regex.NonAsciiIdentifierPart.test(exports2.Character.fromCodePoint(cp));
            },
            // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
            isDecimalDigit: function(cp) {
              return cp >= 48 && cp <= 57;
            },
            isHexDigit: function(cp) {
              return cp >= 48 && cp <= 57 || cp >= 65 && cp <= 70 || cp >= 97 && cp <= 102;
            },
            isOctalDigit: function(cp) {
              return cp >= 48 && cp <= 55;
            }
          };
        },
        /* 5 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var jsx_syntax_1 = __webpack_require__(6);
          var JSXClosingElement = /* @__PURE__ */ function() {
            function JSXClosingElement2(name2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
              this.name = name2;
            }
            return JSXClosingElement2;
          }();
          exports2.JSXClosingElement = JSXClosingElement;
          var JSXElement = /* @__PURE__ */ function() {
            function JSXElement2(openingElement, children, closingElement) {
              this.type = jsx_syntax_1.JSXSyntax.JSXElement;
              this.openingElement = openingElement;
              this.children = children;
              this.closingElement = closingElement;
            }
            return JSXElement2;
          }();
          exports2.JSXElement = JSXElement;
          var JSXEmptyExpression = /* @__PURE__ */ function() {
            function JSXEmptyExpression2() {
              this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
            }
            return JSXEmptyExpression2;
          }();
          exports2.JSXEmptyExpression = JSXEmptyExpression;
          var JSXExpressionContainer = /* @__PURE__ */ function() {
            function JSXExpressionContainer2(expression) {
              this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
              this.expression = expression;
            }
            return JSXExpressionContainer2;
          }();
          exports2.JSXExpressionContainer = JSXExpressionContainer;
          var JSXIdentifier = /* @__PURE__ */ function() {
            function JSXIdentifier2(name2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
              this.name = name2;
            }
            return JSXIdentifier2;
          }();
          exports2.JSXIdentifier = JSXIdentifier;
          var JSXMemberExpression = /* @__PURE__ */ function() {
            function JSXMemberExpression2(object, property) {
              this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
              this.object = object;
              this.property = property;
            }
            return JSXMemberExpression2;
          }();
          exports2.JSXMemberExpression = JSXMemberExpression;
          var JSXAttribute = /* @__PURE__ */ function() {
            function JSXAttribute2(name2, value2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
              this.name = name2;
              this.value = value2;
            }
            return JSXAttribute2;
          }();
          exports2.JSXAttribute = JSXAttribute;
          var JSXNamespacedName = /* @__PURE__ */ function() {
            function JSXNamespacedName2(namespace, name2) {
              this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
              this.namespace = namespace;
              this.name = name2;
            }
            return JSXNamespacedName2;
          }();
          exports2.JSXNamespacedName = JSXNamespacedName;
          var JSXOpeningElement = /* @__PURE__ */ function() {
            function JSXOpeningElement2(name2, selfClosing, attributes) {
              this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
              this.name = name2;
              this.selfClosing = selfClosing;
              this.attributes = attributes;
            }
            return JSXOpeningElement2;
          }();
          exports2.JSXOpeningElement = JSXOpeningElement;
          var JSXSpreadAttribute = /* @__PURE__ */ function() {
            function JSXSpreadAttribute2(argument) {
              this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
              this.argument = argument;
            }
            return JSXSpreadAttribute2;
          }();
          exports2.JSXSpreadAttribute = JSXSpreadAttribute;
          var JSXText = /* @__PURE__ */ function() {
            function JSXText2(value2, raw) {
              this.type = jsx_syntax_1.JSXSyntax.JSXText;
              this.value = value2;
              this.raw = raw;
            }
            return JSXText2;
          }();
          exports2.JSXText = JSXText;
        },
        /* 6 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.JSXSyntax = {
            JSXAttribute: "JSXAttribute",
            JSXClosingElement: "JSXClosingElement",
            JSXElement: "JSXElement",
            JSXEmptyExpression: "JSXEmptyExpression",
            JSXExpressionContainer: "JSXExpressionContainer",
            JSXIdentifier: "JSXIdentifier",
            JSXMemberExpression: "JSXMemberExpression",
            JSXNamespacedName: "JSXNamespacedName",
            JSXOpeningElement: "JSXOpeningElement",
            JSXSpreadAttribute: "JSXSpreadAttribute",
            JSXText: "JSXText"
          };
        },
        /* 7 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var syntax_1 = __webpack_require__(2);
          var ArrayExpression = /* @__PURE__ */ function() {
            function ArrayExpression2(elements) {
              this.type = syntax_1.Syntax.ArrayExpression;
              this.elements = elements;
            }
            return ArrayExpression2;
          }();
          exports2.ArrayExpression = ArrayExpression;
          var ArrayPattern = /* @__PURE__ */ function() {
            function ArrayPattern2(elements) {
              this.type = syntax_1.Syntax.ArrayPattern;
              this.elements = elements;
            }
            return ArrayPattern2;
          }();
          exports2.ArrayPattern = ArrayPattern;
          var ArrowFunctionExpression = /* @__PURE__ */ function() {
            function ArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = false;
            }
            return ArrowFunctionExpression2;
          }();
          exports2.ArrowFunctionExpression = ArrowFunctionExpression;
          var AssignmentExpression = /* @__PURE__ */ function() {
            function AssignmentExpression2(operator, left, right) {
              this.type = syntax_1.Syntax.AssignmentExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return AssignmentExpression2;
          }();
          exports2.AssignmentExpression = AssignmentExpression;
          var AssignmentPattern = /* @__PURE__ */ function() {
            function AssignmentPattern2(left, right) {
              this.type = syntax_1.Syntax.AssignmentPattern;
              this.left = left;
              this.right = right;
            }
            return AssignmentPattern2;
          }();
          exports2.AssignmentPattern = AssignmentPattern;
          var AsyncArrowFunctionExpression = /* @__PURE__ */ function() {
            function AsyncArrowFunctionExpression2(params, body, expression) {
              this.type = syntax_1.Syntax.ArrowFunctionExpression;
              this.id = null;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = expression;
              this.async = true;
            }
            return AsyncArrowFunctionExpression2;
          }();
          exports2.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
          var AsyncFunctionDeclaration = /* @__PURE__ */ function() {
            function AsyncFunctionDeclaration2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionDeclaration2;
          }();
          exports2.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
          var AsyncFunctionExpression = /* @__PURE__ */ function() {
            function AsyncFunctionExpression2(id, params, body) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = false;
              this.expression = false;
              this.async = true;
            }
            return AsyncFunctionExpression2;
          }();
          exports2.AsyncFunctionExpression = AsyncFunctionExpression;
          var AwaitExpression = /* @__PURE__ */ function() {
            function AwaitExpression2(argument) {
              this.type = syntax_1.Syntax.AwaitExpression;
              this.argument = argument;
            }
            return AwaitExpression2;
          }();
          exports2.AwaitExpression = AwaitExpression;
          var BinaryExpression = /* @__PURE__ */ function() {
            function BinaryExpression2(operator, left, right) {
              var logical = operator === "||" || operator === "&&";
              this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
              this.operator = operator;
              this.left = left;
              this.right = right;
            }
            return BinaryExpression2;
          }();
          exports2.BinaryExpression = BinaryExpression;
          var BlockStatement = /* @__PURE__ */ function() {
            function BlockStatement2(body) {
              this.type = syntax_1.Syntax.BlockStatement;
              this.body = body;
            }
            return BlockStatement2;
          }();
          exports2.BlockStatement = BlockStatement;
          var BreakStatement = /* @__PURE__ */ function() {
            function BreakStatement2(label) {
              this.type = syntax_1.Syntax.BreakStatement;
              this.label = label;
            }
            return BreakStatement2;
          }();
          exports2.BreakStatement = BreakStatement;
          var CallExpression = /* @__PURE__ */ function() {
            function CallExpression2(callee, args) {
              this.type = syntax_1.Syntax.CallExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return CallExpression2;
          }();
          exports2.CallExpression = CallExpression;
          var CatchClause = /* @__PURE__ */ function() {
            function CatchClause2(param3, body) {
              this.type = syntax_1.Syntax.CatchClause;
              this.param = param3;
              this.body = body;
            }
            return CatchClause2;
          }();
          exports2.CatchClause = CatchClause;
          var ClassBody = /* @__PURE__ */ function() {
            function ClassBody2(body) {
              this.type = syntax_1.Syntax.ClassBody;
              this.body = body;
            }
            return ClassBody2;
          }();
          exports2.ClassBody = ClassBody;
          var ClassDeclaration = /* @__PURE__ */ function() {
            function ClassDeclaration2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassDeclaration;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassDeclaration2;
          }();
          exports2.ClassDeclaration = ClassDeclaration;
          var ClassExpression = /* @__PURE__ */ function() {
            function ClassExpression2(id, superClass, body) {
              this.type = syntax_1.Syntax.ClassExpression;
              this.id = id;
              this.superClass = superClass;
              this.body = body;
            }
            return ClassExpression2;
          }();
          exports2.ClassExpression = ClassExpression;
          var ComputedMemberExpression = /* @__PURE__ */ function() {
            function ComputedMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = true;
              this.object = object;
              this.property = property;
            }
            return ComputedMemberExpression2;
          }();
          exports2.ComputedMemberExpression = ComputedMemberExpression;
          var ConditionalExpression = /* @__PURE__ */ function() {
            function ConditionalExpression2(test2, consequent, alternate) {
              this.type = syntax_1.Syntax.ConditionalExpression;
              this.test = test2;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return ConditionalExpression2;
          }();
          exports2.ConditionalExpression = ConditionalExpression;
          var ContinueStatement = /* @__PURE__ */ function() {
            function ContinueStatement2(label) {
              this.type = syntax_1.Syntax.ContinueStatement;
              this.label = label;
            }
            return ContinueStatement2;
          }();
          exports2.ContinueStatement = ContinueStatement;
          var DebuggerStatement = /* @__PURE__ */ function() {
            function DebuggerStatement2() {
              this.type = syntax_1.Syntax.DebuggerStatement;
            }
            return DebuggerStatement2;
          }();
          exports2.DebuggerStatement = DebuggerStatement;
          var Directive = /* @__PURE__ */ function() {
            function Directive2(expression, directive) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
              this.directive = directive;
            }
            return Directive2;
          }();
          exports2.Directive = Directive;
          var DoWhileStatement = /* @__PURE__ */ function() {
            function DoWhileStatement2(body, test2) {
              this.type = syntax_1.Syntax.DoWhileStatement;
              this.body = body;
              this.test = test2;
            }
            return DoWhileStatement2;
          }();
          exports2.DoWhileStatement = DoWhileStatement;
          var EmptyStatement = /* @__PURE__ */ function() {
            function EmptyStatement2() {
              this.type = syntax_1.Syntax.EmptyStatement;
            }
            return EmptyStatement2;
          }();
          exports2.EmptyStatement = EmptyStatement;
          var ExportAllDeclaration = /* @__PURE__ */ function() {
            function ExportAllDeclaration2(source) {
              this.type = syntax_1.Syntax.ExportAllDeclaration;
              this.source = source;
            }
            return ExportAllDeclaration2;
          }();
          exports2.ExportAllDeclaration = ExportAllDeclaration;
          var ExportDefaultDeclaration = /* @__PURE__ */ function() {
            function ExportDefaultDeclaration2(declaration) {
              this.type = syntax_1.Syntax.ExportDefaultDeclaration;
              this.declaration = declaration;
            }
            return ExportDefaultDeclaration2;
          }();
          exports2.ExportDefaultDeclaration = ExportDefaultDeclaration;
          var ExportNamedDeclaration = /* @__PURE__ */ function() {
            function ExportNamedDeclaration2(declaration, specifiers, source) {
              this.type = syntax_1.Syntax.ExportNamedDeclaration;
              this.declaration = declaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ExportNamedDeclaration2;
          }();
          exports2.ExportNamedDeclaration = ExportNamedDeclaration;
          var ExportSpecifier = /* @__PURE__ */ function() {
            function ExportSpecifier2(local, exported) {
              this.type = syntax_1.Syntax.ExportSpecifier;
              this.exported = exported;
              this.local = local;
            }
            return ExportSpecifier2;
          }();
          exports2.ExportSpecifier = ExportSpecifier;
          var ExpressionStatement = /* @__PURE__ */ function() {
            function ExpressionStatement2(expression) {
              this.type = syntax_1.Syntax.ExpressionStatement;
              this.expression = expression;
            }
            return ExpressionStatement2;
          }();
          exports2.ExpressionStatement = ExpressionStatement;
          var ForInStatement = /* @__PURE__ */ function() {
            function ForInStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForInStatement;
              this.left = left;
              this.right = right;
              this.body = body;
              this.each = false;
            }
            return ForInStatement2;
          }();
          exports2.ForInStatement = ForInStatement;
          var ForOfStatement = /* @__PURE__ */ function() {
            function ForOfStatement2(left, right, body) {
              this.type = syntax_1.Syntax.ForOfStatement;
              this.left = left;
              this.right = right;
              this.body = body;
            }
            return ForOfStatement2;
          }();
          exports2.ForOfStatement = ForOfStatement;
          var ForStatement = /* @__PURE__ */ function() {
            function ForStatement2(init2, test2, update, body) {
              this.type = syntax_1.Syntax.ForStatement;
              this.init = init2;
              this.test = test2;
              this.update = update;
              this.body = body;
            }
            return ForStatement2;
          }();
          exports2.ForStatement = ForStatement;
          var FunctionDeclaration = /* @__PURE__ */ function() {
            function FunctionDeclaration2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionDeclaration;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionDeclaration2;
          }();
          exports2.FunctionDeclaration = FunctionDeclaration;
          var FunctionExpression = /* @__PURE__ */ function() {
            function FunctionExpression2(id, params, body, generator) {
              this.type = syntax_1.Syntax.FunctionExpression;
              this.id = id;
              this.params = params;
              this.body = body;
              this.generator = generator;
              this.expression = false;
              this.async = false;
            }
            return FunctionExpression2;
          }();
          exports2.FunctionExpression = FunctionExpression;
          var Identifier = /* @__PURE__ */ function() {
            function Identifier2(name2) {
              this.type = syntax_1.Syntax.Identifier;
              this.name = name2;
            }
            return Identifier2;
          }();
          exports2.Identifier = Identifier;
          var IfStatement = /* @__PURE__ */ function() {
            function IfStatement2(test2, consequent, alternate) {
              this.type = syntax_1.Syntax.IfStatement;
              this.test = test2;
              this.consequent = consequent;
              this.alternate = alternate;
            }
            return IfStatement2;
          }();
          exports2.IfStatement = IfStatement;
          var ImportDeclaration = /* @__PURE__ */ function() {
            function ImportDeclaration2(specifiers, source) {
              this.type = syntax_1.Syntax.ImportDeclaration;
              this.specifiers = specifiers;
              this.source = source;
            }
            return ImportDeclaration2;
          }();
          exports2.ImportDeclaration = ImportDeclaration;
          var ImportDefaultSpecifier = /* @__PURE__ */ function() {
            function ImportDefaultSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportDefaultSpecifier;
              this.local = local;
            }
            return ImportDefaultSpecifier2;
          }();
          exports2.ImportDefaultSpecifier = ImportDefaultSpecifier;
          var ImportNamespaceSpecifier = /* @__PURE__ */ function() {
            function ImportNamespaceSpecifier2(local) {
              this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
              this.local = local;
            }
            return ImportNamespaceSpecifier2;
          }();
          exports2.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
          var ImportSpecifier = /* @__PURE__ */ function() {
            function ImportSpecifier2(local, imported) {
              this.type = syntax_1.Syntax.ImportSpecifier;
              this.local = local;
              this.imported = imported;
            }
            return ImportSpecifier2;
          }();
          exports2.ImportSpecifier = ImportSpecifier;
          var LabeledStatement = /* @__PURE__ */ function() {
            function LabeledStatement2(label, body) {
              this.type = syntax_1.Syntax.LabeledStatement;
              this.label = label;
              this.body = body;
            }
            return LabeledStatement2;
          }();
          exports2.LabeledStatement = LabeledStatement;
          var Literal = /* @__PURE__ */ function() {
            function Literal2(value2, raw) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value2;
              this.raw = raw;
            }
            return Literal2;
          }();
          exports2.Literal = Literal;
          var MetaProperty = /* @__PURE__ */ function() {
            function MetaProperty2(meta, property) {
              this.type = syntax_1.Syntax.MetaProperty;
              this.meta = meta;
              this.property = property;
            }
            return MetaProperty2;
          }();
          exports2.MetaProperty = MetaProperty;
          var MethodDefinition = /* @__PURE__ */ function() {
            function MethodDefinition2(key, computed, value2, kind, isStatic) {
              this.type = syntax_1.Syntax.MethodDefinition;
              this.key = key;
              this.computed = computed;
              this.value = value2;
              this.kind = kind;
              this.static = isStatic;
            }
            return MethodDefinition2;
          }();
          exports2.MethodDefinition = MethodDefinition;
          var Module = /* @__PURE__ */ function() {
            function Module2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "module";
            }
            return Module2;
          }();
          exports2.Module = Module;
          var NewExpression = /* @__PURE__ */ function() {
            function NewExpression2(callee, args) {
              this.type = syntax_1.Syntax.NewExpression;
              this.callee = callee;
              this.arguments = args;
            }
            return NewExpression2;
          }();
          exports2.NewExpression = NewExpression;
          var ObjectExpression = /* @__PURE__ */ function() {
            function ObjectExpression2(properties) {
              this.type = syntax_1.Syntax.ObjectExpression;
              this.properties = properties;
            }
            return ObjectExpression2;
          }();
          exports2.ObjectExpression = ObjectExpression;
          var ObjectPattern = /* @__PURE__ */ function() {
            function ObjectPattern2(properties) {
              this.type = syntax_1.Syntax.ObjectPattern;
              this.properties = properties;
            }
            return ObjectPattern2;
          }();
          exports2.ObjectPattern = ObjectPattern;
          var Property = /* @__PURE__ */ function() {
            function Property2(kind, key, computed, value2, method, shorthand) {
              this.type = syntax_1.Syntax.Property;
              this.key = key;
              this.computed = computed;
              this.value = value2;
              this.kind = kind;
              this.method = method;
              this.shorthand = shorthand;
            }
            return Property2;
          }();
          exports2.Property = Property;
          var RegexLiteral = /* @__PURE__ */ function() {
            function RegexLiteral2(value2, raw, pattern, flags) {
              this.type = syntax_1.Syntax.Literal;
              this.value = value2;
              this.raw = raw;
              this.regex = { pattern, flags };
            }
            return RegexLiteral2;
          }();
          exports2.RegexLiteral = RegexLiteral;
          var RestElement = /* @__PURE__ */ function() {
            function RestElement2(argument) {
              this.type = syntax_1.Syntax.RestElement;
              this.argument = argument;
            }
            return RestElement2;
          }();
          exports2.RestElement = RestElement;
          var ReturnStatement = /* @__PURE__ */ function() {
            function ReturnStatement2(argument) {
              this.type = syntax_1.Syntax.ReturnStatement;
              this.argument = argument;
            }
            return ReturnStatement2;
          }();
          exports2.ReturnStatement = ReturnStatement;
          var Script = /* @__PURE__ */ function() {
            function Script2(body) {
              this.type = syntax_1.Syntax.Program;
              this.body = body;
              this.sourceType = "script";
            }
            return Script2;
          }();
          exports2.Script = Script;
          var SequenceExpression = /* @__PURE__ */ function() {
            function SequenceExpression2(expressions) {
              this.type = syntax_1.Syntax.SequenceExpression;
              this.expressions = expressions;
            }
            return SequenceExpression2;
          }();
          exports2.SequenceExpression = SequenceExpression;
          var SpreadElement = /* @__PURE__ */ function() {
            function SpreadElement2(argument) {
              this.type = syntax_1.Syntax.SpreadElement;
              this.argument = argument;
            }
            return SpreadElement2;
          }();
          exports2.SpreadElement = SpreadElement;
          var StaticMemberExpression = /* @__PURE__ */ function() {
            function StaticMemberExpression2(object, property) {
              this.type = syntax_1.Syntax.MemberExpression;
              this.computed = false;
              this.object = object;
              this.property = property;
            }
            return StaticMemberExpression2;
          }();
          exports2.StaticMemberExpression = StaticMemberExpression;
          var Super = /* @__PURE__ */ function() {
            function Super2() {
              this.type = syntax_1.Syntax.Super;
            }
            return Super2;
          }();
          exports2.Super = Super;
          var SwitchCase = /* @__PURE__ */ function() {
            function SwitchCase2(test2, consequent) {
              this.type = syntax_1.Syntax.SwitchCase;
              this.test = test2;
              this.consequent = consequent;
            }
            return SwitchCase2;
          }();
          exports2.SwitchCase = SwitchCase;
          var SwitchStatement = /* @__PURE__ */ function() {
            function SwitchStatement2(discriminant, cases) {
              this.type = syntax_1.Syntax.SwitchStatement;
              this.discriminant = discriminant;
              this.cases = cases;
            }
            return SwitchStatement2;
          }();
          exports2.SwitchStatement = SwitchStatement;
          var TaggedTemplateExpression = /* @__PURE__ */ function() {
            function TaggedTemplateExpression2(tag, quasi) {
              this.type = syntax_1.Syntax.TaggedTemplateExpression;
              this.tag = tag;
              this.quasi = quasi;
            }
            return TaggedTemplateExpression2;
          }();
          exports2.TaggedTemplateExpression = TaggedTemplateExpression;
          var TemplateElement = /* @__PURE__ */ function() {
            function TemplateElement2(value2, tail) {
              this.type = syntax_1.Syntax.TemplateElement;
              this.value = value2;
              this.tail = tail;
            }
            return TemplateElement2;
          }();
          exports2.TemplateElement = TemplateElement;
          var TemplateLiteral = /* @__PURE__ */ function() {
            function TemplateLiteral2(quasis, expressions) {
              this.type = syntax_1.Syntax.TemplateLiteral;
              this.quasis = quasis;
              this.expressions = expressions;
            }
            return TemplateLiteral2;
          }();
          exports2.TemplateLiteral = TemplateLiteral;
          var ThisExpression = /* @__PURE__ */ function() {
            function ThisExpression2() {
              this.type = syntax_1.Syntax.ThisExpression;
            }
            return ThisExpression2;
          }();
          exports2.ThisExpression = ThisExpression;
          var ThrowStatement = /* @__PURE__ */ function() {
            function ThrowStatement2(argument) {
              this.type = syntax_1.Syntax.ThrowStatement;
              this.argument = argument;
            }
            return ThrowStatement2;
          }();
          exports2.ThrowStatement = ThrowStatement;
          var TryStatement = /* @__PURE__ */ function() {
            function TryStatement2(block, handler, finalizer) {
              this.type = syntax_1.Syntax.TryStatement;
              this.block = block;
              this.handler = handler;
              this.finalizer = finalizer;
            }
            return TryStatement2;
          }();
          exports2.TryStatement = TryStatement;
          var UnaryExpression = /* @__PURE__ */ function() {
            function UnaryExpression2(operator, argument) {
              this.type = syntax_1.Syntax.UnaryExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = true;
            }
            return UnaryExpression2;
          }();
          exports2.UnaryExpression = UnaryExpression;
          var UpdateExpression = /* @__PURE__ */ function() {
            function UpdateExpression2(operator, argument, prefix) {
              this.type = syntax_1.Syntax.UpdateExpression;
              this.operator = operator;
              this.argument = argument;
              this.prefix = prefix;
            }
            return UpdateExpression2;
          }();
          exports2.UpdateExpression = UpdateExpression;
          var VariableDeclaration = /* @__PURE__ */ function() {
            function VariableDeclaration2(declarations, kind) {
              this.type = syntax_1.Syntax.VariableDeclaration;
              this.declarations = declarations;
              this.kind = kind;
            }
            return VariableDeclaration2;
          }();
          exports2.VariableDeclaration = VariableDeclaration;
          var VariableDeclarator = /* @__PURE__ */ function() {
            function VariableDeclarator2(id, init2) {
              this.type = syntax_1.Syntax.VariableDeclarator;
              this.id = id;
              this.init = init2;
            }
            return VariableDeclarator2;
          }();
          exports2.VariableDeclarator = VariableDeclarator;
          var WhileStatement = /* @__PURE__ */ function() {
            function WhileStatement2(test2, body) {
              this.type = syntax_1.Syntax.WhileStatement;
              this.test = test2;
              this.body = body;
            }
            return WhileStatement2;
          }();
          exports2.WhileStatement = WhileStatement;
          var WithStatement = /* @__PURE__ */ function() {
            function WithStatement2(object, body) {
              this.type = syntax_1.Syntax.WithStatement;
              this.object = object;
              this.body = body;
            }
            return WithStatement2;
          }();
          exports2.WithStatement = WithStatement;
          var YieldExpression = /* @__PURE__ */ function() {
            function YieldExpression2(argument, delegate) {
              this.type = syntax_1.Syntax.YieldExpression;
              this.argument = argument;
              this.delegate = delegate;
            }
            return YieldExpression2;
          }();
          exports2.YieldExpression = YieldExpression;
        },
        /* 8 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var assert_12 = __webpack_require__(9);
          var error_handler_1 = __webpack_require__(10);
          var messages_1 = __webpack_require__(11);
          var Node = __webpack_require__(7);
          var scanner_1 = __webpack_require__(12);
          var syntax_1 = __webpack_require__(2);
          var token_1 = __webpack_require__(13);
          var ArrowParameterPlaceHolder = "ArrowParameterPlaceHolder";
          var Parser = function() {
            function Parser2(code2, options, delegate) {
              if (options === void 0) {
                options = {};
              }
              this.config = {
                range: typeof options.range === "boolean" && options.range,
                loc: typeof options.loc === "boolean" && options.loc,
                source: null,
                tokens: typeof options.tokens === "boolean" && options.tokens,
                comment: typeof options.comment === "boolean" && options.comment,
                tolerant: typeof options.tolerant === "boolean" && options.tolerant
              };
              if (this.config.loc && options.source && options.source !== null) {
                this.config.source = String(options.source);
              }
              this.delegate = delegate;
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = this.config.tolerant;
              this.scanner = new scanner_1.Scanner(code2, this.errorHandler);
              this.scanner.trackComment = this.config.comment;
              this.operatorPrecedence = {
                ")": 0,
                ";": 0,
                ",": 0,
                "=": 0,
                "]": 0,
                "||": 1,
                "&&": 2,
                "|": 3,
                "^": 4,
                "&": 5,
                "==": 6,
                "!=": 6,
                "===": 6,
                "!==": 6,
                "<": 7,
                ">": 7,
                "<=": 7,
                ">=": 7,
                "<<": 8,
                ">>": 8,
                ">>>": 8,
                "+": 9,
                "-": 9,
                "*": 11,
                "/": 11,
                "%": 11
              };
              this.lookahead = {
                type: 2,
                value: "",
                lineNumber: this.scanner.lineNumber,
                lineStart: 0,
                start: 0,
                end: 0
              };
              this.hasLineTerminator = false;
              this.context = {
                isModule: false,
                await: false,
                allowIn: true,
                allowStrictDirective: true,
                allowYield: true,
                firstCoverInitializedNameError: null,
                isAssignmentTarget: false,
                isBindingElement: false,
                inFunctionBody: false,
                inIteration: false,
                inSwitch: false,
                labelSet: {},
                strict: false
              };
              this.tokens = [];
              this.startMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.lastMarker = {
                index: 0,
                line: this.scanner.lineNumber,
                column: 0
              };
              this.nextToken();
              this.lastMarker = {
                index: this.scanner.index,
                line: this.scanner.lineNumber,
                column: this.scanner.index - this.scanner.lineStart
              };
            }
            Parser2.prototype.throwError = function(messageFormat) {
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_12.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index2 = this.lastMarker.index;
              var line = this.lastMarker.line;
              var column = this.lastMarker.column + 1;
              throw this.errorHandler.createError(index2, line, column, msg);
            };
            Parser2.prototype.tolerateError = function(messageFormat) {
              var args = Array.prototype.slice.call(arguments, 1);
              var msg = messageFormat.replace(/%(\d)/g, function(whole, idx) {
                assert_12.assert(idx < args.length, "Message reference must be in range");
                return args[idx];
              });
              var index2 = this.lastMarker.index;
              var line = this.scanner.lineNumber;
              var column = this.lastMarker.column + 1;
              this.errorHandler.tolerateError(index2, line, column, msg);
            };
            Parser2.prototype.unexpectedTokenError = function(token, message) {
              var msg = message || messages_1.Messages.UnexpectedToken;
              var value2;
              if (token) {
                if (!message) {
                  msg = token.type === 2 ? messages_1.Messages.UnexpectedEOS : token.type === 3 ? messages_1.Messages.UnexpectedIdentifier : token.type === 6 ? messages_1.Messages.UnexpectedNumber : token.type === 8 ? messages_1.Messages.UnexpectedString : token.type === 10 ? messages_1.Messages.UnexpectedTemplate : messages_1.Messages.UnexpectedToken;
                  if (token.type === 4) {
                    if (this.scanner.isFutureReservedWord(token.value)) {
                      msg = messages_1.Messages.UnexpectedReserved;
                    } else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
                      msg = messages_1.Messages.StrictReservedWord;
                    }
                  }
                }
                value2 = token.value;
              } else {
                value2 = "ILLEGAL";
              }
              msg = msg.replace("%0", value2);
              if (token && typeof token.lineNumber === "number") {
                var index2 = token.start;
                var line = token.lineNumber;
                var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
                var column = token.start - lastMarkerLineStart + 1;
                return this.errorHandler.createError(index2, line, column, msg);
              } else {
                var index2 = this.lastMarker.index;
                var line = this.lastMarker.line;
                var column = this.lastMarker.column + 1;
                return this.errorHandler.createError(index2, line, column, msg);
              }
            };
            Parser2.prototype.throwUnexpectedToken = function(token, message) {
              throw this.unexpectedTokenError(token, message);
            };
            Parser2.prototype.tolerateUnexpectedToken = function(token, message) {
              this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
            };
            Parser2.prototype.collectComments = function() {
              if (!this.config.comment) {
                this.scanner.scanComments();
              } else {
                var comments = this.scanner.scanComments();
                if (comments.length > 0 && this.delegate) {
                  for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var node2 = void 0;
                    node2 = {
                      type: e.multiLine ? "BlockComment" : "LineComment",
                      value: this.scanner.source.slice(e.slice[0], e.slice[1])
                    };
                    if (this.config.range) {
                      node2.range = e.range;
                    }
                    if (this.config.loc) {
                      node2.loc = e.loc;
                    }
                    var metadata = {
                      start: {
                        line: e.loc.start.line,
                        column: e.loc.start.column,
                        offset: e.range[0]
                      },
                      end: {
                        line: e.loc.end.line,
                        column: e.loc.end.column,
                        offset: e.range[1]
                      }
                    };
                    this.delegate(node2, metadata);
                  }
                }
              }
            };
            Parser2.prototype.getTokenRaw = function(token) {
              return this.scanner.source.slice(token.start, token.end);
            };
            Parser2.prototype.convertToken = function(token) {
              var t2 = {
                type: token_1.TokenName[token.type],
                value: this.getTokenRaw(token)
              };
              if (this.config.range) {
                t2.range = [token.start, token.end];
              }
              if (this.config.loc) {
                t2.loc = {
                  start: {
                    line: this.startMarker.line,
                    column: this.startMarker.column
                  },
                  end: {
                    line: this.scanner.lineNumber,
                    column: this.scanner.index - this.scanner.lineStart
                  }
                };
              }
              if (token.type === 9) {
                var pattern = token.pattern;
                var flags = token.flags;
                t2.regex = { pattern, flags };
              }
              return t2;
            };
            Parser2.prototype.nextToken = function() {
              var token = this.lookahead;
              this.lastMarker.index = this.scanner.index;
              this.lastMarker.line = this.scanner.lineNumber;
              this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
              this.collectComments();
              if (this.scanner.index !== this.startMarker.index) {
                this.startMarker.index = this.scanner.index;
                this.startMarker.line = this.scanner.lineNumber;
                this.startMarker.column = this.scanner.index - this.scanner.lineStart;
              }
              var next = this.scanner.lex();
              this.hasLineTerminator = token.lineNumber !== next.lineNumber;
              if (next && this.context.strict && next.type === 3) {
                if (this.scanner.isStrictModeReservedWord(next.value)) {
                  next.type = 4;
                }
              }
              this.lookahead = next;
              if (this.config.tokens && next.type !== 2) {
                this.tokens.push(this.convertToken(next));
              }
              return token;
            };
            Parser2.prototype.nextRegexToken = function() {
              this.collectComments();
              var token = this.scanner.scanRegExp();
              if (this.config.tokens) {
                this.tokens.pop();
                this.tokens.push(this.convertToken(token));
              }
              this.lookahead = token;
              this.nextToken();
              return token;
            };
            Parser2.prototype.createNode = function() {
              return {
                index: this.startMarker.index,
                line: this.startMarker.line,
                column: this.startMarker.column
              };
            };
            Parser2.prototype.startNode = function(token, lastLineStart) {
              if (lastLineStart === void 0) {
                lastLineStart = 0;
              }
              var column = token.start - token.lineStart;
              var line = token.lineNumber;
              if (column < 0) {
                column += lastLineStart;
                line--;
              }
              return {
                index: token.start,
                line,
                column
              };
            };
            Parser2.prototype.finalize = function(marker, node2) {
              if (this.config.range) {
                node2.range = [marker.index, this.lastMarker.index];
              }
              if (this.config.loc) {
                node2.loc = {
                  start: {
                    line: marker.line,
                    column: marker.column
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column
                  }
                };
                if (this.config.source) {
                  node2.loc.source = this.config.source;
                }
              }
              if (this.delegate) {
                var metadata = {
                  start: {
                    line: marker.line,
                    column: marker.column,
                    offset: marker.index
                  },
                  end: {
                    line: this.lastMarker.line,
                    column: this.lastMarker.column,
                    offset: this.lastMarker.index
                  }
                };
                this.delegate(node2, metadata);
              }
              return node2;
            };
            Parser2.prototype.expect = function(value2) {
              var token = this.nextToken();
              if (token.type !== 7 || token.value !== value2) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser2.prototype.expectCommaSeparator = function() {
              if (this.config.tolerant) {
                var token = this.lookahead;
                if (token.type === 7 && token.value === ",") {
                  this.nextToken();
                } else if (token.type === 7 && token.value === ";") {
                  this.nextToken();
                  this.tolerateUnexpectedToken(token);
                } else {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
                }
              } else {
                this.expect(",");
              }
            };
            Parser2.prototype.expectKeyword = function(keyword2) {
              var token = this.nextToken();
              if (token.type !== 4 || token.value !== keyword2) {
                this.throwUnexpectedToken(token);
              }
            };
            Parser2.prototype.match = function(value2) {
              return this.lookahead.type === 7 && this.lookahead.value === value2;
            };
            Parser2.prototype.matchKeyword = function(keyword2) {
              return this.lookahead.type === 4 && this.lookahead.value === keyword2;
            };
            Parser2.prototype.matchContextualKeyword = function(keyword2) {
              return this.lookahead.type === 3 && this.lookahead.value === keyword2;
            };
            Parser2.prototype.matchAssign = function() {
              if (this.lookahead.type !== 7) {
                return false;
              }
              var op = this.lookahead.value;
              return op === "=" || op === "*=" || op === "**=" || op === "/=" || op === "%=" || op === "+=" || op === "-=" || op === "<<=" || op === ">>=" || op === ">>>=" || op === "&=" || op === "^=" || op === "|=";
            };
            Parser2.prototype.isolateCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              if (this.context.firstCoverInitializedNameError !== null) {
                this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
              }
              this.context.isBindingElement = previousIsBindingElement;
              this.context.isAssignmentTarget = previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
              return result;
            };
            Parser2.prototype.inheritCoverGrammar = function(parseFunction) {
              var previousIsBindingElement = this.context.isBindingElement;
              var previousIsAssignmentTarget = this.context.isAssignmentTarget;
              var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
              this.context.isBindingElement = true;
              this.context.isAssignmentTarget = true;
              this.context.firstCoverInitializedNameError = null;
              var result = parseFunction.call(this);
              this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
              this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
              this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
              return result;
            };
            Parser2.prototype.consumeSemicolon = function() {
              if (this.match(";")) {
                this.nextToken();
              } else if (!this.hasLineTerminator) {
                if (this.lookahead.type !== 2 && !this.match("}")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.lastMarker.index = this.startMarker.index;
                this.lastMarker.line = this.startMarker.line;
                this.lastMarker.column = this.startMarker.column;
              }
            };
            Parser2.prototype.parsePrimaryExpression = function() {
              var node2 = this.createNode();
              var expr;
              var token, raw;
              switch (this.lookahead.type) {
                case 3:
                  if ((this.context.isModule || this.context.await) && this.lookahead.value === "await") {
                    this.tolerateUnexpectedToken(this.lookahead);
                  }
                  expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node2, new Node.Identifier(this.nextToken().value));
                  break;
                case 6:
                case 8:
                  if (this.context.strict && this.lookahead.octal) {
                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
                  }
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node2, new Node.Literal(token.value, raw));
                  break;
                case 1:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node2, new Node.Literal(token.value === "true", raw));
                  break;
                case 5:
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  token = this.nextToken();
                  raw = this.getTokenRaw(token);
                  expr = this.finalize(node2, new Node.Literal(null, raw));
                  break;
                case 10:
                  expr = this.parseTemplateLiteral();
                  break;
                case 7:
                  switch (this.lookahead.value) {
                    case "(":
                      this.context.isBindingElement = false;
                      expr = this.inheritCoverGrammar(this.parseGroupExpression);
                      break;
                    case "[":
                      expr = this.inheritCoverGrammar(this.parseArrayInitializer);
                      break;
                    case "{":
                      expr = this.inheritCoverGrammar(this.parseObjectInitializer);
                      break;
                    case "/":
                    case "/=":
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                      this.scanner.index = this.startMarker.index;
                      token = this.nextRegexToken();
                      raw = this.getTokenRaw(token);
                      expr = this.finalize(node2, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
                      break;
                    default:
                      expr = this.throwUnexpectedToken(this.nextToken());
                  }
                  break;
                case 4:
                  if (!this.context.strict && this.context.allowYield && this.matchKeyword("yield")) {
                    expr = this.parseIdentifierName();
                  } else if (!this.context.strict && this.matchKeyword("let")) {
                    expr = this.finalize(node2, new Node.Identifier(this.nextToken().value));
                  } else {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    if (this.matchKeyword("function")) {
                      expr = this.parseFunctionExpression();
                    } else if (this.matchKeyword("this")) {
                      this.nextToken();
                      expr = this.finalize(node2, new Node.ThisExpression());
                    } else if (this.matchKeyword("class")) {
                      expr = this.parseClassExpression();
                    } else {
                      expr = this.throwUnexpectedToken(this.nextToken());
                    }
                  }
                  break;
                default:
                  expr = this.throwUnexpectedToken(this.nextToken());
              }
              return expr;
            };
            Parser2.prototype.parseSpreadElement = function() {
              var node2 = this.createNode();
              this.expect("...");
              var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
              return this.finalize(node2, new Node.SpreadElement(arg));
            };
            Parser2.prototype.parseArrayInitializer = function() {
              var node2 = this.createNode();
              var elements = [];
              this.expect("[");
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else if (this.match("...")) {
                  var element = this.parseSpreadElement();
                  if (!this.match("]")) {
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    this.expect(",");
                  }
                  elements.push(element);
                } else {
                  elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node2, new Node.ArrayExpression(elements));
            };
            Parser2.prototype.parsePropertyMethod = function(params) {
              this.context.isAssignmentTarget = false;
              this.context.isBindingElement = false;
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = params.simple;
              var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
              if (this.context.strict && params.firstRestricted) {
                this.tolerateUnexpectedToken(params.firstRestricted, params.message);
              }
              if (this.context.strict && params.stricted) {
                this.tolerateUnexpectedToken(params.stricted, params.message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              return body;
            };
            Parser2.prototype.parsePropertyMethodFunction = function() {
              var isGenerator = false;
              var node2 = this.createNode();
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.parsePropertyMethodAsyncFunction = function() {
              var node2 = this.createNode();
              var previousAllowYield = this.context.allowYield;
              var previousAwait = this.context.await;
              this.context.allowYield = false;
              this.context.await = true;
              var params = this.parseFormalParameters();
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              this.context.await = previousAwait;
              return this.finalize(node2, new Node.AsyncFunctionExpression(null, params.params, method));
            };
            Parser2.prototype.parseObjectPropertyKey = function() {
              var node2 = this.createNode();
              var token = this.nextToken();
              var key;
              switch (token.type) {
                case 8:
                case 6:
                  if (this.context.strict && token.octal) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
                  }
                  var raw = this.getTokenRaw(token);
                  key = this.finalize(node2, new Node.Literal(token.value, raw));
                  break;
                case 3:
                case 1:
                case 5:
                case 4:
                  key = this.finalize(node2, new Node.Identifier(token.value));
                  break;
                case 7:
                  if (token.value === "[") {
                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    this.expect("]");
                  } else {
                    key = this.throwUnexpectedToken(token);
                  }
                  break;
                default:
                  key = this.throwUnexpectedToken(token);
              }
              return key;
            };
            Parser2.prototype.isPropertyKey = function(key, value2) {
              return key.type === syntax_1.Syntax.Identifier && key.name === value2 || key.type === syntax_1.Syntax.Literal && key.value === value2;
            };
            Parser2.prototype.parseObjectProperty = function(hasProto2) {
              var node2 = this.createNode();
              var token = this.lookahead;
              var kind;
              var key = null;
              var value2 = null;
              var computed = false;
              var method = false;
              var shorthand = false;
              var isAsync = false;
              if (token.type === 3) {
                var id = token.value;
                this.nextToken();
                computed = this.match("[");
                isAsync = !this.hasLineTerminator && id === "async" && !this.match(":") && !this.match("(") && !this.match("*") && !this.match(",");
                key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node2, new Node.Identifier(id));
              } else if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3 && !isAsync && token.value === "get" && lookaheadPropertyKey) {
                kind = "get";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.context.allowYield = false;
                value2 = this.parseGetterMethod();
              } else if (token.type === 3 && !isAsync && token.value === "set" && lookaheadPropertyKey) {
                kind = "set";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseSetterMethod();
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseGeneratorMethod();
                method = true;
              } else {
                if (!key) {
                  this.throwUnexpectedToken(this.lookahead);
                }
                kind = "init";
                if (this.match(":") && !isAsync) {
                  if (!computed && this.isPropertyKey(key, "__proto__")) {
                    if (hasProto2.value) {
                      this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
                    }
                    hasProto2.value = true;
                  }
                  this.nextToken();
                  value2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                } else if (this.match("(")) {
                  value2 = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                  method = true;
                } else if (token.type === 3) {
                  var id = this.finalize(node2, new Node.Identifier(token.value));
                  if (this.match("=")) {
                    this.context.firstCoverInitializedNameError = this.lookahead;
                    this.nextToken();
                    shorthand = true;
                    var init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    value2 = this.finalize(node2, new Node.AssignmentPattern(id, init2));
                  } else {
                    shorthand = true;
                    value2 = id;
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node2, new Node.Property(kind, key, computed, value2, method, shorthand));
            };
            Parser2.prototype.parseObjectInitializer = function() {
              var node2 = this.createNode();
              this.expect("{");
              var properties = [];
              var hasProto2 = { value: false };
              while (!this.match("}")) {
                properties.push(this.parseObjectProperty(hasProto2));
                if (!this.match("}")) {
                  this.expectCommaSeparator();
                }
              }
              this.expect("}");
              return this.finalize(node2, new Node.ObjectExpression(properties));
            };
            Parser2.prototype.parseTemplateHead = function() {
              assert_12.assert(this.lookahead.head, "Template literal must start with a template head");
              var node2 = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node2, new Node.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser2.prototype.parseTemplateElement = function() {
              if (this.lookahead.type !== 10) {
                this.throwUnexpectedToken();
              }
              var node2 = this.createNode();
              var token = this.nextToken();
              var raw = token.value;
              var cooked = token.cooked;
              return this.finalize(node2, new Node.TemplateElement({ raw, cooked }, token.tail));
            };
            Parser2.prototype.parseTemplateLiteral = function() {
              var node2 = this.createNode();
              var expressions = [];
              var quasis = [];
              var quasi = this.parseTemplateHead();
              quasis.push(quasi);
              while (!quasi.tail) {
                expressions.push(this.parseExpression());
                quasi = this.parseTemplateElement();
                quasis.push(quasi);
              }
              return this.finalize(node2, new Node.TemplateLiteral(quasis, expressions));
            };
            Parser2.prototype.reinterpretExpressionAsPattern = function(expr) {
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                case syntax_1.Syntax.MemberExpression:
                case syntax_1.Syntax.RestElement:
                case syntax_1.Syntax.AssignmentPattern:
                  break;
                case syntax_1.Syntax.SpreadElement:
                  expr.type = syntax_1.Syntax.RestElement;
                  this.reinterpretExpressionAsPattern(expr.argument);
                  break;
                case syntax_1.Syntax.ArrayExpression:
                  expr.type = syntax_1.Syntax.ArrayPattern;
                  for (var i = 0; i < expr.elements.length; i++) {
                    if (expr.elements[i] !== null) {
                      this.reinterpretExpressionAsPattern(expr.elements[i]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectExpression:
                  expr.type = syntax_1.Syntax.ObjectPattern;
                  for (var i = 0; i < expr.properties.length; i++) {
                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
                  }
                  break;
                case syntax_1.Syntax.AssignmentExpression:
                  expr.type = syntax_1.Syntax.AssignmentPattern;
                  delete expr.operator;
                  this.reinterpretExpressionAsPattern(expr.left);
                  break;
              }
            };
            Parser2.prototype.parseGroupExpression = function() {
              var expr;
              this.expect("(");
              if (this.match(")")) {
                this.nextToken();
                if (!this.match("=>")) {
                  this.expect("=>");
                }
                expr = {
                  type: ArrowParameterPlaceHolder,
                  params: [],
                  async: false
                };
              } else {
                var startToken = this.lookahead;
                var params = [];
                if (this.match("...")) {
                  expr = this.parseRestElement(params);
                  this.expect(")");
                  if (!this.match("=>")) {
                    this.expect("=>");
                  }
                  expr = {
                    type: ArrowParameterPlaceHolder,
                    params: [expr],
                    async: false
                  };
                } else {
                  var arrow = false;
                  this.context.isBindingElement = true;
                  expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  if (this.match(",")) {
                    var expressions = [];
                    this.context.isAssignmentTarget = false;
                    expressions.push(expr);
                    while (this.lookahead.type !== 2) {
                      if (!this.match(",")) {
                        break;
                      }
                      this.nextToken();
                      if (this.match(")")) {
                        this.nextToken();
                        for (var i = 0; i < expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expressions[i]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else if (this.match("...")) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        expressions.push(this.parseRestElement(params));
                        this.expect(")");
                        if (!this.match("=>")) {
                          this.expect("=>");
                        }
                        this.context.isBindingElement = false;
                        for (var i = 0; i < expressions.length; i++) {
                          this.reinterpretExpressionAsPattern(expressions[i]);
                        }
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: expressions,
                          async: false
                        };
                      } else {
                        expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
                      }
                      if (arrow) {
                        break;
                      }
                    }
                    if (!arrow) {
                      expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
                    }
                  }
                  if (!arrow) {
                    this.expect(")");
                    if (this.match("=>")) {
                      if (expr.type === syntax_1.Syntax.Identifier && expr.name === "yield") {
                        arrow = true;
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: [expr],
                          async: false
                        };
                      }
                      if (!arrow) {
                        if (!this.context.isBindingElement) {
                          this.throwUnexpectedToken(this.lookahead);
                        }
                        if (expr.type === syntax_1.Syntax.SequenceExpression) {
                          for (var i = 0; i < expr.expressions.length; i++) {
                            this.reinterpretExpressionAsPattern(expr.expressions[i]);
                          }
                        } else {
                          this.reinterpretExpressionAsPattern(expr);
                        }
                        var parameters = expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr];
                        expr = {
                          type: ArrowParameterPlaceHolder,
                          params: parameters,
                          async: false
                        };
                      }
                    }
                    this.context.isBindingElement = false;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAssignmentExpression);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.isIdentifierName = function(token) {
              return token.type === 3 || token.type === 4 || token.type === 1 || token.type === 5;
            };
            Parser2.prototype.parseIdentifierName = function() {
              var node2 = this.createNode();
              var token = this.nextToken();
              if (!this.isIdentifierName(token)) {
                this.throwUnexpectedToken(token);
              }
              return this.finalize(node2, new Node.Identifier(token.value));
            };
            Parser2.prototype.parseNewExpression = function() {
              var node2 = this.createNode();
              var id = this.parseIdentifierName();
              assert_12.assert(id.name === "new", "New expression must start with `new`");
              var expr;
              if (this.match(".")) {
                this.nextToken();
                if (this.lookahead.type === 3 && this.context.inFunctionBody && this.lookahead.value === "target") {
                  var property = this.parseIdentifierName();
                  expr = new Node.MetaProperty(id, property);
                } else {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
                var args = this.match("(") ? this.parseArguments() : [];
                expr = new Node.NewExpression(callee, args);
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return this.finalize(node2, expr);
            };
            Parser2.prototype.parseAsyncArgument = function() {
              var arg = this.parseAssignmentExpression();
              this.context.firstCoverInitializedNameError = null;
              return arg;
            };
            Parser2.prototype.parseAsyncArguments = function() {
              this.expect("(");
              var args = [];
              if (!this.match(")")) {
                while (true) {
                  var expr = this.match("...") ? this.parseSpreadElement() : this.isolateCoverGrammar(this.parseAsyncArgument);
                  args.push(expr);
                  if (this.match(")")) {
                    break;
                  }
                  this.expectCommaSeparator();
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return args;
            };
            Parser2.prototype.parseLeftHandSideExpressionAllowCall = function() {
              var startToken = this.lookahead;
              var maybeAsync2 = this.matchContextualKeyword("async");
              var previousAllowIn = this.context.allowIn;
              this.context.allowIn = true;
              var expr;
              if (this.matchKeyword("super") && this.context.inFunctionBody) {
                expr = this.createNode();
                this.nextToken();
                expr = this.finalize(expr, new Node.Super());
                if (!this.match("(") && !this.match(".") && !this.match("[")) {
                  this.throwUnexpectedToken(this.lookahead);
                }
              } else {
                expr = this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              }
              while (true) {
                if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
                } else if (this.match("(")) {
                  var asyncArrow = maybeAsync2 && startToken.lineNumber === this.lookahead.lineNumber;
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = false;
                  var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
                  expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
                  if (asyncArrow && this.match("=>")) {
                    for (var i = 0; i < args.length; ++i) {
                      this.reinterpretExpressionAsPattern(args[i]);
                    }
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: args,
                      async: true
                    };
                  }
                } else if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              this.context.allowIn = previousAllowIn;
              return expr;
            };
            Parser2.prototype.parseSuper = function() {
              var node2 = this.createNode();
              this.expectKeyword("super");
              if (!this.match("[") && !this.match(".")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              return this.finalize(node2, new Node.Super());
            };
            Parser2.prototype.parseLeftHandSideExpression = function() {
              assert_12.assert(this.context.allowIn, "callee of new expression always allow in keyword.");
              var node2 = this.startNode(this.lookahead);
              var expr = this.matchKeyword("super") && this.context.inFunctionBody ? this.parseSuper() : this.inheritCoverGrammar(this.matchKeyword("new") ? this.parseNewExpression : this.parsePrimaryExpression);
              while (true) {
                if (this.match("[")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect("[");
                  var property = this.isolateCoverGrammar(this.parseExpression);
                  this.expect("]");
                  expr = this.finalize(node2, new Node.ComputedMemberExpression(expr, property));
                } else if (this.match(".")) {
                  this.context.isBindingElement = false;
                  this.context.isAssignmentTarget = true;
                  this.expect(".");
                  var property = this.parseIdentifierName();
                  expr = this.finalize(node2, new Node.StaticMemberExpression(expr, property));
                } else if (this.lookahead.type === 10 && this.lookahead.head) {
                  var quasi = this.parseTemplateLiteral();
                  expr = this.finalize(node2, new Node.TaggedTemplateExpression(expr, quasi));
                } else {
                  break;
                }
              }
              return expr;
            };
            Parser2.prototype.parseUpdateExpression = function() {
              var expr;
              var startToken = this.lookahead;
              if (this.match("++") || this.match("--")) {
                var node2 = this.startNode(startToken);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                  this.tolerateError(messages_1.Messages.StrictLHSPrefix);
                }
                if (!this.context.isAssignmentTarget) {
                  this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                }
                var prefix = true;
                expr = this.finalize(node2, new Node.UpdateExpression(token.value, expr, prefix));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else {
                expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
                if (!this.hasLineTerminator && this.lookahead.type === 7) {
                  if (this.match("++") || this.match("--")) {
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
                      this.tolerateError(messages_1.Messages.StrictLHSPostfix);
                    }
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    this.context.isAssignmentTarget = false;
                    this.context.isBindingElement = false;
                    var operator = this.nextToken().value;
                    var prefix = false;
                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseAwaitExpression = function() {
              var node2 = this.createNode();
              this.nextToken();
              var argument = this.parseUnaryExpression();
              return this.finalize(node2, new Node.AwaitExpression(argument));
            };
            Parser2.prototype.parseUnaryExpression = function() {
              var expr;
              if (this.match("+") || this.match("-") || this.match("~") || this.match("!") || this.matchKeyword("delete") || this.matchKeyword("void") || this.matchKeyword("typeof")) {
                var node2 = this.startNode(this.lookahead);
                var token = this.nextToken();
                expr = this.inheritCoverGrammar(this.parseUnaryExpression);
                expr = this.finalize(node2, new Node.UnaryExpression(token.value, expr));
                if (this.context.strict && expr.operator === "delete" && expr.argument.type === syntax_1.Syntax.Identifier) {
                  this.tolerateError(messages_1.Messages.StrictDelete);
                }
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              } else if (this.context.await && this.matchContextualKeyword("await")) {
                expr = this.parseAwaitExpression();
              } else {
                expr = this.parseUpdateExpression();
              }
              return expr;
            };
            Parser2.prototype.parseExponentiationExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
              if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match("**")) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression("**", left, right));
              }
              return expr;
            };
            Parser2.prototype.binaryPrecedence = function(token) {
              var op = token.value;
              var precedence;
              if (token.type === 7) {
                precedence = this.operatorPrecedence[op] || 0;
              } else if (token.type === 4) {
                precedence = op === "instanceof" || this.context.allowIn && op === "in" ? 7 : 0;
              } else {
                precedence = 0;
              }
              return precedence;
            };
            Parser2.prototype.parseBinaryExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
              var token = this.lookahead;
              var prec = this.binaryPrecedence(token);
              if (prec > 0) {
                this.nextToken();
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
                var markers = [startToken, this.lookahead];
                var left = expr;
                var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
                var stack = [left, token.value, right];
                var precedences = [prec];
                while (true) {
                  prec = this.binaryPrecedence(this.lookahead);
                  if (prec <= 0) {
                    break;
                  }
                  while (stack.length > 2 && prec <= precedences[precedences.length - 1]) {
                    right = stack.pop();
                    var operator = stack.pop();
                    precedences.pop();
                    left = stack.pop();
                    markers.pop();
                    var node2 = this.startNode(markers[markers.length - 1]);
                    stack.push(this.finalize(node2, new Node.BinaryExpression(operator, left, right)));
                  }
                  stack.push(this.nextToken().value);
                  precedences.push(prec);
                  markers.push(this.lookahead);
                  stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
                }
                var i = stack.length - 1;
                expr = stack[i];
                var lastMarker = markers.pop();
                while (i > 1) {
                  var marker = markers.pop();
                  var lastLineStart = lastMarker && lastMarker.lineStart;
                  var node2 = this.startNode(marker, lastLineStart);
                  var operator = stack[i - 1];
                  expr = this.finalize(node2, new Node.BinaryExpression(operator, stack[i - 2], expr));
                  i -= 2;
                  lastMarker = marker;
                }
              }
              return expr;
            };
            Parser2.prototype.parseConditionalExpression = function() {
              var startToken = this.lookahead;
              var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
              if (this.match("?")) {
                this.nextToken();
                var previousAllowIn = this.context.allowIn;
                this.context.allowIn = true;
                var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowIn = previousAllowIn;
                this.expect(":");
                var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
                expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
                this.context.isAssignmentTarget = false;
                this.context.isBindingElement = false;
              }
              return expr;
            };
            Parser2.prototype.checkPatternParam = function(options, param3) {
              switch (param3.type) {
                case syntax_1.Syntax.Identifier:
                  this.validateParam(options, param3, param3.name);
                  break;
                case syntax_1.Syntax.RestElement:
                  this.checkPatternParam(options, param3.argument);
                  break;
                case syntax_1.Syntax.AssignmentPattern:
                  this.checkPatternParam(options, param3.left);
                  break;
                case syntax_1.Syntax.ArrayPattern:
                  for (var i = 0; i < param3.elements.length; i++) {
                    if (param3.elements[i] !== null) {
                      this.checkPatternParam(options, param3.elements[i]);
                    }
                  }
                  break;
                case syntax_1.Syntax.ObjectPattern:
                  for (var i = 0; i < param3.properties.length; i++) {
                    this.checkPatternParam(options, param3.properties[i].value);
                  }
                  break;
              }
              options.simple = options.simple && param3 instanceof Node.Identifier;
            };
            Parser2.prototype.reinterpretAsCoverFormalsList = function(expr) {
              var params = [expr];
              var options;
              var asyncArrow = false;
              switch (expr.type) {
                case syntax_1.Syntax.Identifier:
                  break;
                case ArrowParameterPlaceHolder:
                  params = expr.params;
                  asyncArrow = expr.async;
                  break;
                default:
                  return null;
              }
              options = {
                simple: true,
                paramSet: {}
              };
              for (var i = 0; i < params.length; ++i) {
                var param3 = params[i];
                if (param3.type === syntax_1.Syntax.AssignmentPattern) {
                  if (param3.right.type === syntax_1.Syntax.YieldExpression) {
                    if (param3.right.argument) {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                    param3.right.type = syntax_1.Syntax.Identifier;
                    param3.right.name = "yield";
                    delete param3.right.argument;
                    delete param3.right.delegate;
                  }
                } else if (asyncArrow && param3.type === syntax_1.Syntax.Identifier && param3.name === "await") {
                  this.throwUnexpectedToken(this.lookahead);
                }
                this.checkPatternParam(options, param3);
                params[i] = param3;
              }
              if (this.context.strict || !this.context.allowYield) {
                for (var i = 0; i < params.length; ++i) {
                  var param3 = params[i];
                  if (param3.type === syntax_1.Syntax.YieldExpression) {
                    this.throwUnexpectedToken(this.lookahead);
                  }
                }
              }
              if (options.message === messages_1.Messages.StrictParamDupe) {
                var token = this.context.strict ? options.stricted : options.firstRestricted;
                this.throwUnexpectedToken(token, options.message);
              }
              return {
                simple: options.simple,
                params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser2.prototype.parseAssignmentExpression = function() {
              var expr;
              if (!this.context.allowYield && this.matchKeyword("yield")) {
                expr = this.parseYieldExpression();
              } else {
                var startToken = this.lookahead;
                var token = startToken;
                expr = this.parseConditionalExpression();
                if (token.type === 3 && token.lineNumber === this.lookahead.lineNumber && token.value === "async") {
                  if (this.lookahead.type === 3 || this.matchKeyword("yield")) {
                    var arg = this.parsePrimaryExpression();
                    this.reinterpretExpressionAsPattern(arg);
                    expr = {
                      type: ArrowParameterPlaceHolder,
                      params: [arg],
                      async: true
                    };
                  }
                }
                if (expr.type === ArrowParameterPlaceHolder || this.match("=>")) {
                  this.context.isAssignmentTarget = false;
                  this.context.isBindingElement = false;
                  var isAsync = expr.async;
                  var list = this.reinterpretAsCoverFormalsList(expr);
                  if (list) {
                    if (this.hasLineTerminator) {
                      this.tolerateUnexpectedToken(this.lookahead);
                    }
                    this.context.firstCoverInitializedNameError = null;
                    var previousStrict = this.context.strict;
                    var previousAllowStrictDirective = this.context.allowStrictDirective;
                    this.context.allowStrictDirective = list.simple;
                    var previousAllowYield = this.context.allowYield;
                    var previousAwait = this.context.await;
                    this.context.allowYield = true;
                    this.context.await = isAsync;
                    var node2 = this.startNode(startToken);
                    this.expect("=>");
                    var body = void 0;
                    if (this.match("{")) {
                      var previousAllowIn = this.context.allowIn;
                      this.context.allowIn = true;
                      body = this.parseFunctionSourceElements();
                      this.context.allowIn = previousAllowIn;
                    } else {
                      body = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    }
                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
                    if (this.context.strict && list.firstRestricted) {
                      this.throwUnexpectedToken(list.firstRestricted, list.message);
                    }
                    if (this.context.strict && list.stricted) {
                      this.tolerateUnexpectedToken(list.stricted, list.message);
                    }
                    expr = isAsync ? this.finalize(node2, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) : this.finalize(node2, new Node.ArrowFunctionExpression(list.params, body, expression));
                    this.context.strict = previousStrict;
                    this.context.allowStrictDirective = previousAllowStrictDirective;
                    this.context.allowYield = previousAllowYield;
                    this.context.await = previousAwait;
                  }
                } else {
                  if (this.matchAssign()) {
                    if (!this.context.isAssignmentTarget) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
                    }
                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
                      var id = expr;
                      if (this.scanner.isRestrictedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
                      }
                      if (this.scanner.isStrictModeReservedWord(id.name)) {
                        this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                      }
                    }
                    if (!this.match("=")) {
                      this.context.isAssignmentTarget = false;
                      this.context.isBindingElement = false;
                    } else {
                      this.reinterpretExpressionAsPattern(expr);
                    }
                    token = this.nextToken();
                    var operator = token.value;
                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
                    this.context.firstCoverInitializedNameError = null;
                  }
                }
              }
              return expr;
            };
            Parser2.prototype.parseExpression = function() {
              var startToken = this.lookahead;
              var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
              if (this.match(",")) {
                var expressions = [];
                expressions.push(expr);
                while (this.lookahead.type !== 2) {
                  if (!this.match(",")) {
                    break;
                  }
                  this.nextToken();
                  expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                }
                expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
              }
              return expr;
            };
            Parser2.prototype.parseStatementListItem = function() {
              var statement;
              this.context.isAssignmentTarget = true;
              this.context.isBindingElement = true;
              if (this.lookahead.type === 4) {
                switch (this.lookahead.value) {
                  case "export":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
                    }
                    statement = this.parseExportDeclaration();
                    break;
                  case "import":
                    if (!this.context.isModule) {
                      this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
                    }
                    statement = this.parseImportDeclaration();
                    break;
                  case "const":
                    statement = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "function":
                    statement = this.parseFunctionDeclaration();
                    break;
                  case "class":
                    statement = this.parseClassDeclaration();
                    break;
                  case "let":
                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
                    break;
                  default:
                    statement = this.parseStatement();
                    break;
                }
              } else {
                statement = this.parseStatement();
              }
              return statement;
            };
            Parser2.prototype.parseBlock = function() {
              var node2 = this.createNode();
              this.expect("{");
              var block = [];
              while (true) {
                if (this.match("}")) {
                  break;
                }
                block.push(this.parseStatementListItem());
              }
              this.expect("}");
              return this.finalize(node2, new Node.BlockStatement(block));
            };
            Parser2.prototype.parseLexicalBinding = function(kind, options) {
              var node2 = this.createNode();
              var params = [];
              var id = this.parsePattern(params, kind);
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init2 = null;
              if (kind === "const") {
                if (!this.matchKeyword("in") && !this.matchContextualKeyword("of")) {
                  if (this.match("=")) {
                    this.nextToken();
                    init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
                  } else {
                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, "const");
                  }
                }
              } else if (!options.inFor && id.type !== syntax_1.Syntax.Identifier || this.match("=")) {
                this.expect("=");
                init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              }
              return this.finalize(node2, new Node.VariableDeclarator(id, init2));
            };
            Parser2.prototype.parseBindingList = function(kind, options) {
              var list = [this.parseLexicalBinding(kind, options)];
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseLexicalBinding(kind, options));
              }
              return list;
            };
            Parser2.prototype.isLexicalDeclaration = function() {
              var state2 = this.scanner.saveState();
              this.scanner.scanComments();
              var next = this.scanner.lex();
              this.scanner.restoreState(state2);
              return next.type === 3 || next.type === 7 && next.value === "[" || next.type === 7 && next.value === "{" || next.type === 4 && next.value === "let" || next.type === 4 && next.value === "yield";
            };
            Parser2.prototype.parseLexicalDeclaration = function(options) {
              var node2 = this.createNode();
              var kind = this.nextToken().value;
              assert_12.assert(kind === "let" || kind === "const", "Lexical declaration must be either let or const");
              var declarations = this.parseBindingList(kind, options);
              this.consumeSemicolon();
              return this.finalize(node2, new Node.VariableDeclaration(declarations, kind));
            };
            Parser2.prototype.parseBindingRestElement = function(params, kind) {
              var node2 = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params, kind);
              return this.finalize(node2, new Node.RestElement(arg));
            };
            Parser2.prototype.parseArrayPattern = function(params, kind) {
              var node2 = this.createNode();
              this.expect("[");
              var elements = [];
              while (!this.match("]")) {
                if (this.match(",")) {
                  this.nextToken();
                  elements.push(null);
                } else {
                  if (this.match("...")) {
                    elements.push(this.parseBindingRestElement(params, kind));
                    break;
                  } else {
                    elements.push(this.parsePatternWithDefault(params, kind));
                  }
                  if (!this.match("]")) {
                    this.expect(",");
                  }
                }
              }
              this.expect("]");
              return this.finalize(node2, new Node.ArrayPattern(elements));
            };
            Parser2.prototype.parsePropertyPattern = function(params, kind) {
              var node2 = this.createNode();
              var computed = false;
              var shorthand = false;
              var method = false;
              var key;
              var value2;
              if (this.lookahead.type === 3) {
                var keyToken = this.lookahead;
                key = this.parseVariableIdentifier();
                var init2 = this.finalize(node2, new Node.Identifier(keyToken.value));
                if (this.match("=")) {
                  params.push(keyToken);
                  shorthand = true;
                  this.nextToken();
                  var expr = this.parseAssignmentExpression();
                  value2 = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init2, expr));
                } else if (!this.match(":")) {
                  params.push(keyToken);
                  shorthand = true;
                  value2 = init2;
                } else {
                  this.expect(":");
                  value2 = this.parsePatternWithDefault(params, kind);
                }
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                this.expect(":");
                value2 = this.parsePatternWithDefault(params, kind);
              }
              return this.finalize(node2, new Node.Property("init", key, computed, value2, method, shorthand));
            };
            Parser2.prototype.parseObjectPattern = function(params, kind) {
              var node2 = this.createNode();
              var properties = [];
              this.expect("{");
              while (!this.match("}")) {
                properties.push(this.parsePropertyPattern(params, kind));
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return this.finalize(node2, new Node.ObjectPattern(properties));
            };
            Parser2.prototype.parsePattern = function(params, kind) {
              var pattern;
              if (this.match("[")) {
                pattern = this.parseArrayPattern(params, kind);
              } else if (this.match("{")) {
                pattern = this.parseObjectPattern(params, kind);
              } else {
                if (this.matchKeyword("let") && (kind === "const" || kind === "let")) {
                  this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
                }
                params.push(this.lookahead);
                pattern = this.parseVariableIdentifier(kind);
              }
              return pattern;
            };
            Parser2.prototype.parsePatternWithDefault = function(params, kind) {
              var startToken = this.lookahead;
              var pattern = this.parsePattern(params, kind);
              if (this.match("=")) {
                this.nextToken();
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = true;
                var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
                this.context.allowYield = previousAllowYield;
                pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
              }
              return pattern;
            };
            Parser2.prototype.parseVariableIdentifier = function(kind) {
              var node2 = this.createNode();
              var token = this.nextToken();
              if (token.type === 4 && token.value === "yield") {
                if (this.context.strict) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else if (!this.context.allowYield) {
                  this.throwUnexpectedToken(token);
                }
              } else if (token.type !== 3) {
                if (this.context.strict && token.type === 4 && this.scanner.isStrictModeReservedWord(token.value)) {
                  this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
                } else {
                  if (this.context.strict || token.value !== "let" || kind !== "var") {
                    this.throwUnexpectedToken(token);
                  }
                }
              } else if ((this.context.isModule || this.context.await) && token.type === 3 && token.value === "await") {
                this.tolerateUnexpectedToken(token);
              }
              return this.finalize(node2, new Node.Identifier(token.value));
            };
            Parser2.prototype.parseVariableDeclaration = function(options) {
              var node2 = this.createNode();
              var params = [];
              var id = this.parsePattern(params, "var");
              if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(id.name)) {
                  this.tolerateError(messages_1.Messages.StrictVarName);
                }
              }
              var init2 = null;
              if (this.match("=")) {
                this.nextToken();
                init2 = this.isolateCoverGrammar(this.parseAssignmentExpression);
              } else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
                this.expect("=");
              }
              return this.finalize(node2, new Node.VariableDeclarator(id, init2));
            };
            Parser2.prototype.parseVariableDeclarationList = function(options) {
              var opt = { inFor: options.inFor };
              var list = [];
              list.push(this.parseVariableDeclaration(opt));
              while (this.match(",")) {
                this.nextToken();
                list.push(this.parseVariableDeclaration(opt));
              }
              return list;
            };
            Parser2.prototype.parseVariableStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("var");
              var declarations = this.parseVariableDeclarationList({ inFor: false });
              this.consumeSemicolon();
              return this.finalize(node2, new Node.VariableDeclaration(declarations, "var"));
            };
            Parser2.prototype.parseEmptyStatement = function() {
              var node2 = this.createNode();
              this.expect(";");
              return this.finalize(node2, new Node.EmptyStatement());
            };
            Parser2.prototype.parseExpressionStatement = function() {
              var node2 = this.createNode();
              var expr = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node2, new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseIfClause = function() {
              if (this.context.strict && this.matchKeyword("function")) {
                this.tolerateError(messages_1.Messages.StrictFunction);
              }
              return this.parseStatement();
            };
            Parser2.prototype.parseIfStatement = function() {
              var node2 = this.createNode();
              var consequent;
              var alternate = null;
              this.expectKeyword("if");
              this.expect("(");
              var test2 = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                consequent = this.parseIfClause();
                if (this.matchKeyword("else")) {
                  this.nextToken();
                  alternate = this.parseIfClause();
                }
              }
              return this.finalize(node2, new Node.IfStatement(test2, consequent, alternate));
            };
            Parser2.prototype.parseDoWhileStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("do");
              var previousInIteration = this.context.inIteration;
              this.context.inIteration = true;
              var body = this.parseStatement();
              this.context.inIteration = previousInIteration;
              this.expectKeyword("while");
              this.expect("(");
              var test2 = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
              } else {
                this.expect(")");
                if (this.match(";")) {
                  this.nextToken();
                }
              }
              return this.finalize(node2, new Node.DoWhileStatement(body, test2));
            };
            Parser2.prototype.parseWhileStatement = function() {
              var node2 = this.createNode();
              var body;
              this.expectKeyword("while");
              this.expect("(");
              var test2 = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.parseStatement();
                this.context.inIteration = previousInIteration;
              }
              return this.finalize(node2, new Node.WhileStatement(test2, body));
            };
            Parser2.prototype.parseForStatement = function() {
              var init2 = null;
              var test2 = null;
              var update = null;
              var forIn = true;
              var left, right;
              var node2 = this.createNode();
              this.expectKeyword("for");
              this.expect("(");
              if (this.match(";")) {
                this.nextToken();
              } else {
                if (this.matchKeyword("var")) {
                  init2 = this.createNode();
                  this.nextToken();
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  var declarations = this.parseVariableDeclarationList({ inFor: true });
                  this.context.allowIn = previousAllowIn;
                  if (declarations.length === 1 && this.matchKeyword("in")) {
                    var decl = declarations[0];
                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
                      this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, "for-in");
                    }
                    init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init2;
                    right = this.parseExpression();
                    init2 = null;
                  } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                    init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, "var"));
                    this.nextToken();
                    left = init2;
                    right = this.parseAssignmentExpression();
                    init2 = null;
                    forIn = false;
                  } else {
                    init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, "var"));
                    this.expect(";");
                  }
                } else if (this.matchKeyword("const") || this.matchKeyword("let")) {
                  init2 = this.createNode();
                  var kind = this.nextToken().value;
                  if (!this.context.strict && this.lookahead.value === "in") {
                    init2 = this.finalize(init2, new Node.Identifier(kind));
                    this.nextToken();
                    left = init2;
                    right = this.parseExpression();
                    init2 = null;
                  } else {
                    var previousAllowIn = this.context.allowIn;
                    this.context.allowIn = false;
                    var declarations = this.parseBindingList(kind, { inFor: true });
                    this.context.allowIn = previousAllowIn;
                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword("in")) {
                      init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init2;
                      right = this.parseExpression();
                      init2 = null;
                    } else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword("of")) {
                      init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, kind));
                      this.nextToken();
                      left = init2;
                      right = this.parseAssignmentExpression();
                      init2 = null;
                      forIn = false;
                    } else {
                      this.consumeSemicolon();
                      init2 = this.finalize(init2, new Node.VariableDeclaration(declarations, kind));
                    }
                  }
                } else {
                  var initStartToken = this.lookahead;
                  var previousAllowIn = this.context.allowIn;
                  this.context.allowIn = false;
                  init2 = this.inheritCoverGrammar(this.parseAssignmentExpression);
                  this.context.allowIn = previousAllowIn;
                  if (this.matchKeyword("in")) {
                    if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init2);
                    left = init2;
                    right = this.parseExpression();
                    init2 = null;
                  } else if (this.matchContextualKeyword("of")) {
                    if (!this.context.isAssignmentTarget || init2.type === syntax_1.Syntax.AssignmentExpression) {
                      this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
                    }
                    this.nextToken();
                    this.reinterpretExpressionAsPattern(init2);
                    left = init2;
                    right = this.parseAssignmentExpression();
                    init2 = null;
                    forIn = false;
                  } else {
                    if (this.match(",")) {
                      var initSeq = [init2];
                      while (this.match(",")) {
                        this.nextToken();
                        initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
                      }
                      init2 = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
                    }
                    this.expect(";");
                  }
                }
              }
              if (typeof left === "undefined") {
                if (!this.match(";")) {
                  test2 = this.parseExpression();
                }
                this.expect(";");
                if (!this.match(")")) {
                  update = this.parseExpression();
                }
              }
              var body;
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                var previousInIteration = this.context.inIteration;
                this.context.inIteration = true;
                body = this.isolateCoverGrammar(this.parseStatement);
                this.context.inIteration = previousInIteration;
              }
              return typeof left === "undefined" ? this.finalize(node2, new Node.ForStatement(init2, test2, update, body)) : forIn ? this.finalize(node2, new Node.ForInStatement(left, right, body)) : this.finalize(node2, new Node.ForOfStatement(left, right, body));
            };
            Parser2.prototype.parseContinueStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("continue");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                label = id;
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration) {
                this.throwError(messages_1.Messages.IllegalContinue);
              }
              return this.finalize(node2, new Node.ContinueStatement(label));
            };
            Parser2.prototype.parseBreakStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("break");
              var label = null;
              if (this.lookahead.type === 3 && !this.hasLineTerminator) {
                var id = this.parseVariableIdentifier();
                var key = "$" + id.name;
                if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.UnknownLabel, id.name);
                }
                label = id;
              }
              this.consumeSemicolon();
              if (label === null && !this.context.inIteration && !this.context.inSwitch) {
                this.throwError(messages_1.Messages.IllegalBreak);
              }
              return this.finalize(node2, new Node.BreakStatement(label));
            };
            Parser2.prototype.parseReturnStatement = function() {
              if (!this.context.inFunctionBody) {
                this.tolerateError(messages_1.Messages.IllegalReturn);
              }
              var node2 = this.createNode();
              this.expectKeyword("return");
              var hasArgument = !this.match(";") && !this.match("}") && !this.hasLineTerminator && this.lookahead.type !== 2 || this.lookahead.type === 8 || this.lookahead.type === 10;
              var argument = hasArgument ? this.parseExpression() : null;
              this.consumeSemicolon();
              return this.finalize(node2, new Node.ReturnStatement(argument));
            };
            Parser2.prototype.parseWithStatement = function() {
              if (this.context.strict) {
                this.tolerateError(messages_1.Messages.StrictModeWith);
              }
              var node2 = this.createNode();
              var body;
              this.expectKeyword("with");
              this.expect("(");
              var object = this.parseExpression();
              if (!this.match(")") && this.config.tolerant) {
                this.tolerateUnexpectedToken(this.nextToken());
                body = this.finalize(this.createNode(), new Node.EmptyStatement());
              } else {
                this.expect(")");
                body = this.parseStatement();
              }
              return this.finalize(node2, new Node.WithStatement(object, body));
            };
            Parser2.prototype.parseSwitchCase = function() {
              var node2 = this.createNode();
              var test2;
              if (this.matchKeyword("default")) {
                this.nextToken();
                test2 = null;
              } else {
                this.expectKeyword("case");
                test2 = this.parseExpression();
              }
              this.expect(":");
              var consequent = [];
              while (true) {
                if (this.match("}") || this.matchKeyword("default") || this.matchKeyword("case")) {
                  break;
                }
                consequent.push(this.parseStatementListItem());
              }
              return this.finalize(node2, new Node.SwitchCase(test2, consequent));
            };
            Parser2.prototype.parseSwitchStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("switch");
              this.expect("(");
              var discriminant = this.parseExpression();
              this.expect(")");
              var previousInSwitch = this.context.inSwitch;
              this.context.inSwitch = true;
              var cases = [];
              var defaultFound = false;
              this.expect("{");
              while (true) {
                if (this.match("}")) {
                  break;
                }
                var clause = this.parseSwitchCase();
                if (clause.test === null) {
                  if (defaultFound) {
                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
                  }
                  defaultFound = true;
                }
                cases.push(clause);
              }
              this.expect("}");
              this.context.inSwitch = previousInSwitch;
              return this.finalize(node2, new Node.SwitchStatement(discriminant, cases));
            };
            Parser2.prototype.parseLabelledStatement = function() {
              var node2 = this.createNode();
              var expr = this.parseExpression();
              var statement;
              if (expr.type === syntax_1.Syntax.Identifier && this.match(":")) {
                this.nextToken();
                var id = expr;
                var key = "$" + id.name;
                if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
                  this.throwError(messages_1.Messages.Redeclaration, "Label", id.name);
                }
                this.context.labelSet[key] = true;
                var body = void 0;
                if (this.matchKeyword("class")) {
                  this.tolerateUnexpectedToken(this.lookahead);
                  body = this.parseClassDeclaration();
                } else if (this.matchKeyword("function")) {
                  var token = this.lookahead;
                  var declaration = this.parseFunctionDeclaration();
                  if (this.context.strict) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
                  } else if (declaration.generator) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
                  }
                  body = declaration;
                } else {
                  body = this.parseStatement();
                }
                delete this.context.labelSet[key];
                statement = new Node.LabeledStatement(id, body);
              } else {
                this.consumeSemicolon();
                statement = new Node.ExpressionStatement(expr);
              }
              return this.finalize(node2, statement);
            };
            Parser2.prototype.parseThrowStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("throw");
              if (this.hasLineTerminator) {
                this.throwError(messages_1.Messages.NewlineAfterThrow);
              }
              var argument = this.parseExpression();
              this.consumeSemicolon();
              return this.finalize(node2, new Node.ThrowStatement(argument));
            };
            Parser2.prototype.parseCatchClause = function() {
              var node2 = this.createNode();
              this.expectKeyword("catch");
              this.expect("(");
              if (this.match(")")) {
                this.throwUnexpectedToken(this.lookahead);
              }
              var params = [];
              var param3 = this.parsePattern(params);
              var paramMap = {};
              for (var i = 0; i < params.length; i++) {
                var key = "$" + params[i].value;
                if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
                  this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
                }
                paramMap[key] = true;
              }
              if (this.context.strict && param3.type === syntax_1.Syntax.Identifier) {
                if (this.scanner.isRestrictedWord(param3.name)) {
                  this.tolerateError(messages_1.Messages.StrictCatchVariable);
                }
              }
              this.expect(")");
              var body = this.parseBlock();
              return this.finalize(node2, new Node.CatchClause(param3, body));
            };
            Parser2.prototype.parseFinallyClause = function() {
              this.expectKeyword("finally");
              return this.parseBlock();
            };
            Parser2.prototype.parseTryStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("try");
              var block = this.parseBlock();
              var handler = this.matchKeyword("catch") ? this.parseCatchClause() : null;
              var finalizer = this.matchKeyword("finally") ? this.parseFinallyClause() : null;
              if (!handler && !finalizer) {
                this.throwError(messages_1.Messages.NoCatchOrFinally);
              }
              return this.finalize(node2, new Node.TryStatement(block, handler, finalizer));
            };
            Parser2.prototype.parseDebuggerStatement = function() {
              var node2 = this.createNode();
              this.expectKeyword("debugger");
              this.consumeSemicolon();
              return this.finalize(node2, new Node.DebuggerStatement());
            };
            Parser2.prototype.parseStatement = function() {
              var statement;
              switch (this.lookahead.type) {
                case 1:
                case 5:
                case 6:
                case 8:
                case 10:
                case 9:
                  statement = this.parseExpressionStatement();
                  break;
                case 7:
                  var value2 = this.lookahead.value;
                  if (value2 === "{") {
                    statement = this.parseBlock();
                  } else if (value2 === "(") {
                    statement = this.parseExpressionStatement();
                  } else if (value2 === ";") {
                    statement = this.parseEmptyStatement();
                  } else {
                    statement = this.parseExpressionStatement();
                  }
                  break;
                case 3:
                  statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
                  break;
                case 4:
                  switch (this.lookahead.value) {
                    case "break":
                      statement = this.parseBreakStatement();
                      break;
                    case "continue":
                      statement = this.parseContinueStatement();
                      break;
                    case "debugger":
                      statement = this.parseDebuggerStatement();
                      break;
                    case "do":
                      statement = this.parseDoWhileStatement();
                      break;
                    case "for":
                      statement = this.parseForStatement();
                      break;
                    case "function":
                      statement = this.parseFunctionDeclaration();
                      break;
                    case "if":
                      statement = this.parseIfStatement();
                      break;
                    case "return":
                      statement = this.parseReturnStatement();
                      break;
                    case "switch":
                      statement = this.parseSwitchStatement();
                      break;
                    case "throw":
                      statement = this.parseThrowStatement();
                      break;
                    case "try":
                      statement = this.parseTryStatement();
                      break;
                    case "var":
                      statement = this.parseVariableStatement();
                      break;
                    case "while":
                      statement = this.parseWhileStatement();
                      break;
                    case "with":
                      statement = this.parseWithStatement();
                      break;
                    default:
                      statement = this.parseExpressionStatement();
                      break;
                  }
                  break;
                default:
                  statement = this.throwUnexpectedToken(this.lookahead);
              }
              return statement;
            };
            Parser2.prototype.parseFunctionSourceElements = function() {
              var node2 = this.createNode();
              this.expect("{");
              var body = this.parseDirectivePrologues();
              var previousLabelSet = this.context.labelSet;
              var previousInIteration = this.context.inIteration;
              var previousInSwitch = this.context.inSwitch;
              var previousInFunctionBody = this.context.inFunctionBody;
              this.context.labelSet = {};
              this.context.inIteration = false;
              this.context.inSwitch = false;
              this.context.inFunctionBody = true;
              while (this.lookahead.type !== 2) {
                if (this.match("}")) {
                  break;
                }
                body.push(this.parseStatementListItem());
              }
              this.expect("}");
              this.context.labelSet = previousLabelSet;
              this.context.inIteration = previousInIteration;
              this.context.inSwitch = previousInSwitch;
              this.context.inFunctionBody = previousInFunctionBody;
              return this.finalize(node2, new Node.BlockStatement(body));
            };
            Parser2.prototype.validateParam = function(options, param3, name2) {
              var key = "$" + name2;
              if (this.context.strict) {
                if (this.scanner.isRestrictedWord(name2)) {
                  options.stricted = param3;
                  options.message = messages_1.Messages.StrictParamName;
                }
                if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param3;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              } else if (!options.firstRestricted) {
                if (this.scanner.isRestrictedWord(name2)) {
                  options.firstRestricted = param3;
                  options.message = messages_1.Messages.StrictParamName;
                } else if (this.scanner.isStrictModeReservedWord(name2)) {
                  options.firstRestricted = param3;
                  options.message = messages_1.Messages.StrictReservedWord;
                } else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
                  options.stricted = param3;
                  options.message = messages_1.Messages.StrictParamDupe;
                }
              }
              if (typeof Object.defineProperty === "function") {
                Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
              } else {
                options.paramSet[key] = true;
              }
            };
            Parser2.prototype.parseRestElement = function(params) {
              var node2 = this.createNode();
              this.expect("...");
              var arg = this.parsePattern(params);
              if (this.match("=")) {
                this.throwError(messages_1.Messages.DefaultRestParameter);
              }
              if (!this.match(")")) {
                this.throwError(messages_1.Messages.ParameterAfterRestParameter);
              }
              return this.finalize(node2, new Node.RestElement(arg));
            };
            Parser2.prototype.parseFormalParameter = function(options) {
              var params = [];
              var param3 = this.match("...") ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
              for (var i = 0; i < params.length; i++) {
                this.validateParam(options, params[i], params[i].value);
              }
              options.simple = options.simple && param3 instanceof Node.Identifier;
              options.params.push(param3);
            };
            Parser2.prototype.parseFormalParameters = function(firstRestricted) {
              var options;
              options = {
                simple: true,
                params: [],
                firstRestricted
              };
              this.expect("(");
              if (!this.match(")")) {
                options.paramSet = {};
                while (this.lookahead.type !== 2) {
                  this.parseFormalParameter(options);
                  if (this.match(")")) {
                    break;
                  }
                  this.expect(",");
                  if (this.match(")")) {
                    break;
                  }
                }
              }
              this.expect(")");
              return {
                simple: options.simple,
                params: options.params,
                stricted: options.stricted,
                firstRestricted: options.firstRestricted,
                message: options.message
              };
            };
            Parser2.prototype.matchAsyncFunction = function() {
              var match2 = this.matchContextualKeyword("async");
              if (match2) {
                var state2 = this.scanner.saveState();
                this.scanner.scanComments();
                var next = this.scanner.lex();
                this.scanner.restoreState(state2);
                match2 = state2.lineNumber === next.lineNumber && next.type === 4 && next.value === "function";
              }
              return match2;
            };
            Parser2.prototype.parseFunctionDeclaration = function(identifierIsOptional) {
              var node2 = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted = null;
              if (!identifierIsOptional || !this.match("(")) {
                var token = this.lookahead;
                id = this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node2, new Node.AsyncFunctionDeclaration(id, params, body)) : this.finalize(node2, new Node.FunctionDeclaration(id, params, body, isGenerator));
            };
            Parser2.prototype.parseFunctionExpression = function() {
              var node2 = this.createNode();
              var isAsync = this.matchContextualKeyword("async");
              if (isAsync) {
                this.nextToken();
              }
              this.expectKeyword("function");
              var isGenerator = isAsync ? false : this.match("*");
              if (isGenerator) {
                this.nextToken();
              }
              var message;
              var id = null;
              var firstRestricted;
              var previousAllowAwait = this.context.await;
              var previousAllowYield = this.context.allowYield;
              this.context.await = isAsync;
              this.context.allowYield = !isGenerator;
              if (!this.match("(")) {
                var token = this.lookahead;
                id = !this.context.strict && !isGenerator && this.matchKeyword("yield") ? this.parseIdentifierName() : this.parseVariableIdentifier();
                if (this.context.strict) {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
                  }
                } else {
                  if (this.scanner.isRestrictedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictFunctionName;
                  } else if (this.scanner.isStrictModeReservedWord(token.value)) {
                    firstRestricted = token;
                    message = messages_1.Messages.StrictReservedWord;
                  }
                }
              }
              var formalParameters = this.parseFormalParameters(firstRestricted);
              var params = formalParameters.params;
              var stricted = formalParameters.stricted;
              firstRestricted = formalParameters.firstRestricted;
              if (formalParameters.message) {
                message = formalParameters.message;
              }
              var previousStrict = this.context.strict;
              var previousAllowStrictDirective = this.context.allowStrictDirective;
              this.context.allowStrictDirective = formalParameters.simple;
              var body = this.parseFunctionSourceElements();
              if (this.context.strict && firstRestricted) {
                this.throwUnexpectedToken(firstRestricted, message);
              }
              if (this.context.strict && stricted) {
                this.tolerateUnexpectedToken(stricted, message);
              }
              this.context.strict = previousStrict;
              this.context.allowStrictDirective = previousAllowStrictDirective;
              this.context.await = previousAllowAwait;
              this.context.allowYield = previousAllowYield;
              return isAsync ? this.finalize(node2, new Node.AsyncFunctionExpression(id, params, body)) : this.finalize(node2, new Node.FunctionExpression(id, params, body, isGenerator));
            };
            Parser2.prototype.parseDirective = function() {
              var token = this.lookahead;
              var node2 = this.createNode();
              var expr = this.parseExpression();
              var directive = expr.type === syntax_1.Syntax.Literal ? this.getTokenRaw(token).slice(1, -1) : null;
              this.consumeSemicolon();
              return this.finalize(node2, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
            };
            Parser2.prototype.parseDirectivePrologues = function() {
              var firstRestricted = null;
              var body = [];
              while (true) {
                var token = this.lookahead;
                if (token.type !== 8) {
                  break;
                }
                var statement = this.parseDirective();
                body.push(statement);
                var directive = statement.directive;
                if (typeof directive !== "string") {
                  break;
                }
                if (directive === "use strict") {
                  this.context.strict = true;
                  if (firstRestricted) {
                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
                  }
                  if (!this.context.allowStrictDirective) {
                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
                  }
                } else {
                  if (!firstRestricted && token.octal) {
                    firstRestricted = token;
                  }
                }
              }
              return body;
            };
            Parser2.prototype.qualifiedPropertyName = function(token) {
              switch (token.type) {
                case 3:
                case 8:
                case 1:
                case 5:
                case 6:
                case 4:
                  return true;
                case 7:
                  return token.value === "[";
              }
              return false;
            };
            Parser2.prototype.parseGetterMethod = function() {
              var node2 = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length > 0) {
                this.tolerateError(messages_1.Messages.BadGetterArity);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseSetterMethod = function() {
              var node2 = this.createNode();
              var isGenerator = false;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = !isGenerator;
              var formalParameters = this.parseFormalParameters();
              if (formalParameters.params.length !== 1) {
                this.tolerateError(messages_1.Messages.BadSetterArity);
              } else if (formalParameters.params[0] instanceof Node.RestElement) {
                this.tolerateError(messages_1.Messages.BadSetterRestParameter);
              }
              var method = this.parsePropertyMethod(formalParameters);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
            };
            Parser2.prototype.parseGeneratorMethod = function() {
              var node2 = this.createNode();
              var isGenerator = true;
              var previousAllowYield = this.context.allowYield;
              this.context.allowYield = true;
              var params = this.parseFormalParameters();
              this.context.allowYield = false;
              var method = this.parsePropertyMethod(params);
              this.context.allowYield = previousAllowYield;
              return this.finalize(node2, new Node.FunctionExpression(null, params.params, method, isGenerator));
            };
            Parser2.prototype.isStartOfExpression = function() {
              var start = true;
              var value2 = this.lookahead.value;
              switch (this.lookahead.type) {
                case 7:
                  start = value2 === "[" || value2 === "(" || value2 === "{" || value2 === "+" || value2 === "-" || value2 === "!" || value2 === "~" || value2 === "++" || value2 === "--" || value2 === "/" || value2 === "/=";
                  break;
                case 4:
                  start = value2 === "class" || value2 === "delete" || value2 === "function" || value2 === "let" || value2 === "new" || value2 === "super" || value2 === "this" || value2 === "typeof" || value2 === "void" || value2 === "yield";
                  break;
              }
              return start;
            };
            Parser2.prototype.parseYieldExpression = function() {
              var node2 = this.createNode();
              this.expectKeyword("yield");
              var argument = null;
              var delegate = false;
              if (!this.hasLineTerminator) {
                var previousAllowYield = this.context.allowYield;
                this.context.allowYield = false;
                delegate = this.match("*");
                if (delegate) {
                  this.nextToken();
                  argument = this.parseAssignmentExpression();
                } else if (this.isStartOfExpression()) {
                  argument = this.parseAssignmentExpression();
                }
                this.context.allowYield = previousAllowYield;
              }
              return this.finalize(node2, new Node.YieldExpression(argument, delegate));
            };
            Parser2.prototype.parseClassElement = function(hasConstructor) {
              var token = this.lookahead;
              var node2 = this.createNode();
              var kind = "";
              var key = null;
              var value2 = null;
              var computed = false;
              var method = false;
              var isStatic = false;
              var isAsync = false;
              if (this.match("*")) {
                this.nextToken();
              } else {
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                var id = key;
                if (id.name === "static" && (this.qualifiedPropertyName(this.lookahead) || this.match("*"))) {
                  token = this.lookahead;
                  isStatic = true;
                  computed = this.match("[");
                  if (this.match("*")) {
                    this.nextToken();
                  } else {
                    key = this.parseObjectPropertyKey();
                  }
                }
                if (token.type === 3 && !this.hasLineTerminator && token.value === "async") {
                  var punctuator = this.lookahead.value;
                  if (punctuator !== ":" && punctuator !== "(" && punctuator !== "*") {
                    isAsync = true;
                    token = this.lookahead;
                    key = this.parseObjectPropertyKey();
                    if (token.type === 3 && token.value === "constructor") {
                      this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
                    }
                  }
                }
              }
              var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
              if (token.type === 3) {
                if (token.value === "get" && lookaheadPropertyKey) {
                  kind = "get";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  this.context.allowYield = false;
                  value2 = this.parseGetterMethod();
                } else if (token.value === "set" && lookaheadPropertyKey) {
                  kind = "set";
                  computed = this.match("[");
                  key = this.parseObjectPropertyKey();
                  value2 = this.parseSetterMethod();
                }
              } else if (token.type === 7 && token.value === "*" && lookaheadPropertyKey) {
                kind = "init";
                computed = this.match("[");
                key = this.parseObjectPropertyKey();
                value2 = this.parseGeneratorMethod();
                method = true;
              }
              if (!kind && key && this.match("(")) {
                kind = "init";
                value2 = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
                method = true;
              }
              if (!kind) {
                this.throwUnexpectedToken(this.lookahead);
              }
              if (kind === "init") {
                kind = "method";
              }
              if (!computed) {
                if (isStatic && this.isPropertyKey(key, "prototype")) {
                  this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
                }
                if (!isStatic && this.isPropertyKey(key, "constructor")) {
                  if (kind !== "method" || !method || value2 && value2.generator) {
                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
                  }
                  if (hasConstructor.value) {
                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
                  } else {
                    hasConstructor.value = true;
                  }
                  kind = "constructor";
                }
              }
              return this.finalize(node2, new Node.MethodDefinition(key, computed, value2, kind, isStatic));
            };
            Parser2.prototype.parseClassElementList = function() {
              var body = [];
              var hasConstructor = { value: false };
              this.expect("{");
              while (!this.match("}")) {
                if (this.match(";")) {
                  this.nextToken();
                } else {
                  body.push(this.parseClassElement(hasConstructor));
                }
              }
              this.expect("}");
              return body;
            };
            Parser2.prototype.parseClassBody = function() {
              var node2 = this.createNode();
              var elementList = this.parseClassElementList();
              return this.finalize(node2, new Node.ClassBody(elementList));
            };
            Parser2.prototype.parseClassDeclaration = function(identifierIsOptional) {
              var node2 = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = identifierIsOptional && this.lookahead.type !== 3 ? null : this.parseVariableIdentifier();
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node2, new Node.ClassDeclaration(id, superClass, classBody));
            };
            Parser2.prototype.parseClassExpression = function() {
              var node2 = this.createNode();
              var previousStrict = this.context.strict;
              this.context.strict = true;
              this.expectKeyword("class");
              var id = this.lookahead.type === 3 ? this.parseVariableIdentifier() : null;
              var superClass = null;
              if (this.matchKeyword("extends")) {
                this.nextToken();
                superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
              }
              var classBody = this.parseClassBody();
              this.context.strict = previousStrict;
              return this.finalize(node2, new Node.ClassExpression(id, superClass, classBody));
            };
            Parser2.prototype.parseModule = function() {
              this.context.strict = true;
              this.context.isModule = true;
              this.scanner.isModule = true;
              var node2 = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node2, new Node.Module(body));
            };
            Parser2.prototype.parseScript = function() {
              var node2 = this.createNode();
              var body = this.parseDirectivePrologues();
              while (this.lookahead.type !== 2) {
                body.push(this.parseStatementListItem());
              }
              return this.finalize(node2, new Node.Script(body));
            };
            Parser2.prototype.parseModuleSpecifier = function() {
              var node2 = this.createNode();
              if (this.lookahead.type !== 8) {
                this.throwError(messages_1.Messages.InvalidModuleSpecifier);
              }
              var token = this.nextToken();
              var raw = this.getTokenRaw(token);
              return this.finalize(node2, new Node.Literal(token.value, raw));
            };
            Parser2.prototype.parseImportSpecifier = function() {
              var node2 = this.createNode();
              var imported;
              var local;
              if (this.lookahead.type === 3) {
                imported = this.parseVariableIdentifier();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                }
              } else {
                imported = this.parseIdentifierName();
                local = imported;
                if (this.matchContextualKeyword("as")) {
                  this.nextToken();
                  local = this.parseVariableIdentifier();
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
              }
              return this.finalize(node2, new Node.ImportSpecifier(local, imported));
            };
            Parser2.prototype.parseNamedImports = function() {
              this.expect("{");
              var specifiers = [];
              while (!this.match("}")) {
                specifiers.push(this.parseImportSpecifier());
                if (!this.match("}")) {
                  this.expect(",");
                }
              }
              this.expect("}");
              return specifiers;
            };
            Parser2.prototype.parseImportDefaultSpecifier = function() {
              var node2 = this.createNode();
              var local = this.parseIdentifierName();
              return this.finalize(node2, new Node.ImportDefaultSpecifier(local));
            };
            Parser2.prototype.parseImportNamespaceSpecifier = function() {
              var node2 = this.createNode();
              this.expect("*");
              if (!this.matchContextualKeyword("as")) {
                this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
              }
              this.nextToken();
              var local = this.parseIdentifierName();
              return this.finalize(node2, new Node.ImportNamespaceSpecifier(local));
            };
            Parser2.prototype.parseImportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalImportDeclaration);
              }
              var node2 = this.createNode();
              this.expectKeyword("import");
              var src2;
              var specifiers = [];
              if (this.lookahead.type === 8) {
                src2 = this.parseModuleSpecifier();
              } else {
                if (this.match("{")) {
                  specifiers = specifiers.concat(this.parseNamedImports());
                } else if (this.match("*")) {
                  specifiers.push(this.parseImportNamespaceSpecifier());
                } else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword("default")) {
                  specifiers.push(this.parseImportDefaultSpecifier());
                  if (this.match(",")) {
                    this.nextToken();
                    if (this.match("*")) {
                      specifiers.push(this.parseImportNamespaceSpecifier());
                    } else if (this.match("{")) {
                      specifiers = specifiers.concat(this.parseNamedImports());
                    } else {
                      this.throwUnexpectedToken(this.lookahead);
                    }
                  }
                } else {
                  this.throwUnexpectedToken(this.nextToken());
                }
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                src2 = this.parseModuleSpecifier();
              }
              this.consumeSemicolon();
              return this.finalize(node2, new Node.ImportDeclaration(specifiers, src2));
            };
            Parser2.prototype.parseExportSpecifier = function() {
              var node2 = this.createNode();
              var local = this.parseIdentifierName();
              var exported = local;
              if (this.matchContextualKeyword("as")) {
                this.nextToken();
                exported = this.parseIdentifierName();
              }
              return this.finalize(node2, new Node.ExportSpecifier(local, exported));
            };
            Parser2.prototype.parseExportDeclaration = function() {
              if (this.context.inFunctionBody) {
                this.throwError(messages_1.Messages.IllegalExportDeclaration);
              }
              var node2 = this.createNode();
              this.expectKeyword("export");
              var exportDeclaration;
              if (this.matchKeyword("default")) {
                this.nextToken();
                if (this.matchKeyword("function")) {
                  var declaration = this.parseFunctionDeclaration(true);
                  exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchKeyword("class")) {
                  var declaration = this.parseClassDeclaration(true);
                  exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
                } else if (this.matchContextualKeyword("async")) {
                  var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
                  exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
                } else {
                  if (this.matchContextualKeyword("from")) {
                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
                  }
                  var declaration = this.match("{") ? this.parseObjectInitializer() : this.match("[") ? this.parseArrayInitializer() : this.parseAssignmentExpression();
                  this.consumeSemicolon();
                  exportDeclaration = this.finalize(node2, new Node.ExportDefaultDeclaration(declaration));
                }
              } else if (this.match("*")) {
                this.nextToken();
                if (!this.matchContextualKeyword("from")) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                }
                this.nextToken();
                var src2 = this.parseModuleSpecifier();
                this.consumeSemicolon();
                exportDeclaration = this.finalize(node2, new Node.ExportAllDeclaration(src2));
              } else if (this.lookahead.type === 4) {
                var declaration = void 0;
                switch (this.lookahead.value) {
                  case "let":
                  case "const":
                    declaration = this.parseLexicalDeclaration({ inFor: false });
                    break;
                  case "var":
                  case "class":
                  case "function":
                    declaration = this.parseStatementListItem();
                    break;
                  default:
                    this.throwUnexpectedToken(this.lookahead);
                }
                exportDeclaration = this.finalize(node2, new Node.ExportNamedDeclaration(declaration, [], null));
              } else if (this.matchAsyncFunction()) {
                var declaration = this.parseFunctionDeclaration();
                exportDeclaration = this.finalize(node2, new Node.ExportNamedDeclaration(declaration, [], null));
              } else {
                var specifiers = [];
                var source = null;
                var isExportFromIdentifier = false;
                this.expect("{");
                while (!this.match("}")) {
                  isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword("default");
                  specifiers.push(this.parseExportSpecifier());
                  if (!this.match("}")) {
                    this.expect(",");
                  }
                }
                this.expect("}");
                if (this.matchContextualKeyword("from")) {
                  this.nextToken();
                  source = this.parseModuleSpecifier();
                  this.consumeSemicolon();
                } else if (isExportFromIdentifier) {
                  var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
                  this.throwError(message, this.lookahead.value);
                } else {
                  this.consumeSemicolon();
                }
                exportDeclaration = this.finalize(node2, new Node.ExportNamedDeclaration(null, specifiers, source));
              }
              return exportDeclaration;
            };
            return Parser2;
          }();
          exports2.Parser = Parser;
        },
        /* 9 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          function assert2(condition, message) {
            if (!condition) {
              throw new Error("ASSERT: " + message);
            }
          }
          exports2.assert = assert2;
        },
        /* 10 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var ErrorHandler = function() {
            function ErrorHandler2() {
              this.errors = [];
              this.tolerant = false;
            }
            ErrorHandler2.prototype.recordError = function(error2) {
              this.errors.push(error2);
            };
            ErrorHandler2.prototype.tolerate = function(error2) {
              if (this.tolerant) {
                this.recordError(error2);
              } else {
                throw error2;
              }
            };
            ErrorHandler2.prototype.constructError = function(msg, column) {
              var error2 = new Error(msg);
              try {
                throw error2;
              } catch (base) {
                if (Object.create && Object.defineProperty) {
                  error2 = Object.create(base);
                  Object.defineProperty(error2, "column", { value: column });
                }
              }
              return error2;
            };
            ErrorHandler2.prototype.createError = function(index2, line, col, description2) {
              var msg = "Line " + line + ": " + description2;
              var error2 = this.constructError(msg, col);
              error2.index = index2;
              error2.lineNumber = line;
              error2.description = description2;
              return error2;
            };
            ErrorHandler2.prototype.throwError = function(index2, line, col, description2) {
              throw this.createError(index2, line, col, description2);
            };
            ErrorHandler2.prototype.tolerateError = function(index2, line, col, description2) {
              var error2 = this.createError(index2, line, col, description2);
              if (this.tolerant) {
                this.recordError(error2);
              } else {
                throw error2;
              }
            };
            return ErrorHandler2;
          }();
          exports2.ErrorHandler = ErrorHandler;
        },
        /* 11 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.Messages = {
            BadGetterArity: "Getter must not have any formal parameters",
            BadSetterArity: "Setter must have exactly one formal parameter",
            BadSetterRestParameter: "Setter function argument must not be a rest parameter",
            ConstructorIsAsync: "Class constructor may not be an async method",
            ConstructorSpecialMethod: "Class constructor may not be an accessor",
            DeclarationMissingInitializer: "Missing initializer in %0 declaration",
            DefaultRestParameter: "Unexpected token =",
            DuplicateBinding: "Duplicate binding %0",
            DuplicateConstructor: "A class may only have one constructor",
            DuplicateProtoProperty: "Duplicate __proto__ fields are not allowed in object literals",
            ForInOfLoopInitializer: "%0 loop variable declaration may not have an initializer",
            GeneratorInLegacyContext: "Generator declarations are not allowed in legacy contexts",
            IllegalBreak: "Illegal break statement",
            IllegalContinue: "Illegal continue statement",
            IllegalExportDeclaration: "Unexpected token",
            IllegalImportDeclaration: "Unexpected token",
            IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list",
            IllegalReturn: "Illegal return statement",
            InvalidEscapedReservedWord: "Keyword must not contain escaped characters",
            InvalidHexEscapeSequence: "Invalid hexadecimal escape sequence",
            InvalidLHSInAssignment: "Invalid left-hand side in assignment",
            InvalidLHSInForIn: "Invalid left-hand side in for-in",
            InvalidLHSInForLoop: "Invalid left-hand side in for-loop",
            InvalidModuleSpecifier: "Unexpected token",
            InvalidRegExp: "Invalid regular expression",
            LetInLexicalBinding: "let is disallowed as a lexically bound name",
            MissingFromClause: "Unexpected token",
            MultipleDefaultsInSwitch: "More than one default clause in switch statement",
            NewlineAfterThrow: "Illegal newline after throw",
            NoAsAfterImportNamespace: "Unexpected token",
            NoCatchOrFinally: "Missing catch or finally after try",
            ParameterAfterRestParameter: "Rest parameter must be last formal parameter",
            Redeclaration: "%0 '%1' has already been declared",
            StaticPrototype: "Classes may not have static property named prototype",
            StrictCatchVariable: "Catch variable may not be eval or arguments in strict mode",
            StrictDelete: "Delete of an unqualified identifier in strict mode.",
            StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block",
            StrictFunctionName: "Function name may not be eval or arguments in strict mode",
            StrictLHSAssignment: "Assignment to eval or arguments is not allowed in strict mode",
            StrictLHSPostfix: "Postfix increment/decrement may not have eval or arguments operand in strict mode",
            StrictLHSPrefix: "Prefix increment/decrement may not have eval or arguments operand in strict mode",
            StrictModeWith: "Strict mode code may not include a with statement",
            StrictOctalLiteral: "Octal literals are not allowed in strict mode.",
            StrictParamDupe: "Strict mode function may not have duplicate parameter names",
            StrictParamName: "Parameter name eval or arguments is not allowed in strict mode",
            StrictReservedWord: "Use of future reserved word in strict mode",
            StrictVarName: "Variable name may not be eval or arguments in strict mode",
            TemplateOctalLiteral: "Octal literals are not allowed in template strings.",
            UnexpectedEOS: "Unexpected end of input",
            UnexpectedIdentifier: "Unexpected identifier",
            UnexpectedNumber: "Unexpected number",
            UnexpectedReserved: "Unexpected reserved word",
            UnexpectedString: "Unexpected string",
            UnexpectedTemplate: "Unexpected quasi %0",
            UnexpectedToken: "Unexpected token %0",
            UnexpectedTokenIllegal: "Unexpected token ILLEGAL",
            UnknownLabel: "Undefined label '%0'",
            UnterminatedRegExp: "Invalid regular expression: missing /"
          };
        },
        /* 12 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var assert_12 = __webpack_require__(9);
          var character_1 = __webpack_require__(4);
          var messages_1 = __webpack_require__(11);
          function hexValue(ch) {
            return "0123456789abcdef".indexOf(ch.toLowerCase());
          }
          function octalValue(ch) {
            return "01234567".indexOf(ch);
          }
          var Scanner = function() {
            function Scanner2(code2, handler) {
              this.source = code2;
              this.errorHandler = handler;
              this.trackComment = false;
              this.isModule = false;
              this.length = code2.length;
              this.index = 0;
              this.lineNumber = code2.length > 0 ? 1 : 0;
              this.lineStart = 0;
              this.curlyStack = [];
            }
            Scanner2.prototype.saveState = function() {
              return {
                index: this.index,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart
              };
            };
            Scanner2.prototype.restoreState = function(state2) {
              this.index = state2.index;
              this.lineNumber = state2.lineNumber;
              this.lineStart = state2.lineStart;
            };
            Scanner2.prototype.eof = function() {
              return this.index >= this.length;
            };
            Scanner2.prototype.throwUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.tolerateUnexpectedToken = function(message) {
              if (message === void 0) {
                message = messages_1.Messages.UnexpectedTokenIllegal;
              }
              this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
            };
            Scanner2.prototype.skipSingleLineComment = function(offset) {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - offset;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - offset
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                ++this.index;
                if (character_1.Character.isLineTerminator(ch)) {
                  if (this.trackComment) {
                    loc.end = {
                      line: this.lineNumber,
                      column: this.index - this.lineStart - 1
                    };
                    var entry = {
                      multiLine: false,
                      slice: [start + offset, this.index - 1],
                      range: [start, this.index - 1],
                      loc
                    };
                    comments.push(entry);
                  }
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  return comments;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: false,
                  slice: [start + offset, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              return comments;
            };
            Scanner2.prototype.skipMultiLineComment = function() {
              var comments = [];
              var start, loc;
              if (this.trackComment) {
                comments = [];
                start = this.index - 2;
                loc = {
                  start: {
                    line: this.lineNumber,
                    column: this.index - this.lineStart - 2
                  },
                  end: {}
                };
              }
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isLineTerminator(ch)) {
                  if (ch === 13 && this.source.charCodeAt(this.index + 1) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  ++this.index;
                  this.lineStart = this.index;
                } else if (ch === 42) {
                  if (this.source.charCodeAt(this.index + 1) === 47) {
                    this.index += 2;
                    if (this.trackComment) {
                      loc.end = {
                        line: this.lineNumber,
                        column: this.index - this.lineStart
                      };
                      var entry = {
                        multiLine: true,
                        slice: [start + 2, this.index - 2],
                        range: [start, this.index],
                        loc
                      };
                      comments.push(entry);
                    }
                    return comments;
                  }
                  ++this.index;
                } else {
                  ++this.index;
                }
              }
              if (this.trackComment) {
                loc.end = {
                  line: this.lineNumber,
                  column: this.index - this.lineStart
                };
                var entry = {
                  multiLine: true,
                  slice: [start + 2, this.index],
                  range: [start, this.index],
                  loc
                };
                comments.push(entry);
              }
              this.tolerateUnexpectedToken();
              return comments;
            };
            Scanner2.prototype.scanComments = function() {
              var comments;
              if (this.trackComment) {
                comments = [];
              }
              var start = this.index === 0;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isWhiteSpace(ch)) {
                  ++this.index;
                } else if (character_1.Character.isLineTerminator(ch)) {
                  ++this.index;
                  if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
                    ++this.index;
                  }
                  ++this.lineNumber;
                  this.lineStart = this.index;
                  start = true;
                } else if (ch === 47) {
                  ch = this.source.charCodeAt(this.index + 1);
                  if (ch === 47) {
                    this.index += 2;
                    var comment = this.skipSingleLineComment(2);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                    start = true;
                  } else if (ch === 42) {
                    this.index += 2;
                    var comment = this.skipMultiLineComment();
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (start && ch === 45) {
                  if (this.source.charCodeAt(this.index + 1) === 45 && this.source.charCodeAt(this.index + 2) === 62) {
                    this.index += 3;
                    var comment = this.skipSingleLineComment(3);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else if (ch === 60 && !this.isModule) {
                  if (this.source.slice(this.index + 1, this.index + 4) === "!--") {
                    this.index += 4;
                    var comment = this.skipSingleLineComment(4);
                    if (this.trackComment) {
                      comments = comments.concat(comment);
                    }
                  } else {
                    break;
                  }
                } else {
                  break;
                }
              }
              return comments;
            };
            Scanner2.prototype.isFutureReservedWord = function(id) {
              switch (id) {
                case "enum":
                case "export":
                case "import":
                case "super":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isStrictModeReservedWord = function(id) {
              switch (id) {
                case "implements":
                case "interface":
                case "package":
                case "private":
                case "protected":
                case "public":
                case "static":
                case "yield":
                case "let":
                  return true;
                default:
                  return false;
              }
            };
            Scanner2.prototype.isRestrictedWord = function(id) {
              return id === "eval" || id === "arguments";
            };
            Scanner2.prototype.isKeyword = function(id) {
              switch (id.length) {
                case 2:
                  return id === "if" || id === "in" || id === "do";
                case 3:
                  return id === "var" || id === "for" || id === "new" || id === "try" || id === "let";
                case 4:
                  return id === "this" || id === "else" || id === "case" || id === "void" || id === "with" || id === "enum";
                case 5:
                  return id === "while" || id === "break" || id === "catch" || id === "throw" || id === "const" || id === "yield" || id === "class" || id === "super";
                case 6:
                  return id === "return" || id === "typeof" || id === "delete" || id === "switch" || id === "export" || id === "import";
                case 7:
                  return id === "default" || id === "finally" || id === "extends";
                case 8:
                  return id === "function" || id === "continue" || id === "debugger";
                case 10:
                  return id === "instanceof";
                default:
                  return false;
              }
            };
            Scanner2.prototype.codePointAt = function(i) {
              var cp = this.source.charCodeAt(i);
              if (cp >= 55296 && cp <= 56319) {
                var second = this.source.charCodeAt(i + 1);
                if (second >= 56320 && second <= 57343) {
                  var first2 = cp;
                  cp = (first2 - 55296) * 1024 + second - 56320 + 65536;
                }
              }
              return cp;
            };
            Scanner2.prototype.scanHexEscape = function(prefix) {
              var len = prefix === "u" ? 4 : 2;
              var code2 = 0;
              for (var i = 0; i < len; ++i) {
                if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  code2 = code2 * 16 + hexValue(this.source[this.index++]);
                } else {
                  return null;
                }
              }
              return String.fromCharCode(code2);
            };
            Scanner2.prototype.scanUnicodeCodePointEscape = function() {
              var ch = this.source[this.index];
              var code2 = 0;
              if (ch === "}") {
                this.throwUnexpectedToken();
              }
              while (!this.eof()) {
                ch = this.source[this.index++];
                if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
                  break;
                }
                code2 = code2 * 16 + hexValue(ch);
              }
              if (code2 > 1114111 || ch !== "}") {
                this.throwUnexpectedToken();
              }
              return character_1.Character.fromCodePoint(code2);
            };
            Scanner2.prototype.getIdentifier = function() {
              var start = this.index++;
              while (!this.eof()) {
                var ch = this.source.charCodeAt(this.index);
                if (ch === 92) {
                  this.index = start;
                  return this.getComplexIdentifier();
                } else if (ch >= 55296 && ch < 57343) {
                  this.index = start;
                  return this.getComplexIdentifier();
                }
                if (character_1.Character.isIdentifierPart(ch)) {
                  ++this.index;
                } else {
                  break;
                }
              }
              return this.source.slice(start, this.index);
            };
            Scanner2.prototype.getComplexIdentifier = function() {
              var cp = this.codePointAt(this.index);
              var id = character_1.Character.fromCodePoint(cp);
              this.index += id.length;
              var ch;
              if (cp === 92) {
                if (this.source.charCodeAt(this.index) !== 117) {
                  this.throwUnexpectedToken();
                }
                ++this.index;
                if (this.source[this.index] === "{") {
                  ++this.index;
                  ch = this.scanUnicodeCodePointEscape();
                } else {
                  ch = this.scanHexEscape("u");
                  if (ch === null || ch === "\\" || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken();
                  }
                }
                id = ch;
              }
              while (!this.eof()) {
                cp = this.codePointAt(this.index);
                if (!character_1.Character.isIdentifierPart(cp)) {
                  break;
                }
                ch = character_1.Character.fromCodePoint(cp);
                id += ch;
                this.index += ch.length;
                if (cp === 92) {
                  id = id.substr(0, id.length - 1);
                  if (this.source.charCodeAt(this.index) !== 117) {
                    this.throwUnexpectedToken();
                  }
                  ++this.index;
                  if (this.source[this.index] === "{") {
                    ++this.index;
                    ch = this.scanUnicodeCodePointEscape();
                  } else {
                    ch = this.scanHexEscape("u");
                    if (ch === null || ch === "\\" || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                      this.throwUnexpectedToken();
                    }
                  }
                  id += ch;
                }
              }
              return id;
            };
            Scanner2.prototype.octalToDecimal = function(ch) {
              var octal = ch !== "0";
              var code2 = octalValue(ch);
              if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                octal = true;
                code2 = code2 * 8 + octalValue(this.source[this.index++]);
                if ("0123".indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  code2 = code2 * 8 + octalValue(this.source[this.index++]);
                }
              }
              return {
                code: code2,
                octal
              };
            };
            Scanner2.prototype.scanIdentifier = function() {
              var type3;
              var start = this.index;
              var id = this.source.charCodeAt(start) === 92 ? this.getComplexIdentifier() : this.getIdentifier();
              if (id.length === 1) {
                type3 = 3;
              } else if (this.isKeyword(id)) {
                type3 = 4;
              } else if (id === "null") {
                type3 = 5;
              } else if (id === "true" || id === "false") {
                type3 = 1;
              } else {
                type3 = 3;
              }
              if (type3 !== 3 && start + id.length !== this.index) {
                var restore2 = this.index;
                this.index = start;
                this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
                this.index = restore2;
              }
              return {
                type: type3,
                value: id,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanPunctuator = function() {
              var start = this.index;
              var str2 = this.source[this.index];
              switch (str2) {
                case "(":
                case "{":
                  if (str2 === "{") {
                    this.curlyStack.push("{");
                  }
                  ++this.index;
                  break;
                case ".":
                  ++this.index;
                  if (this.source[this.index] === "." && this.source[this.index + 1] === ".") {
                    this.index += 2;
                    str2 = "...";
                  }
                  break;
                case "}":
                  ++this.index;
                  this.curlyStack.pop();
                  break;
                case ")":
                case ";":
                case ",":
                case "[":
                case "]":
                case ":":
                case "?":
                case "~":
                  ++this.index;
                  break;
                default:
                  str2 = this.source.substr(this.index, 4);
                  if (str2 === ">>>=") {
                    this.index += 4;
                  } else {
                    str2 = str2.substr(0, 3);
                    if (str2 === "===" || str2 === "!==" || str2 === ">>>" || str2 === "<<=" || str2 === ">>=" || str2 === "**=") {
                      this.index += 3;
                    } else {
                      str2 = str2.substr(0, 2);
                      if (str2 === "&&" || str2 === "||" || str2 === "==" || str2 === "!=" || str2 === "+=" || str2 === "-=" || str2 === "*=" || str2 === "/=" || str2 === "++" || str2 === "--" || str2 === "<<" || str2 === ">>" || str2 === "&=" || str2 === "|=" || str2 === "^=" || str2 === "%=" || str2 === "<=" || str2 === ">=" || str2 === "=>" || str2 === "**") {
                        this.index += 2;
                      } else {
                        str2 = this.source[this.index];
                        if ("<>=!+-*%&|^/".indexOf(str2) >= 0) {
                          ++this.index;
                        }
                      }
                    }
                  }
              }
              if (this.index === start) {
                this.throwUnexpectedToken();
              }
              return {
                type: 7,
                value: str2,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanHexLiteral = function(start) {
              var num = "";
              while (!this.eof()) {
                if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt("0x" + num, 16),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanBinaryLiteral = function(start) {
              var num = "";
              var ch;
              while (!this.eof()) {
                ch = this.source[this.index];
                if (ch !== "0" && ch !== "1") {
                  break;
                }
                num += this.source[this.index++];
              }
              if (num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (!this.eof()) {
                ch = this.source.charCodeAt(this.index);
                if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
                  this.throwUnexpectedToken();
                }
              }
              return {
                type: 6,
                value: parseInt(num, 2),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanOctalLiteral = function(prefix, start) {
              var num = "";
              var octal = false;
              if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
                octal = true;
                num = "0" + this.source[this.index++];
              } else {
                ++this.index;
              }
              while (!this.eof()) {
                if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
                  break;
                }
                num += this.source[this.index++];
              }
              if (!octal && num.length === 0) {
                this.throwUnexpectedToken();
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseInt(num, 8),
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.isImplicitOctalLiteral = function() {
              for (var i = this.index + 1; i < this.length; ++i) {
                var ch = this.source[i];
                if (ch === "8" || ch === "9") {
                  return false;
                }
                if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                  return true;
                }
              }
              return true;
            };
            Scanner2.prototype.scanNumericLiteral = function() {
              var start = this.index;
              var ch = this.source[start];
              assert_12.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || ch === ".", "Numeric literal must start with a decimal digit or a decimal point");
              var num = "";
              if (ch !== ".") {
                num = this.source[this.index++];
                ch = this.source[this.index];
                if (num === "0") {
                  if (ch === "x" || ch === "X") {
                    ++this.index;
                    return this.scanHexLiteral(start);
                  }
                  if (ch === "b" || ch === "B") {
                    ++this.index;
                    return this.scanBinaryLiteral(start);
                  }
                  if (ch === "o" || ch === "O") {
                    return this.scanOctalLiteral(ch, start);
                  }
                  if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                    if (this.isImplicitOctalLiteral()) {
                      return this.scanOctalLiteral(ch, start);
                    }
                  }
                }
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === ".") {
                num += this.source[this.index++];
                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  num += this.source[this.index++];
                }
                ch = this.source[this.index];
              }
              if (ch === "e" || ch === "E") {
                num += this.source[this.index++];
                ch = this.source[this.index];
                if (ch === "+" || ch === "-") {
                  num += this.source[this.index++];
                }
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                  while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                    num += this.source[this.index++];
                  }
                } else {
                  this.throwUnexpectedToken();
                }
              }
              if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
                this.throwUnexpectedToken();
              }
              return {
                type: 6,
                value: parseFloat(num),
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanStringLiteral = function() {
              var start = this.index;
              var quote = this.source[start];
              assert_12.assert(quote === "'" || quote === '"', "String literal must starts with a quote");
              ++this.index;
              var octal = false;
              var str2 = "";
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === quote) {
                  quote = "";
                  break;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          str2 += this.scanUnicodeCodePointEscape();
                        } else {
                          var unescaped_1 = this.scanHexEscape(ch);
                          if (unescaped_1 === null) {
                            this.throwUnexpectedToken();
                          }
                          str2 += unescaped_1;
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        str2 += unescaped;
                        break;
                      case "n":
                        str2 += "\n";
                        break;
                      case "r":
                        str2 += "\r";
                        break;
                      case "t":
                        str2 += "	";
                        break;
                      case "b":
                        str2 += "\b";
                        break;
                      case "f":
                        str2 += "\f";
                        break;
                      case "v":
                        str2 += "\v";
                        break;
                      case "8":
                      case "9":
                        str2 += ch;
                        this.tolerateUnexpectedToken();
                        break;
                      default:
                        if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          var octToDec = this.octalToDecimal(ch);
                          octal = octToDec.octal || octal;
                          str2 += String.fromCharCode(octToDec.code);
                        } else {
                          str2 += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  break;
                } else {
                  str2 += ch;
                }
              }
              if (quote !== "") {
                this.index = start;
                this.throwUnexpectedToken();
              }
              return {
                type: 8,
                value: str2,
                octal,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.scanTemplate = function() {
              var cooked = "";
              var terminated = false;
              var start = this.index;
              var head = this.source[start] === "`";
              var tail = false;
              var rawOffset = 2;
              ++this.index;
              while (!this.eof()) {
                var ch = this.source[this.index++];
                if (ch === "`") {
                  rawOffset = 1;
                  tail = true;
                  terminated = true;
                  break;
                } else if (ch === "$") {
                  if (this.source[this.index] === "{") {
                    this.curlyStack.push("${");
                    ++this.index;
                    terminated = true;
                    break;
                  }
                  cooked += ch;
                } else if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    switch (ch) {
                      case "n":
                        cooked += "\n";
                        break;
                      case "r":
                        cooked += "\r";
                        break;
                      case "t":
                        cooked += "	";
                        break;
                      case "u":
                        if (this.source[this.index] === "{") {
                          ++this.index;
                          cooked += this.scanUnicodeCodePointEscape();
                        } else {
                          var restore2 = this.index;
                          var unescaped_2 = this.scanHexEscape(ch);
                          if (unescaped_2 !== null) {
                            cooked += unescaped_2;
                          } else {
                            this.index = restore2;
                            cooked += ch;
                          }
                        }
                        break;
                      case "x":
                        var unescaped = this.scanHexEscape(ch);
                        if (unescaped === null) {
                          this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
                        }
                        cooked += unescaped;
                        break;
                      case "b":
                        cooked += "\b";
                        break;
                      case "f":
                        cooked += "\f";
                        break;
                      case "v":
                        cooked += "\v";
                        break;
                      default:
                        if (ch === "0") {
                          if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
                            this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                          }
                          cooked += "\0";
                        } else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
                          this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
                        } else {
                          cooked += ch;
                        }
                        break;
                    }
                  } else {
                    ++this.lineNumber;
                    if (ch === "\r" && this.source[this.index] === "\n") {
                      ++this.index;
                    }
                    this.lineStart = this.index;
                  }
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  ++this.lineNumber;
                  if (ch === "\r" && this.source[this.index] === "\n") {
                    ++this.index;
                  }
                  this.lineStart = this.index;
                  cooked += "\n";
                } else {
                  cooked += ch;
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken();
              }
              if (!head) {
                this.curlyStack.pop();
              }
              return {
                type: 10,
                value: this.source.slice(start + 1, this.index - rawOffset),
                cooked,
                head,
                tail,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.testRegExp = function(pattern, flags) {
              var astralSubstitute = "ï¿¿";
              var tmp = pattern;
              var self3 = this;
              if (flags.indexOf("u") >= 0) {
                tmp = tmp.replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function($0, $1, $2) {
                  var codePoint = parseInt($1 || $2, 16);
                  if (codePoint > 1114111) {
                    self3.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
                  }
                  if (codePoint <= 65535) {
                    return String.fromCharCode(codePoint);
                  }
                  return astralSubstitute;
                }).replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
              }
              try {
                RegExp(tmp);
              } catch (e) {
                this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
              }
              try {
                return new RegExp(pattern, flags);
              } catch (exception) {
                return null;
              }
            };
            Scanner2.prototype.scanRegExpBody = function() {
              var ch = this.source[this.index];
              assert_12.assert(ch === "/", "Regular expression literal must start with a slash");
              var str2 = this.source[this.index++];
              var classMarker = false;
              var terminated = false;
              while (!this.eof()) {
                ch = this.source[this.index++];
                str2 += ch;
                if (ch === "\\") {
                  ch = this.source[this.index++];
                  if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                  }
                  str2 += ch;
                } else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
                  this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
                } else if (classMarker) {
                  if (ch === "]") {
                    classMarker = false;
                  }
                } else {
                  if (ch === "/") {
                    terminated = true;
                    break;
                  } else if (ch === "[") {
                    classMarker = true;
                  }
                }
              }
              if (!terminated) {
                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
              }
              return str2.substr(1, str2.length - 2);
            };
            Scanner2.prototype.scanRegExpFlags = function() {
              var str2 = "";
              var flags = "";
              while (!this.eof()) {
                var ch = this.source[this.index];
                if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
                  break;
                }
                ++this.index;
                if (ch === "\\" && !this.eof()) {
                  ch = this.source[this.index];
                  if (ch === "u") {
                    ++this.index;
                    var restore2 = this.index;
                    var char = this.scanHexEscape("u");
                    if (char !== null) {
                      flags += char;
                      for (str2 += "\\u"; restore2 < this.index; ++restore2) {
                        str2 += this.source[restore2];
                      }
                    } else {
                      this.index = restore2;
                      flags += "u";
                      str2 += "\\u";
                    }
                    this.tolerateUnexpectedToken();
                  } else {
                    str2 += "\\";
                    this.tolerateUnexpectedToken();
                  }
                } else {
                  flags += ch;
                  str2 += ch;
                }
              }
              return flags;
            };
            Scanner2.prototype.scanRegExp = function() {
              var start = this.index;
              var pattern = this.scanRegExpBody();
              var flags = this.scanRegExpFlags();
              var value2 = this.testRegExp(pattern, flags);
              return {
                type: 9,
                value: "",
                pattern,
                flags,
                regex: value2,
                lineNumber: this.lineNumber,
                lineStart: this.lineStart,
                start,
                end: this.index
              };
            };
            Scanner2.prototype.lex = function() {
              if (this.eof()) {
                return {
                  type: 2,
                  value: "",
                  lineNumber: this.lineNumber,
                  lineStart: this.lineStart,
                  start: this.index,
                  end: this.index
                };
              }
              var cp = this.source.charCodeAt(this.index);
              if (character_1.Character.isIdentifierStart(cp)) {
                return this.scanIdentifier();
              }
              if (cp === 40 || cp === 41 || cp === 59) {
                return this.scanPunctuator();
              }
              if (cp === 39 || cp === 34) {
                return this.scanStringLiteral();
              }
              if (cp === 46) {
                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
                  return this.scanNumericLiteral();
                }
                return this.scanPunctuator();
              }
              if (character_1.Character.isDecimalDigit(cp)) {
                return this.scanNumericLiteral();
              }
              if (cp === 96 || cp === 125 && this.curlyStack[this.curlyStack.length - 1] === "${") {
                return this.scanTemplate();
              }
              if (cp >= 55296 && cp < 57343) {
                if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
                  return this.scanIdentifier();
                }
              }
              return this.scanPunctuator();
            };
            return Scanner2;
          }();
          exports2.Scanner = Scanner;
        },
        /* 13 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.TokenName = {};
          exports2.TokenName[
            1
            /* BooleanLiteral */
          ] = "Boolean";
          exports2.TokenName[
            2
            /* EOF */
          ] = "<end>";
          exports2.TokenName[
            3
            /* Identifier */
          ] = "Identifier";
          exports2.TokenName[
            4
            /* Keyword */
          ] = "Keyword";
          exports2.TokenName[
            5
            /* NullLiteral */
          ] = "Null";
          exports2.TokenName[
            6
            /* NumericLiteral */
          ] = "Numeric";
          exports2.TokenName[
            7
            /* Punctuator */
          ] = "Punctuator";
          exports2.TokenName[
            8
            /* StringLiteral */
          ] = "String";
          exports2.TokenName[
            9
            /* RegularExpression */
          ] = "RegularExpression";
          exports2.TokenName[
            10
            /* Template */
          ] = "Template";
        },
        /* 14 */
        /***/
        function(module3, exports2) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          exports2.XHTMLEntities = {
            quot: '"',
            amp: "&",
            apos: "'",
            gt: ">",
            nbsp: "Â ",
            iexcl: "Â¡",
            cent: "Â¢",
            pound: "Â£",
            curren: "Â¤",
            yen: "Â¥",
            brvbar: "Â¦",
            sect: "Â§",
            uml: "Â¨",
            copy: "Â©",
            ordf: "Âª",
            laquo: "Â«",
            not: "Â¬",
            shy: "Â­",
            reg: "Â®",
            macr: "Â¯",
            deg: "Â°",
            plusmn: "Â±",
            sup2: "Â²",
            sup3: "Â³",
            acute: "Â´",
            micro: "Âµ",
            para: "Â¶",
            middot: "Â·",
            cedil: "Â¸",
            sup1: "Â¹",
            ordm: "Âº",
            raquo: "Â»",
            frac14: "Â¼",
            frac12: "Â½",
            frac34: "Â¾",
            iquest: "Â¿",
            Agrave: "Ã€",
            Aacute: "Ã",
            Acirc: "Ã‚",
            Atilde: "Ãƒ",
            Auml: "Ã„",
            Aring: "Ã…",
            AElig: "Ã†",
            Ccedil: "Ã‡",
            Egrave: "Ãˆ",
            Eacute: "Ã‰",
            Ecirc: "ÃŠ",
            Euml: "Ã‹",
            Igrave: "ÃŒ",
            Iacute: "Ã",
            Icirc: "ÃŽ",
            Iuml: "Ã",
            ETH: "Ã",
            Ntilde: "Ã‘",
            Ograve: "Ã’",
            Oacute: "Ã“",
            Ocirc: "Ã”",
            Otilde: "Ã•",
            Ouml: "Ã–",
            times: "Ã—",
            Oslash: "Ã˜",
            Ugrave: "Ã™",
            Uacute: "Ãš",
            Ucirc: "Ã›",
            Uuml: "Ãœ",
            Yacute: "Ã",
            THORN: "Ãž",
            szlig: "ÃŸ",
            agrave: "Ã ",
            aacute: "Ã¡",
            acirc: "Ã¢",
            atilde: "Ã£",
            auml: "Ã¤",
            aring: "Ã¥",
            aelig: "Ã¦",
            ccedil: "Ã§",
            egrave: "Ã¨",
            eacute: "Ã©",
            ecirc: "Ãª",
            euml: "Ã«",
            igrave: "Ã¬",
            iacute: "Ã­",
            icirc: "Ã®",
            iuml: "Ã¯",
            eth: "Ã°",
            ntilde: "Ã±",
            ograve: "Ã²",
            oacute: "Ã³",
            ocirc: "Ã´",
            otilde: "Ãµ",
            ouml: "Ã¶",
            divide: "Ã·",
            oslash: "Ã¸",
            ugrave: "Ã¹",
            uacute: "Ãº",
            ucirc: "Ã»",
            uuml: "Ã¼",
            yacute: "Ã½",
            thorn: "Ã¾",
            yuml: "Ã¿",
            OElig: "Å’",
            oelig: "Å“",
            Scaron: "Å ",
            scaron: "Å¡",
            Yuml: "Å¸",
            fnof: "Æ’",
            circ: "Ë†",
            tilde: "Ëœ",
            Alpha: "Î‘",
            Beta: "Î’",
            Gamma: "Î“",
            Delta: "Î”",
            Epsilon: "Î•",
            Zeta: "Î–",
            Eta: "Î—",
            Theta: "Î˜",
            Iota: "Î™",
            Kappa: "Îš",
            Lambda: "Î›",
            Mu: "Îœ",
            Nu: "Î",
            Xi: "Îž",
            Omicron: "ÎŸ",
            Pi: "Î ",
            Rho: "Î¡",
            Sigma: "Î£",
            Tau: "Î¤",
            Upsilon: "Î¥",
            Phi: "Î¦",
            Chi: "Î§",
            Psi: "Î¨",
            Omega: "Î©",
            alpha: "Î±",
            beta: "Î²",
            gamma: "Î³",
            delta: "Î´",
            epsilon: "Îµ",
            zeta: "Î¶",
            eta: "Î·",
            theta: "Î¸",
            iota: "Î¹",
            kappa: "Îº",
            lambda: "Î»",
            mu: "Î¼",
            nu: "Î½",
            xi: "Î¾",
            omicron: "Î¿",
            pi: "Ï€",
            rho: "Ï",
            sigmaf: "Ï‚",
            sigma: "Ïƒ",
            tau: "Ï„",
            upsilon: "Ï…",
            phi: "Ï†",
            chi: "Ï‡",
            psi: "Ïˆ",
            omega: "Ï‰",
            thetasym: "Ï‘",
            upsih: "Ï’",
            piv: "Ï–",
            ensp: "â€‚",
            emsp: "â€ƒ",
            thinsp: "â€‰",
            zwnj: "â€Œ",
            zwj: "â€",
            lrm: "â€Ž",
            rlm: "â€",
            ndash: "â€“",
            mdash: "â€”",
            lsquo: "â€˜",
            rsquo: "â€™",
            sbquo: "â€š",
            ldquo: "â€œ",
            rdquo: "â€",
            bdquo: "â€ž",
            dagger: "â€ ",
            Dagger: "â€¡",
            bull: "â€¢",
            hellip: "â€¦",
            permil: "â€°",
            prime: "â€²",
            Prime: "â€³",
            lsaquo: "â€¹",
            rsaquo: "â€º",
            oline: "â€¾",
            frasl: "â„",
            euro: "â‚¬",
            image: "â„‘",
            weierp: "â„˜",
            real: "â„œ",
            trade: "â„¢",
            alefsym: "â„µ",
            larr: "â†",
            uarr: "â†‘",
            rarr: "â†’",
            darr: "â†“",
            harr: "â†”",
            crarr: "â†µ",
            lArr: "â‡",
            uArr: "â‡‘",
            rArr: "â‡’",
            dArr: "â‡“",
            hArr: "â‡”",
            forall: "âˆ€",
            part: "âˆ‚",
            exist: "âˆƒ",
            empty: "âˆ…",
            nabla: "âˆ‡",
            isin: "âˆˆ",
            notin: "âˆ‰",
            ni: "âˆ‹",
            prod: "âˆ",
            sum: "âˆ‘",
            minus: "âˆ’",
            lowast: "âˆ—",
            radic: "âˆš",
            prop: "âˆ",
            infin: "âˆž",
            ang: "âˆ ",
            and: "âˆ§",
            or: "âˆ¨",
            cap: "âˆ©",
            cup: "âˆª",
            int: "âˆ«",
            there4: "âˆ´",
            sim: "âˆ¼",
            cong: "â‰…",
            asymp: "â‰ˆ",
            ne: "â‰ ",
            equiv: "â‰¡",
            le: "â‰¤",
            ge: "â‰¥",
            sub: "âŠ‚",
            sup: "âŠƒ",
            nsub: "âŠ„",
            sube: "âŠ†",
            supe: "âŠ‡",
            oplus: "âŠ•",
            otimes: "âŠ—",
            perp: "âŠ¥",
            sdot: "â‹…",
            lceil: "âŒˆ",
            rceil: "âŒ‰",
            lfloor: "âŒŠ",
            rfloor: "âŒ‹",
            loz: "â—Š",
            spades: "â™ ",
            clubs: "â™£",
            hearts: "â™¥",
            diams: "â™¦",
            lang: "âŸ¨",
            rang: "âŸ©"
          };
        },
        /* 15 */
        /***/
        function(module3, exports2, __webpack_require__) {
          Object.defineProperty(exports2, "__esModule", { value: true });
          var error_handler_1 = __webpack_require__(10);
          var scanner_1 = __webpack_require__(12);
          var token_1 = __webpack_require__(13);
          var Reader = function() {
            function Reader2() {
              this.values = [];
              this.curly = this.paren = -1;
            }
            Reader2.prototype.beforeFunctionExpression = function(t2) {
              return [
                "(",
                "{",
                "[",
                "in",
                "typeof",
                "instanceof",
                "new",
                "return",
                "case",
                "delete",
                "throw",
                "void",
                // assignment operators
                "=",
                "+=",
                "-=",
                "*=",
                "**=",
                "/=",
                "%=",
                "<<=",
                ">>=",
                ">>>=",
                "&=",
                "|=",
                "^=",
                ",",
                // binary/unary operators
                "+",
                "-",
                "*",
                "**",
                "/",
                "%",
                "++",
                "--",
                "<<",
                ">>",
                ">>>",
                "&",
                "|",
                "^",
                "!",
                "~",
                "&&",
                "||",
                "?",
                ":",
                "===",
                "==",
                ">=",
                "<=",
                "<",
                ">",
                "!=",
                "!=="
              ].indexOf(t2) >= 0;
            };
            Reader2.prototype.isRegexStart = function() {
              var previous = this.values[this.values.length - 1];
              var regex = previous !== null;
              switch (previous) {
                case "this":
                case "]":
                  regex = false;
                  break;
                case ")":
                  var keyword2 = this.values[this.paren - 1];
                  regex = keyword2 === "if" || keyword2 === "while" || keyword2 === "for" || keyword2 === "with";
                  break;
                case "}":
                  regex = false;
                  if (this.values[this.curly - 3] === "function") {
                    var check = this.values[this.curly - 4];
                    regex = check ? !this.beforeFunctionExpression(check) : false;
                  } else if (this.values[this.curly - 4] === "function") {
                    var check = this.values[this.curly - 5];
                    regex = check ? !this.beforeFunctionExpression(check) : true;
                  }
                  break;
              }
              return regex;
            };
            Reader2.prototype.push = function(token) {
              if (token.type === 7 || token.type === 4) {
                if (token.value === "{") {
                  this.curly = this.values.length;
                } else if (token.value === "(") {
                  this.paren = this.values.length;
                }
                this.values.push(token.value);
              } else {
                this.values.push(null);
              }
            };
            return Reader2;
          }();
          var Tokenizer = function() {
            function Tokenizer2(code2, config) {
              this.errorHandler = new error_handler_1.ErrorHandler();
              this.errorHandler.tolerant = config ? typeof config.tolerant === "boolean" && config.tolerant : false;
              this.scanner = new scanner_1.Scanner(code2, this.errorHandler);
              this.scanner.trackComment = config ? typeof config.comment === "boolean" && config.comment : false;
              this.trackRange = config ? typeof config.range === "boolean" && config.range : false;
              this.trackLoc = config ? typeof config.loc === "boolean" && config.loc : false;
              this.buffer = [];
              this.reader = new Reader();
            }
            Tokenizer2.prototype.errors = function() {
              return this.errorHandler.errors;
            };
            Tokenizer2.prototype.getNextToken = function() {
              if (this.buffer.length === 0) {
                var comments = this.scanner.scanComments();
                if (this.scanner.trackComment) {
                  for (var i = 0; i < comments.length; ++i) {
                    var e = comments[i];
                    var value2 = this.scanner.source.slice(e.slice[0], e.slice[1]);
                    var comment = {
                      type: e.multiLine ? "BlockComment" : "LineComment",
                      value: value2
                    };
                    if (this.trackRange) {
                      comment.range = e.range;
                    }
                    if (this.trackLoc) {
                      comment.loc = e.loc;
                    }
                    this.buffer.push(comment);
                  }
                }
                if (!this.scanner.eof()) {
                  var loc = void 0;
                  if (this.trackLoc) {
                    loc = {
                      start: {
                        line: this.scanner.lineNumber,
                        column: this.scanner.index - this.scanner.lineStart
                      },
                      end: {}
                    };
                  }
                  var startRegex = this.scanner.source[this.scanner.index] === "/" && this.reader.isRegexStart();
                  var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
                  this.reader.push(token);
                  var entry = {
                    type: token_1.TokenName[token.type],
                    value: this.scanner.source.slice(token.start, token.end)
                  };
                  if (this.trackRange) {
                    entry.range = [token.start, token.end];
                  }
                  if (this.trackLoc) {
                    loc.end = {
                      line: this.scanner.lineNumber,
                      column: this.scanner.index - this.scanner.lineStart
                    };
                    entry.loc = loc;
                  }
                  if (token.type === 9) {
                    var pattern = token.pattern;
                    var flags = token.flags;
                    entry.regex = { pattern, flags };
                  }
                  this.buffer.push(entry);
                }
              }
              return this.buffer.shift();
            };
            return Tokenizer2;
          }();
          exports2.Tokenizer = Tokenizer;
        }
        /******/
      ])
    );
  });
})(esprima$1);
var esprimaExports = esprima$1.exports;
var main$1 = {};
var extendStatics = function(d2, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b2) {
    d3.__proto__ = b2;
  } || function(d3, b2) {
    for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d3[p] = b2[p];
  };
  return extendStatics(d2, b);
};
function __extends(d2, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d2, b);
  function __2() {
    this.constructor = d2;
  }
  d2.prototype = b === null ? Object.create(b) : (__2.prototype = b.prototype, new __2());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i = 1, n = arguments.length; i < n; i++) {
      s2 = arguments[i];
      for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p)) t2[p] = s2[p];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e) {
  var t2 = {};
  for (var p in s2) if (Object.prototype.hasOwnProperty.call(s2, p) && e.indexOf(p) < 0)
    t2[p] = s2[p];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s2); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p[i]))
        t2[p[i]] = s2[p[i]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc2) {
  var c = arguments.length, r = c < 3 ? target : desc2 === null ? desc2 = Object.getOwnPropertyDescriptor(target, key) : desc2, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc2);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d2 = decorators[i]) r = (c < 3 ? d2(r) : c > 3 ? d2(target, key, r) : d2(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context2 = {};
    for (var p in contextIn) context2[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context2.access[p] = contextIn.access[p];
    context2.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context2);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value2) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value2 = useValue ? initializers[i].call(thisArg, value2) : initializers[i].call(thisArg);
  }
  return useValue ? value2 : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name2, prefix) {
  if (typeof name2 === "symbol") name2 = name2.description ? "[".concat(name2.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name2) : name2 });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve3) {
      resolve3(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve3, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve3(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f, y2, t2, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t2 = _.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t2[1]) {
            _.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _.label < t2[2]) {
            _.label = t2[2];
            _.ops.push(op);
            break;
          }
          if (t2[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y2 = 0;
    } finally {
      f = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
var __createBinding$1 = Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
};
function __exportStar(m2, o) {
  for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding$1(o, m2, p);
}
function __values(o) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m2 = s2 && o[s2], i = 0;
  if (m2) return m2.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m2 = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m2) return o;
  var i = m2.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error2) {
    e = { error: error2 };
  } finally {
    try {
      if (r && !r.done && (m2 = i["return"])) m2.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s2 = 0, i = 0, il = arguments.length; i < il; i++) s2 += arguments[i].length;
  for (var r = Array(s2), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j2 = 0, jl = a.length; j2 < jl; j2++, k++)
      r[k] = a[j2];
  return r;
}
function __spreadArray(to, from2, pack2) {
  if (pack2 || arguments.length === 2) for (var i = 0, l = from2.length, ar; i < l; i++) {
    if (ar || !(i in from2)) {
      if (!ar) ar = Array.prototype.slice.call(from2, 0, i);
      ar[i] = from2[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from2));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume2(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume2(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle2(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle2(q[0][2], r);
  }
  function fulfill(value2) {
    resume2("next", value2);
  }
  function reject(value2) {
    resume2("throw", value2);
  }
  function settle2(f, v) {
    if (f(v), q.shift(), q.length) resume2(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m2 = o[Symbol.asyncIterator], i;
  return m2 ? m2.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve3, reject) {
        v = o[n](v), settle2(resolve3, reject, v.done, v.value);
      });
    };
  }
  function settle2(resolve3, reject, d2, v) {
    Promise.resolve(v).then(function(v2) {
      resolve3({ value: v2, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
var __setModuleDefault$1 = Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
};
function __importStar$1(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding$1(result, mod, k);
  }
  __setModuleDefault$1(result, mod);
  return result;
}
function __importDefault$2(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state2, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state2.get(receiver);
}
function __classPrivateFieldSet(receiver, state2, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state2 === "function" ? receiver !== state2 || !f : !state2.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state2.set(receiver, value2), value2;
}
function __classPrivateFieldIn(state2, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state2 === "function" ? receiver === state2 : state2.has(receiver);
}
function __addDisposableResource(env, value2, async2) {
  if (value2 !== null && value2 !== void 0) {
    if (typeof value2 !== "object" && typeof value2 !== "function") throw new TypeError("Object expected.");
    var dispose2, inner;
    if (async2) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose2 = value2[Symbol.asyncDispose];
    }
    if (dispose2 === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose2 = value2[Symbol.dispose];
      if (async2) inner = dispose2;
    }
    if (typeof dispose2 !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose2 = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value: value2, dispose: dispose2, async: async2 });
  } else if (async2) {
    env.stack.push({ async: true });
  }
  return value2;
}
var _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error2, suppressed, message) {
  var e = new Error(message);
  return e.name = "SuppressedError", e.error = error2, e.suppressed = suppressed, e;
};
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s2 = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s2 === 1) return s2 = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s2 |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s2 |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s2 === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
const tslib_es6 = {
  __extends,
  __assign,
  __rest,
  __decorate,
  __param,
  __metadata,
  __awaiter,
  __generator,
  __createBinding: __createBinding$1,
  __exportStar,
  __values,
  __read,
  __spread,
  __spreadArrays,
  __spreadArray,
  __await,
  __asyncGenerator,
  __asyncDelegator,
  __asyncValues,
  __makeTemplateObject,
  __importStar: __importStar$1,
  __importDefault: __importDefault$2,
  __classPrivateFieldGet,
  __classPrivateFieldSet,
  __classPrivateFieldIn,
  __addDisposableResource,
  __disposeResources
};
const tslib_es6$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  __addDisposableResource,
  get __assign() {
    return __assign;
  },
  __asyncDelegator,
  __asyncGenerator,
  __asyncValues,
  __await,
  __awaiter,
  __classPrivateFieldGet,
  __classPrivateFieldIn,
  __classPrivateFieldSet,
  __createBinding: __createBinding$1,
  __decorate,
  __disposeResources,
  __esDecorate,
  __exportStar,
  __extends,
  __generator,
  __importDefault: __importDefault$2,
  __importStar: __importStar$1,
  __makeTemplateObject,
  __metadata,
  __param,
  __propKey,
  __read,
  __rest,
  __runInitializers,
  __setFunctionName,
  __spread,
  __spreadArray,
  __spreadArrays,
  __values,
  default: tslib_es6
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(tslib_es6$1);
var fork = { exports: {} };
var types$2 = {};
var hasRequiredTypes$1;
function requireTypes$1() {
  if (hasRequiredTypes$1) return types$2;
  hasRequiredTypes$1 = 1;
  Object.defineProperty(types$2, "__esModule", { value: true });
  types$2.Def = void 0;
  var tslib_1 = require$$0;
  var Op = Object.prototype;
  var objToStr = Op.toString;
  var hasOwn = Op.hasOwnProperty;
  var BaseType = (
    /** @class */
    function() {
      function BaseType2() {
      }
      BaseType2.prototype.assert = function(value2, deep) {
        if (!this.check(value2, deep)) {
          var str2 = shallowStringify(value2);
          throw new Error(str2 + " does not match type " + this);
        }
        return true;
      };
      BaseType2.prototype.arrayOf = function() {
        var elemType = this;
        return new ArrayType(elemType);
      };
      return BaseType2;
    }()
  );
  var ArrayType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(ArrayType2, _super);
      function ArrayType2(elemType) {
        var _this = _super.call(this) || this;
        _this.elemType = elemType;
        _this.kind = "ArrayType";
        return _this;
      }
      ArrayType2.prototype.toString = function() {
        return "[" + this.elemType + "]";
      };
      ArrayType2.prototype.check = function(value2, deep) {
        var _this = this;
        return Array.isArray(value2) && value2.every(function(elem) {
          return _this.elemType.check(elem, deep);
        });
      };
      return ArrayType2;
    }(BaseType)
  );
  var IdentityType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(IdentityType2, _super);
      function IdentityType2(value2) {
        var _this = _super.call(this) || this;
        _this.value = value2;
        _this.kind = "IdentityType";
        return _this;
      }
      IdentityType2.prototype.toString = function() {
        return String(this.value);
      };
      IdentityType2.prototype.check = function(value2, deep) {
        var result = value2 === this.value;
        if (!result && typeof deep === "function") {
          deep(this, value2);
        }
        return result;
      };
      return IdentityType2;
    }(BaseType)
  );
  var ObjectType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(ObjectType2, _super);
      function ObjectType2(fields) {
        var _this = _super.call(this) || this;
        _this.fields = fields;
        _this.kind = "ObjectType";
        return _this;
      }
      ObjectType2.prototype.toString = function() {
        return "{ " + this.fields.join(", ") + " }";
      };
      ObjectType2.prototype.check = function(value2, deep) {
        return objToStr.call(value2) === objToStr.call({}) && this.fields.every(function(field) {
          return field.type.check(value2[field.name], deep);
        });
      };
      return ObjectType2;
    }(BaseType)
  );
  var OrType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(OrType2, _super);
      function OrType2(types2) {
        var _this = _super.call(this) || this;
        _this.types = types2;
        _this.kind = "OrType";
        return _this;
      }
      OrType2.prototype.toString = function() {
        return this.types.join(" | ");
      };
      OrType2.prototype.check = function(value2, deep) {
        return this.types.some(function(type3) {
          return type3.check(value2, deep);
        });
      };
      return OrType2;
    }(BaseType)
  );
  var PredicateType = (
    /** @class */
    function(_super) {
      tslib_1.__extends(PredicateType2, _super);
      function PredicateType2(name2, predicate) {
        var _this = _super.call(this) || this;
        _this.name = name2;
        _this.predicate = predicate;
        _this.kind = "PredicateType";
        return _this;
      }
      PredicateType2.prototype.toString = function() {
        return this.name;
      };
      PredicateType2.prototype.check = function(value2, deep) {
        var result = this.predicate(value2, deep);
        if (!result && typeof deep === "function") {
          deep(this, value2);
        }
        return result;
      };
      return PredicateType2;
    }(BaseType)
  );
  var Def = (
    /** @class */
    function() {
      function Def2(type3, typeName) {
        this.type = type3;
        this.typeName = typeName;
        this.baseNames = [];
        this.ownFields = /* @__PURE__ */ Object.create(null);
        this.allSupertypes = /* @__PURE__ */ Object.create(null);
        this.supertypeList = [];
        this.allFields = /* @__PURE__ */ Object.create(null);
        this.fieldNames = [];
        this.finalized = false;
        this.buildable = false;
        this.buildParams = [];
      }
      Def2.prototype.isSupertypeOf = function(that) {
        if (that instanceof Def2) {
          if (this.finalized !== true || that.finalized !== true) {
            throw new Error("");
          }
          return hasOwn.call(that.allSupertypes, this.typeName);
        } else {
          throw new Error(that + " is not a Def");
        }
      };
      Def2.prototype.checkAllFields = function(value2, deep) {
        var allFields = this.allFields;
        if (this.finalized !== true) {
          throw new Error("" + this.typeName);
        }
        function checkFieldByName(name2) {
          var field = allFields[name2];
          var type3 = field.type;
          var child = field.getValue(value2);
          return type3.check(child, deep);
        }
        return value2 !== null && typeof value2 === "object" && Object.keys(allFields).every(checkFieldByName);
      };
      Def2.prototype.bases = function() {
        var supertypeNames = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          supertypeNames[_i] = arguments[_i];
        }
        var bases = this.baseNames;
        if (this.finalized) {
          if (supertypeNames.length !== bases.length) {
            throw new Error("");
          }
          for (var i = 0; i < supertypeNames.length; i++) {
            if (supertypeNames[i] !== bases[i]) {
              throw new Error("");
            }
          }
          return this;
        }
        supertypeNames.forEach(function(baseName) {
          if (bases.indexOf(baseName) < 0) {
            bases.push(baseName);
          }
        });
        return this;
      };
      return Def2;
    }()
  );
  types$2.Def = Def;
  var Field = (
    /** @class */
    function() {
      function Field2(name2, type3, defaultFn, hidden2) {
        this.name = name2;
        this.type = type3;
        this.defaultFn = defaultFn;
        this.hidden = !!hidden2;
      }
      Field2.prototype.toString = function() {
        return JSON.stringify(this.name) + ": " + this.type;
      };
      Field2.prototype.getValue = function(obj) {
        var value2 = obj[this.name];
        if (typeof value2 !== "undefined") {
          return value2;
        }
        if (typeof this.defaultFn === "function") {
          value2 = this.defaultFn.call(obj);
        }
        return value2;
      };
      return Field2;
    }()
  );
  function shallowStringify(value2) {
    if (Array.isArray(value2)) {
      return "[" + value2.map(shallowStringify).join(", ") + "]";
    }
    if (value2 && typeof value2 === "object") {
      return "{ " + Object.keys(value2).map(function(key) {
        return key + ": " + value2[key];
      }).join(", ") + " }";
    }
    return JSON.stringify(value2);
  }
  function typesPlugin(_fork) {
    var Type = {
      or: function() {
        var types2 = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          types2[_i] = arguments[_i];
        }
        return new OrType(types2.map(function(type3) {
          return Type.from(type3);
        }));
      },
      from: function(value2, name2) {
        if (value2 instanceof ArrayType || value2 instanceof IdentityType || value2 instanceof ObjectType || value2 instanceof OrType || value2 instanceof PredicateType) {
          return value2;
        }
        if (value2 instanceof Def) {
          return value2.type;
        }
        if (isArray2.check(value2)) {
          if (value2.length !== 1) {
            throw new Error("only one element type is permitted for typed arrays");
          }
          return new ArrayType(Type.from(value2[0]));
        }
        if (isObject2.check(value2)) {
          return new ObjectType(Object.keys(value2).map(function(name3) {
            return new Field(name3, Type.from(value2[name3], name3));
          }));
        }
        if (typeof value2 === "function") {
          var bicfIndex = builtInCtorFns.indexOf(value2);
          if (bicfIndex >= 0) {
            return builtInCtorTypes[bicfIndex];
          }
          if (typeof name2 !== "string") {
            throw new Error("missing name");
          }
          return new PredicateType(name2, value2);
        }
        return new IdentityType(value2);
      },
      // Define a type whose name is registered in a namespace (the defCache) so
      // that future definitions will return the same type given the same name.
      // In particular, this system allows for circular and forward definitions.
      // The Def object d returned from Type.def may be used to configure the
      // type d.type by calling methods such as d.bases, d.build, and d.field.
      def: function(typeName) {
        return hasOwn.call(defCache, typeName) ? defCache[typeName] : defCache[typeName] = new DefImpl(typeName);
      },
      hasDef: function(typeName) {
        return hasOwn.call(defCache, typeName);
      }
    };
    var builtInCtorFns = [];
    var builtInCtorTypes = [];
    function defBuiltInType(name2, example) {
      var objStr = objToStr.call(example);
      var type3 = new PredicateType(name2, function(value2) {
        return objToStr.call(value2) === objStr;
      });
      if (example && typeof example.constructor === "function") {
        builtInCtorFns.push(example.constructor);
        builtInCtorTypes.push(type3);
      }
      return type3;
    }
    var isString2 = defBuiltInType("string", "truthy");
    var isFunction2 = defBuiltInType("function", function() {
    });
    var isArray2 = defBuiltInType("array", []);
    var isObject2 = defBuiltInType("object", {});
    var isRegExp2 = defBuiltInType("RegExp", /./);
    var isDate2 = defBuiltInType("Date", /* @__PURE__ */ new Date());
    var isNumber2 = defBuiltInType("number", 3);
    var isBoolean2 = defBuiltInType("boolean", true);
    var isNull = defBuiltInType("null", null);
    var isUndefined2 = defBuiltInType("undefined", void 0);
    var builtInTypes = {
      string: isString2,
      function: isFunction2,
      array: isArray2,
      object: isObject2,
      RegExp: isRegExp2,
      Date: isDate2,
      number: isNumber2,
      boolean: isBoolean2,
      null: isNull,
      undefined: isUndefined2
    };
    var defCache = /* @__PURE__ */ Object.create(null);
    function defFromValue(value2) {
      if (value2 && typeof value2 === "object") {
        var type3 = value2.type;
        if (typeof type3 === "string" && hasOwn.call(defCache, type3)) {
          var d2 = defCache[type3];
          if (d2.finalized) {
            return d2;
          }
        }
      }
      return null;
    }
    var DefImpl = (
      /** @class */
      function(_super) {
        tslib_1.__extends(DefImpl2, _super);
        function DefImpl2(typeName) {
          var _this = _super.call(this, new PredicateType(typeName, function(value2, deep) {
            return _this.check(value2, deep);
          }), typeName) || this;
          return _this;
        }
        DefImpl2.prototype.check = function(value2, deep) {
          if (this.finalized !== true) {
            throw new Error("prematurely checking unfinalized type " + this.typeName);
          }
          if (value2 === null || typeof value2 !== "object") {
            return false;
          }
          var vDef = defFromValue(value2);
          if (!vDef) {
            if (this.typeName === "SourceLocation" || this.typeName === "Position") {
              return this.checkAllFields(value2, deep);
            }
            return false;
          }
          if (deep && vDef === this) {
            return this.checkAllFields(value2, deep);
          }
          if (!this.isSupertypeOf(vDef)) {
            return false;
          }
          if (!deep) {
            return true;
          }
          return vDef.checkAllFields(value2, deep) && this.checkAllFields(value2, false);
        };
        DefImpl2.prototype.build = function() {
          var _this = this;
          var buildParams = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            buildParams[_i] = arguments[_i];
          }
          this.buildParams = buildParams;
          if (this.buildable) {
            return this;
          }
          this.field("type", String, function() {
            return _this.typeName;
          });
          this.buildable = true;
          var addParam = function(built, param3, arg, isArgAvailable) {
            if (hasOwn.call(built, param3))
              return;
            var all3 = _this.allFields;
            if (!hasOwn.call(all3, param3)) {
              throw new Error("" + param3);
            }
            var field = all3[param3];
            var type3 = field.type;
            var value2;
            if (isArgAvailable) {
              value2 = arg;
            } else if (field.defaultFn) {
              value2 = field.defaultFn.call(built);
            } else {
              var message = "no value or default function given for field " + JSON.stringify(param3) + " of " + _this.typeName + "(" + _this.buildParams.map(function(name2) {
                return all3[name2];
              }).join(", ") + ")";
              throw new Error(message);
            }
            if (!type3.check(value2)) {
              throw new Error(shallowStringify(value2) + " does not match field " + field + " of type " + _this.typeName);
            }
            built[param3] = value2;
          };
          var builder = function() {
            var args = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args[_i2] = arguments[_i2];
            }
            var argc = args.length;
            if (!_this.finalized) {
              throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
            }
            var built = Object.create(nodePrototype);
            _this.buildParams.forEach(function(param3, i) {
              if (i < argc) {
                addParam(built, param3, args[i], true);
              } else {
                addParam(built, param3, null, false);
              }
            });
            Object.keys(_this.allFields).forEach(function(param3) {
              addParam(built, param3, null, false);
            });
            if (built.type !== _this.typeName) {
              throw new Error("");
            }
            return built;
          };
          builder.from = function(obj) {
            if (!_this.finalized) {
              throw new Error("attempting to instantiate unfinalized type " + _this.typeName);
            }
            var built = Object.create(nodePrototype);
            Object.keys(_this.allFields).forEach(function(param3) {
              if (hasOwn.call(obj, param3)) {
                addParam(built, param3, obj[param3], true);
              } else {
                addParam(built, param3, null, false);
              }
            });
            if (built.type !== _this.typeName) {
              throw new Error("");
            }
            return built;
          };
          Object.defineProperty(builders, getBuilderName(this.typeName), {
            enumerable: true,
            value: builder
          });
          return this;
        };
        DefImpl2.prototype.field = function(name2, type3, defaultFn, hidden2) {
          if (this.finalized) {
            console.error("Ignoring attempt to redefine field " + JSON.stringify(name2) + " of finalized type " + JSON.stringify(this.typeName));
            return this;
          }
          this.ownFields[name2] = new Field(name2, Type.from(type3), defaultFn, hidden2);
          return this;
        };
        DefImpl2.prototype.finalize = function() {
          var _this = this;
          if (!this.finalized) {
            var allFields = this.allFields;
            var allSupertypes = this.allSupertypes;
            this.baseNames.forEach(function(name2) {
              var def = defCache[name2];
              if (def instanceof Def) {
                def.finalize();
                extend2(allFields, def.allFields);
                extend2(allSupertypes, def.allSupertypes);
              } else {
                var message = "unknown supertype name " + JSON.stringify(name2) + " for subtype " + JSON.stringify(_this.typeName);
                throw new Error(message);
              }
            });
            extend2(allFields, this.ownFields);
            allSupertypes[this.typeName] = this;
            this.fieldNames.length = 0;
            for (var fieldName in allFields) {
              if (hasOwn.call(allFields, fieldName) && !allFields[fieldName].hidden) {
                this.fieldNames.push(fieldName);
              }
            }
            Object.defineProperty(namedTypes2, this.typeName, {
              enumerable: true,
              value: this.type
            });
            this.finalized = true;
            populateSupertypeList(this.typeName, this.supertypeList);
            if (this.buildable && this.supertypeList.lastIndexOf("Expression") >= 0) {
              wrapExpressionBuilderWithStatement(this.typeName);
            }
          }
        };
        return DefImpl2;
      }(Def)
    );
    function getSupertypeNames(typeName) {
      if (!hasOwn.call(defCache, typeName)) {
        throw new Error("");
      }
      var d2 = defCache[typeName];
      if (d2.finalized !== true) {
        throw new Error("");
      }
      return d2.supertypeList.slice(1);
    }
    function computeSupertypeLookupTable(candidates) {
      var table = {};
      var typeNames = Object.keys(defCache);
      var typeNameCount = typeNames.length;
      for (var i = 0; i < typeNameCount; ++i) {
        var typeName = typeNames[i];
        var d2 = defCache[typeName];
        if (d2.finalized !== true) {
          throw new Error("" + typeName);
        }
        for (var j2 = 0; j2 < d2.supertypeList.length; ++j2) {
          var superTypeName = d2.supertypeList[j2];
          if (hasOwn.call(candidates, superTypeName)) {
            table[typeName] = superTypeName;
            break;
          }
        }
      }
      return table;
    }
    var builders = /* @__PURE__ */ Object.create(null);
    var nodePrototype = {};
    function defineMethod(name2, func) {
      var old = nodePrototype[name2];
      if (isUndefined2.check(func)) {
        delete nodePrototype[name2];
      } else {
        isFunction2.assert(func);
        Object.defineProperty(nodePrototype, name2, {
          enumerable: true,
          configurable: true,
          value: func
        });
      }
      return old;
    }
    function getBuilderName(typeName) {
      return typeName.replace(/^[A-Z]+/, function(upperCasePrefix) {
        var len = upperCasePrefix.length;
        switch (len) {
          case 0:
            return "";
          case 1:
            return upperCasePrefix.toLowerCase();
          default:
            return upperCasePrefix.slice(0, len - 1).toLowerCase() + upperCasePrefix.charAt(len - 1);
        }
      });
    }
    function getStatementBuilderName(typeName) {
      typeName = getBuilderName(typeName);
      return typeName.replace(/(Expression)?$/, "Statement");
    }
    var namedTypes2 = {};
    function getFieldNames(object) {
      var d2 = defFromValue(object);
      if (d2) {
        return d2.fieldNames.slice(0);
      }
      if ("type" in object) {
        throw new Error("did not recognize object of type " + JSON.stringify(object.type));
      }
      return Object.keys(object);
    }
    function getFieldValue(object, fieldName) {
      var d2 = defFromValue(object);
      if (d2) {
        var field = d2.allFields[fieldName];
        if (field) {
          return field.getValue(object);
        }
      }
      return object && object[fieldName];
    }
    function eachField(object, callback, context2) {
      getFieldNames(object).forEach(function(name2) {
        callback.call(this, name2, getFieldValue(object, name2));
      }, context2);
    }
    function someField(object, callback, context2) {
      return getFieldNames(object).some(function(name2) {
        return callback.call(this, name2, getFieldValue(object, name2));
      }, context2);
    }
    function wrapExpressionBuilderWithStatement(typeName) {
      var wrapperName = getStatementBuilderName(typeName);
      if (builders[wrapperName])
        return;
      var wrapped = builders[getBuilderName(typeName)];
      if (!wrapped)
        return;
      var builder = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return builders.expressionStatement(wrapped.apply(builders, args));
      };
      builder.from = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        return builders.expressionStatement(wrapped.from.apply(builders, args));
      };
      builders[wrapperName] = builder;
    }
    function populateSupertypeList(typeName, list) {
      list.length = 0;
      list.push(typeName);
      var lastSeen = /* @__PURE__ */ Object.create(null);
      for (var pos = 0; pos < list.length; ++pos) {
        typeName = list[pos];
        var d2 = defCache[typeName];
        if (d2.finalized !== true) {
          throw new Error("");
        }
        if (hasOwn.call(lastSeen, typeName)) {
          delete list[lastSeen[typeName]];
        }
        lastSeen[typeName] = pos;
        list.push.apply(list, d2.baseNames);
      }
      for (var to = 0, from2 = to, len = list.length; from2 < len; ++from2) {
        if (hasOwn.call(list, from2)) {
          list[to++] = list[from2];
        }
      }
      list.length = to;
    }
    function extend2(into, from2) {
      Object.keys(from2).forEach(function(name2) {
        into[name2] = from2[name2];
      });
      return into;
    }
    function finalize() {
      Object.keys(defCache).forEach(function(name2) {
        defCache[name2].finalize();
      });
    }
    return {
      Type,
      builtInTypes,
      getSupertypeNames,
      computeSupertypeLookupTable,
      builders,
      defineMethod,
      getBuilderName,
      getStatementBuilderName,
      namedTypes: namedTypes2,
      getFieldNames,
      getFieldValue,
      eachField,
      someField,
      finalize
    };
  }
  types$2.default = typesPlugin;
  return types$2;
}
var pathVisitor = { exports: {} };
var nodePath = { exports: {} };
var path$5 = { exports: {} };
var hasRequiredPath;
function requirePath() {
  if (hasRequiredPath) return path$5.exports;
  hasRequiredPath = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    function pathPlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var isArray2 = types2.builtInTypes.array;
      var isNumber2 = types2.builtInTypes.number;
      var Path = function Path2(value2, parentPath, name2) {
        if (!(this instanceof Path2)) {
          throw new Error("Path constructor cannot be invoked without 'new'");
        }
        if (parentPath) {
          if (!(parentPath instanceof Path2)) {
            throw new Error("");
          }
        } else {
          parentPath = null;
          name2 = null;
        }
        this.value = value2;
        this.parentPath = parentPath;
        this.name = name2;
        this.__childCache = null;
      };
      var Pp = Path.prototype;
      function getChildCache(path3) {
        return path3.__childCache || (path3.__childCache = /* @__PURE__ */ Object.create(null));
      }
      function getChildPath(path3, name2) {
        var cache2 = getChildCache(path3);
        var actualChildValue = path3.getValueProperty(name2);
        var childPath = cache2[name2];
        if (!hasOwn.call(cache2, name2) || // Ensure consistency between cache and reality.
        childPath.value !== actualChildValue) {
          childPath = cache2[name2] = new path3.constructor(actualChildValue, path3, name2);
        }
        return childPath;
      }
      Pp.getValueProperty = function getValueProperty(name2) {
        return this.value[name2];
      };
      Pp.get = function get2() {
        var names = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          names[_i] = arguments[_i];
        }
        var path3 = this;
        var count = names.length;
        for (var i = 0; i < count; ++i) {
          path3 = getChildPath(path3, names[i]);
        }
        return path3;
      };
      Pp.each = function each(callback, context2) {
        var childPaths = [];
        var len = this.value.length;
        var i = 0;
        for (var i = 0; i < len; ++i) {
          if (hasOwn.call(this.value, i)) {
            childPaths[i] = this.get(i);
          }
        }
        context2 = context2 || this;
        for (i = 0; i < len; ++i) {
          if (hasOwn.call(childPaths, i)) {
            callback.call(context2, childPaths[i]);
          }
        }
      };
      Pp.map = function map2(callback, context2) {
        var result = [];
        this.each(function(childPath) {
          result.push(callback.call(this, childPath));
        }, context2);
        return result;
      };
      Pp.filter = function filter3(callback, context2) {
        var result = [];
        this.each(function(childPath) {
          if (callback.call(this, childPath)) {
            result.push(childPath);
          }
        }, context2);
        return result;
      };
      function emptyMoves() {
      }
      function getMoves(path3, offset, start, end) {
        isArray2.assert(path3.value);
        if (offset === 0) {
          return emptyMoves;
        }
        var length = path3.value.length;
        if (length < 1) {
          return emptyMoves;
        }
        var argc = arguments.length;
        if (argc === 2) {
          start = 0;
          end = length;
        } else if (argc === 3) {
          start = Math.max(start, 0);
          end = length;
        } else {
          start = Math.max(start, 0);
          end = Math.min(end, length);
        }
        isNumber2.assert(start);
        isNumber2.assert(end);
        var moves = /* @__PURE__ */ Object.create(null);
        var cache2 = getChildCache(path3);
        for (var i = start; i < end; ++i) {
          if (hasOwn.call(path3.value, i)) {
            var childPath = path3.get(i);
            if (childPath.name !== i) {
              throw new Error("");
            }
            var newIndex = i + offset;
            childPath.name = newIndex;
            moves[newIndex] = childPath;
            delete cache2[i];
          }
        }
        delete cache2.length;
        return function() {
          for (var newIndex2 in moves) {
            var childPath2 = moves[newIndex2];
            if (childPath2.name !== +newIndex2) {
              throw new Error("");
            }
            cache2[newIndex2] = childPath2;
            path3.value[newIndex2] = childPath2.value;
          }
        };
      }
      Pp.shift = function shift() {
        var move2 = getMoves(this, -1);
        var result = this.value.shift();
        move2();
        return result;
      };
      Pp.unshift = function unshift() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var move2 = getMoves(this, args.length);
        var result = this.value.unshift.apply(this.value, args);
        move2();
        return result;
      };
      Pp.push = function push() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        isArray2.assert(this.value);
        delete getChildCache(this).length;
        return this.value.push.apply(this.value, args);
      };
      Pp.pop = function pop() {
        isArray2.assert(this.value);
        var cache2 = getChildCache(this);
        delete cache2[this.value.length - 1];
        delete cache2.length;
        return this.value.pop();
      };
      Pp.insertAt = function insertAt(index2) {
        var argc = arguments.length;
        var move2 = getMoves(this, argc - 1, index2);
        if (move2 === emptyMoves && argc <= 1) {
          return this;
        }
        index2 = Math.max(index2, 0);
        for (var i = 1; i < argc; ++i) {
          this.value[index2 + i - 1] = arguments[i];
        }
        move2();
        return this;
      };
      Pp.insertBefore = function insertBefore() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pp = this.parentPath;
        var argc = args.length;
        var insertAtArgs = [this.name];
        for (var i = 0; i < argc; ++i) {
          insertAtArgs.push(args[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      Pp.insertAfter = function insertAfter() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var pp = this.parentPath;
        var argc = args.length;
        var insertAtArgs = [this.name + 1];
        for (var i = 0; i < argc; ++i) {
          insertAtArgs.push(args[i]);
        }
        return pp.insertAt.apply(pp, insertAtArgs);
      };
      function repairRelationshipWithParent(path3) {
        if (!(path3 instanceof Path)) {
          throw new Error("");
        }
        var pp = path3.parentPath;
        if (!pp) {
          return path3;
        }
        var parentValue = pp.value;
        var parentCache = getChildCache(pp);
        if (parentValue[path3.name] === path3.value) {
          parentCache[path3.name] = path3;
        } else if (isArray2.check(parentValue)) {
          var i = parentValue.indexOf(path3.value);
          if (i >= 0) {
            parentCache[path3.name = i] = path3;
          }
        } else {
          parentValue[path3.name] = path3.value;
          parentCache[path3.name] = path3;
        }
        if (parentValue[path3.name] !== path3.value) {
          throw new Error("");
        }
        if (path3.parentPath.get(path3.name) !== path3) {
          throw new Error("");
        }
        return path3;
      }
      Pp.replace = function replace(replacement) {
        var results = [];
        var parentValue = this.parentPath.value;
        var parentCache = getChildCache(this.parentPath);
        var count = arguments.length;
        repairRelationshipWithParent(this);
        if (isArray2.check(parentValue)) {
          var originalLength = parentValue.length;
          var move2 = getMoves(this.parentPath, count - 1, this.name + 1);
          var spliceArgs = [this.name, 1];
          for (var i = 0; i < count; ++i) {
            spliceArgs.push(arguments[i]);
          }
          var splicedOut = parentValue.splice.apply(parentValue, spliceArgs);
          if (splicedOut[0] !== this.value) {
            throw new Error("");
          }
          if (parentValue.length !== originalLength - 1 + count) {
            throw new Error("");
          }
          move2();
          if (count === 0) {
            delete this.value;
            delete parentCache[this.name];
            this.__childCache = null;
          } else {
            if (parentValue[this.name] !== replacement) {
              throw new Error("");
            }
            if (this.value !== replacement) {
              this.value = replacement;
              this.__childCache = null;
            }
            for (i = 0; i < count; ++i) {
              results.push(this.parentPath.get(this.name + i));
            }
            if (results[0] !== this) {
              throw new Error("");
            }
          }
        } else if (count === 1) {
          if (this.value !== replacement) {
            this.__childCache = null;
          }
          this.value = parentValue[this.name] = replacement;
          results.push(this);
        } else if (count === 0) {
          delete parentValue[this.name];
          delete this.value;
          this.__childCache = null;
        } else {
          throw new Error("Could not replace path");
        }
        return results;
      };
      return Path;
    }
    exports.default = pathPlugin;
    module2.exports = exports["default"];
  })(path$5, path$5.exports);
  return path$5.exports;
}
var scope = { exports: {} };
var hasRequiredScope;
function requireScope() {
  if (hasRequiredScope) return scope.exports;
  hasRequiredScope = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var hasOwn = Object.prototype.hasOwnProperty;
    function scopePlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var namedTypes2 = types2.namedTypes;
      var Node = namedTypes2.Node;
      var Expression = namedTypes2.Expression;
      var isArray2 = types2.builtInTypes.array;
      var b = types2.builders;
      var Scope2 = function Scope3(path3, parentScope) {
        if (!(this instanceof Scope3)) {
          throw new Error("Scope constructor cannot be invoked without 'new'");
        }
        ScopeType.assert(path3.value);
        var depth;
        if (parentScope) {
          if (!(parentScope instanceof Scope3)) {
            throw new Error("");
          }
          depth = parentScope.depth + 1;
        } else {
          parentScope = null;
          depth = 0;
        }
        Object.defineProperties(this, {
          path: { value: path3 },
          node: { value: path3.value },
          isGlobal: { value: !parentScope, enumerable: true },
          depth: { value: depth },
          parent: { value: parentScope },
          bindings: { value: {} },
          types: { value: {} }
        });
      };
      var scopeTypes = [
        // Program nodes introduce global scopes.
        namedTypes2.Program,
        // Function is the supertype of FunctionExpression,
        // FunctionDeclaration, ArrowExpression, etc.
        namedTypes2.Function,
        // In case you didn't know, the caught parameter shadows any variable
        // of the same name in an outer scope.
        namedTypes2.CatchClause
      ];
      var ScopeType = Type.or.apply(Type, scopeTypes);
      Scope2.isEstablishedBy = function(node2) {
        return ScopeType.check(node2);
      };
      var Sp = Scope2.prototype;
      Sp.didScan = false;
      Sp.declares = function(name2) {
        this.scan();
        return hasOwn.call(this.bindings, name2);
      };
      Sp.declaresType = function(name2) {
        this.scan();
        return hasOwn.call(this.types, name2);
      };
      Sp.declareTemporary = function(prefix) {
        if (prefix) {
          if (!/^[a-z$_]/i.test(prefix)) {
            throw new Error("");
          }
        } else {
          prefix = "t$";
        }
        prefix += this.depth.toString(36) + "$";
        this.scan();
        var index2 = 0;
        while (this.declares(prefix + index2)) {
          ++index2;
        }
        var name2 = prefix + index2;
        return this.bindings[name2] = types2.builders.identifier(name2);
      };
      Sp.injectTemporary = function(identifier, init2) {
        identifier || (identifier = this.declareTemporary());
        var bodyPath = this.path.get("body");
        if (namedTypes2.BlockStatement.check(bodyPath.value)) {
          bodyPath = bodyPath.get("body");
        }
        bodyPath.unshift(b.variableDeclaration("var", [b.variableDeclarator(identifier, init2 || null)]));
        return identifier;
      };
      Sp.scan = function(force) {
        if (force || !this.didScan) {
          for (var name2 in this.bindings) {
            delete this.bindings[name2];
          }
          scanScope(this.path, this.bindings, this.types);
          this.didScan = true;
        }
      };
      Sp.getBindings = function() {
        this.scan();
        return this.bindings;
      };
      Sp.getTypes = function() {
        this.scan();
        return this.types;
      };
      function scanScope(path3, bindings, scopeTypes2) {
        var node2 = path3.value;
        ScopeType.assert(node2);
        if (namedTypes2.CatchClause.check(node2)) {
          var param3 = path3.get("param");
          if (param3.value) {
            addPattern(param3, bindings);
          }
        } else {
          recursiveScanScope(path3, bindings, scopeTypes2);
        }
      }
      function recursiveScanScope(path3, bindings, scopeTypes2) {
        var node2 = path3.value;
        if (path3.parent && namedTypes2.FunctionExpression.check(path3.parent.node) && path3.parent.node.id) {
          addPattern(path3.parent.get("id"), bindings);
        }
        if (!node2) ;
        else if (isArray2.check(node2)) {
          path3.each(function(childPath) {
            recursiveScanChild(childPath, bindings, scopeTypes2);
          });
        } else if (namedTypes2.Function.check(node2)) {
          path3.get("params").each(function(paramPath) {
            addPattern(paramPath, bindings);
          });
          recursiveScanChild(path3.get("body"), bindings, scopeTypes2);
        } else if (namedTypes2.TypeAlias && namedTypes2.TypeAlias.check(node2) || namedTypes2.InterfaceDeclaration && namedTypes2.InterfaceDeclaration.check(node2) || namedTypes2.TSTypeAliasDeclaration && namedTypes2.TSTypeAliasDeclaration.check(node2) || namedTypes2.TSInterfaceDeclaration && namedTypes2.TSInterfaceDeclaration.check(node2)) {
          addTypePattern(path3.get("id"), scopeTypes2);
        } else if (namedTypes2.VariableDeclarator.check(node2)) {
          addPattern(path3.get("id"), bindings);
          recursiveScanChild(path3.get("init"), bindings, scopeTypes2);
        } else if (node2.type === "ImportSpecifier" || node2.type === "ImportNamespaceSpecifier" || node2.type === "ImportDefaultSpecifier") {
          addPattern(
            // Esprima used to use the .name field to refer to the local
            // binding identifier for ImportSpecifier nodes, but .id for
            // ImportNamespaceSpecifier and ImportDefaultSpecifier nodes.
            // ESTree/Acorn/ESpree use .local for all three node types.
            path3.get(node2.local ? "local" : node2.name ? "name" : "id"),
            bindings
          );
        } else if (Node.check(node2) && !Expression.check(node2)) {
          types2.eachField(node2, function(name2, child) {
            var childPath = path3.get(name2);
            if (!pathHasValue(childPath, child)) {
              throw new Error("");
            }
            recursiveScanChild(childPath, bindings, scopeTypes2);
          });
        }
      }
      function pathHasValue(path3, value2) {
        if (path3.value === value2) {
          return true;
        }
        if (Array.isArray(path3.value) && path3.value.length === 0 && Array.isArray(value2) && value2.length === 0) {
          return true;
        }
        return false;
      }
      function recursiveScanChild(path3, bindings, scopeTypes2) {
        var node2 = path3.value;
        if (!node2 || Expression.check(node2)) ;
        else if (namedTypes2.FunctionDeclaration.check(node2) && node2.id !== null) {
          addPattern(path3.get("id"), bindings);
        } else if (namedTypes2.ClassDeclaration && namedTypes2.ClassDeclaration.check(node2)) {
          addPattern(path3.get("id"), bindings);
        } else if (ScopeType.check(node2)) {
          if (namedTypes2.CatchClause.check(node2) && // TODO Broaden this to accept any pattern.
          namedTypes2.Identifier.check(node2.param)) {
            var catchParamName = node2.param.name;
            var hadBinding = hasOwn.call(bindings, catchParamName);
            recursiveScanScope(path3.get("body"), bindings, scopeTypes2);
            if (!hadBinding) {
              delete bindings[catchParamName];
            }
          }
        } else {
          recursiveScanScope(path3, bindings, scopeTypes2);
        }
      }
      function addPattern(patternPath, bindings) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern);
        if (namedTypes2.Identifier.check(pattern)) {
          if (hasOwn.call(bindings, pattern.name)) {
            bindings[pattern.name].push(patternPath);
          } else {
            bindings[pattern.name] = [patternPath];
          }
        } else if (namedTypes2.AssignmentPattern && namedTypes2.AssignmentPattern.check(pattern)) {
          addPattern(patternPath.get("left"), bindings);
        } else if (namedTypes2.ObjectPattern && namedTypes2.ObjectPattern.check(pattern)) {
          patternPath.get("properties").each(function(propertyPath) {
            var property = propertyPath.value;
            if (namedTypes2.Pattern.check(property)) {
              addPattern(propertyPath, bindings);
            } else if (namedTypes2.Property.check(property)) {
              addPattern(propertyPath.get("value"), bindings);
            } else if (namedTypes2.SpreadProperty && namedTypes2.SpreadProperty.check(property)) {
              addPattern(propertyPath.get("argument"), bindings);
            }
          });
        } else if (namedTypes2.ArrayPattern && namedTypes2.ArrayPattern.check(pattern)) {
          patternPath.get("elements").each(function(elementPath) {
            var element = elementPath.value;
            if (namedTypes2.Pattern.check(element)) {
              addPattern(elementPath, bindings);
            } else if (namedTypes2.SpreadElement && namedTypes2.SpreadElement.check(element)) {
              addPattern(elementPath.get("argument"), bindings);
            }
          });
        } else if (namedTypes2.PropertyPattern && namedTypes2.PropertyPattern.check(pattern)) {
          addPattern(patternPath.get("pattern"), bindings);
        } else if (namedTypes2.SpreadElementPattern && namedTypes2.SpreadElementPattern.check(pattern) || namedTypes2.SpreadPropertyPattern && namedTypes2.SpreadPropertyPattern.check(pattern)) {
          addPattern(patternPath.get("argument"), bindings);
        }
      }
      function addTypePattern(patternPath, types3) {
        var pattern = patternPath.value;
        namedTypes2.Pattern.assert(pattern);
        if (namedTypes2.Identifier.check(pattern)) {
          if (hasOwn.call(types3, pattern.name)) {
            types3[pattern.name].push(patternPath);
          } else {
            types3[pattern.name] = [patternPath];
          }
        }
      }
      Sp.lookup = function(name2) {
        for (var scope2 = this; scope2; scope2 = scope2.parent)
          if (scope2.declares(name2))
            break;
        return scope2;
      };
      Sp.lookupType = function(name2) {
        for (var scope2 = this; scope2; scope2 = scope2.parent)
          if (scope2.declaresType(name2))
            break;
        return scope2;
      };
      Sp.getGlobalScope = function() {
        var scope2 = this;
        while (!scope2.isGlobal)
          scope2 = scope2.parent;
        return scope2;
      };
      return Scope2;
    }
    exports.default = scopePlugin;
    module2.exports = exports["default"];
  })(scope, scope.exports);
  return scope.exports;
}
var hasRequiredNodePath;
function requireNodePath() {
  if (hasRequiredNodePath) return nodePath.exports;
  hasRequiredNodePath = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var path_12 = tslib_1.__importDefault(requirePath());
    var scope_1 = tslib_1.__importDefault(requireScope());
    function nodePathPlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var n = types2.namedTypes;
      var b = types2.builders;
      var isNumber2 = types2.builtInTypes.number;
      var isArray2 = types2.builtInTypes.array;
      var Path = fork2.use(path_12.default);
      var Scope2 = fork2.use(scope_1.default);
      var NodePath = function NodePath2(value2, parentPath, name2) {
        if (!(this instanceof NodePath2)) {
          throw new Error("NodePath constructor cannot be invoked without 'new'");
        }
        Path.call(this, value2, parentPath, name2);
      };
      var NPp = NodePath.prototype = Object.create(Path.prototype, {
        constructor: {
          value: NodePath,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      Object.defineProperties(NPp, {
        node: {
          get: function() {
            Object.defineProperty(this, "node", {
              configurable: true,
              value: this._computeNode()
            });
            return this.node;
          }
        },
        parent: {
          get: function() {
            Object.defineProperty(this, "parent", {
              configurable: true,
              value: this._computeParent()
            });
            return this.parent;
          }
        },
        scope: {
          get: function() {
            Object.defineProperty(this, "scope", {
              configurable: true,
              value: this._computeScope()
            });
            return this.scope;
          }
        }
      });
      NPp.replace = function() {
        delete this.node;
        delete this.parent;
        delete this.scope;
        return Path.prototype.replace.apply(this, arguments);
      };
      NPp.prune = function() {
        var remainingNodePath = this.parent;
        this.replace();
        return cleanUpNodesAfterPrune(remainingNodePath);
      };
      NPp._computeNode = function() {
        var value2 = this.value;
        if (n.Node.check(value2)) {
          return value2;
        }
        var pp = this.parentPath;
        return pp && pp.node || null;
      };
      NPp._computeParent = function() {
        var value2 = this.value;
        var pp = this.parentPath;
        if (!n.Node.check(value2)) {
          while (pp && !n.Node.check(pp.value)) {
            pp = pp.parentPath;
          }
          if (pp) {
            pp = pp.parentPath;
          }
        }
        while (pp && !n.Node.check(pp.value)) {
          pp = pp.parentPath;
        }
        return pp || null;
      };
      NPp._computeScope = function() {
        var value2 = this.value;
        var pp = this.parentPath;
        var scope2 = pp && pp.scope;
        if (n.Node.check(value2) && Scope2.isEstablishedBy(value2)) {
          scope2 = new Scope2(this, scope2);
        }
        return scope2 || null;
      };
      NPp.getValueProperty = function(name2) {
        return types2.getFieldValue(this.value, name2);
      };
      NPp.needsParens = function(assumeExpressionContext) {
        var pp = this.parentPath;
        if (!pp) {
          return false;
        }
        var node2 = this.value;
        if (!n.Expression.check(node2)) {
          return false;
        }
        if (node2.type === "Identifier") {
          return false;
        }
        while (!n.Node.check(pp.value)) {
          pp = pp.parentPath;
          if (!pp) {
            return false;
          }
        }
        var parent = pp.value;
        switch (node2.type) {
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
            return parent.type === "MemberExpression" && this.name === "object" && parent.object === node2;
          case "BinaryExpression":
          case "LogicalExpression":
            switch (parent.type) {
              case "CallExpression":
                return this.name === "callee" && parent.callee === node2;
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
                return true;
              case "MemberExpression":
                return this.name === "object" && parent.object === node2;
              case "BinaryExpression":
              case "LogicalExpression": {
                var n_1 = node2;
                var po = parent.operator;
                var pp_1 = PRECEDENCE[po];
                var no = n_1.operator;
                var np = PRECEDENCE[no];
                if (pp_1 > np) {
                  return true;
                }
                if (pp_1 === np && this.name === "right") {
                  if (parent.right !== n_1) {
                    throw new Error("Nodes must be equal");
                  }
                  return true;
                }
              }
              default:
                return false;
            }
          case "SequenceExpression":
            switch (parent.type) {
              case "ForStatement":
                return false;
              case "ExpressionStatement":
                return this.name !== "expression";
              default:
                return true;
            }
          case "YieldExpression":
            switch (parent.type) {
              case "BinaryExpression":
              case "LogicalExpression":
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "CallExpression":
              case "MemberExpression":
              case "NewExpression":
              case "ConditionalExpression":
              case "YieldExpression":
                return true;
              default:
                return false;
            }
          case "Literal":
            return parent.type === "MemberExpression" && isNumber2.check(node2.value) && this.name === "object" && parent.object === node2;
          case "AssignmentExpression":
          case "ConditionalExpression":
            switch (parent.type) {
              case "UnaryExpression":
              case "SpreadElement":
              case "SpreadProperty":
              case "BinaryExpression":
              case "LogicalExpression":
                return true;
              case "CallExpression":
                return this.name === "callee" && parent.callee === node2;
              case "ConditionalExpression":
                return this.name === "test" && parent.test === node2;
              case "MemberExpression":
                return this.name === "object" && parent.object === node2;
              default:
                return false;
            }
          default:
            if (parent.type === "NewExpression" && this.name === "callee" && parent.callee === node2) {
              return containsCallExpression(node2);
            }
        }
        if (assumeExpressionContext !== true && !this.canBeFirstInStatement() && this.firstInStatement())
          return true;
        return false;
      };
      function isBinary(node2) {
        return n.BinaryExpression.check(node2) || n.LogicalExpression.check(node2);
      }
      var PRECEDENCE = {};
      [
        ["||"],
        ["&&"],
        ["|"],
        ["^"],
        ["&"],
        ["==", "===", "!=", "!=="],
        ["<", ">", "<=", ">=", "in", "instanceof"],
        [">>", "<<", ">>>"],
        ["+", "-"],
        ["*", "/", "%"]
      ].forEach(function(tier, i) {
        tier.forEach(function(op) {
          PRECEDENCE[op] = i;
        });
      });
      function containsCallExpression(node2) {
        if (n.CallExpression.check(node2)) {
          return true;
        }
        if (isArray2.check(node2)) {
          return node2.some(containsCallExpression);
        }
        if (n.Node.check(node2)) {
          return types2.someField(node2, function(_name, child) {
            return containsCallExpression(child);
          });
        }
        return false;
      }
      NPp.canBeFirstInStatement = function() {
        var node2 = this.node;
        return !n.FunctionExpression.check(node2) && !n.ObjectExpression.check(node2);
      };
      NPp.firstInStatement = function() {
        return firstInStatement(this);
      };
      function firstInStatement(path3) {
        for (var node2, parent; path3.parent; path3 = path3.parent) {
          node2 = path3.node;
          parent = path3.parent.node;
          if (n.BlockStatement.check(parent) && path3.parent.name === "body" && path3.name === 0) {
            if (parent.body[0] !== node2) {
              throw new Error("Nodes must be equal");
            }
            return true;
          }
          if (n.ExpressionStatement.check(parent) && path3.name === "expression") {
            if (parent.expression !== node2) {
              throw new Error("Nodes must be equal");
            }
            return true;
          }
          if (n.SequenceExpression.check(parent) && path3.parent.name === "expressions" && path3.name === 0) {
            if (parent.expressions[0] !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.CallExpression.check(parent) && path3.name === "callee") {
            if (parent.callee !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.MemberExpression.check(parent) && path3.name === "object") {
            if (parent.object !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.ConditionalExpression.check(parent) && path3.name === "test") {
            if (parent.test !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (isBinary(parent) && path3.name === "left") {
            if (parent.left !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          if (n.UnaryExpression.check(parent) && !parent.prefix && path3.name === "argument") {
            if (parent.argument !== node2) {
              throw new Error("Nodes must be equal");
            }
            continue;
          }
          return false;
        }
        return true;
      }
      function cleanUpNodesAfterPrune(remainingNodePath) {
        if (n.VariableDeclaration.check(remainingNodePath.node)) {
          var declarations = remainingNodePath.get("declarations").value;
          if (!declarations || declarations.length === 0) {
            return remainingNodePath.prune();
          }
        } else if (n.ExpressionStatement.check(remainingNodePath.node)) {
          if (!remainingNodePath.get("expression").value) {
            return remainingNodePath.prune();
          }
        } else if (n.IfStatement.check(remainingNodePath.node)) {
          cleanUpIfStatementAfterPrune(remainingNodePath);
        }
        return remainingNodePath;
      }
      function cleanUpIfStatementAfterPrune(ifStatement) {
        var testExpression = ifStatement.get("test").value;
        var alternate = ifStatement.get("alternate").value;
        var consequent = ifStatement.get("consequent").value;
        if (!consequent && !alternate) {
          var testExpressionStatement = b.expressionStatement(testExpression);
          ifStatement.replace(testExpressionStatement);
        } else if (!consequent && alternate) {
          var negatedTestExpression = b.unaryExpression("!", testExpression, true);
          if (n.UnaryExpression.check(testExpression) && testExpression.operator === "!") {
            negatedTestExpression = testExpression.argument;
          }
          ifStatement.get("test").replace(negatedTestExpression);
          ifStatement.get("consequent").replace(alternate);
          ifStatement.get("alternate").replace();
        }
      }
      return NodePath;
    }
    exports.default = nodePathPlugin;
    module2.exports = exports["default"];
  })(nodePath, nodePath.exports);
  return nodePath.exports;
}
var hasRequiredPathVisitor;
function requirePathVisitor() {
  if (hasRequiredPathVisitor) return pathVisitor.exports;
  hasRequiredPathVisitor = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var node_path_1 = tslib_1.__importDefault(requireNodePath());
    var hasOwn = Object.prototype.hasOwnProperty;
    function pathVisitorPlugin(fork2) {
      var types2 = fork2.use(types_1.default);
      var NodePath = fork2.use(node_path_1.default);
      var isArray2 = types2.builtInTypes.array;
      var isObject2 = types2.builtInTypes.object;
      var isFunction2 = types2.builtInTypes.function;
      var undefined$1;
      var PathVisitor = function PathVisitor2() {
        if (!(this instanceof PathVisitor2)) {
          throw new Error("PathVisitor constructor cannot be invoked without 'new'");
        }
        this._reusableContextStack = [];
        this._methodNameTable = computeMethodNameTable(this);
        this._shouldVisitComments = hasOwn.call(this._methodNameTable, "Block") || hasOwn.call(this._methodNameTable, "Line");
        this.Context = makeContextConstructor(this);
        this._visiting = false;
        this._changeReported = false;
      };
      function computeMethodNameTable(visitor) {
        var typeNames = /* @__PURE__ */ Object.create(null);
        for (var methodName in visitor) {
          if (/^visit[A-Z]/.test(methodName)) {
            typeNames[methodName.slice("visit".length)] = true;
          }
        }
        var supertypeTable = types2.computeSupertypeLookupTable(typeNames);
        var methodNameTable = /* @__PURE__ */ Object.create(null);
        var typeNameKeys = Object.keys(supertypeTable);
        var typeNameCount = typeNameKeys.length;
        for (var i = 0; i < typeNameCount; ++i) {
          var typeName = typeNameKeys[i];
          methodName = "visit" + supertypeTable[typeName];
          if (isFunction2.check(visitor[methodName])) {
            methodNameTable[typeName] = methodName;
          }
        }
        return methodNameTable;
      }
      PathVisitor.fromMethodsObject = function fromMethodsObject(methods2) {
        if (methods2 instanceof PathVisitor) {
          return methods2;
        }
        if (!isObject2.check(methods2)) {
          return new PathVisitor();
        }
        var Visitor = function Visitor2() {
          if (!(this instanceof Visitor2)) {
            throw new Error("Visitor constructor cannot be invoked without 'new'");
          }
          PathVisitor.call(this);
        };
        var Vp = Visitor.prototype = Object.create(PVp);
        Vp.constructor = Visitor;
        extend2(Vp, methods2);
        extend2(Visitor, PathVisitor);
        isFunction2.assert(Visitor.fromMethodsObject);
        isFunction2.assert(Visitor.visit);
        return new Visitor();
      };
      function extend2(target, source) {
        for (var property in source) {
          if (hasOwn.call(source, property)) {
            target[property] = source[property];
          }
        }
        return target;
      }
      PathVisitor.visit = function visit(node2, methods2) {
        return PathVisitor.fromMethodsObject(methods2).visit(node2);
      };
      var PVp = PathVisitor.prototype;
      PVp.visit = function() {
        if (this._visiting) {
          throw new Error("Recursively calling visitor.visit(path) resets visitor state. Try this.visit(path) or this.traverse(path) instead.");
        }
        this._visiting = true;
        this._changeReported = false;
        this._abortRequested = false;
        var argc = arguments.length;
        var args = new Array(argc);
        for (var i = 0; i < argc; ++i) {
          args[i] = arguments[i];
        }
        if (!(args[0] instanceof NodePath)) {
          args[0] = new NodePath({ root: args[0] }).get("root");
        }
        this.reset.apply(this, args);
        var didNotThrow;
        try {
          var root2 = this.visitWithoutReset(args[0]);
          didNotThrow = true;
        } finally {
          this._visiting = false;
          if (!didNotThrow && this._abortRequested) {
            return args[0].value;
          }
        }
        return root2;
      };
      PVp.AbortRequest = function AbortRequest() {
      };
      PVp.abort = function() {
        var visitor = this;
        visitor._abortRequested = true;
        var request2 = new visitor.AbortRequest();
        request2.cancel = function() {
          visitor._abortRequested = false;
        };
        throw request2;
      };
      PVp.reset = function(_path) {
      };
      PVp.visitWithoutReset = function(path3) {
        if (this instanceof this.Context) {
          return this.visitor.visitWithoutReset(path3);
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        var value2 = path3.value;
        var methodName = value2 && typeof value2 === "object" && typeof value2.type === "string" && this._methodNameTable[value2.type];
        if (methodName) {
          var context2 = this.acquireContext(path3);
          try {
            return context2.invokeVisitorMethod(methodName);
          } finally {
            this.releaseContext(context2);
          }
        } else {
          return visitChildren(path3, this);
        }
      };
      function visitChildren(path3, visitor) {
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(visitor instanceof PathVisitor)) {
          throw new Error("");
        }
        var value2 = path3.value;
        if (isArray2.check(value2)) {
          path3.each(visitor.visitWithoutReset, visitor);
        } else if (!isObject2.check(value2)) ;
        else {
          var childNames = types2.getFieldNames(value2);
          if (visitor._shouldVisitComments && value2.comments && childNames.indexOf("comments") < 0) {
            childNames.push("comments");
          }
          var childCount = childNames.length;
          var childPaths = [];
          for (var i = 0; i < childCount; ++i) {
            var childName = childNames[i];
            if (!hasOwn.call(value2, childName)) {
              value2[childName] = types2.getFieldValue(value2, childName);
            }
            childPaths.push(path3.get(childName));
          }
          for (var i = 0; i < childCount; ++i) {
            visitor.visitWithoutReset(childPaths[i]);
          }
        }
        return path3.value;
      }
      PVp.acquireContext = function(path3) {
        if (this._reusableContextStack.length === 0) {
          return new this.Context(path3);
        }
        return this._reusableContextStack.pop().reset(path3);
      };
      PVp.releaseContext = function(context2) {
        if (!(context2 instanceof this.Context)) {
          throw new Error("");
        }
        this._reusableContextStack.push(context2);
        context2.currentPath = null;
      };
      PVp.reportChanged = function() {
        this._changeReported = true;
      };
      PVp.wasChangeReported = function() {
        return this._changeReported;
      };
      function makeContextConstructor(visitor) {
        function Context(path3) {
          if (!(this instanceof Context)) {
            throw new Error("");
          }
          if (!(this instanceof PathVisitor)) {
            throw new Error("");
          }
          if (!(path3 instanceof NodePath)) {
            throw new Error("");
          }
          Object.defineProperty(this, "visitor", {
            value: visitor,
            writable: false,
            enumerable: true,
            configurable: false
          });
          this.currentPath = path3;
          this.needToCallTraverse = true;
          Object.seal(this);
        }
        if (!(visitor instanceof PathVisitor)) {
          throw new Error("");
        }
        var Cp = Context.prototype = Object.create(visitor);
        Cp.constructor = Context;
        extend2(Cp, sharedContextProtoMethods);
        return Context;
      }
      var sharedContextProtoMethods = /* @__PURE__ */ Object.create(null);
      sharedContextProtoMethods.reset = function reset2(path3) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        this.currentPath = path3;
        this.needToCallTraverse = true;
        return this;
      };
      sharedContextProtoMethods.invokeVisitorMethod = function invokeVisitorMethod(methodName) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        var result = this.visitor[methodName].call(this, this.currentPath);
        if (result === false) {
          this.needToCallTraverse = false;
        } else if (result !== undefined$1) {
          this.currentPath = this.currentPath.replace(result)[0];
          if (this.needToCallTraverse) {
            this.traverse(this.currentPath);
          }
        }
        if (this.needToCallTraverse !== false) {
          throw new Error("Must either call this.traverse or return false in " + methodName);
        }
        var path3 = this.currentPath;
        return path3 && path3.value;
      };
      sharedContextProtoMethods.traverse = function traverse(path3, newVisitor) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        this.needToCallTraverse = false;
        return visitChildren(path3, PathVisitor.fromMethodsObject(newVisitor || this.visitor));
      };
      sharedContextProtoMethods.visit = function visit(path3, newVisitor) {
        if (!(this instanceof this.Context)) {
          throw new Error("");
        }
        if (!(path3 instanceof NodePath)) {
          throw new Error("");
        }
        if (!(this.currentPath instanceof NodePath)) {
          throw new Error("");
        }
        this.needToCallTraverse = false;
        return PathVisitor.fromMethodsObject(newVisitor || this.visitor).visitWithoutReset(path3);
      };
      sharedContextProtoMethods.reportChanged = function reportChanged() {
        this.visitor.reportChanged();
      };
      sharedContextProtoMethods.abort = function abort2() {
        this.needToCallTraverse = false;
        this.visitor.abort();
      };
      return PathVisitor;
    }
    exports.default = pathVisitorPlugin;
    module2.exports = exports["default"];
  })(pathVisitor, pathVisitor.exports);
  return pathVisitor.exports;
}
var equiv = { exports: {} };
var hasRequiredEquiv;
function requireEquiv() {
  if (hasRequiredEquiv) return equiv.exports;
  hasRequiredEquiv = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var getFieldNames = types2.getFieldNames;
      var getFieldValue = types2.getFieldValue;
      var isArray2 = types2.builtInTypes.array;
      var isObject2 = types2.builtInTypes.object;
      var isDate2 = types2.builtInTypes.Date;
      var isRegExp2 = types2.builtInTypes.RegExp;
      var hasOwn = Object.prototype.hasOwnProperty;
      function astNodesAreEquivalent(a, b, problemPath) {
        if (isArray2.check(problemPath)) {
          problemPath.length = 0;
        } else {
          problemPath = null;
        }
        return areEquivalent(a, b, problemPath);
      }
      astNodesAreEquivalent.assert = function(a, b) {
        var problemPath = [];
        if (!astNodesAreEquivalent(a, b, problemPath)) {
          if (problemPath.length === 0) {
            if (a !== b) {
              throw new Error("Nodes must be equal");
            }
          } else {
            throw new Error("Nodes differ in the following path: " + problemPath.map(subscriptForProperty).join(""));
          }
        }
      };
      function subscriptForProperty(property) {
        if (/[_$a-z][_$a-z0-9]*/i.test(property)) {
          return "." + property;
        }
        return "[" + JSON.stringify(property) + "]";
      }
      function areEquivalent(a, b, problemPath) {
        if (a === b) {
          return true;
        }
        if (isArray2.check(a)) {
          return arraysAreEquivalent(a, b, problemPath);
        }
        if (isObject2.check(a)) {
          return objectsAreEquivalent(a, b, problemPath);
        }
        if (isDate2.check(a)) {
          return isDate2.check(b) && +a === +b;
        }
        if (isRegExp2.check(a)) {
          return isRegExp2.check(b) && (a.source === b.source && a.global === b.global && a.multiline === b.multiline && a.ignoreCase === b.ignoreCase);
        }
        return a == b;
      }
      function arraysAreEquivalent(a, b, problemPath) {
        isArray2.assert(a);
        var aLength = a.length;
        if (!isArray2.check(b) || b.length !== aLength) {
          if (problemPath) {
            problemPath.push("length");
          }
          return false;
        }
        for (var i = 0; i < aLength; ++i) {
          if (problemPath) {
            problemPath.push(i);
          }
          if (i in a !== i in b) {
            return false;
          }
          if (!areEquivalent(a[i], b[i], problemPath)) {
            return false;
          }
          if (problemPath) {
            var problemPathTail = problemPath.pop();
            if (problemPathTail !== i) {
              throw new Error("" + problemPathTail);
            }
          }
        }
        return true;
      }
      function objectsAreEquivalent(a, b, problemPath) {
        isObject2.assert(a);
        if (!isObject2.check(b)) {
          return false;
        }
        if (a.type !== b.type) {
          if (problemPath) {
            problemPath.push("type");
          }
          return false;
        }
        var aNames = getFieldNames(a);
        var aNameCount = aNames.length;
        var bNames = getFieldNames(b);
        var bNameCount = bNames.length;
        if (aNameCount === bNameCount) {
          for (var i = 0; i < aNameCount; ++i) {
            var name2 = aNames[i];
            var aChild = getFieldValue(a, name2);
            var bChild = getFieldValue(b, name2);
            if (problemPath) {
              problemPath.push(name2);
            }
            if (!areEquivalent(aChild, bChild, problemPath)) {
              return false;
            }
            if (problemPath) {
              var problemPathTail = problemPath.pop();
              if (problemPathTail !== name2) {
                throw new Error("" + problemPathTail);
              }
            }
          }
          return true;
        }
        if (!problemPath) {
          return false;
        }
        var seenNames = /* @__PURE__ */ Object.create(null);
        for (i = 0; i < aNameCount; ++i) {
          seenNames[aNames[i]] = true;
        }
        for (i = 0; i < bNameCount; ++i) {
          name2 = bNames[i];
          if (!hasOwn.call(seenNames, name2)) {
            problemPath.push(name2);
            return false;
          }
          delete seenNames[name2];
        }
        for (name2 in seenNames) {
          problemPath.push(name2);
          break;
        }
        return false;
      }
      return astNodesAreEquivalent;
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(equiv, equiv.exports);
  return equiv.exports;
}
var hasRequiredFork;
function requireFork() {
  if (hasRequiredFork) return fork.exports;
  hasRequiredFork = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var path_visitor_1 = tslib_1.__importDefault(requirePathVisitor());
    var equiv_1 = tslib_1.__importDefault(requireEquiv());
    var path_12 = tslib_1.__importDefault(requirePath());
    var node_path_1 = tslib_1.__importDefault(requireNodePath());
    function default_1(defs) {
      var fork2 = createFork();
      var types2 = fork2.use(types_1.default);
      defs.forEach(fork2.use);
      types2.finalize();
      var PathVisitor = fork2.use(path_visitor_1.default);
      return {
        Type: types2.Type,
        builtInTypes: types2.builtInTypes,
        namedTypes: types2.namedTypes,
        builders: types2.builders,
        defineMethod: types2.defineMethod,
        getFieldNames: types2.getFieldNames,
        getFieldValue: types2.getFieldValue,
        eachField: types2.eachField,
        someField: types2.someField,
        getSupertypeNames: types2.getSupertypeNames,
        getBuilderName: types2.getBuilderName,
        astNodesAreEquivalent: fork2.use(equiv_1.default),
        finalize: types2.finalize,
        Path: fork2.use(path_12.default),
        NodePath: fork2.use(node_path_1.default),
        PathVisitor,
        use: fork2.use,
        visit: PathVisitor.visit
      };
    }
    exports.default = default_1;
    function createFork() {
      var used = [];
      var usedResult = [];
      function use2(plugin) {
        var idx = used.indexOf(plugin);
        if (idx === -1) {
          idx = used.length;
          used.push(plugin);
          usedResult[idx] = plugin(fork2);
        }
        return usedResult[idx];
      }
      var fork2 = { use: use2 };
      return fork2;
    }
    module2.exports = exports["default"];
  })(fork, fork.exports);
  return fork.exports;
}
var core = { exports: {} };
var shared = { exports: {} };
var hasRequiredShared;
function requireShared() {
  if (hasRequiredShared) return shared.exports;
  hasRequiredShared = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var builtin = types2.builtInTypes;
      var isNumber2 = builtin.number;
      function geq(than) {
        return Type.from(function(value2) {
          return isNumber2.check(value2) && value2 >= than;
        }, isNumber2 + " >= " + than);
      }
      var defaults2 = {
        // Functions were used because (among other reasons) that's the most
        // elegant way to allow for the emptyArray one always to give a new
        // array instance.
        "null": function() {
          return null;
        },
        "emptyArray": function() {
          return [];
        },
        "false": function() {
          return false;
        },
        "true": function() {
          return true;
        },
        "undefined": function() {
        },
        "use strict": function() {
          return "use strict";
        }
      };
      var naiveIsPrimitive = Type.or(builtin.string, builtin.number, builtin.boolean, builtin.null, builtin.undefined);
      var isPrimitive = Type.from(function(value2) {
        if (value2 === null)
          return true;
        var type3 = typeof value2;
        if (type3 === "object" || type3 === "function") {
          return false;
        }
        return true;
      }, naiveIsPrimitive.toString());
      return {
        geq,
        defaults: defaults2,
        isPrimitive
      };
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(shared, shared.exports);
  return shared.exports;
}
var hasRequiredCore;
function requireCore() {
  if (hasRequiredCore) return core.exports;
  hasRequiredCore = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var def = Type.def;
      var or = Type.or;
      var shared2 = fork2.use(shared_1.default);
      var defaults2 = shared2.defaults;
      var geq = shared2.geq;
      def("Printable").field("loc", or(def("SourceLocation"), null), defaults2["null"], true);
      def("Node").bases("Printable").field("type", String).field("comments", or([def("Comment")], null), defaults2["null"], true);
      def("SourceLocation").field("start", def("Position")).field("end", def("Position")).field("source", or(String, null), defaults2["null"]);
      def("Position").field("line", geq(1)).field("column", geq(0));
      def("File").bases("Node").build("program", "name").field("program", def("Program")).field("name", or(String, null), defaults2["null"]);
      def("Program").bases("Node").build("body").field("body", [def("Statement")]);
      def("Function").bases("Node").field("id", or(def("Identifier"), null), defaults2["null"]).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("generator", Boolean, defaults2["false"]).field("async", Boolean, defaults2["false"]);
      def("Statement").bases("Node");
      def("EmptyStatement").bases("Statement").build();
      def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]);
      def("ExpressionStatement").bases("Statement").build("expression").field("expression", def("Expression"));
      def("IfStatement").bases("Statement").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Statement")).field("alternate", or(def("Statement"), null), defaults2["null"]);
      def("LabeledStatement").bases("Statement").build("label", "body").field("label", def("Identifier")).field("body", def("Statement"));
      def("BreakStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2["null"]);
      def("ContinueStatement").bases("Statement").build("label").field("label", or(def("Identifier"), null), defaults2["null"]);
      def("WithStatement").bases("Statement").build("object", "body").field("object", def("Expression")).field("body", def("Statement"));
      def("SwitchStatement").bases("Statement").build("discriminant", "cases", "lexical").field("discriminant", def("Expression")).field("cases", [def("SwitchCase")]).field("lexical", Boolean, defaults2["false"]);
      def("ReturnStatement").bases("Statement").build("argument").field("argument", or(def("Expression"), null));
      def("ThrowStatement").bases("Statement").build("argument").field("argument", def("Expression"));
      def("TryStatement").bases("Statement").build("block", "handler", "finalizer").field("block", def("BlockStatement")).field("handler", or(def("CatchClause"), null), function() {
        return this.handlers && this.handlers[0] || null;
      }).field("handlers", [def("CatchClause")], function() {
        return this.handler ? [this.handler] : [];
      }, true).field("guardedHandlers", [def("CatchClause")], defaults2.emptyArray).field("finalizer", or(def("BlockStatement"), null), defaults2["null"]);
      def("CatchClause").bases("Node").build("param", "guard", "body").field("param", or(def("Pattern"), null), defaults2["null"]).field("guard", or(def("Expression"), null), defaults2["null"]).field("body", def("BlockStatement"));
      def("WhileStatement").bases("Statement").build("test", "body").field("test", def("Expression")).field("body", def("Statement"));
      def("DoWhileStatement").bases("Statement").build("body", "test").field("body", def("Statement")).field("test", def("Expression"));
      def("ForStatement").bases("Statement").build("init", "test", "update", "body").field("init", or(def("VariableDeclaration"), def("Expression"), null)).field("test", or(def("Expression"), null)).field("update", or(def("Expression"), null)).field("body", def("Statement"));
      def("ForInStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
      def("DebuggerStatement").bases("Statement").build();
      def("Declaration").bases("Statement");
      def("FunctionDeclaration").bases("Function", "Declaration").build("id", "params", "body").field("id", def("Identifier"));
      def("FunctionExpression").bases("Function", "Expression").build("id", "params", "body");
      def("VariableDeclaration").bases("Declaration").build("kind", "declarations").field("kind", or("var", "let", "const")).field("declarations", [def("VariableDeclarator")]);
      def("VariableDeclarator").bases("Node").build("id", "init").field("id", def("Pattern")).field("init", or(def("Expression"), null), defaults2["null"]);
      def("Expression").bases("Node");
      def("ThisExpression").bases("Expression").build();
      def("ArrayExpression").bases("Expression").build("elements").field("elements", [or(def("Expression"), null)]);
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [def("Property")]);
      def("Property").bases("Node").build("kind", "key", "value").field("kind", or("init", "get", "set")).field("key", or(def("Literal"), def("Identifier"))).field("value", def("Expression"));
      def("SequenceExpression").bases("Expression").build("expressions").field("expressions", [def("Expression")]);
      var UnaryOperator = or("-", "+", "!", "~", "typeof", "void", "delete");
      def("UnaryExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UnaryOperator).field("argument", def("Expression")).field("prefix", Boolean, defaults2["true"]);
      var BinaryOperator = or(
        "==",
        "!=",
        "===",
        "!==",
        "<",
        "<=",
        ">",
        ">=",
        "<<",
        ">>",
        ">>>",
        "+",
        "-",
        "*",
        "/",
        "%",
        "**",
        "&",
        // TODO Missing from the Parser API.
        "|",
        "^",
        "in",
        "instanceof"
      );
      def("BinaryExpression").bases("Expression").build("operator", "left", "right").field("operator", BinaryOperator).field("left", def("Expression")).field("right", def("Expression"));
      var AssignmentOperator = or("=", "+=", "-=", "*=", "/=", "%=", "<<=", ">>=", ">>>=", "|=", "^=", "&=");
      def("AssignmentExpression").bases("Expression").build("operator", "left", "right").field("operator", AssignmentOperator).field("left", or(def("Pattern"), def("MemberExpression"))).field("right", def("Expression"));
      var UpdateOperator = or("++", "--");
      def("UpdateExpression").bases("Expression").build("operator", "argument", "prefix").field("operator", UpdateOperator).field("argument", def("Expression")).field("prefix", Boolean);
      var LogicalOperator = or("||", "&&");
      def("LogicalExpression").bases("Expression").build("operator", "left", "right").field("operator", LogicalOperator).field("left", def("Expression")).field("right", def("Expression"));
      def("ConditionalExpression").bases("Expression").build("test", "consequent", "alternate").field("test", def("Expression")).field("consequent", def("Expression")).field("alternate", def("Expression"));
      def("NewExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
      def("CallExpression").bases("Expression").build("callee", "arguments").field("callee", def("Expression")).field("arguments", [def("Expression")]);
      def("MemberExpression").bases("Expression").build("object", "property", "computed").field("object", def("Expression")).field("property", or(def("Identifier"), def("Expression"))).field("computed", Boolean, function() {
        var type3 = this.property.type;
        if (type3 === "Literal" || type3 === "MemberExpression" || type3 === "BinaryExpression") {
          return true;
        }
        return false;
      });
      def("Pattern").bases("Node");
      def("SwitchCase").bases("Node").build("test", "consequent").field("test", or(def("Expression"), null)).field("consequent", [def("Statement")]);
      def("Identifier").bases("Expression", "Pattern").build("name").field("name", String).field("optional", Boolean, defaults2["false"]);
      def("Literal").bases("Expression").build("value").field("value", or(String, Boolean, null, Number, RegExp)).field("regex", or({
        pattern: String,
        flags: String
      }, null), function() {
        if (this.value instanceof RegExp) {
          var flags = "";
          if (this.value.ignoreCase)
            flags += "i";
          if (this.value.multiline)
            flags += "m";
          if (this.value.global)
            flags += "g";
          return {
            pattern: this.value.source,
            flags
          };
        }
        return null;
      });
      def("Comment").bases("Printable").field("value", String).field("leading", Boolean, defaults2["true"]).field("trailing", Boolean, defaults2["false"]);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(core, core.exports);
  return core.exports;
}
var es6 = { exports: {} };
var hasRequiredEs6;
function requireEs6() {
  if (hasRequiredEs6) return es6.exports;
  hasRequiredEs6 = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var core_1 = tslib_1.__importDefault(requireCore());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(core_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("generator", Boolean, defaults2["false"]).field("expression", Boolean, defaults2["false"]).field("defaults", [or(def("Expression"), null)], defaults2.emptyArray).field("rest", or(def("Identifier"), null), defaults2["null"]);
      def("RestElement").bases("Pattern").build("argument").field("argument", def("Pattern")).field(
        "typeAnnotation",
        // for Babylon. Flow parser puts it on the identifier
        or(def("TypeAnnotation"), def("TSTypeAnnotation"), null),
        defaults2["null"]
      );
      def("SpreadElementPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
      def("FunctionDeclaration").build("id", "params", "body", "generator", "expression");
      def("FunctionExpression").build("id", "params", "body", "generator", "expression");
      def("ArrowFunctionExpression").bases("Function", "Expression").build("params", "body", "expression").field("id", null, defaults2["null"]).field("body", or(def("BlockStatement"), def("Expression"))).field("generator", false, defaults2["false"]);
      def("ForOfStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Pattern"))).field("right", def("Expression")).field("body", def("Statement"));
      def("YieldExpression").bases("Expression").build("argument", "delegate").field("argument", or(def("Expression"), null)).field("delegate", Boolean, defaults2["false"]);
      def("GeneratorExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
      def("ComprehensionExpression").bases("Expression").build("body", "blocks", "filter").field("body", def("Expression")).field("blocks", [def("ComprehensionBlock")]).field("filter", or(def("Expression"), null));
      def("ComprehensionBlock").bases("Node").build("left", "right", "each").field("left", def("Pattern")).field("right", def("Expression")).field("each", Boolean);
      def("Property").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field("method", Boolean, defaults2["false"]).field("shorthand", Boolean, defaults2["false"]).field("computed", Boolean, defaults2["false"]);
      def("ObjectProperty").field("shorthand", Boolean, defaults2["false"]);
      def("PropertyPattern").bases("Pattern").build("key", "pattern").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("pattern", def("Pattern")).field("computed", Boolean, defaults2["false"]);
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [or(def("PropertyPattern"), def("Property"))]);
      def("ArrayPattern").bases("Pattern").build("elements").field("elements", [or(def("Pattern"), null)]);
      def("MethodDefinition").bases("Declaration").build("kind", "key", "value", "static").field("kind", or("constructor", "method", "get", "set")).field("key", def("Expression")).field("value", def("Function")).field("computed", Boolean, defaults2["false"]).field("static", Boolean, defaults2["false"]);
      def("SpreadElement").bases("Node").build("argument").field("argument", def("Expression"));
      def("ArrayExpression").field("elements", [or(def("Expression"), def("SpreadElement"), def("RestElement"), null)]);
      def("NewExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
      def("CallExpression").field("arguments", [or(def("Expression"), def("SpreadElement"))]);
      def("AssignmentPattern").bases("Pattern").build("left", "right").field("left", def("Pattern")).field("right", def("Expression"));
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"));
      def("ClassProperty").bases("Declaration").build("key").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("computed", Boolean, defaults2["false"]);
      def("ClassPropertyDefinition").bases("Declaration").build("definition").field("definition", ClassBodyElement);
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
      def("ClassDeclaration").bases("Declaration").build("id", "body", "superClass").field("id", or(def("Identifier"), null)).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults2["null"]);
      def("ClassExpression").bases("Expression").build("id", "body", "superClass").field("id", or(def("Identifier"), null), defaults2["null"]).field("body", def("ClassBody")).field("superClass", or(def("Expression"), null), defaults2["null"]);
      def("Specifier").bases("Node");
      def("ModuleSpecifier").bases("Specifier").field("local", or(def("Identifier"), null), defaults2["null"]).field("id", or(def("Identifier"), null), defaults2["null"]).field("name", or(def("Identifier"), null), defaults2["null"]);
      def("ImportSpecifier").bases("ModuleSpecifier").build("id", "name");
      def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("id");
      def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("id");
      def("ImportDeclaration").bases("Declaration").build("specifiers", "source", "importKind").field("specifiers", [or(def("ImportSpecifier"), def("ImportNamespaceSpecifier"), def("ImportDefaultSpecifier"))], defaults2.emptyArray).field("source", def("Literal")).field("importKind", or("value", "type"), function() {
        return "value";
      });
      def("TaggedTemplateExpression").bases("Expression").build("tag", "quasi").field("tag", def("Expression")).field("quasi", def("TemplateLiteral"));
      def("TemplateLiteral").bases("Expression").build("quasis", "expressions").field("quasis", [def("TemplateElement")]).field("expressions", [def("Expression")]);
      def("TemplateElement").bases("Node").build("value", "tail").field("value", { "cooked": String, "raw": String }).field("tail", Boolean);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(es6, es6.exports);
  return es6.exports;
}
var es7 = { exports: {} };
var hasRequiredEs7;
function requireEs7() {
  if (hasRequiredEs7) return es7.exports;
  hasRequiredEs7 = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es6_1 = tslib_1.__importDefault(requireEs6());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es6_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults2 = fork2.use(shared_1.default).defaults;
      def("Function").field("async", Boolean, defaults2["false"]);
      def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("ObjectExpression").field("properties", [or(def("Property"), def("SpreadProperty"), def("SpreadElement"))]);
      def("SpreadPropertyPattern").bases("Pattern").build("argument").field("argument", def("Pattern"));
      def("ObjectPattern").field("properties", [or(def("Property"), def("PropertyPattern"), def("SpreadPropertyPattern"))]);
      def("AwaitExpression").bases("Expression").build("argument", "all").field("argument", or(def("Expression"), null)).field("all", Boolean, defaults2["false"]);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(es7, es7.exports);
  return es7.exports;
}
var es2020 = { exports: {} };
var hasRequiredEs2020;
function requireEs2020() {
  if (hasRequiredEs2020) return es2020.exports;
  hasRequiredEs2020 = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      def("ImportExpression").bases("Expression").build("source").field("source", def("Expression"));
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(es2020, es2020.exports);
  return es2020.exports;
}
var jsx = { exports: {} };
var hasRequiredJsx;
function requireJsx() {
  if (hasRequiredJsx) return jsx.exports;
  hasRequiredJsx = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults2 = fork2.use(shared_1.default).defaults;
      def("JSXAttribute").bases("Node").build("name", "value").field("name", or(def("JSXIdentifier"), def("JSXNamespacedName"))).field("value", or(
        def("Literal"),
        // attr="value"
        def("JSXExpressionContainer"),
        // attr={value}
        null
        // attr= or just attr
      ), defaults2["null"]);
      def("JSXIdentifier").bases("Identifier").build("name").field("name", String);
      def("JSXNamespacedName").bases("Node").build("namespace", "name").field("namespace", def("JSXIdentifier")).field("name", def("JSXIdentifier"));
      def("JSXMemberExpression").bases("MemberExpression").build("object", "property").field("object", or(def("JSXIdentifier"), def("JSXMemberExpression"))).field("property", def("JSXIdentifier")).field("computed", Boolean, defaults2.false);
      var JSXElementName = or(def("JSXIdentifier"), def("JSXNamespacedName"), def("JSXMemberExpression"));
      def("JSXSpreadAttribute").bases("Node").build("argument").field("argument", def("Expression"));
      var JSXAttributes = [or(def("JSXAttribute"), def("JSXSpreadAttribute"))];
      def("JSXExpressionContainer").bases("Expression").build("expression").field("expression", def("Expression"));
      def("JSXElement").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningElement")).field("closingElement", or(def("JSXClosingElement"), null), defaults2["null"]).field("children", [or(
        def("JSXElement"),
        def("JSXExpressionContainer"),
        def("JSXFragment"),
        def("JSXText"),
        def("Literal")
        // TODO Esprima should return JSXText instead.
      )], defaults2.emptyArray).field("name", JSXElementName, function() {
        return this.openingElement.name;
      }, true).field("selfClosing", Boolean, function() {
        return this.openingElement.selfClosing;
      }, true).field("attributes", JSXAttributes, function() {
        return this.openingElement.attributes;
      }, true);
      def("JSXOpeningElement").bases("Node").build("name", "attributes", "selfClosing").field("name", JSXElementName).field("attributes", JSXAttributes, defaults2.emptyArray).field("selfClosing", Boolean, defaults2["false"]);
      def("JSXClosingElement").bases("Node").build("name").field("name", JSXElementName);
      def("JSXFragment").bases("Expression").build("openingElement", "closingElement", "children").field("openingElement", def("JSXOpeningFragment")).field("closingElement", def("JSXClosingFragment")).field("children", [or(
        def("JSXElement"),
        def("JSXExpressionContainer"),
        def("JSXFragment"),
        def("JSXText"),
        def("Literal")
        // TODO Esprima should return JSXText instead.
      )], defaults2.emptyArray);
      def("JSXOpeningFragment").bases("Node").build();
      def("JSXClosingFragment").bases("Node").build();
      def("JSXText").bases("Literal").build("value").field("value", String);
      def("JSXEmptyExpression").bases("Expression").build();
      def("JSXSpreadChild").bases("Expression").build("expression").field("expression", def("Expression"));
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(jsx, jsx.exports);
  return jsx.exports;
}
var flow = { exports: {} };
var typeAnnotations = { exports: {} };
var hasRequiredTypeAnnotations;
function requireTypeAnnotations() {
  if (hasRequiredTypeAnnotations) return typeAnnotations.exports;
  hasRequiredTypeAnnotations = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults2 = fork2.use(shared_1.default).defaults;
      var TypeAnnotation = or(def("TypeAnnotation"), def("TSTypeAnnotation"), null);
      var TypeParamDecl = or(def("TypeParameterDeclaration"), def("TSTypeParameterDeclaration"), null);
      def("Identifier").field("typeAnnotation", TypeAnnotation, defaults2["null"]);
      def("ObjectPattern").field("typeAnnotation", TypeAnnotation, defaults2["null"]);
      def("Function").field("returnType", TypeAnnotation, defaults2["null"]).field("typeParameters", TypeParamDecl, defaults2["null"]);
      def("ClassProperty").build("key", "value", "typeAnnotation", "static").field("value", or(def("Expression"), null)).field("static", Boolean, defaults2["false"]).field("typeAnnotation", TypeAnnotation, defaults2["null"]);
      [
        "ClassDeclaration",
        "ClassExpression"
      ].forEach(function(typeName) {
        def(typeName).field("typeParameters", TypeParamDecl, defaults2["null"]).field("superTypeParameters", or(def("TypeParameterInstantiation"), def("TSTypeParameterInstantiation"), null), defaults2["null"]).field("implements", or([def("ClassImplements")], [def("TSExpressionWithTypeArguments")]), defaults2.emptyArray);
      });
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(typeAnnotations, typeAnnotations.exports);
  return typeAnnotations.exports;
}
var hasRequiredFlow;
function requireFlow() {
  if (hasRequiredFlow) return flow.exports;
  hasRequiredFlow = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default);
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults2 = fork2.use(shared_1.default).defaults;
      def("Flow").bases("Node");
      def("FlowType").bases("Flow");
      def("AnyTypeAnnotation").bases("FlowType").build();
      def("EmptyTypeAnnotation").bases("FlowType").build();
      def("MixedTypeAnnotation").bases("FlowType").build();
      def("VoidTypeAnnotation").bases("FlowType").build();
      def("NumberTypeAnnotation").bases("FlowType").build();
      def("NumberLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
      def("NumericLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Number).field("raw", String);
      def("StringTypeAnnotation").bases("FlowType").build();
      def("StringLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", String).field("raw", String);
      def("BooleanTypeAnnotation").bases("FlowType").build();
      def("BooleanLiteralTypeAnnotation").bases("FlowType").build("value", "raw").field("value", Boolean).field("raw", String);
      def("TypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
      def("NullableTypeAnnotation").bases("FlowType").build("typeAnnotation").field("typeAnnotation", def("FlowType"));
      def("NullLiteralTypeAnnotation").bases("FlowType").build();
      def("NullTypeAnnotation").bases("FlowType").build();
      def("ThisTypeAnnotation").bases("FlowType").build();
      def("ExistsTypeAnnotation").bases("FlowType").build();
      def("ExistentialTypeParam").bases("FlowType").build();
      def("FunctionTypeAnnotation").bases("FlowType").build("params", "returnType", "rest", "typeParameters").field("params", [def("FunctionTypeParam")]).field("returnType", def("FlowType")).field("rest", or(def("FunctionTypeParam"), null)).field("typeParameters", or(def("TypeParameterDeclaration"), null));
      def("FunctionTypeParam").bases("Node").build("name", "typeAnnotation", "optional").field("name", def("Identifier")).field("typeAnnotation", def("FlowType")).field("optional", Boolean);
      def("ArrayTypeAnnotation").bases("FlowType").build("elementType").field("elementType", def("FlowType"));
      def("ObjectTypeAnnotation").bases("FlowType").build("properties", "indexers", "callProperties").field("properties", [
        or(def("ObjectTypeProperty"), def("ObjectTypeSpreadProperty"))
      ]).field("indexers", [def("ObjectTypeIndexer")], defaults2.emptyArray).field("callProperties", [def("ObjectTypeCallProperty")], defaults2.emptyArray).field("inexact", or(Boolean, void 0), defaults2["undefined"]).field("exact", Boolean, defaults2["false"]).field("internalSlots", [def("ObjectTypeInternalSlot")], defaults2.emptyArray);
      def("Variance").bases("Node").build("kind").field("kind", or("plus", "minus"));
      var LegacyVariance = or(def("Variance"), "plus", "minus", null);
      def("ObjectTypeProperty").bases("Node").build("key", "value", "optional").field("key", or(def("Literal"), def("Identifier"))).field("value", def("FlowType")).field("optional", Boolean).field("variance", LegacyVariance, defaults2["null"]);
      def("ObjectTypeIndexer").bases("Node").build("id", "key", "value").field("id", def("Identifier")).field("key", def("FlowType")).field("value", def("FlowType")).field("variance", LegacyVariance, defaults2["null"]);
      def("ObjectTypeCallProperty").bases("Node").build("value").field("value", def("FunctionTypeAnnotation")).field("static", Boolean, defaults2["false"]);
      def("QualifiedTypeIdentifier").bases("Node").build("qualification", "id").field("qualification", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("id", def("Identifier"));
      def("GenericTypeAnnotation").bases("FlowType").build("id", "typeParameters").field("id", or(def("Identifier"), def("QualifiedTypeIdentifier"))).field("typeParameters", or(def("TypeParameterInstantiation"), null));
      def("MemberTypeAnnotation").bases("FlowType").build("object", "property").field("object", def("Identifier")).field("property", or(def("MemberTypeAnnotation"), def("GenericTypeAnnotation")));
      def("UnionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("IntersectionTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("TypeofTypeAnnotation").bases("FlowType").build("argument").field("argument", def("FlowType"));
      def("ObjectTypeSpreadProperty").bases("Node").build("argument").field("argument", def("FlowType"));
      def("ObjectTypeInternalSlot").bases("Node").build("id", "value", "optional", "static", "method").field("id", def("Identifier")).field("value", def("FlowType")).field("optional", Boolean).field("static", Boolean).field("method", Boolean);
      def("TypeParameterDeclaration").bases("Node").build("params").field("params", [def("TypeParameter")]);
      def("TypeParameterInstantiation").bases("Node").build("params").field("params", [def("FlowType")]);
      def("TypeParameter").bases("FlowType").build("name", "variance", "bound").field("name", String).field("variance", LegacyVariance, defaults2["null"]).field("bound", or(def("TypeAnnotation"), null), defaults2["null"]);
      def("ClassProperty").field("variance", LegacyVariance, defaults2["null"]);
      def("ClassImplements").bases("Node").build("id").field("id", def("Identifier")).field("superClass", or(def("Expression"), null), defaults2["null"]).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults2["null"]);
      def("InterfaceTypeAnnotation").bases("FlowType").build("body", "extends").field("body", def("ObjectTypeAnnotation")).field("extends", or([def("InterfaceExtends")], null), defaults2["null"]);
      def("InterfaceDeclaration").bases("Declaration").build("id", "body", "extends").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null), defaults2["null"]).field("body", def("ObjectTypeAnnotation")).field("extends", [def("InterfaceExtends")]);
      def("DeclareInterface").bases("InterfaceDeclaration").build("id", "body", "extends");
      def("InterfaceExtends").bases("Node").build("id").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterInstantiation"), null), defaults2["null"]);
      def("TypeAlias").bases("Declaration").build("id", "typeParameters", "right").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("right", def("FlowType"));
      def("OpaqueType").bases("Declaration").build("id", "typeParameters", "impltype", "supertype").field("id", def("Identifier")).field("typeParameters", or(def("TypeParameterDeclaration"), null)).field("impltype", def("FlowType")).field("supertype", def("FlowType"));
      def("DeclareTypeAlias").bases("TypeAlias").build("id", "typeParameters", "right");
      def("DeclareOpaqueType").bases("TypeAlias").build("id", "typeParameters", "supertype");
      def("TypeCastExpression").bases("Expression").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TypeAnnotation"));
      def("TupleTypeAnnotation").bases("FlowType").build("types").field("types", [def("FlowType")]);
      def("DeclareVariable").bases("Statement").build("id").field("id", def("Identifier"));
      def("DeclareFunction").bases("Statement").build("id").field("id", def("Identifier"));
      def("DeclareClass").bases("InterfaceDeclaration").build("id");
      def("DeclareModule").bases("Statement").build("id", "body").field("id", or(def("Identifier"), def("Literal"))).field("body", def("BlockStatement"));
      def("DeclareModuleExports").bases("Statement").build("typeAnnotation").field("typeAnnotation", def("TypeAnnotation"));
      def("DeclareExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("DeclareVariable"),
        def("DeclareFunction"),
        def("DeclareClass"),
        def("FlowType"),
        // Implies default.
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2["null"]);
      def("DeclareExportAllDeclaration").bases("Declaration").build("source").field("source", or(def("Literal"), null), defaults2["null"]);
      def("FlowPredicate").bases("Flow");
      def("InferredPredicate").bases("FlowPredicate").build();
      def("DeclaredPredicate").bases("FlowPredicate").build("value").field("value", def("Expression"));
      def("CallExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults2["null"]);
      def("NewExpression").field("typeArguments", or(null, def("TypeParameterInstantiation")), defaults2["null"]);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(flow, flow.exports);
  return flow.exports;
}
var esprima = { exports: {} };
var hasRequiredEsprima;
function requireEsprima() {
  if (hasRequiredEsprima) return esprima.exports;
  hasRequiredEsprima = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var es7_1 = tslib_1.__importDefault(requireEs7());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var defaults2 = fork2.use(shared_1.default).defaults;
      var def = types2.Type.def;
      var or = types2.Type.or;
      def("VariableDeclaration").field("declarations", [or(
        def("VariableDeclarator"),
        def("Identifier")
        // Esprima deviation.
      )]);
      def("Property").field("value", or(
        def("Expression"),
        def("Pattern")
        // Esprima deviation.
      ));
      def("ArrayPattern").field("elements", [or(def("Pattern"), def("SpreadElement"), null)]);
      def("ObjectPattern").field("properties", [or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty")
        // Used by Esprima.
      )]);
      def("ExportSpecifier").bases("ModuleSpecifier").build("id", "name");
      def("ExportBatchSpecifier").bases("Specifier").build();
      def("ExportDeclaration").bases("Declaration").build("default", "declaration", "specifiers", "source").field("default", Boolean).field("declaration", or(
        def("Declaration"),
        def("Expression"),
        // Implies default.
        null
      )).field("specifiers", [or(def("ExportSpecifier"), def("ExportBatchSpecifier"))], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2["null"]);
      def("Block").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
      def("Line").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(esprima, esprima.exports);
  return esprima.exports;
}
var babel = { exports: {} };
var babelCore = { exports: {} };
var hasRequiredBabelCore;
function requireBabelCore() {
  if (hasRequiredBabelCore) return babelCore.exports;
  hasRequiredBabelCore = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    var es7_1 = tslib_1.__importDefault(requireEs7());
    function default_1(fork2) {
      fork2.use(es7_1.default);
      var types2 = fork2.use(types_1.default);
      var defaults2 = fork2.use(shared_1.default).defaults;
      var def = types2.Type.def;
      var or = types2.Type.or;
      def("Noop").bases("Statement").build();
      def("DoExpression").bases("Expression").build("body").field("body", [def("Statement")]);
      def("Super").bases("Expression").build();
      def("BindExpression").bases("Expression").build("object", "callee").field("object", or(def("Expression"), null)).field("callee", def("Expression"));
      def("Decorator").bases("Node").build("expression").field("expression", def("Expression"));
      def("Property").field("decorators", or([def("Decorator")], null), defaults2["null"]);
      def("MethodDefinition").field("decorators", or([def("Decorator")], null), defaults2["null"]);
      def("MetaProperty").bases("Expression").build("meta", "property").field("meta", def("Identifier")).field("property", def("Identifier"));
      def("ParenthesizedExpression").bases("Expression").build("expression").field("expression", def("Expression"));
      def("ImportSpecifier").bases("ModuleSpecifier").build("imported", "local").field("imported", def("Identifier"));
      def("ImportDefaultSpecifier").bases("ModuleSpecifier").build("local");
      def("ImportNamespaceSpecifier").bases("ModuleSpecifier").build("local");
      def("ExportDefaultDeclaration").bases("Declaration").build("declaration").field("declaration", or(def("Declaration"), def("Expression")));
      def("ExportNamedDeclaration").bases("Declaration").build("declaration", "specifiers", "source").field("declaration", or(def("Declaration"), null)).field("specifiers", [def("ExportSpecifier")], defaults2.emptyArray).field("source", or(def("Literal"), null), defaults2["null"]);
      def("ExportSpecifier").bases("ModuleSpecifier").build("local", "exported").field("exported", def("Identifier"));
      def("ExportNamespaceSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
      def("ExportDefaultSpecifier").bases("Specifier").build("exported").field("exported", def("Identifier"));
      def("ExportAllDeclaration").bases("Declaration").build("exported", "source").field("exported", or(def("Identifier"), null)).field("source", def("Literal"));
      def("CommentBlock").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
      def("CommentLine").bases("Comment").build(
        "value",
        /*optional:*/
        "leading",
        "trailing"
      );
      def("Directive").bases("Node").build("value").field("value", def("DirectiveLiteral"));
      def("DirectiveLiteral").bases("Node", "Expression").build("value").field("value", String, defaults2["use strict"]);
      def("InterpreterDirective").bases("Node").build("value").field("value", String);
      def("BlockStatement").bases("Statement").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults2.emptyArray);
      def("Program").bases("Node").build("body").field("body", [def("Statement")]).field("directives", [def("Directive")], defaults2.emptyArray).field("interpreter", or(def("InterpreterDirective"), null), defaults2["null"]);
      def("StringLiteral").bases("Literal").build("value").field("value", String);
      def("NumericLiteral").bases("Literal").build("value").field("value", Number).field("raw", or(String, null), defaults2["null"]).field("extra", {
        rawValue: Number,
        raw: String
      }, function getDefault() {
        return {
          rawValue: this.value,
          raw: this.value + ""
        };
      });
      def("BigIntLiteral").bases("Literal").build("value").field("value", or(String, Number)).field("extra", {
        rawValue: String,
        raw: String
      }, function getDefault() {
        return {
          rawValue: String(this.value),
          raw: this.value + "n"
        };
      });
      def("NullLiteral").bases("Literal").build().field("value", null, defaults2["null"]);
      def("BooleanLiteral").bases("Literal").build("value").field("value", Boolean);
      def("RegExpLiteral").bases("Literal").build("pattern", "flags").field("pattern", String).field("flags", String).field("value", RegExp, function() {
        return new RegExp(this.pattern, this.flags);
      });
      var ObjectExpressionProperty = or(def("Property"), def("ObjectMethod"), def("ObjectProperty"), def("SpreadProperty"), def("SpreadElement"));
      def("ObjectExpression").bases("Expression").build("properties").field("properties", [ObjectExpressionProperty]);
      def("ObjectMethod").bases("Node", "Function").build("kind", "key", "params", "body", "computed").field("kind", or("method", "get", "set")).field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("params", [def("Pattern")]).field("body", def("BlockStatement")).field("computed", Boolean, defaults2["false"]).field("generator", Boolean, defaults2["false"]).field("async", Boolean, defaults2["false"]).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults2["null"]
      ).field("decorators", or([def("Decorator")], null), defaults2["null"]);
      def("ObjectProperty").bases("Node").build("key", "value").field("key", or(def("Literal"), def("Identifier"), def("Expression"))).field("value", or(def("Expression"), def("Pattern"))).field(
        "accessibility",
        // TypeScript
        or(def("Literal"), null),
        defaults2["null"]
      ).field("computed", Boolean, defaults2["false"]);
      var ClassBodyElement = or(def("MethodDefinition"), def("VariableDeclarator"), def("ClassPropertyDefinition"), def("ClassProperty"), def("ClassPrivateProperty"), def("ClassMethod"), def("ClassPrivateMethod"));
      def("ClassBody").bases("Declaration").build("body").field("body", [ClassBodyElement]);
      def("ClassMethod").bases("Declaration", "Function").build("kind", "key", "params", "body", "computed", "static").field("key", or(def("Literal"), def("Identifier"), def("Expression")));
      def("ClassPrivateMethod").bases("Declaration", "Function").build("key", "params", "body", "kind", "computed", "static").field("key", def("PrivateName"));
      [
        "ClassMethod",
        "ClassPrivateMethod"
      ].forEach(function(typeName) {
        def(typeName).field("kind", or("get", "set", "method", "constructor"), function() {
          return "method";
        }).field("body", def("BlockStatement")).field("computed", Boolean, defaults2["false"]).field("static", or(Boolean, null), defaults2["null"]).field("abstract", or(Boolean, null), defaults2["null"]).field("access", or("public", "private", "protected", null), defaults2["null"]).field("accessibility", or("public", "private", "protected", null), defaults2["null"]).field("decorators", or([def("Decorator")], null), defaults2["null"]).field("optional", or(Boolean, null), defaults2["null"]);
      });
      def("ClassPrivateProperty").bases("ClassProperty").build("key", "value").field("key", def("PrivateName")).field("value", or(def("Expression"), null), defaults2["null"]);
      def("PrivateName").bases("Expression", "Pattern").build("id").field("id", def("Identifier"));
      var ObjectPatternProperty = or(
        def("Property"),
        def("PropertyPattern"),
        def("SpreadPropertyPattern"),
        def("SpreadProperty"),
        // Used by Esprima
        def("ObjectProperty"),
        // Babel 6
        def("RestProperty")
        // Babel 6
      );
      def("ObjectPattern").bases("Pattern").build("properties").field("properties", [ObjectPatternProperty]).field("decorators", or([def("Decorator")], null), defaults2["null"]);
      def("SpreadProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("RestProperty").bases("Node").build("argument").field("argument", def("Expression"));
      def("ForAwaitStatement").bases("Statement").build("left", "right", "body").field("left", or(def("VariableDeclaration"), def("Expression"))).field("right", def("Expression")).field("body", def("Statement"));
      def("Import").bases("Expression").build();
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(babelCore, babelCore.exports);
  return babelCore.exports;
}
var hasRequiredBabel;
function requireBabel() {
  if (hasRequiredBabel) return babel.exports;
  hasRequiredBabel = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var babel_core_1 = tslib_1.__importDefault(requireBabelCore());
    var flow_1 = tslib_1.__importDefault(requireFlow());
    function default_1(fork2) {
      fork2.use(babel_core_1.default);
      fork2.use(flow_1.default);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(babel, babel.exports);
  return babel.exports;
}
var typescript = { exports: {} };
var hasRequiredTypescript;
function requireTypescript() {
  if (hasRequiredTypescript) return typescript.exports;
  hasRequiredTypescript = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var babel_core_1 = tslib_1.__importDefault(requireBabelCore());
    var type_annotations_1 = tslib_1.__importDefault(requireTypeAnnotations());
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    function default_1(fork2) {
      fork2.use(babel_core_1.default);
      fork2.use(type_annotations_1.default);
      var types2 = fork2.use(types_1.default);
      var n = types2.namedTypes;
      var def = types2.Type.def;
      var or = types2.Type.or;
      var defaults2 = fork2.use(shared_1.default).defaults;
      var StringLiteral = types2.Type.from(function(value2, deep) {
        if (n.StringLiteral && n.StringLiteral.check(value2, deep)) {
          return true;
        }
        if (n.Literal && n.Literal.check(value2, deep) && typeof value2.value === "string") {
          return true;
        }
        return false;
      }, "StringLiteral");
      def("TSType").bases("Node");
      var TSEntityName = or(def("Identifier"), def("TSQualifiedName"));
      def("TSTypeReference").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("typeName", "typeParameters").field("typeName", TSEntityName);
      def("TSHasOptionalTypeParameterInstantiation").field("typeParameters", or(def("TSTypeParameterInstantiation"), null), defaults2["null"]);
      def("TSHasOptionalTypeParameters").field("typeParameters", or(def("TSTypeParameterDeclaration"), null, void 0), defaults2["null"]);
      def("TSHasOptionalTypeAnnotation").field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults2["null"]);
      def("TSQualifiedName").bases("Node").build("left", "right").field("left", TSEntityName).field("right", TSEntityName);
      def("TSAsExpression").bases("Expression", "Pattern").build("expression", "typeAnnotation").field("expression", def("Expression")).field("typeAnnotation", def("TSType")).field("extra", or({ parenthesized: Boolean }, null), defaults2["null"]);
      def("TSNonNullExpression").bases("Expression", "Pattern").build("expression").field("expression", def("Expression"));
      [
        "TSAnyKeyword",
        "TSBigIntKeyword",
        "TSBooleanKeyword",
        "TSNeverKeyword",
        "TSNullKeyword",
        "TSNumberKeyword",
        "TSObjectKeyword",
        "TSStringKeyword",
        "TSSymbolKeyword",
        "TSUndefinedKeyword",
        "TSUnknownKeyword",
        "TSVoidKeyword",
        "TSThisType"
      ].forEach(function(keywordType) {
        def(keywordType).bases("TSType").build();
      });
      def("TSArrayType").bases("TSType").build("elementType").field("elementType", def("TSType"));
      def("TSLiteralType").bases("TSType").build("literal").field("literal", or(def("NumericLiteral"), def("StringLiteral"), def("BooleanLiteral"), def("TemplateLiteral"), def("UnaryExpression")));
      [
        "TSUnionType",
        "TSIntersectionType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType").build("types").field("types", [def("TSType")]);
      });
      def("TSConditionalType").bases("TSType").build("checkType", "extendsType", "trueType", "falseType").field("checkType", def("TSType")).field("extendsType", def("TSType")).field("trueType", def("TSType")).field("falseType", def("TSType"));
      def("TSInferType").bases("TSType").build("typeParameter").field("typeParameter", def("TSTypeParameter"));
      def("TSParenthesizedType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      var ParametersType = [or(def("Identifier"), def("RestElement"), def("ArrayPattern"), def("ObjectPattern"))];
      [
        "TSFunctionType",
        "TSConstructorType"
      ].forEach(function(typeName) {
        def(typeName).bases("TSType", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters").field("parameters", ParametersType);
      });
      def("TSDeclareFunction").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "params", "returnType").field("declare", Boolean, defaults2["false"]).field("async", Boolean, defaults2["false"]).field("generator", Boolean, defaults2["false"]).field("id", or(def("Identifier"), null), defaults2["null"]).field("params", [def("Pattern")]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults2["null"]);
      def("TSDeclareMethod").bases("Declaration", "TSHasOptionalTypeParameters").build("key", "params", "returnType").field("async", Boolean, defaults2["false"]).field("generator", Boolean, defaults2["false"]).field("params", [def("Pattern")]).field("abstract", Boolean, defaults2["false"]).field("accessibility", or("public", "private", "protected", void 0), defaults2["undefined"]).field("static", Boolean, defaults2["false"]).field("computed", Boolean, defaults2["false"]).field("optional", Boolean, defaults2["false"]).field("key", or(
        def("Identifier"),
        def("StringLiteral"),
        def("NumericLiteral"),
        // Only allowed if .computed is true.
        def("Expression")
      )).field("kind", or("get", "set", "method", "constructor"), function getDefault() {
        return "method";
      }).field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults2["undefined"]
      ).field("decorators", or([def("Decorator")], null), defaults2["null"]).field("returnType", or(
        def("TSTypeAnnotation"),
        def("Noop"),
        // Still used?
        null
      ), defaults2["null"]);
      def("TSMappedType").bases("TSType").build("typeParameter", "typeAnnotation").field("readonly", or(Boolean, "+", "-"), defaults2["false"]).field("typeParameter", def("TSTypeParameter")).field("optional", or(Boolean, "+", "-"), defaults2["false"]).field("typeAnnotation", or(def("TSType"), null), defaults2["null"]);
      def("TSTupleType").bases("TSType").build("elementTypes").field("elementTypes", [or(def("TSType"), def("TSNamedTupleMember"))]);
      def("TSNamedTupleMember").bases("TSType").build("label", "elementType", "optional").field("label", def("Identifier")).field("optional", Boolean, defaults2["false"]).field("elementType", def("TSType"));
      def("TSRestType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      def("TSOptionalType").bases("TSType").build("typeAnnotation").field("typeAnnotation", def("TSType"));
      def("TSIndexedAccessType").bases("TSType").build("objectType", "indexType").field("objectType", def("TSType")).field("indexType", def("TSType"));
      def("TSTypeOperator").bases("TSType").build("operator").field("operator", String).field("typeAnnotation", def("TSType"));
      def("TSTypeAnnotation").bases("Node").build("typeAnnotation").field("typeAnnotation", or(def("TSType"), def("TSTypeAnnotation")));
      def("TSIndexSignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", [def("Identifier")]).field("readonly", Boolean, defaults2["false"]);
      def("TSPropertySignature").bases("Declaration", "TSHasOptionalTypeAnnotation").build("key", "typeAnnotation", "optional").field("key", def("Expression")).field("computed", Boolean, defaults2["false"]).field("readonly", Boolean, defaults2["false"]).field("optional", Boolean, defaults2["false"]).field("initializer", or(def("Expression"), null), defaults2["null"]);
      def("TSMethodSignature").bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("key", "parameters", "typeAnnotation").field("key", def("Expression")).field("computed", Boolean, defaults2["false"]).field("optional", Boolean, defaults2["false"]).field("parameters", ParametersType);
      def("TSTypePredicate").bases("TSTypeAnnotation", "TSType").build("parameterName", "typeAnnotation", "asserts").field("parameterName", or(def("Identifier"), def("TSThisType"))).field("typeAnnotation", or(def("TSTypeAnnotation"), null), defaults2["null"]).field("asserts", Boolean, defaults2["false"]);
      [
        "TSCallSignatureDeclaration",
        "TSConstructSignatureDeclaration"
      ].forEach(function(typeName) {
        def(typeName).bases("Declaration", "TSHasOptionalTypeParameters", "TSHasOptionalTypeAnnotation").build("parameters", "typeAnnotation").field("parameters", ParametersType);
      });
      def("TSEnumMember").bases("Node").build("id", "initializer").field("id", or(def("Identifier"), StringLiteral)).field("initializer", or(def("Expression"), null), defaults2["null"]);
      def("TSTypeQuery").bases("TSType").build("exprName").field("exprName", or(TSEntityName, def("TSImportType")));
      var TSTypeMember = or(def("TSCallSignatureDeclaration"), def("TSConstructSignatureDeclaration"), def("TSIndexSignature"), def("TSMethodSignature"), def("TSPropertySignature"));
      def("TSTypeLiteral").bases("TSType").build("members").field("members", [TSTypeMember]);
      def("TSTypeParameter").bases("Identifier").build("name", "constraint", "default").field("name", String).field("constraint", or(def("TSType"), void 0), defaults2["undefined"]).field("default", or(def("TSType"), void 0), defaults2["undefined"]);
      def("TSTypeAssertion").bases("Expression", "Pattern").build("typeAnnotation", "expression").field("typeAnnotation", def("TSType")).field("expression", def("Expression")).field("extra", or({ parenthesized: Boolean }, null), defaults2["null"]);
      def("TSTypeParameterDeclaration").bases("Declaration").build("params").field("params", [def("TSTypeParameter")]);
      def("TSTypeParameterInstantiation").bases("Node").build("params").field("params", [def("TSType")]);
      def("TSEnumDeclaration").bases("Declaration").build("id", "members").field("id", def("Identifier")).field("const", Boolean, defaults2["false"]).field("declare", Boolean, defaults2["false"]).field("members", [def("TSEnumMember")]).field("initializer", or(def("Expression"), null), defaults2["null"]);
      def("TSTypeAliasDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "typeAnnotation").field("id", def("Identifier")).field("declare", Boolean, defaults2["false"]).field("typeAnnotation", def("TSType"));
      def("TSModuleBlock").bases("Node").build("body").field("body", [def("Statement")]);
      def("TSModuleDeclaration").bases("Declaration").build("id", "body").field("id", or(StringLiteral, TSEntityName)).field("declare", Boolean, defaults2["false"]).field("global", Boolean, defaults2["false"]).field("body", or(def("TSModuleBlock"), def("TSModuleDeclaration"), null), defaults2["null"]);
      def("TSImportType").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("argument", "qualifier", "typeParameters").field("argument", StringLiteral).field("qualifier", or(TSEntityName, void 0), defaults2["undefined"]);
      def("TSImportEqualsDeclaration").bases("Declaration").build("id", "moduleReference").field("id", def("Identifier")).field("isExport", Boolean, defaults2["false"]).field("moduleReference", or(TSEntityName, def("TSExternalModuleReference")));
      def("TSExternalModuleReference").bases("Declaration").build("expression").field("expression", StringLiteral);
      def("TSExportAssignment").bases("Statement").build("expression").field("expression", def("Expression"));
      def("TSNamespaceExportDeclaration").bases("Declaration").build("id").field("id", def("Identifier"));
      def("TSInterfaceBody").bases("Node").build("body").field("body", [TSTypeMember]);
      def("TSExpressionWithTypeArguments").bases("TSType", "TSHasOptionalTypeParameterInstantiation").build("expression", "typeParameters").field("expression", TSEntityName);
      def("TSInterfaceDeclaration").bases("Declaration", "TSHasOptionalTypeParameters").build("id", "body").field("id", TSEntityName).field("declare", Boolean, defaults2["false"]).field("extends", or([def("TSExpressionWithTypeArguments")], null), defaults2["null"]).field("body", def("TSInterfaceBody"));
      def("TSParameterProperty").bases("Pattern").build("parameter").field("accessibility", or("public", "private", "protected", void 0), defaults2["undefined"]).field("readonly", Boolean, defaults2["false"]).field("parameter", or(def("Identifier"), def("AssignmentPattern")));
      def("ClassProperty").field(
        "access",
        // Not "accessibility"?
        or("public", "private", "protected", void 0),
        defaults2["undefined"]
      );
      def("ClassBody").field("body", [or(
        def("MethodDefinition"),
        def("VariableDeclarator"),
        def("ClassPropertyDefinition"),
        def("ClassProperty"),
        def("ClassPrivateProperty"),
        def("ClassMethod"),
        def("ClassPrivateMethod"),
        // Just need to add these types:
        def("TSDeclareMethod"),
        TSTypeMember
      )]);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(typescript, typescript.exports);
  return typescript.exports;
}
var esProposals = { exports: {} };
var hasRequiredEsProposals;
function requireEsProposals() {
  if (hasRequiredEsProposals) return esProposals.exports;
  hasRequiredEsProposals = 1;
  (function(module2, exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var tslib_1 = require$$0;
    var types_1 = tslib_1.__importDefault(requireTypes$1());
    var shared_1 = tslib_1.__importDefault(requireShared());
    var core_1 = tslib_1.__importDefault(requireCore());
    function default_1(fork2) {
      fork2.use(core_1.default);
      var types2 = fork2.use(types_1.default);
      var Type = types2.Type;
      var def = types2.Type.def;
      var or = Type.or;
      var shared2 = fork2.use(shared_1.default);
      var defaults2 = shared2.defaults;
      def("OptionalMemberExpression").bases("MemberExpression").build("object", "property", "computed", "optional").field("optional", Boolean, defaults2["true"]);
      def("OptionalCallExpression").bases("CallExpression").build("callee", "arguments", "optional").field("optional", Boolean, defaults2["true"]);
      var LogicalOperator = or("||", "&&", "??");
      def("LogicalExpression").field("operator", LogicalOperator);
    }
    exports.default = default_1;
    module2.exports = exports["default"];
  })(esProposals, esProposals.exports);
  return esProposals.exports;
}
var namedTypes = {};
var hasRequiredNamedTypes;
function requireNamedTypes() {
  if (hasRequiredNamedTypes) return namedTypes;
  hasRequiredNamedTypes = 1;
  (function(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.namedTypes = void 0;
    /* @__PURE__ */ (function(namedTypes2) {
    })(exports.namedTypes || (exports.namedTypes = {}));
  })(namedTypes);
  return namedTypes;
}
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.visit = exports.use = exports.Type = exports.someField = exports.PathVisitor = exports.Path = exports.NodePath = exports.namedTypes = exports.getSupertypeNames = exports.getFieldValue = exports.getFieldNames = exports.getBuilderName = exports.finalize = exports.eachField = exports.defineMethod = exports.builtInTypes = exports.builders = exports.astNodesAreEquivalent = void 0;
  var tslib_1 = require$$0;
  var fork_1 = tslib_1.__importDefault(requireFork());
  var core_1 = tslib_1.__importDefault(requireCore());
  var es6_1 = tslib_1.__importDefault(requireEs6());
  var es7_1 = tslib_1.__importDefault(requireEs7());
  var es2020_1 = tslib_1.__importDefault(requireEs2020());
  var jsx_1 = tslib_1.__importDefault(requireJsx());
  var flow_1 = tslib_1.__importDefault(requireFlow());
  var esprima_12 = tslib_1.__importDefault(requireEsprima());
  var babel_1 = tslib_1.__importDefault(requireBabel());
  var typescript_1 = tslib_1.__importDefault(requireTypescript());
  var es_proposals_1 = tslib_1.__importDefault(requireEsProposals());
  var namedTypes_1 = requireNamedTypes();
  Object.defineProperty(exports, "namedTypes", { enumerable: true, get: function() {
    return namedTypes_1.namedTypes;
  } });
  var _a = fork_1.default([
    // This core module of AST types captures ES5 as it is parsed today by
    // git://github.com/ariya/esprima.git#master.
    core_1.default,
    // Feel free to add to or remove from this list of extension modules to
    // configure the precise type hierarchy that you need.
    es6_1.default,
    es7_1.default,
    es2020_1.default,
    jsx_1.default,
    flow_1.default,
    esprima_12.default,
    babel_1.default,
    typescript_1.default,
    es_proposals_1.default
  ]), astNodesAreEquivalent = _a.astNodesAreEquivalent, builders = _a.builders, builtInTypes = _a.builtInTypes, defineMethod = _a.defineMethod, eachField = _a.eachField, finalize = _a.finalize, getBuilderName = _a.getBuilderName, getFieldNames = _a.getFieldNames, getFieldValue = _a.getFieldValue, getSupertypeNames = _a.getSupertypeNames, n = _a.namedTypes, NodePath = _a.NodePath, Path = _a.Path, PathVisitor = _a.PathVisitor, someField = _a.someField, Type = _a.Type, use2 = _a.use, visit = _a.visit;
  exports.astNodesAreEquivalent = astNodesAreEquivalent;
  exports.builders = builders;
  exports.builtInTypes = builtInTypes;
  exports.defineMethod = defineMethod;
  exports.eachField = eachField;
  exports.finalize = finalize;
  exports.getBuilderName = getBuilderName;
  exports.getFieldNames = getFieldNames;
  exports.getFieldValue = getFieldValue;
  exports.getSupertypeNames = getSupertypeNames;
  exports.NodePath = NodePath;
  exports.Path = Path;
  exports.PathVisitor = PathVisitor;
  exports.someField = someField;
  exports.Type = Type;
  exports.use = use2;
  exports.visit = visit;
  Object.assign(namedTypes_1.namedTypes, n);
})(main$1);
Object.defineProperty(degenerator$1, "__esModule", { value: true });
degenerator$1.degenerator = void 0;
const util_1$5 = require$$1$3;
const escodegen_1 = escodegen;
const esprima_1 = esprimaExports;
const ast_types_1 = main$1;
function degenerator(code2, _names) {
  if (!Array.isArray(_names)) {
    throw new TypeError('an array of async function "names" is required');
  }
  const names = _names.slice(0);
  const ast2 = (0, esprima_1.parseScript)(code2);
  let lastNamesLength = 0;
  do {
    lastNamesLength = names.length;
    (0, ast_types_1.visit)(ast2, {
      visitVariableDeclaration(path3) {
        if (path3.node.declarations) {
          for (let i = 0; i < path3.node.declarations.length; i++) {
            const declaration = path3.node.declarations[i];
            if (ast_types_1.namedTypes.VariableDeclarator.check(declaration) && ast_types_1.namedTypes.Identifier.check(declaration.init) && ast_types_1.namedTypes.Identifier.check(declaration.id) && checkName(declaration.init.name, names) && !checkName(declaration.id.name, names)) {
              names.push(declaration.id.name);
            }
          }
        }
        return false;
      },
      visitAssignmentExpression(path3) {
        if (ast_types_1.namedTypes.Identifier.check(path3.node.left) && ast_types_1.namedTypes.Identifier.check(path3.node.right) && checkName(path3.node.right.name, names) && !checkName(path3.node.left.name, names)) {
          names.push(path3.node.left.name);
        }
        return false;
      },
      visitFunction(path3) {
        if (path3.node.id) {
          let shouldDegenerate = false;
          (0, ast_types_1.visit)(path3.node, {
            visitCallExpression(path4) {
              if (checkNames(path4.node, names)) {
                shouldDegenerate = true;
              }
              return false;
            }
          });
          if (!shouldDegenerate) {
            return false;
          }
          path3.node.async = true;
          if (!checkName(path3.node.id.name, names)) {
            names.push(path3.node.id.name);
          }
        }
        this.traverse(path3);
      }
    });
  } while (lastNamesLength !== names.length);
  (0, ast_types_1.visit)(ast2, {
    visitCallExpression(path3) {
      if (checkNames(path3.node, names)) {
        const delegate = false;
        const { name: name2, parent: { node: pNode } } = path3;
        const expr = ast_types_1.builders.awaitExpression(path3.node, delegate);
        if (ast_types_1.namedTypes.CallExpression.check(pNode)) {
          pNode.arguments[name2] = expr;
        } else {
          pNode[name2] = expr;
        }
      }
      this.traverse(path3);
    }
  });
  return (0, escodegen_1.generate)(ast2);
}
degenerator$1.degenerator = degenerator;
function checkNames({ callee }, names) {
  let name2;
  if (ast_types_1.namedTypes.Identifier.check(callee)) {
    name2 = callee.name;
  } else if (ast_types_1.namedTypes.MemberExpression.check(callee)) {
    if (ast_types_1.namedTypes.Identifier.check(callee.object) && ast_types_1.namedTypes.Identifier.check(callee.property)) {
      name2 = `${callee.object.name}.${callee.property.name}`;
    } else {
      return false;
    }
  } else if (ast_types_1.namedTypes.FunctionExpression.check(callee)) {
    if (callee.id) {
      name2 = callee.id.name;
    } else {
      return false;
    }
  } else {
    throw new Error(`Don't know how to get name for: ${callee.type}`);
  }
  return checkName(name2, names);
}
function checkName(name2, names) {
  for (let i = 0; i < names.length; i++) {
    const n = names[i];
    if (util_1$5.types.isRegExp(n)) {
      if (n.test(name2)) {
        return true;
      }
    } else if (name2 === n) {
      return true;
    }
  }
  return false;
}
var compile$1 = {};
Object.defineProperty(compile$1, "__esModule", { value: true });
compile$1.compile = void 0;
const util_1$4 = require$$1$3;
const degenerator_1 = degenerator$1;
function compile(qjs, code2, returnName, options = {}) {
  const compiled = (0, degenerator_1.degenerator)(code2, options.names ?? []);
  const vm = qjs.newContext();
  if (options.sandbox) {
    for (const [name2, value2] of Object.entries(options.sandbox)) {
      if (typeof value2 !== "function") {
        throw new Error(`Expected a "function" for sandbox property \`${name2}\`, but got "${typeof value2}"`);
      }
      const fnHandle = vm.newFunction(name2, (...args) => {
        const result = value2(...args.map((arg) => quickJSHandleToHost(vm, arg)));
        vm.runtime.executePendingJobs();
        return hostToQuickJSHandle(vm, result);
      });
      fnHandle.consume((handle3) => vm.setProp(vm.global, name2, handle3));
    }
  }
  const fnResult = vm.evalCode(`${compiled};${returnName}`, options.filename);
  const fn = vm.unwrapResult(fnResult);
  const t2 = vm.typeof(fn);
  if (t2 !== "function") {
    throw new Error(`Expected a "function" named \`${returnName}\` to be defined, but got "${t2}"`);
  }
  const r = async function(...args) {
    let promiseHandle;
    let resolvedHandle;
    try {
      const result = vm.callFunction(fn, vm.undefined, ...args.map((arg) => hostToQuickJSHandle(vm, arg)));
      promiseHandle = vm.unwrapResult(result);
      const resolvedResultP = vm.resolvePromise(promiseHandle);
      vm.runtime.executePendingJobs();
      const resolvedResult = await resolvedResultP;
      resolvedHandle = vm.unwrapResult(resolvedResult);
      return quickJSHandleToHost(vm, resolvedHandle);
    } catch (err) {
      if (err && typeof err === "object" && "cause" in err && err.cause) {
        if (typeof err.cause === "object" && "stack" in err.cause && "name" in err.cause && "message" in err.cause && typeof err.cause.stack === "string" && typeof err.cause.name === "string" && typeof err.cause.message === "string") {
          err.cause.stack = `${err.cause.name}: ${err.cause.message}
${err.cause.stack}`;
        }
        throw err.cause;
      }
      throw err;
    } finally {
      promiseHandle == null ? void 0 : promiseHandle.dispose();
      resolvedHandle == null ? void 0 : resolvedHandle.dispose();
    }
  };
  Object.defineProperty(r, "toString", {
    value: () => compiled,
    enumerable: false
  });
  return r;
}
compile$1.compile = compile;
function quickJSHandleToHost(vm, val) {
  return vm.dump(val);
}
function hostToQuickJSHandle(vm, val) {
  if (typeof val === "undefined") {
    return vm.undefined;
  } else if (val === null) {
    return vm.null;
  } else if (typeof val === "string") {
    return vm.newString(val);
  } else if (typeof val === "number") {
    return vm.newNumber(val);
  } else if (typeof val === "bigint") {
    return vm.newBigInt(val);
  } else if (typeof val === "boolean") {
    return val ? vm.true : vm.false;
  } else if (util_1$4.types.isPromise(val)) {
    const promise2 = vm.newPromise();
    promise2.settled.then(vm.runtime.executePendingJobs);
    val.then((r) => {
      promise2.resolve(hostToQuickJSHandle(vm, r));
    }, (err) => {
      promise2.reject(hostToQuickJSHandle(vm, err));
    });
    return promise2.handle;
  } else if (util_1$4.types.isNativeError(val)) {
    return vm.newError(val);
  }
  throw new Error(`Unsupported value: ${val}`);
}
(function(exports) {
  var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    var desc2 = Object.getOwnPropertyDescriptor(m2, k);
    if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
      desc2 = { enumerable: true, get: function() {
        return m2[k];
      } };
    }
    Object.defineProperty(o, k2, desc2);
  } : function(o, m2, k, k2) {
    if (k2 === void 0) k2 = k;
    o[k2] = m2[k];
  });
  var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
    for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar2(degenerator$1, exports);
  __exportStar2(compile$1, exports);
})(dist$1);
var dateRange$1 = {};
Object.defineProperty(dateRange$1, "__esModule", { value: true });
function dateRange() {
  return false;
}
dateRange$1.default = dateRange;
var dnsDomainIs$1 = {};
Object.defineProperty(dnsDomainIs$1, "__esModule", { value: true });
function dnsDomainIs(host2, domain) {
  host2 = String(host2);
  domain = String(domain);
  return host2.substr(domain.length * -1) === domain;
}
dnsDomainIs$1.default = dnsDomainIs;
var dnsDomainLevels$1 = {};
Object.defineProperty(dnsDomainLevels$1, "__esModule", { value: true });
function dnsDomainLevels(host2) {
  const match2 = String(host2).match(/\./g);
  let levels = 0;
  if (match2) {
    levels = match2.length;
  }
  return levels;
}
dnsDomainLevels$1.default = dnsDomainLevels;
var dnsResolve$1 = {};
var util$2 = {};
Object.defineProperty(util$2, "__esModule", { value: true });
util$2.isGMT = util$2.dnsLookup = void 0;
const dns_1 = require$$3$4;
function dnsLookup(host2, opts) {
  return new Promise((resolve3, reject) => {
    (0, dns_1.lookup)(host2, opts, (err, res2) => {
      if (err) {
        reject(err);
      } else {
        resolve3(res2);
      }
    });
  });
}
util$2.dnsLookup = dnsLookup;
function isGMT(v) {
  return v === "GMT";
}
util$2.isGMT = isGMT;
Object.defineProperty(dnsResolve$1, "__esModule", { value: true });
const util_1$3 = util$2;
async function dnsResolve(host2) {
  const family = 4;
  try {
    const r = await (0, util_1$3.dnsLookup)(host2, { family });
    if (typeof r === "string") {
      return r;
    }
  } catch (err) {
  }
  return null;
}
dnsResolve$1.default = dnsResolve;
var isInNet$1 = {};
var netmask = {};
(function() {
  var Netmask, atob2, chr, chr0, chrA, chra, ip2long, long2ip;
  long2ip = function(long) {
    var a, b, c, d2;
    a = (long & 255 << 24) >>> 24;
    b = (long & 255 << 16) >>> 16;
    c = (long & 255 << 8) >>> 8;
    d2 = long & 255;
    return [a, b, c, d2].join(".");
  };
  ip2long = function(ip3) {
    var b, c, i, j2, n, ref2;
    b = [];
    for (i = j2 = 0; j2 <= 3; i = ++j2) {
      if (ip3.length === 0) {
        break;
      }
      if (i > 0) {
        if (ip3[0] !== ".") {
          throw new Error("Invalid IP");
        }
        ip3 = ip3.substring(1);
      }
      ref2 = atob2(ip3), n = ref2[0], c = ref2[1];
      ip3 = ip3.substring(c);
      b.push(n);
    }
    if (ip3.length !== 0) {
      throw new Error("Invalid IP");
    }
    switch (b.length) {
      case 1:
        if (b[0] > 4294967295) {
          throw new Error("Invalid IP");
        }
        return b[0] >>> 0;
      case 2:
        if (b[0] > 255 || b[1] > 16777215) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1]) >>> 0;
      case 3:
        if (b[0] > 255 || b[1] > 255 || b[2] > 65535) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1] << 16 | b[2]) >>> 0;
      case 4:
        if (b[0] > 255 || b[1] > 255 || b[2] > 255 || b[3] > 255) {
          throw new Error("Invalid IP");
        }
        return (b[0] << 24 | b[1] << 16 | b[2] << 8 | b[3]) >>> 0;
      default:
        throw new Error("Invalid IP");
    }
  };
  chr = function(b) {
    return b.charCodeAt(0);
  };
  chr0 = chr("0");
  chra = chr("a");
  chrA = chr("A");
  atob2 = function(s2) {
    var base, dmax, i, n, start;
    n = 0;
    base = 10;
    dmax = "9";
    i = 0;
    if (s2.length > 1 && s2[i] === "0") {
      if (s2[i + 1] === "x" || s2[i + 1] === "X") {
        i += 2;
        base = 16;
      } else if ("0" <= s2[i + 1] && s2[i + 1] <= "9") {
        i++;
        base = 8;
        dmax = "7";
      }
    }
    start = i;
    while (i < s2.length) {
      if ("0" <= s2[i] && s2[i] <= dmax) {
        n = n * base + (chr(s2[i]) - chr0) >>> 0;
      } else if (base === 16) {
        if ("a" <= s2[i] && s2[i] <= "f") {
          n = n * base + (10 + chr(s2[i]) - chra) >>> 0;
        } else if ("A" <= s2[i] && s2[i] <= "F") {
          n = n * base + (10 + chr(s2[i]) - chrA) >>> 0;
        } else {
          break;
        }
      } else {
        break;
      }
      if (n > 4294967295) {
        throw new Error("too large");
      }
      i++;
    }
    if (i === start) {
      throw new Error("empty octet");
    }
    return [n, i];
  };
  Netmask = function() {
    function Netmask2(net2, mask) {
      var i, j2, ref2;
      if (typeof net2 !== "string") {
        throw new Error("Missing `net' parameter");
      }
      if (!mask) {
        ref2 = net2.split("/", 2), net2 = ref2[0], mask = ref2[1];
      }
      if (!mask) {
        mask = 32;
      }
      if (typeof mask === "string" && mask.indexOf(".") > -1) {
        try {
          this.maskLong = ip2long(mask);
        } catch (error1) {
          throw new Error("Invalid mask: " + mask);
        }
        for (i = j2 = 32; j2 >= 0; i = --j2) {
          if (this.maskLong === 4294967295 << 32 - i >>> 0) {
            this.bitmask = i;
            break;
          }
        }
      } else if (mask || mask === 0) {
        this.bitmask = parseInt(mask, 10);
        this.maskLong = 0;
        if (this.bitmask > 0) {
          this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
        }
      } else {
        throw new Error("Invalid mask: empty");
      }
      try {
        this.netLong = (ip2long(net2) & this.maskLong) >>> 0;
      } catch (error1) {
        throw new Error("Invalid net address: " + net2);
      }
      if (!(this.bitmask <= 32)) {
        throw new Error("Invalid mask for ip4: " + mask);
      }
      this.size = Math.pow(2, 32 - this.bitmask);
      this.base = long2ip(this.netLong);
      this.mask = long2ip(this.maskLong);
      this.hostmask = long2ip(~this.maskLong);
      this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
      this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
      this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
    }
    Netmask2.prototype.contains = function(ip3) {
      if (typeof ip3 === "string" && (ip3.indexOf("/") > 0 || ip3.split(".").length !== 4)) {
        ip3 = new Netmask2(ip3);
      }
      if (ip3 instanceof Netmask2) {
        return this.contains(ip3.base) && this.contains(ip3.broadcast || ip3.last);
      } else {
        return (ip2long(ip3) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
      }
    };
    Netmask2.prototype.next = function(count) {
      if (count == null) {
        count = 1;
      }
      return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
    };
    Netmask2.prototype.forEach = function(fn) {
      var index2, lastLong, long;
      long = ip2long(this.first);
      lastLong = ip2long(this.last);
      index2 = 0;
      while (long <= lastLong) {
        fn(long2ip(long), long, index2);
        index2++;
        long++;
      }
    };
    Netmask2.prototype.toString = function() {
      return this.base + "/" + this.bitmask;
    };
    return Netmask2;
  }();
  netmask.ip2long = ip2long;
  netmask.long2ip = long2ip;
  netmask.Netmask = Netmask;
}).call(commonjsGlobal);
Object.defineProperty(isInNet$1, "__esModule", { value: true });
const netmask_1 = netmask;
const util_1$2 = util$2;
async function isInNet(host2, pattern, mask) {
  const family = 4;
  try {
    const ip3 = await (0, util_1$2.dnsLookup)(host2, { family });
    if (typeof ip3 === "string") {
      const netmask2 = new netmask_1.Netmask(pattern, mask);
      return netmask2.contains(ip3);
    }
  } catch (err) {
  }
  return false;
}
isInNet$1.default = isInNet;
var isPlainHostName$1 = {};
Object.defineProperty(isPlainHostName$1, "__esModule", { value: true });
function isPlainHostName(host2) {
  return !/\./.test(host2);
}
isPlainHostName$1.default = isPlainHostName;
var isResolvable$1 = {};
Object.defineProperty(isResolvable$1, "__esModule", { value: true });
const util_1$1 = util$2;
async function isResolvable(host2) {
  const family = 4;
  try {
    if (await (0, util_1$1.dnsLookup)(host2, { family })) {
      return true;
    }
  } catch (err) {
  }
  return false;
}
isResolvable$1.default = isResolvable;
var localHostOrDomainIs$1 = {};
Object.defineProperty(localHostOrDomainIs$1, "__esModule", { value: true });
function localHostOrDomainIs(host2, hostdom) {
  const parts = host2.split(".");
  const domparts = hostdom.split(".");
  let matches2 = true;
  for (let i = 0; i < parts.length; i++) {
    if (parts[i] !== domparts[i]) {
      matches2 = false;
      break;
    }
  }
  return matches2;
}
localHostOrDomainIs$1.default = localHostOrDomainIs;
var myIpAddress$1 = {};
var ip2 = {};
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ip = void 0;
  const os_1 = __importDefault2(require$$0$b);
  exports.ip = {
    address() {
      const interfaces = os_1.default.networkInterfaces();
      const family = normalizeFamily();
      const all3 = Object.values(interfaces).map((addrs = []) => {
        const addresses = addrs.filter((details) => {
          const detailsFamily = normalizeFamily(details.family);
          if (detailsFamily !== family || exports.ip.isLoopback(details.address)) {
            return false;
          }
          return true;
        });
        return addresses.length ? addresses[0].address : void 0;
      }).filter(Boolean);
      return !all3.length ? exports.ip.loopback(family) : all3[0];
    },
    isLoopback(addr) {
      return /^(::f{4}:)?127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})/.test(addr) || /^fe80::1$/.test(addr) || /^::1$/.test(addr) || /^::$/.test(addr);
    },
    loopback(family) {
      family = normalizeFamily(family);
      if (family !== "ipv4" && family !== "ipv6") {
        throw new Error("family must be ipv4 or ipv6");
      }
      return family === "ipv4" ? "127.0.0.1" : "fe80::1";
    }
  };
  function normalizeFamily(family) {
    if (family === 4) {
      return "ipv4";
    }
    if (family === 6) {
      return "ipv6";
    }
    return family ? family.toLowerCase() : "ipv4";
  }
})(ip2);
var __importDefault$1 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(myIpAddress$1, "__esModule", { value: true });
const ip_1 = ip2;
const net_1 = __importDefault$1(require$$0$6);
async function myIpAddress() {
  return new Promise((resolve3, reject) => {
    const socket = net_1.default.connect({ host: "8.8.8.8", port: 53 });
    const onError = () => {
      resolve3(ip_1.ip.address());
    };
    socket.once("error", onError);
    socket.once("connect", () => {
      socket.removeListener("error", onError);
      const addr = socket.address();
      socket.destroy();
      if (typeof addr === "string") {
        resolve3(addr);
      } else if (addr.address) {
        resolve3(addr.address);
      } else {
        reject(new Error("Expected a `string`"));
      }
    });
  });
}
myIpAddress$1.default = myIpAddress;
var shExpMatch$1 = {};
Object.defineProperty(shExpMatch$1, "__esModule", { value: true });
function shExpMatch(str2, shexp) {
  const re = toRegExp(shexp);
  return re.test(str2);
}
shExpMatch$1.default = shExpMatch;
function toRegExp(str2) {
  str2 = String(str2).replace(/\./g, "\\.").replace(/\?/g, ".").replace(/\*/g, ".*");
  return new RegExp(`^${str2}$`);
}
var timeRange$1 = {};
Object.defineProperty(timeRange$1, "__esModule", { value: true });
function timeRange() {
  const args = Array.prototype.slice.call(arguments);
  const lastArg = args.pop();
  const useGMTzone = lastArg === "GMT";
  const currentDate = /* @__PURE__ */ new Date();
  if (!useGMTzone) {
    args.push(lastArg);
  }
  let result = false;
  const noOfArgs = args.length;
  const numericArgs = args.map((n) => parseInt(n, 10));
  if (noOfArgs === 1) {
    result = getCurrentHour(useGMTzone, currentDate) === numericArgs[0];
  } else if (noOfArgs === 2) {
    const currentHour = getCurrentHour(useGMTzone, currentDate);
    result = numericArgs[0] <= currentHour && currentHour < numericArgs[1];
  } else if (noOfArgs === 4) {
    result = valueInRange$1(secondsElapsedToday(numericArgs[0], numericArgs[1], 0), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), 0), secondsElapsedToday(numericArgs[2], numericArgs[3], 59));
  } else if (noOfArgs === 6) {
    result = valueInRange$1(secondsElapsedToday(numericArgs[0], numericArgs[1], numericArgs[2]), secondsElapsedToday(getCurrentHour(useGMTzone, currentDate), getCurrentMinute(useGMTzone, currentDate), getCurrentSecond(useGMTzone, currentDate)), secondsElapsedToday(numericArgs[3], numericArgs[4], numericArgs[5]));
  }
  return result;
}
timeRange$1.default = timeRange;
function secondsElapsedToday(hh, mm, ss) {
  return hh * 3600 + mm * 60 + ss;
}
function getCurrentHour(gmt, currentDate) {
  return gmt ? currentDate.getUTCHours() : currentDate.getHours();
}
function getCurrentMinute(gmt, currentDate) {
  return gmt ? currentDate.getUTCMinutes() : currentDate.getMinutes();
}
function getCurrentSecond(gmt, currentDate) {
  return gmt ? currentDate.getUTCSeconds() : currentDate.getSeconds();
}
function valueInRange$1(start, value2, finish) {
  return start <= value2 && value2 <= finish;
}
var weekdayRange$1 = {};
Object.defineProperty(weekdayRange$1, "__esModule", { value: true });
const util_1 = util$2;
const weekdays = ["SUN", "MON", "TUE", "WED", "THU", "FRI", "SAT"];
function weekdayRange(wd1, wd2, gmt) {
  let useGMTzone = false;
  let wd1Index = -1;
  let wd2Index = -1;
  let wd2IsGmt = false;
  if ((0, util_1.isGMT)(gmt)) {
    useGMTzone = true;
  } else if ((0, util_1.isGMT)(wd2)) {
    useGMTzone = true;
    wd2IsGmt = true;
  }
  wd1Index = weekdays.indexOf(wd1);
  if (!wd2IsGmt && isWeekday(wd2)) {
    wd2Index = weekdays.indexOf(wd2);
  }
  const todaysDay = getTodaysDay(useGMTzone);
  let result;
  if (wd2Index < 0) {
    result = todaysDay === wd1Index;
  } else if (wd1Index <= wd2Index) {
    result = valueInRange(wd1Index, todaysDay, wd2Index);
  } else {
    result = valueInRange(wd1Index, todaysDay, 6) || valueInRange(0, todaysDay, wd2Index);
  }
  return result;
}
weekdayRange$1.default = weekdayRange;
function getTodaysDay(gmt) {
  return gmt ? (/* @__PURE__ */ new Date()).getUTCDay() : (/* @__PURE__ */ new Date()).getDay();
}
function valueInRange(start, value2, finish) {
  return start <= value2 && value2 <= finish;
}
function isWeekday(v) {
  if (!v)
    return false;
  return weekdays.includes(v);
}
(function(exports) {
  var __importDefault2 = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.sandbox = exports.createPacResolver = void 0;
  const degenerator_12 = dist$1;
  const dateRange_1 = __importDefault2(dateRange$1);
  const dnsDomainIs_1 = __importDefault2(dnsDomainIs$1);
  const dnsDomainLevels_1 = __importDefault2(dnsDomainLevels$1);
  const dnsResolve_1 = __importDefault2(dnsResolve$1);
  const isInNet_1 = __importDefault2(isInNet$1);
  const isPlainHostName_1 = __importDefault2(isPlainHostName$1);
  const isResolvable_1 = __importDefault2(isResolvable$1);
  const localHostOrDomainIs_1 = __importDefault2(localHostOrDomainIs$1);
  const myIpAddress_1 = __importDefault2(myIpAddress$1);
  const shExpMatch_1 = __importDefault2(shExpMatch$1);
  const timeRange_1 = __importDefault2(timeRange$1);
  const weekdayRange_1 = __importDefault2(weekdayRange$1);
  function createPacResolver(qjs, _str, _opts = {}) {
    const str2 = Buffer.isBuffer(_str) ? _str.toString("utf8") : _str;
    const context2 = {
      ...exports.sandbox,
      ..._opts.sandbox
    };
    const names = Object.keys(context2).filter((k) => isAsyncFunction(context2[k]));
    const opts = {
      filename: "proxy.pac",
      names,
      ..._opts,
      sandbox: context2
    };
    const resolver = (0, degenerator_12.compile)(qjs, str2, "FindProxyForURL", opts);
    function FindProxyForURL(url2, _host) {
      const urlObj = typeof url2 === "string" ? new URL(url2) : url2;
      const host2 = _host || urlObj.hostname;
      if (!host2) {
        throw new TypeError("Could not determine `host`");
      }
      return resolver(urlObj.href, host2);
    }
    Object.defineProperty(FindProxyForURL, "toString", {
      value: () => resolver.toString(),
      enumerable: false
    });
    return FindProxyForURL;
  }
  exports.createPacResolver = createPacResolver;
  exports.sandbox = Object.freeze({
    alert: (message = "") => console.log("%s", message),
    dateRange: dateRange_1.default,
    dnsDomainIs: dnsDomainIs_1.default,
    dnsDomainLevels: dnsDomainLevels_1.default,
    dnsResolve: dnsResolve_1.default,
    isInNet: isInNet_1.default,
    isPlainHostName: isPlainHostName_1.default,
    isResolvable: isResolvable_1.default,
    localHostOrDomainIs: localHostOrDomainIs_1.default,
    myIpAddress: myIpAddress_1.default,
    shExpMatch: shExpMatch_1.default,
    timeRange: timeRange_1.default,
    weekdayRange: weekdayRange_1.default
  });
  function isAsyncFunction(v) {
    if (typeof v !== "function")
      return false;
    if (v.constructor.name === "AsyncFunction")
      return true;
    if (String(v).indexOf("__awaiter(") !== -1)
      return true;
    return Boolean(v.async);
  }
})(dist$2);
var dist = {};
var variants = {};
var esmHelpers = {};
Object.defineProperty(esmHelpers, "__esModule", { value: true });
esmHelpers.unwrapJavascript = esmHelpers.unwrapTypescript = void 0;
function fakeUnwrapDefault(mod) {
  return mod.default;
}
function actualUnwrapDefault(mod) {
  const maybeUnwrap = mod.default;
  return maybeUnwrap ?? mod;
}
esmHelpers.unwrapTypescript = actualUnwrapDefault;
esmHelpers.unwrapJavascript = fakeUnwrapDefault;
var module = {};
var debug$2 = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.debugLog = exports.QTS_DEBUG = void 0;
  exports.QTS_DEBUG = Boolean(typeof process === "object" && process.env.QTS_DEBUG);
  exports.debugLog = exports.QTS_DEBUG ? console.log.bind(console) : () => {
  };
})(debug$2);
var errors = {};
Object.defineProperty(errors, "__esModule", { value: true });
errors.QuickJSMemoryLeakDetected = errors.QuickJSAsyncifySuspended = errors.QuickJSAsyncifyError = errors.QuickJSNotImplemented = errors.QuickJSUseAfterFree = errors.QuickJSWrongOwner = errors.QuickJSUnwrapError = void 0;
class QuickJSUnwrapError extends Error {
  constructor(cause, context2) {
    super(String(cause));
    this.cause = cause;
    this.context = context2;
    this.name = "QuickJSUnwrapError";
  }
}
errors.QuickJSUnwrapError = QuickJSUnwrapError;
class QuickJSWrongOwner extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSWrongOwner";
  }
}
errors.QuickJSWrongOwner = QuickJSWrongOwner;
class QuickJSUseAfterFree extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSUseAfterFree";
  }
}
errors.QuickJSUseAfterFree = QuickJSUseAfterFree;
class QuickJSNotImplemented extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSNotImplemented";
  }
}
errors.QuickJSNotImplemented = QuickJSNotImplemented;
class QuickJSAsyncifyError extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSAsyncifyError";
  }
}
errors.QuickJSAsyncifyError = QuickJSAsyncifyError;
class QuickJSAsyncifySuspended extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSAsyncifySuspended";
  }
}
errors.QuickJSAsyncifySuspended = QuickJSAsyncifySuspended;
class QuickJSMemoryLeakDetected extends Error {
  constructor() {
    super(...arguments);
    this.name = "QuickJSMemoryLeakDetected";
  }
}
errors.QuickJSMemoryLeakDetected = QuickJSMemoryLeakDetected;
var lifetime = {};
var asyncifyHelpers = {};
Object.defineProperty(asyncifyHelpers, "__esModule", { value: true });
asyncifyHelpers.awaitEachYieldedPromise = asyncifyHelpers.maybeAsync = asyncifyHelpers.maybeAsyncFn = void 0;
function* awaitYield(value2) {
  return yield value2;
}
function awaitYieldOf(generator) {
  return awaitYield(awaitEachYieldedPromise(generator));
}
const AwaitYield = awaitYield;
AwaitYield.of = awaitYieldOf;
function maybeAsyncFn(that, fn) {
  return (...args) => {
    const generator = fn.call(that, AwaitYield, ...args);
    return awaitEachYieldedPromise(generator);
  };
}
asyncifyHelpers.maybeAsyncFn = maybeAsyncFn;
function maybeAsync(that, startGenerator) {
  const generator = startGenerator.call(that, AwaitYield);
  return awaitEachYieldedPromise(generator);
}
asyncifyHelpers.maybeAsync = maybeAsync;
function awaitEachYieldedPromise(gen) {
  function handleNextStep(step) {
    if (step.done) {
      return step.value;
    }
    if (step.value instanceof Promise) {
      return step.value.then((value2) => handleNextStep(gen.next(value2)), (error2) => handleNextStep(gen.throw(error2)));
    }
    return handleNextStep(gen.next(step.value));
  }
  return handleNextStep(gen.next());
}
asyncifyHelpers.awaitEachYieldedPromise = awaitEachYieldedPromise;
Object.defineProperty(lifetime, "__esModule", { value: true });
lifetime.Scope = lifetime.WeakLifetime = lifetime.StaticLifetime = lifetime.Lifetime = void 0;
const asyncify_helpers_1 = asyncifyHelpers;
const debug_1$1 = debug$2;
const errors_1$1 = errors;
class Lifetime {
  /**
   * When the Lifetime is disposed, it will call `disposer(_value)`. Use the
   * disposer function to implement whatever cleanup needs to happen at the end
   * of `value`'s lifetime.
   *
   * `_owner` is not used or controlled by the lifetime. It's just metadata for
   * the creator.
   */
  constructor(_value, copier, disposer, _owner) {
    this._value = _value;
    this.copier = copier;
    this.disposer = disposer;
    this._owner = _owner;
    this._alive = true;
    this._constructorStack = debug_1$1.QTS_DEBUG ? new Error("Lifetime constructed").stack : void 0;
  }
  get alive() {
    return this._alive;
  }
  /**
   * The value this Lifetime protects. You must never retain the value - it
   * may become invalid, leading to memory errors.
   *
   * @throws If the lifetime has been [[dispose]]d already.
   */
  get value() {
    this.assertAlive();
    return this._value;
  }
  get owner() {
    return this._owner;
  }
  get dupable() {
    return !!this.copier;
  }
  /**
   * Create a new handle pointing to the same [[value]].
   */
  dup() {
    this.assertAlive();
    if (!this.copier) {
      throw new Error("Non-dupable lifetime");
    }
    return new Lifetime(this.copier(this._value), this.copier, this.disposer, this._owner);
  }
  consume(map2) {
    this.assertAlive();
    const result = map2(this);
    this.dispose();
    return result;
  }
  /**
   * Dispose of [[value]] and perform cleanup.
   */
  dispose() {
    this.assertAlive();
    if (this.disposer) {
      this.disposer(this._value);
    }
    this._alive = false;
  }
  assertAlive() {
    if (!this.alive) {
      if (this._constructorStack) {
        throw new errors_1$1.QuickJSUseAfterFree(`Lifetime not alive
${this._constructorStack}
Lifetime used`);
      }
      throw new errors_1$1.QuickJSUseAfterFree("Lifetime not alive");
    }
  }
}
lifetime.Lifetime = Lifetime;
class StaticLifetime extends Lifetime {
  constructor(value2, owner) {
    super(value2, void 0, void 0, owner);
  }
  // Static lifetime doesn't need a copier to be copiable
  get dupable() {
    return true;
  }
  // Copy returns the same instance.
  dup() {
    return this;
  }
  // Dispose does nothing.
  dispose() {
  }
}
lifetime.StaticLifetime = StaticLifetime;
class WeakLifetime extends Lifetime {
  constructor(value2, copier, disposer, owner) {
    super(value2, copier, disposer, owner);
  }
  dispose() {
    this._alive = false;
  }
}
lifetime.WeakLifetime = WeakLifetime;
function scopeFinally(scope2, blockError) {
  let disposeError;
  try {
    scope2.dispose();
  } catch (error2) {
    disposeError = error2;
  }
  if (blockError && disposeError) {
    Object.assign(blockError, {
      message: `${blockError.message}
 Then, failed to dispose scope: ${disposeError.message}`,
      disposeError
    });
    throw blockError;
  }
  if (blockError || disposeError) {
    throw blockError || disposeError;
  }
}
class Scope {
  constructor() {
    this._disposables = new Lifetime(/* @__PURE__ */ new Set());
  }
  /**
   * Run `block` with a new Scope instance that will be disposed after the block returns.
   * Inside `block`, call `scope.manage` on each lifetime you create to have the lifetime
   * automatically disposed after the block returns.
   *
   * @warning Do not use with async functions. Instead, use [[withScopeAsync]].
   */
  static withScope(block) {
    const scope2 = new Scope();
    let blockError;
    try {
      return block(scope2);
    } catch (error2) {
      blockError = error2;
      throw error2;
    } finally {
      scopeFinally(scope2, blockError);
    }
  }
  static withScopeMaybeAsync(_this, block) {
    return (0, asyncify_helpers_1.maybeAsync)(void 0, function* (awaited) {
      const scope2 = new Scope();
      let blockError;
      try {
        return yield* awaited.of(block.call(_this, awaited, scope2));
      } catch (error2) {
        blockError = error2;
        throw error2;
      } finally {
        scopeFinally(scope2, blockError);
      }
    });
  }
  /**
   * Run `block` with a new Scope instance that will be disposed after the
   * block's returned promise settles. Inside `block`, call `scope.manage` on each
   * lifetime you create to have the lifetime automatically disposed after the
   * block returns.
   */
  static async withScopeAsync(block) {
    const scope2 = new Scope();
    let blockError;
    try {
      return await block(scope2);
    } catch (error2) {
      blockError = error2;
      throw error2;
    } finally {
      scopeFinally(scope2, blockError);
    }
  }
  /**
   * Track `lifetime` so that it is disposed when this scope is disposed.
   */
  manage(lifetime2) {
    this._disposables.value.add(lifetime2);
    return lifetime2;
  }
  get alive() {
    return this._disposables.alive;
  }
  dispose() {
    const lifetimes = Array.from(this._disposables.value.values()).reverse();
    for (const lifetime2 of lifetimes) {
      if (lifetime2.alive) {
        lifetime2.dispose();
      }
    }
    this._disposables.dispose();
  }
}
lifetime.Scope = Scope;
var runtime = {};
var context = {};
var deferredPromise = {};
Object.defineProperty(deferredPromise, "__esModule", { value: true });
deferredPromise.QuickJSDeferredPromise = void 0;
class QuickJSDeferredPromise {
  /**
   * Use [[QuickJSContext.newPromise]] to create a new promise instead of calling
   * this constructor directly.
   * @unstable
   */
  constructor(args) {
    this.resolve = (value2) => {
      if (!this.resolveHandle.alive) {
        return;
      }
      this.context.unwrapResult(this.context.callFunction(this.resolveHandle, this.context.undefined, value2 || this.context.undefined)).dispose();
      this.disposeResolvers();
      this.onSettled();
    };
    this.reject = (value2) => {
      if (!this.rejectHandle.alive) {
        return;
      }
      this.context.unwrapResult(this.context.callFunction(this.rejectHandle, this.context.undefined, value2 || this.context.undefined)).dispose();
      this.disposeResolvers();
      this.onSettled();
    };
    this.dispose = () => {
      if (this.handle.alive) {
        this.handle.dispose();
      }
      this.disposeResolvers();
    };
    this.context = args.context;
    this.owner = args.context.runtime;
    this.handle = args.promiseHandle;
    this.settled = new Promise((resolve3) => {
      this.onSettled = resolve3;
    });
    this.resolveHandle = args.resolveHandle;
    this.rejectHandle = args.rejectHandle;
  }
  get alive() {
    return this.handle.alive || this.resolveHandle.alive || this.rejectHandle.alive;
  }
  disposeResolvers() {
    if (this.resolveHandle.alive) {
      this.resolveHandle.dispose();
    }
    if (this.rejectHandle.alive) {
      this.rejectHandle.dispose();
    }
  }
}
deferredPromise.QuickJSDeferredPromise = QuickJSDeferredPromise;
var memory = {};
var hasRequiredMemory;
function requireMemory() {
  if (hasRequiredMemory) return memory;
  hasRequiredMemory = 1;
  Object.defineProperty(memory, "__esModule", { value: true });
  memory.ModuleMemory = void 0;
  const lifetime_12 = lifetime;
  class ModuleMemory {
    constructor(module2) {
      this.module = module2;
    }
    toPointerArray(handleArray) {
      const typedArray = new Int32Array(handleArray.map((handle3) => handle3.value));
      const numBytes = typedArray.length * typedArray.BYTES_PER_ELEMENT;
      const ptr = this.module._malloc(numBytes);
      var heapBytes = new Uint8Array(this.module.HEAPU8.buffer, ptr, numBytes);
      heapBytes.set(new Uint8Array(typedArray.buffer));
      return new lifetime_12.Lifetime(ptr, void 0, (ptr2) => this.module._free(ptr2));
    }
    newMutablePointerArray(length) {
      const zeros = new Int32Array(new Array(length).fill(0));
      const numBytes = zeros.length * zeros.BYTES_PER_ELEMENT;
      const ptr = this.module._malloc(numBytes);
      const typedArray = new Int32Array(this.module.HEAPU8.buffer, ptr, length);
      typedArray.set(zeros);
      return new lifetime_12.Lifetime({ typedArray, ptr }, void 0, (value2) => this.module._free(value2.ptr));
    }
    newHeapCharPointer(string2) {
      const numBytes = this.module.lengthBytesUTF8(string2) + 1;
      const ptr = this.module._malloc(numBytes);
      this.module.stringToUTF8(string2, ptr, numBytes);
      return new lifetime_12.Lifetime(ptr, void 0, (value2) => this.module._free(value2));
    }
    consumeHeapCharPointer(ptr) {
      const str2 = this.module.UTF8ToString(ptr);
      this.module._free(ptr);
      return str2;
    }
  }
  memory.ModuleMemory = ModuleMemory;
  return memory;
}
var types$1 = {};
var typesFfi = {};
var hasRequiredTypesFfi;
function requireTypesFfi() {
  if (hasRequiredTypesFfi) return typesFfi;
  hasRequiredTypesFfi = 1;
  Object.defineProperty(typesFfi, "__esModule", { value: true });
  typesFfi.EvalFlags = typesFfi.assertSync = void 0;
  function assertSync(fn) {
    return function mustBeSync(...args) {
      const result = fn(...args);
      if (result && typeof result === "object" && result instanceof Promise) {
        throw new Error("Function unexpectedly returned a Promise");
      }
      return result;
    };
  }
  typesFfi.assertSync = assertSync;
  typesFfi.EvalFlags = {
    /** global code (default) */
    JS_EVAL_TYPE_GLOBAL: 0 << 0,
    /** module code */
    JS_EVAL_TYPE_MODULE: 1 << 0,
    /** direct call (internal use) */
    JS_EVAL_TYPE_DIRECT: 2 << 0,
    /** indirect call (internal use) */
    JS_EVAL_TYPE_INDIRECT: 3 << 0,
    JS_EVAL_TYPE_MASK: 3 << 0,
    /** force 'strict' mode */
    JS_EVAL_FLAG_STRICT: 1 << 3,
    /** force 'strip' mode */
    JS_EVAL_FLAG_STRIP: 1 << 4,
    /**
     * compile but do not run. The result is an object with a
     * JS_TAG_FUNCTION_BYTECODE or JS_TAG_MODULE tag. It can be executed
     * with JS_EvalFunction().
     */
    JS_EVAL_FLAG_COMPILE_ONLY: 1 << 5,
    /** don't include the stack frames before this eval in the Error() backtraces */
    JS_EVAL_FLAG_BACKTRACE_BARRIER: 1 << 6
  };
  return typesFfi;
}
var hasRequiredTypes;
function requireTypes() {
  if (hasRequiredTypes) return types$1;
  hasRequiredTypes = 1;
  Object.defineProperty(types$1, "__esModule", { value: true });
  types$1.concat = types$1.evalOptionsToFlags = types$1.DefaultIntrinsics = void 0;
  const types_ffi_1 = requireTypesFfi();
  types$1.DefaultIntrinsics = Symbol("DefaultIntrinsics");
  function evalOptionsToFlags(evalOptions) {
    if (typeof evalOptions === "number") {
      return evalOptions;
    }
    if (evalOptions === void 0) {
      return 0;
    }
    const { type: type3, strict, strip: strip2, compileOnly, backtraceBarrier } = evalOptions;
    let flags = 0;
    if (type3 === "global")
      flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_GLOBAL;
    if (type3 === "module")
      flags |= types_ffi_1.EvalFlags.JS_EVAL_TYPE_MODULE;
    if (strict)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRICT;
    if (strip2)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_STRIP;
    if (compileOnly)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_COMPILE_ONLY;
    if (backtraceBarrier)
      flags |= types_ffi_1.EvalFlags.JS_EVAL_FLAG_BACKTRACE_BARRIER;
    return flags;
  }
  types$1.evalOptionsToFlags = evalOptionsToFlags;
  function concat(...values) {
    let result = [];
    for (const value2 of values) {
      if (value2 !== void 0) {
        result = result.concat(value2);
      }
    }
    return result;
  }
  types$1.concat = concat;
  return types$1;
}
var hasRequiredContext;
function requireContext() {
  if (hasRequiredContext) return context;
  hasRequiredContext = 1;
  Object.defineProperty(context, "__esModule", { value: true });
  context.QuickJSContext = void 0;
  const debug_12 = debug$2;
  const deferred_promise_1 = deferredPromise;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const memory_1 = requireMemory();
  const types_1 = requireTypes();
  class ContextMemory extends memory_1.ModuleMemory {
    /** @private */
    constructor(args) {
      var _a;
      super(args.module);
      this.scope = new lifetime_12.Scope();
      this.copyJSValue = (ptr) => {
        return this.ffi.QTS_DupValuePointer(this.ctx.value, ptr);
      };
      this.freeJSValue = (ptr) => {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, ptr);
      };
      (_a = args.ownedLifetimes) == null ? void 0 : _a.forEach((lifetime2) => this.scope.manage(lifetime2));
      this.owner = args.owner;
      this.module = args.module;
      this.ffi = args.ffi;
      this.rt = args.rt;
      this.ctx = this.scope.manage(args.ctx);
    }
    get alive() {
      return this.scope.alive;
    }
    dispose() {
      return this.scope.dispose();
    }
    /**
     * Track `lifetime` so that it is disposed when this scope is disposed.
     */
    manage(lifetime2) {
      return this.scope.manage(lifetime2);
    }
    consumeJSCharPointer(ptr) {
      const str2 = this.module.UTF8ToString(ptr);
      this.ffi.QTS_FreeCString(this.ctx.value, ptr);
      return str2;
    }
    heapValueHandle(ptr) {
      return new lifetime_12.Lifetime(ptr, this.copyJSValue, this.freeJSValue, this.owner);
    }
  }
  class QuickJSContext {
    /**
     * Use {@link QuickJS.createVm} to create a QuickJSContext instance.
     */
    constructor(args) {
      this._undefined = void 0;
      this._null = void 0;
      this._false = void 0;
      this._true = void 0;
      this._global = void 0;
      this._BigInt = void 0;
      this.fnNextId = -32768;
      this.fnMaps = /* @__PURE__ */ new Map();
      this.cToHostCallbacks = {
        callFunction: (ctx, this_ptr, argc, argv, fn_id) => {
          if (ctx !== this.ctx.value) {
            throw new Error("QuickJSContext instance received C -> JS call with mismatched ctx");
          }
          const fn = this.getFunction(fn_id);
          if (!fn) {
            throw new Error(`QuickJSContext had no callback with id ${fn_id}`);
          }
          return lifetime_12.Scope.withScopeMaybeAsync(this, function* (awaited, scope2) {
            const thisHandle = scope2.manage(new lifetime_12.WeakLifetime(this_ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
            const argHandles = new Array(argc);
            for (let i = 0; i < argc; i++) {
              const ptr = this.ffi.QTS_ArgvGetJSValueConstPointer(argv, i);
              argHandles[i] = scope2.manage(new lifetime_12.WeakLifetime(ptr, this.memory.copyJSValue, this.memory.freeJSValue, this.runtime));
            }
            try {
              const result = yield* awaited(fn.apply(thisHandle, argHandles));
              if (result) {
                if ("error" in result && result.error) {
                  (0, debug_12.debugLog)("throw error", result.error);
                  throw result.error;
                }
                const handle3 = scope2.manage(result instanceof lifetime_12.Lifetime ? result : result.value);
                return this.ffi.QTS_DupValuePointer(this.ctx.value, handle3.value);
              }
              return 0;
            } catch (error2) {
              return this.errorToHandle(error2).consume((errorHandle) => this.ffi.QTS_Throw(this.ctx.value, errorHandle.value));
            }
          });
        }
      };
      this.runtime = args.runtime;
      this.module = args.module;
      this.ffi = args.ffi;
      this.rt = args.rt;
      this.ctx = args.ctx;
      this.memory = new ContextMemory({
        ...args,
        owner: this.runtime
      });
      args.callbacks.setContextCallbacks(this.ctx.value, this.cToHostCallbacks);
      this.dump = this.dump.bind(this);
      this.getString = this.getString.bind(this);
      this.getNumber = this.getNumber.bind(this);
      this.resolvePromise = this.resolvePromise.bind(this);
    }
    // @implement Disposable ----------------------------------------------------
    get alive() {
      return this.memory.alive;
    }
    /**
     * Dispose of this VM's underlying resources.
     *
     * @throws Calling this method without disposing of all created handles
     * will result in an error.
     */
    dispose() {
      this.memory.dispose();
    }
    // Globals ------------------------------------------------------------------
    /**
     * [`undefined`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/undefined).
     */
    get undefined() {
      if (this._undefined) {
        return this._undefined;
      }
      const ptr = this.ffi.QTS_GetUndefined();
      return this._undefined = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`null`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/null).
     */
    get null() {
      if (this._null) {
        return this._null;
      }
      const ptr = this.ffi.QTS_GetNull();
      return this._null = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`true`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/true).
     */
    get true() {
      if (this._true) {
        return this._true;
      }
      const ptr = this.ffi.QTS_GetTrue();
      return this._true = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`false`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/false).
     */
    get false() {
      if (this._false) {
        return this._false;
      }
      const ptr = this.ffi.QTS_GetFalse();
      return this._false = new lifetime_12.StaticLifetime(ptr);
    }
    /**
     * [`global`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects).
     * A handle to the global object inside the interpreter.
     * You can set properties to create global variables.
     */
    get global() {
      if (this._global) {
        return this._global;
      }
      const ptr = this.ffi.QTS_GetGlobalObject(this.ctx.value);
      this.memory.manage(this.memory.heapValueHandle(ptr));
      this._global = new lifetime_12.StaticLifetime(ptr, this.runtime);
      return this._global;
    }
    // New values ---------------------------------------------------------------
    /**
     * Converts a Javascript number into a QuickJS value.
     */
    newNumber(num) {
      return this.memory.heapValueHandle(this.ffi.QTS_NewFloat64(this.ctx.value, num));
    }
    /**
     * Create a QuickJS [string](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String) value.
     */
    newString(str2) {
      const ptr = this.memory.newHeapCharPointer(str2).consume((charHandle) => this.ffi.QTS_NewString(this.ctx.value, charHandle.value));
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * Create a QuickJS [symbol](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol) value.
     * No two symbols created with this function will be the same value.
     */
    newUniqueSymbol(description2) {
      const key = (typeof description2 === "symbol" ? description2.description : description2) ?? "";
      const ptr = this.memory.newHeapCharPointer(key).consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 0));
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * Get a symbol from the [global registry](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol#shared_symbols_in_the_global_symbol_registry) for the given key.
     * All symbols created with the same key will be the same value.
     */
    newSymbolFor(key) {
      const description2 = (typeof key === "symbol" ? key.description : key) ?? "";
      const ptr = this.memory.newHeapCharPointer(description2).consume((charHandle) => this.ffi.QTS_NewSymbol(this.ctx.value, charHandle.value, 1));
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * Create a QuickJS [bigint](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/BigInt) value.
     */
    newBigInt(num) {
      if (!this._BigInt) {
        const bigIntHandle2 = this.getProp(this.global, "BigInt");
        this.memory.manage(bigIntHandle2);
        this._BigInt = new lifetime_12.StaticLifetime(bigIntHandle2.value, this.runtime);
      }
      const bigIntHandle = this._BigInt;
      const asString = String(num);
      return this.newString(asString).consume((handle3) => this.unwrapResult(this.callFunction(bigIntHandle, this.undefined, handle3)));
    }
    /**
     * `{}`.
     * Create a new QuickJS [object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer).
     *
     * @param prototype - Like [`Object.create`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/create).
     */
    newObject(prototype2) {
      if (prototype2) {
        this.runtime.assertOwned(prototype2);
      }
      const ptr = prototype2 ? this.ffi.QTS_NewObjectProto(this.ctx.value, prototype2.value) : this.ffi.QTS_NewObject(this.ctx.value);
      return this.memory.heapValueHandle(ptr);
    }
    /**
     * `[]`.
     * Create a new QuickJS [array](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array).
     */
    newArray() {
      const ptr = this.ffi.QTS_NewArray(this.ctx.value);
      return this.memory.heapValueHandle(ptr);
    }
    newPromise(value2) {
      const deferredPromise2 = lifetime_12.Scope.withScope((scope2) => {
        const mutablePointerArray = scope2.manage(this.memory.newMutablePointerArray(2));
        const promisePtr = this.ffi.QTS_NewPromiseCapability(this.ctx.value, mutablePointerArray.value.ptr);
        const promiseHandle = this.memory.heapValueHandle(promisePtr);
        const [resolveHandle, rejectHandle] = Array.from(mutablePointerArray.value.typedArray).map((jsvaluePtr) => this.memory.heapValueHandle(jsvaluePtr));
        return new deferred_promise_1.QuickJSDeferredPromise({
          context: this,
          promiseHandle,
          resolveHandle,
          rejectHandle
        });
      });
      if (value2 && typeof value2 === "function") {
        value2 = new Promise(value2);
      }
      if (value2) {
        Promise.resolve(value2).then(deferredPromise2.resolve, (error2) => error2 instanceof lifetime_12.Lifetime ? deferredPromise2.reject(error2) : this.newError(error2).consume(deferredPromise2.reject));
      }
      return deferredPromise2;
    }
    /**
     * Convert a Javascript function into a QuickJS function value.
     * See [[VmFunctionImplementation]] for more details.
     *
     * A [[VmFunctionImplementation]] should not free its arguments or its return
     * value. A VmFunctionImplementation should also not retain any references to
     * its return value.
     *
     * To implement an async function, create a promise with [[newPromise]], then
     * return the deferred promise handle from `deferred.handle` from your
     * function implementation:
     *
     * ```
     * const deferred = vm.newPromise()
     * someNativeAsyncFunction().then(deferred.resolve)
     * return deferred.handle
     * ```
     */
    newFunction(name2, fn) {
      const fnId = ++this.fnNextId;
      this.setFunction(fnId, fn);
      return this.memory.heapValueHandle(this.ffi.QTS_NewFunction(this.ctx.value, fnId, name2));
    }
    newError(error2) {
      const errorHandle = this.memory.heapValueHandle(this.ffi.QTS_NewError(this.ctx.value));
      if (error2 && typeof error2 === "object") {
        if (error2.name !== void 0) {
          this.newString(error2.name).consume((handle3) => this.setProp(errorHandle, "name", handle3));
        }
        if (error2.message !== void 0) {
          this.newString(error2.message).consume((handle3) => this.setProp(errorHandle, "message", handle3));
        }
      } else if (typeof error2 === "string") {
        this.newString(error2).consume((handle3) => this.setProp(errorHandle, "message", handle3));
      } else if (error2 !== void 0) {
        this.newString(String(error2)).consume((handle3) => this.setProp(errorHandle, "message", handle3));
      }
      return errorHandle;
    }
    // Read values --------------------------------------------------------------
    /**
     * `typeof` operator. **Not** [standards compliant](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof).
     *
     * @remarks
     * Does not support BigInt values correctly.
     */
    typeof(handle3) {
      this.runtime.assertOwned(handle3);
      return this.memory.consumeHeapCharPointer(this.ffi.QTS_Typeof(this.ctx.value, handle3.value));
    }
    /**
     * Converts `handle` into a Javascript number.
     * @returns `NaN` on error, otherwise a `number`.
     */
    getNumber(handle3) {
      this.runtime.assertOwned(handle3);
      return this.ffi.QTS_GetFloat64(this.ctx.value, handle3.value);
    }
    /**
     * Converts `handle` to a Javascript string.
     */
    getString(handle3) {
      this.runtime.assertOwned(handle3);
      return this.memory.consumeJSCharPointer(this.ffi.QTS_GetString(this.ctx.value, handle3.value));
    }
    /**
     * Converts `handle` into a Javascript symbol. If the symbol is in the global
     * registry in the guest, it will be created with Symbol.for on the host.
     */
    getSymbol(handle3) {
      this.runtime.assertOwned(handle3);
      const key = this.memory.consumeJSCharPointer(this.ffi.QTS_GetSymbolDescriptionOrKey(this.ctx.value, handle3.value));
      const isGlobal = this.ffi.QTS_IsGlobalSymbol(this.ctx.value, handle3.value);
      return isGlobal ? Symbol.for(key) : Symbol(key);
    }
    /**
     * Converts `handle` to a Javascript bigint.
     */
    getBigInt(handle3) {
      this.runtime.assertOwned(handle3);
      const asString = this.getString(handle3);
      return BigInt(asString);
    }
    /**
     * `Promise.resolve(value)`.
     * Convert a handle containing a Promise-like value inside the VM into an
     * actual promise on the host.
     *
     * @remarks
     * You may need to call [[executePendingJobs]] to ensure that the promise is resolved.
     *
     * @param promiseLikeHandle - A handle to a Promise-like value with a `.then(onSuccess, onError)` method.
     */
    resolvePromise(promiseLikeHandle) {
      this.runtime.assertOwned(promiseLikeHandle);
      const vmResolveResult = lifetime_12.Scope.withScope((scope2) => {
        const vmPromise = scope2.manage(this.getProp(this.global, "Promise"));
        const vmPromiseResolve = scope2.manage(this.getProp(vmPromise, "resolve"));
        return this.callFunction(vmPromiseResolve, vmPromise, promiseLikeHandle);
      });
      if (vmResolveResult.error) {
        return Promise.resolve(vmResolveResult);
      }
      return new Promise((resolve3) => {
        lifetime_12.Scope.withScope((scope2) => {
          const resolveHandle = scope2.manage(this.newFunction("resolve", (value2) => {
            resolve3({ value: value2 && value2.dup() });
          }));
          const rejectHandle = scope2.manage(this.newFunction("reject", (error2) => {
            resolve3({ error: error2 && error2.dup() });
          }));
          const promiseHandle = scope2.manage(vmResolveResult.value);
          const promiseThenHandle = scope2.manage(this.getProp(promiseHandle, "then"));
          this.unwrapResult(this.callFunction(promiseThenHandle, promiseHandle, resolveHandle, rejectHandle)).dispose();
        });
      });
    }
    // Properties ---------------------------------------------------------------
    /**
     * `handle[key]`.
     * Get a property from a JSValue.
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string (which will be converted automatically).
     */
    getProp(handle3, key) {
      this.runtime.assertOwned(handle3);
      const ptr = this.borrowPropertyKey(key).consume((quickJSKey) => this.ffi.QTS_GetProp(this.ctx.value, handle3.value, quickJSKey.value));
      const result = this.memory.heapValueHandle(ptr);
      return result;
    }
    /**
     * `handle[key] = value`.
     * Set a property on a JSValue.
     *
     * @remarks
     * Note that the QuickJS authors recommend using [[defineProp]] to define new
     * properties.
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string or number (which will be converted automatically to a JSValue).
     */
    setProp(handle3, key, value2) {
      this.runtime.assertOwned(handle3);
      this.borrowPropertyKey(key).consume((quickJSKey) => this.ffi.QTS_SetProp(this.ctx.value, handle3.value, quickJSKey.value, value2.value));
    }
    /**
     * [`Object.defineProperty(handle, key, descriptor)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty).
     *
     * @param key - The property may be specified as a JSValue handle, or as a
     * Javascript string or number (which will be converted automatically to a JSValue).
     */
    defineProp(handle3, key, descriptor) {
      this.runtime.assertOwned(handle3);
      lifetime_12.Scope.withScope((scope2) => {
        const quickJSKey = scope2.manage(this.borrowPropertyKey(key));
        const value2 = descriptor.value || this.undefined;
        const configurable = Boolean(descriptor.configurable);
        const enumerable = Boolean(descriptor.enumerable);
        const hasValue = Boolean(descriptor.value);
        const get2 = descriptor.get ? scope2.manage(this.newFunction(descriptor.get.name, descriptor.get)) : this.undefined;
        const set = descriptor.set ? scope2.manage(this.newFunction(descriptor.set.name, descriptor.set)) : this.undefined;
        this.ffi.QTS_DefineProp(this.ctx.value, handle3.value, quickJSKey.value, value2.value, get2.value, set.value, configurable, enumerable, hasValue);
      });
    }
    // Evaluation ---------------------------------------------------------------
    /**
     * [`func.call(thisVal, ...args)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/call).
     * Call a JSValue as a function.
     *
     * See [[unwrapResult]], which will throw if the function returned an error, or
     * return the result handle directly. If evaluation returned a handle containing
     * a promise, use [[resolvePromise]] to convert it to a native promise and
     * [[executePendingJobs]] to finish evaluating the promise.
     *
     * @returns A result. If the function threw synchronously, `result.error` be a
     * handle to the exception. Otherwise `result.value` will be a handle to the
     * value.
     */
    callFunction(func, thisVal, ...args) {
      this.runtime.assertOwned(func);
      const resultPtr = this.memory.toPointerArray(args).consume((argsArrayPtr) => this.ffi.QTS_Call(this.ctx.value, func.value, thisVal.value, args.length, argsArrayPtr.value));
      const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
      if (errorPtr) {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
        return { error: this.memory.heapValueHandle(errorPtr) };
      }
      return { value: this.memory.heapValueHandle(resultPtr) };
    }
    /**
     * Like [`eval(code)`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval#Description).
     * Evaluates the Javascript source `code` in the global scope of this VM.
     * When working with async code, you many need to call [[executePendingJobs]]
     * to execute callbacks pending after synchronous evaluation returns.
     *
     * See [[unwrapResult]], which will throw if the function returned an error, or
     * return the result handle directly. If evaluation returned a handle containing
     * a promise, use [[resolvePromise]] to convert it to a native promise and
     * [[executePendingJobs]] to finish evaluating the promise.
     *
     * *Note*: to protect against infinite loops, provide an interrupt handler to
     * [[setInterruptHandler]]. You can use [[shouldInterruptAfterDeadline]] to
     * create a time-based deadline.
     *
     * @returns The last statement's value. If the code threw synchronously,
     * `result.error` will be a handle to the exception. If execution was
     * interrupted, the error will have name `InternalError` and message
     * `interrupted`.
     */
    evalCode(code2, filename = "eval.js", options) {
      const detectModule = options === void 0 ? 1 : 0;
      const flags = (0, types_1.evalOptionsToFlags)(options);
      const resultPtr = this.memory.newHeapCharPointer(code2).consume((charHandle) => this.ffi.QTS_Eval(this.ctx.value, charHandle.value, filename, detectModule, flags));
      const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
      if (errorPtr) {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
        return { error: this.memory.heapValueHandle(errorPtr) };
      }
      return { value: this.memory.heapValueHandle(resultPtr) };
    }
    /**
     * Throw an error in the VM, interrupted whatever current execution is in progress when execution resumes.
     * @experimental
     */
    throw(error2) {
      return this.errorToHandle(error2).consume((handle3) => this.ffi.QTS_Throw(this.ctx.value, handle3.value));
    }
    /**
     * @private
     */
    borrowPropertyKey(key) {
      if (typeof key === "number") {
        return this.newNumber(key);
      }
      if (typeof key === "string") {
        return this.newString(key);
      }
      return new lifetime_12.StaticLifetime(key.value, this.runtime);
    }
    /**
     * @private
     */
    getMemory(rt) {
      if (rt === this.rt.value) {
        return this.memory;
      } else {
        throw new Error("Private API. Cannot get memory from a different runtime");
      }
    }
    // Utilities ----------------------------------------------------------------
    /**
     * Dump a JSValue to Javascript in a best-effort fashion.
     * Returns `handle.toString()` if it cannot be serialized to JSON.
     */
    dump(handle3) {
      this.runtime.assertOwned(handle3);
      const type3 = this.typeof(handle3);
      if (type3 === "string") {
        return this.getString(handle3);
      } else if (type3 === "number") {
        return this.getNumber(handle3);
      } else if (type3 === "bigint") {
        return this.getBigInt(handle3);
      } else if (type3 === "undefined") {
        return void 0;
      } else if (type3 === "symbol") {
        return this.getSymbol(handle3);
      }
      const str2 = this.memory.consumeJSCharPointer(this.ffi.QTS_Dump(this.ctx.value, handle3.value));
      try {
        return JSON.parse(str2);
      } catch (err) {
        return str2;
      }
    }
    /**
     * Unwrap a SuccessOrFail result such as a [[VmCallResult]] or a
     * [[ExecutePendingJobsResult]], where the fail branch contains a handle to a QuickJS error value.
     * If the result is a success, returns the value.
     * If the result is an error, converts the error to a native object and throws the error.
     */
    unwrapResult(result) {
      if (result.error) {
        const context2 = "context" in result.error ? result.error.context : this;
        const cause = result.error.consume((error2) => this.dump(error2));
        if (cause && typeof cause === "object" && typeof cause.message === "string") {
          const { message, name: name2, stack } = cause;
          const exception = new errors_12.QuickJSUnwrapError("");
          const hostStack = exception.stack;
          if (typeof name2 === "string") {
            exception.name = cause.name;
          }
          if (typeof stack === "string") {
            exception.stack = `${name2}: ${message}
${cause.stack}Host: ${hostStack}`;
          }
          Object.assign(exception, { cause, context: context2, message });
          throw exception;
        }
        throw new errors_12.QuickJSUnwrapError(cause, context2);
      }
      return result.value;
    }
    /** @private */
    getFunction(fn_id) {
      const map_id = fn_id >> 8;
      const fnMap = this.fnMaps.get(map_id);
      if (!fnMap) {
        return void 0;
      }
      return fnMap.get(fn_id);
    }
    /** @private */
    setFunction(fn_id, handle3) {
      const map_id = fn_id >> 8;
      let fnMap = this.fnMaps.get(map_id);
      if (!fnMap) {
        fnMap = /* @__PURE__ */ new Map();
        this.fnMaps.set(map_id, fnMap);
      }
      return fnMap.set(fn_id, handle3);
    }
    errorToHandle(error2) {
      if (error2 instanceof lifetime_12.Lifetime) {
        return error2;
      }
      return this.newError(error2);
    }
  }
  context.QuickJSContext = QuickJSContext;
  return context;
}
var hasRequiredRuntime;
function requireRuntime() {
  if (hasRequiredRuntime) return runtime;
  hasRequiredRuntime = 1;
  Object.defineProperty(runtime, "__esModule", { value: true });
  runtime.QuickJSRuntime = void 0;
  const asyncify_helpers_12 = asyncifyHelpers;
  const context_1 = requireContext();
  const debug_12 = debug$2;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const memory_1 = requireMemory();
  const types_1 = requireTypes();
  class QuickJSRuntime {
    /** @private */
    constructor(args) {
      var _a;
      this.scope = new lifetime_12.Scope();
      this.contextMap = /* @__PURE__ */ new Map();
      this.cToHostCallbacks = {
        shouldInterrupt: (rt) => {
          if (rt !== this.rt.value) {
            throw new Error("QuickJSContext instance received C -> JS interrupt with mismatched rt");
          }
          const fn = this.interruptHandler;
          if (!fn) {
            throw new Error("QuickJSContext had no interrupt handler");
          }
          return fn(this) ? 1 : 0;
        },
        loadModuleSource: (0, asyncify_helpers_12.maybeAsyncFn)(this, function* (awaited, rt, ctx, moduleName) {
          const moduleLoader = this.moduleLoader;
          if (!moduleLoader) {
            throw new Error("Runtime has no module loader");
          }
          if (rt !== this.rt.value) {
            throw new Error("Runtime pointer mismatch");
          }
          const context2 = this.contextMap.get(ctx) ?? this.newContext({
            contextPointer: ctx
          });
          try {
            const result = yield* awaited(moduleLoader(moduleName, context2));
            if (typeof result === "object" && "error" in result && result.error) {
              (0, debug_12.debugLog)("cToHostLoadModule: loader returned error", result.error);
              throw result.error;
            }
            const moduleSource = typeof result === "string" ? result : "value" in result ? result.value : result;
            return this.memory.newHeapCharPointer(moduleSource).value;
          } catch (error2) {
            (0, debug_12.debugLog)("cToHostLoadModule: caught error", error2);
            context2.throw(error2);
            return 0;
          }
        }),
        normalizeModule: (0, asyncify_helpers_12.maybeAsyncFn)(this, function* (awaited, rt, ctx, baseModuleName, moduleNameRequest) {
          const moduleNormalizer = this.moduleNormalizer;
          if (!moduleNormalizer) {
            throw new Error("Runtime has no module normalizer");
          }
          if (rt !== this.rt.value) {
            throw new Error("Runtime pointer mismatch");
          }
          const context2 = this.contextMap.get(ctx) ?? this.newContext({
            /* TODO: Does this happen? Are we responsible for disposing? I don't think so */
            contextPointer: ctx
          });
          try {
            const result = yield* awaited(moduleNormalizer(baseModuleName, moduleNameRequest, context2));
            if (typeof result === "object" && "error" in result && result.error) {
              (0, debug_12.debugLog)("cToHostNormalizeModule: normalizer returned error", result.error);
              throw result.error;
            }
            const name2 = typeof result === "string" ? result : result.value;
            return context2.getMemory(this.rt.value).newHeapCharPointer(name2).value;
          } catch (error2) {
            (0, debug_12.debugLog)("normalizeModule: caught error", error2);
            context2.throw(error2);
            return 0;
          }
        })
      };
      (_a = args.ownedLifetimes) == null ? void 0 : _a.forEach((lifetime2) => this.scope.manage(lifetime2));
      this.module = args.module;
      this.memory = new memory_1.ModuleMemory(this.module);
      this.ffi = args.ffi;
      this.rt = args.rt;
      this.callbacks = args.callbacks;
      this.scope.manage(this.rt);
      this.callbacks.setRuntimeCallbacks(this.rt.value, this.cToHostCallbacks);
      this.executePendingJobs = this.executePendingJobs.bind(this);
    }
    get alive() {
      return this.scope.alive;
    }
    dispose() {
      return this.scope.dispose();
    }
    newContext(options = {}) {
      if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {
        throw new Error("TODO: Custom intrinsics are not supported yet");
      }
      const ctx = new lifetime_12.Lifetime(options.contextPointer || this.ffi.QTS_NewContext(this.rt.value), void 0, (ctx_ptr) => {
        this.contextMap.delete(ctx_ptr);
        this.callbacks.deleteContext(ctx_ptr);
        this.ffi.QTS_FreeContext(ctx_ptr);
      });
      const context2 = new context_1.QuickJSContext({
        module: this.module,
        ctx,
        ffi: this.ffi,
        rt: this.rt,
        ownedLifetimes: options.ownedLifetimes,
        runtime: this,
        callbacks: this.callbacks
      });
      this.contextMap.set(ctx.value, context2);
      return context2;
    }
    /**
     * Set the loader for EcmaScript modules requested by any context in this
     * runtime.
     *
     * The loader can be removed with [[removeModuleLoader]].
     */
    setModuleLoader(moduleLoader, moduleNormalizer) {
      this.moduleLoader = moduleLoader;
      this.moduleNormalizer = moduleNormalizer;
      this.ffi.QTS_RuntimeEnableModuleLoader(this.rt.value, this.moduleNormalizer ? 1 : 0);
    }
    /**
     * Remove the the loader set by [[setModuleLoader]]. This disables module loading.
     */
    removeModuleLoader() {
      this.moduleLoader = void 0;
      this.ffi.QTS_RuntimeDisableModuleLoader(this.rt.value);
    }
    // Runtime management -------------------------------------------------------
    /**
     * In QuickJS, promises and async functions create pendingJobs. These do not execute
     * immediately and need to be run by calling [[executePendingJobs]].
     *
     * @return true if there is at least one pendingJob queued up.
     */
    hasPendingJob() {
      return Boolean(this.ffi.QTS_IsJobPending(this.rt.value));
    }
    /**
     * Set a callback which is regularly called by the QuickJS engine when it is
     * executing code. This callback can be used to implement an execution
     * timeout.
     *
     * The interrupt handler can be removed with [[removeInterruptHandler]].
     */
    setInterruptHandler(cb) {
      const prevInterruptHandler = this.interruptHandler;
      this.interruptHandler = cb;
      if (!prevInterruptHandler) {
        this.ffi.QTS_RuntimeEnableInterruptHandler(this.rt.value);
      }
    }
    /**
     * Remove the interrupt handler, if any.
     * See [[setInterruptHandler]].
     */
    removeInterruptHandler() {
      if (this.interruptHandler) {
        this.ffi.QTS_RuntimeDisableInterruptHandler(this.rt.value);
        this.interruptHandler = void 0;
      }
    }
    /**
     * Execute pendingJobs on the runtime until `maxJobsToExecute` jobs are
     * executed (default all pendingJobs), the queue is exhausted, or the runtime
     * encounters an exception.
     *
     * In QuickJS, promises and async functions *inside the runtime* create
     * pendingJobs. These do not execute immediately and need to triggered to run.
     *
     * @param maxJobsToExecute - When negative, run all pending jobs. Otherwise execute
     * at most `maxJobsToExecute` before returning.
     *
     * @return On success, the number of executed jobs. On error, the exception
     * that stopped execution, and the context it occurred in. Note that
     * executePendingJobs will not normally return errors thrown inside async
     * functions or rejected promises. Those errors are available by calling
     * [[resolvePromise]] on the promise handle returned by the async function.
     */
    executePendingJobs(maxJobsToExecute = -1) {
      const ctxPtrOut = this.memory.newMutablePointerArray(1);
      const valuePtr = this.ffi.QTS_ExecutePendingJob(this.rt.value, maxJobsToExecute ?? -1, ctxPtrOut.value.ptr);
      const ctxPtr = ctxPtrOut.value.typedArray[0];
      ctxPtrOut.dispose();
      if (ctxPtr === 0) {
        this.ffi.QTS_FreeValuePointerRuntime(this.rt.value, valuePtr);
        return { value: 0 };
      }
      const context2 = this.contextMap.get(ctxPtr) ?? this.newContext({
        contextPointer: ctxPtr
      });
      const resultValue = context2.getMemory(this.rt.value).heapValueHandle(valuePtr);
      const typeOfRet = context2.typeof(resultValue);
      if (typeOfRet === "number") {
        const executedJobs = context2.getNumber(resultValue);
        resultValue.dispose();
        return { value: executedJobs };
      } else {
        const error2 = Object.assign(resultValue, { context: context2 });
        return {
          error: error2
        };
      }
    }
    /**
     * Set the max memory this runtime can allocate.
     * To remove the limit, set to `-1`.
     */
    setMemoryLimit(limitBytes) {
      if (limitBytes < 0 && limitBytes !== -1) {
        throw new Error("Cannot set memory limit to negative number. To unset, pass -1");
      }
      this.ffi.QTS_RuntimeSetMemoryLimit(this.rt.value, limitBytes);
    }
    /**
     * Compute memory usage for this runtime. Returns the result as a handle to a
     * JSValue object. Use [[QuickJSContext.dump]] to convert to a native object.
     * Calling this method will allocate more memory inside the runtime. The information
     * is accurate as of just before the call to `computeMemoryUsage`.
     * For a human-digestible representation, see [[dumpMemoryUsage]].
     */
    computeMemoryUsage() {
      const serviceContextMemory = this.getSystemContext().getMemory(this.rt.value);
      return serviceContextMemory.heapValueHandle(this.ffi.QTS_RuntimeComputeMemoryUsage(this.rt.value, serviceContextMemory.ctx.value));
    }
    /**
     * @returns a human-readable description of memory usage in this runtime.
     * For programmatic access to this information, see [[computeMemoryUsage]].
     */
    dumpMemoryUsage() {
      return this.memory.consumeHeapCharPointer(this.ffi.QTS_RuntimeDumpMemoryUsage(this.rt.value));
    }
    /**
     * Set the max stack size for this runtime, in bytes.
     * To remove the limit, set to `0`.
     */
    setMaxStackSize(stackSize) {
      if (stackSize < 0) {
        throw new Error("Cannot set memory limit to negative number. To unset, pass 0.");
      }
      this.ffi.QTS_RuntimeSetMaxStackSize(this.rt.value, stackSize);
    }
    /**
     * Assert that `handle` is owned by this runtime.
     * @throws QuickJSWrongOwner if owned by a different runtime.
     */
    assertOwned(handle3) {
      if (handle3.owner && handle3.owner.rt !== this.rt) {
        throw new errors_12.QuickJSWrongOwner(`Handle is not owned by this runtime: ${handle3.owner.rt.value} != ${this.rt.value}`);
      }
    }
    getSystemContext() {
      if (!this.context) {
        this.context = this.scope.manage(this.newContext());
      }
      return this.context;
    }
  }
  runtime.QuickJSRuntime = QuickJSRuntime;
  return runtime;
}
var hasRequiredModule;
function requireModule() {
  if (hasRequiredModule) return module;
  hasRequiredModule = 1;
  Object.defineProperty(module, "__esModule", { value: true });
  module.QuickJSWASMModule = module.applyModuleEvalRuntimeOptions = module.applyBaseRuntimeOptions = module.QuickJSModuleCallbacks = void 0;
  const debug_12 = debug$2;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const runtime_1 = requireRuntime();
  const types_1 = requireTypes();
  class QuickJSEmscriptenModuleCallbacks {
    constructor(args) {
      this.callFunction = args.callFunction;
      this.shouldInterrupt = args.shouldInterrupt;
      this.loadModuleSource = args.loadModuleSource;
      this.normalizeModule = args.normalizeModule;
    }
  }
  class QuickJSModuleCallbacks {
    constructor(module2) {
      this.contextCallbacks = /* @__PURE__ */ new Map();
      this.runtimeCallbacks = /* @__PURE__ */ new Map();
      this.suspendedCount = 0;
      this.cToHostCallbacks = new QuickJSEmscriptenModuleCallbacks({
        callFunction: (asyncify, ctx, this_ptr, argc, argv, fn_id) => this.handleAsyncify(asyncify, () => {
          try {
            const vm = this.contextCallbacks.get(ctx);
            if (!vm) {
              throw new Error(`QuickJSContext(ctx = ${ctx}) not found for C function call "${fn_id}"`);
            }
            return vm.callFunction(ctx, this_ptr, argc, argv, fn_id);
          } catch (error2) {
            console.error("[C to host error: returning null]", error2);
            return 0;
          }
        }),
        shouldInterrupt: (asyncify, rt) => this.handleAsyncify(asyncify, () => {
          try {
            const vm = this.runtimeCallbacks.get(rt);
            if (!vm) {
              throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C interrupt`);
            }
            return vm.shouldInterrupt(rt);
          } catch (error2) {
            console.error("[C to host interrupt: returning error]", error2);
            return 1;
          }
        }),
        loadModuleSource: (asyncify, rt, ctx, moduleName) => this.handleAsyncify(asyncify, () => {
          try {
            const runtimeCallbacks = this.runtimeCallbacks.get(rt);
            if (!runtimeCallbacks) {
              throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);
            }
            const loadModule = runtimeCallbacks.loadModuleSource;
            if (!loadModule) {
              throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);
            }
            return loadModule(rt, ctx, moduleName);
          } catch (error2) {
            console.error("[C to host module loader error: returning null]", error2);
            return 0;
          }
        }),
        normalizeModule: (asyncify, rt, ctx, moduleBaseName, moduleName) => this.handleAsyncify(asyncify, () => {
          try {
            const runtimeCallbacks = this.runtimeCallbacks.get(rt);
            if (!runtimeCallbacks) {
              throw new Error(`QuickJSRuntime(rt = ${rt}) not found for C module loader`);
            }
            const normalizeModule = runtimeCallbacks.normalizeModule;
            if (!normalizeModule) {
              throw new Error(`QuickJSRuntime(rt = ${rt}) does not support module loading`);
            }
            return normalizeModule(rt, ctx, moduleBaseName, moduleName);
          } catch (error2) {
            console.error("[C to host module loader error: returning null]", error2);
            return 0;
          }
        })
      });
      this.module = module2;
      this.module.callbacks = this.cToHostCallbacks;
    }
    setRuntimeCallbacks(rt, callbacks) {
      this.runtimeCallbacks.set(rt, callbacks);
    }
    deleteRuntime(rt) {
      this.runtimeCallbacks.delete(rt);
    }
    setContextCallbacks(ctx, callbacks) {
      this.contextCallbacks.set(ctx, callbacks);
    }
    deleteContext(ctx) {
      this.contextCallbacks.delete(ctx);
    }
    handleAsyncify(asyncify, fn) {
      if (asyncify) {
        return asyncify.handleSleep((done) => {
          try {
            const result = fn();
            if (!(result instanceof Promise)) {
              (0, debug_12.debugLog)("asyncify.handleSleep: not suspending:", result);
              done(result);
              return;
            }
            if (this.suspended) {
              throw new errors_12.QuickJSAsyncifyError(`Already suspended at: ${this.suspended.stack}
Attempted to suspend at:`);
            } else {
              this.suspended = new errors_12.QuickJSAsyncifySuspended(`(${this.suspendedCount++})`);
              (0, debug_12.debugLog)("asyncify.handleSleep: suspending:", this.suspended);
            }
            result.then((resolvedResult) => {
              this.suspended = void 0;
              (0, debug_12.debugLog)("asyncify.handleSleep: resolved:", resolvedResult);
              done(resolvedResult);
            }, (error2) => {
              (0, debug_12.debugLog)("asyncify.handleSleep: rejected:", error2);
              console.error("QuickJS: cannot handle error in suspended function", error2);
              this.suspended = void 0;
            });
          } catch (error2) {
            (0, debug_12.debugLog)("asyncify.handleSleep: error:", error2);
            this.suspended = void 0;
            throw error2;
          }
        });
      }
      const value2 = fn();
      if (value2 instanceof Promise) {
        throw new Error("Promise return value not supported in non-asyncify context.");
      }
      return value2;
    }
  }
  module.QuickJSModuleCallbacks = QuickJSModuleCallbacks;
  function applyBaseRuntimeOptions(runtime2, options) {
    if (options.interruptHandler) {
      runtime2.setInterruptHandler(options.interruptHandler);
    }
    if (options.maxStackSizeBytes !== void 0) {
      runtime2.setMaxStackSize(options.maxStackSizeBytes);
    }
    if (options.memoryLimitBytes !== void 0) {
      runtime2.setMemoryLimit(options.memoryLimitBytes);
    }
  }
  module.applyBaseRuntimeOptions = applyBaseRuntimeOptions;
  function applyModuleEvalRuntimeOptions(runtime2, options) {
    if (options.moduleLoader) {
      runtime2.setModuleLoader(options.moduleLoader);
    }
    if (options.shouldInterrupt) {
      runtime2.setInterruptHandler(options.shouldInterrupt);
    }
    if (options.memoryLimitBytes !== void 0) {
      runtime2.setMemoryLimit(options.memoryLimitBytes);
    }
    if (options.maxStackSizeBytes !== void 0) {
      runtime2.setMaxStackSize(options.maxStackSizeBytes);
    }
  }
  module.applyModuleEvalRuntimeOptions = applyModuleEvalRuntimeOptions;
  class QuickJSWASMModule {
    /** @private */
    constructor(module2, ffi) {
      this.module = module2;
      this.ffi = ffi;
      this.callbacks = new QuickJSModuleCallbacks(module2);
    }
    /**
     * Create a runtime.
     * Use the runtime to set limits on CPU and memory usage and configure module
     * loading for one or more [[QuickJSContext]]s inside the runtime.
     */
    newRuntime(options = {}) {
      const rt = new lifetime_12.Lifetime(this.ffi.QTS_NewRuntime(), void 0, (rt_ptr) => {
        this.callbacks.deleteRuntime(rt_ptr);
        this.ffi.QTS_FreeRuntime(rt_ptr);
      });
      const runtime2 = new runtime_1.QuickJSRuntime({
        module: this.module,
        callbacks: this.callbacks,
        ffi: this.ffi,
        rt
      });
      applyBaseRuntimeOptions(runtime2, options);
      if (options.moduleLoader) {
        runtime2.setModuleLoader(options.moduleLoader);
      }
      return runtime2;
    }
    /**
     * A simplified API to create a new [[QuickJSRuntime]] and a
     * [[QuickJSContext]] inside that runtime at the same time. The runtime will
     * be disposed when the context is disposed.
     */
    newContext(options = {}) {
      const runtime2 = this.newRuntime();
      const context2 = runtime2.newContext({
        ...options,
        ownedLifetimes: (0, types_1.concat)(runtime2, options.ownedLifetimes)
      });
      runtime2.context = context2;
      return context2;
    }
    /**
     * One-off evaluate code without needing to create a [[QuickJSRuntime]] or
     * [[QuickJSContext]] explicitly.
     *
     * To protect against infinite loops, use the `shouldInterrupt` option. The
     * [[shouldInterruptAfterDeadline]] function will create a time-based deadline.
     *
     * If you need more control over how the code executes, create a
     * [[QuickJSRuntime]] (with [[newRuntime]]) or a [[QuickJSContext]] (with
     * [[newContext]] or [[QuickJSRuntime.newContext]]), and use its
     * [[QuickJSContext.evalCode]] method.
     *
     * Asynchronous callbacks may not run during the first call to `evalCode`. If
     * you need to work with async code inside QuickJS, create a runtime and use
     * [[QuickJSRuntime.executePendingJobs]].
     *
     * @returns The result is coerced to a native Javascript value using JSON
     * serialization, so properties and values unsupported by JSON will be dropped.
     *
     * @throws If `code` throws during evaluation, the exception will be
     * converted into a native Javascript value and thrown.
     *
     * @throws if `options.shouldInterrupt` interrupted execution, will throw a Error
     * with name `"InternalError"` and  message `"interrupted"`.
     */
    evalCode(code2, options = {}) {
      return lifetime_12.Scope.withScope((scope2) => {
        const vm = scope2.manage(this.newContext());
        applyModuleEvalRuntimeOptions(vm.runtime, options);
        const result = vm.evalCode(code2, "eval.js");
        if (options.memoryLimitBytes !== void 0) {
          vm.runtime.setMemoryLimit(-1);
        }
        if (result.error) {
          const error2 = vm.dump(scope2.manage(result.error));
          throw error2;
        }
        const value2 = vm.dump(scope2.manage(result.value));
        return value2;
      });
    }
    /**
     * Get a low-level interface to the QuickJS functions in this WebAssembly
     * module.
     * @experimental
     * @unstable No warranty is provided with this API. It could change at any time.
     * @private
     */
    getFFI() {
      return this.ffi;
    }
  }
  module.QuickJSWASMModule = QuickJSWASMModule;
  return module;
}
var moduleAsyncify = {};
var runtimeAsyncify = {};
var contextAsyncify = {};
var hasRequiredContextAsyncify;
function requireContextAsyncify() {
  if (hasRequiredContextAsyncify) return contextAsyncify;
  hasRequiredContextAsyncify = 1;
  Object.defineProperty(contextAsyncify, "__esModule", { value: true });
  contextAsyncify.QuickJSAsyncContext = void 0;
  const context_1 = requireContext();
  const debug_12 = debug$2;
  const types_1 = requireTypes();
  class QuickJSAsyncContext extends context_1.QuickJSContext {
    /**
     * Asyncified version of [[evalCode]].
     */
    async evalCodeAsync(code2, filename = "eval.js", options) {
      const detectModule = options === void 0 ? 1 : 0;
      const flags = (0, types_1.evalOptionsToFlags)(options);
      let resultPtr = 0;
      try {
        resultPtr = await this.memory.newHeapCharPointer(code2).consume((charHandle) => this.ffi.QTS_Eval_MaybeAsync(this.ctx.value, charHandle.value, filename, detectModule, flags));
      } catch (error2) {
        (0, debug_12.debugLog)("QTS_Eval_MaybeAsync threw", error2);
        throw error2;
      }
      const errorPtr = this.ffi.QTS_ResolveException(this.ctx.value, resultPtr);
      if (errorPtr) {
        this.ffi.QTS_FreeValuePointer(this.ctx.value, resultPtr);
        return { error: this.memory.heapValueHandle(errorPtr) };
      }
      return { value: this.memory.heapValueHandle(resultPtr) };
    }
    /**
     * Similar to [[newFunction]].
     * Convert an async host Javascript function into a synchronous QuickJS function value.
     *
     * Whenever QuickJS calls this function, the VM's stack will be unwound while
     * waiting the async function to complete, and then restored when the returned
     * promise resolves.
     *
     * Asyncified functions must never call other asyncified functions or
     * `import`, even indirectly, because the stack cannot be unwound twice.
     *
     * See [Emscripten's docs on Asyncify](https://emscripten.org/docs/porting/asyncify.html).
     */
    newAsyncifiedFunction(name2, fn) {
      return this.newFunction(name2, fn);
    }
  }
  contextAsyncify.QuickJSAsyncContext = QuickJSAsyncContext;
  return contextAsyncify;
}
var hasRequiredRuntimeAsyncify;
function requireRuntimeAsyncify() {
  if (hasRequiredRuntimeAsyncify) return runtimeAsyncify;
  hasRequiredRuntimeAsyncify = 1;
  Object.defineProperty(runtimeAsyncify, "__esModule", { value: true });
  runtimeAsyncify.QuickJSAsyncRuntime = void 0;
  const _1 = requireDist();
  const context_asyncify_1 = requireContextAsyncify();
  const runtime_1 = requireRuntime();
  const types_1 = requireTypes();
  class QuickJSAsyncRuntime extends runtime_1.QuickJSRuntime {
    /** @private */
    constructor(args) {
      super(args);
    }
    newContext(options = {}) {
      if (options.intrinsics && options.intrinsics !== types_1.DefaultIntrinsics) {
        throw new Error("TODO: Custom intrinsics are not supported yet");
      }
      const ctx = new _1.Lifetime(this.ffi.QTS_NewContext(this.rt.value), void 0, (ctx_ptr) => {
        this.contextMap.delete(ctx_ptr);
        this.callbacks.deleteContext(ctx_ptr);
        this.ffi.QTS_FreeContext(ctx_ptr);
      });
      const context2 = new context_asyncify_1.QuickJSAsyncContext({
        module: this.module,
        ctx,
        ffi: this.ffi,
        rt: this.rt,
        ownedLifetimes: [],
        runtime: this,
        callbacks: this.callbacks
      });
      this.contextMap.set(ctx.value, context2);
      return context2;
    }
    setModuleLoader(moduleLoader, moduleNormalizer) {
      super.setModuleLoader(moduleLoader, moduleNormalizer);
    }
    /**
     * Set the max stack size for this runtime in bytes.
     * To remove the limit, set to `0`.
     *
     * Setting this limit also adjusts the global `ASYNCIFY_STACK_SIZE` for the entire {@link QuickJSAsyncWASMModule}.
     * See the [pull request](https://github.com/justjake/quickjs-emscripten/pull/114) for more details.
     */
    setMaxStackSize(stackSize) {
      return super.setMaxStackSize(stackSize);
    }
  }
  runtimeAsyncify.QuickJSAsyncRuntime = QuickJSAsyncRuntime;
  return runtimeAsyncify;
}
var hasRequiredModuleAsyncify;
function requireModuleAsyncify() {
  if (hasRequiredModuleAsyncify) return moduleAsyncify;
  hasRequiredModuleAsyncify = 1;
  Object.defineProperty(moduleAsyncify, "__esModule", { value: true });
  moduleAsyncify.QuickJSAsyncWASMModule = void 0;
  const errors_12 = errors;
  const lifetime_12 = lifetime;
  const module_1 = requireModule();
  const runtime_asyncify_1 = requireRuntimeAsyncify();
  class QuickJSAsyncWASMModule extends module_1.QuickJSWASMModule {
    /** @private */
    constructor(module2, ffi) {
      super(module2, ffi);
      this.ffi = ffi;
      this.module = module2;
    }
    /**
     * Create a new async runtime inside this WebAssembly module. All runtimes inside a
     * module are limited to a single async call at a time. For multiple
     * concurrent async actions, create multiple WebAssembly modules.
     */
    newRuntime(options = {}) {
      const rt = new lifetime_12.Lifetime(this.ffi.QTS_NewRuntime(), void 0, (rt_ptr) => {
        this.callbacks.deleteRuntime(rt_ptr);
        this.ffi.QTS_FreeRuntime(rt_ptr);
      });
      const runtime2 = new runtime_asyncify_1.QuickJSAsyncRuntime({
        module: this.module,
        ffi: this.ffi,
        rt,
        callbacks: this.callbacks
      });
      (0, module_1.applyBaseRuntimeOptions)(runtime2, options);
      if (options.moduleLoader) {
        runtime2.setModuleLoader(options.moduleLoader);
      }
      return runtime2;
    }
    /**
     * A simplified API to create a new [[QuickJSRuntime]] and a
     * [[QuickJSContext]] inside that runtime at the same time. The runtime will
     * be disposed when the context is disposed.
     */
    newContext(options = {}) {
      const runtime2 = this.newRuntime();
      const lifetimes = options.ownedLifetimes ? options.ownedLifetimes.concat([runtime2]) : [runtime2];
      const context2 = runtime2.newContext({ ...options, ownedLifetimes: lifetimes });
      runtime2.context = context2;
      return context2;
    }
    /** Synchronous evalCode is not supported. */
    evalCode() {
      throw new errors_12.QuickJSNotImplemented("QuickJSWASMModuleAsyncify.evalCode: use evalCodeAsync instead");
    }
    /**
     * One-off evaluate code without needing to create a [[QuickJSRuntimeAsync]] or
     * [[QuickJSContextSync]] explicitly.
     *
     * This version allows for asynchronous Ecmascript module loading.
     *
     * Note that only a single async action can occur at a time inside the entire WebAssembly module.
     * **Multiple concurrent async actions is an error.**
     *
     * See the documentation for [[QuickJSWASMModule.evalCode]] for more details.
     */
    evalCodeAsync(code2, options) {
      return lifetime_12.Scope.withScopeAsync(async (scope2) => {
        const vm = scope2.manage(this.newContext());
        (0, module_1.applyModuleEvalRuntimeOptions)(vm.runtime, options);
        const result = await vm.evalCodeAsync(code2, "eval.js");
        if (options.memoryLimitBytes !== void 0) {
          vm.runtime.setMemoryLimit(-1);
        }
        if (result.error) {
          const error2 = vm.dump(scope2.manage(result.error));
          throw error2;
        }
        const value2 = vm.dump(scope2.manage(result.value));
        return value2;
      });
    }
  }
  moduleAsyncify.QuickJSAsyncWASMModule = QuickJSAsyncWASMModule;
  return moduleAsyncify;
}
var ffi_WASM_RELEASE_SYNC = {};
var hasRequiredFfi_WASM_RELEASE_SYNC;
function requireFfi_WASM_RELEASE_SYNC() {
  if (hasRequiredFfi_WASM_RELEASE_SYNC) return ffi_WASM_RELEASE_SYNC;
  hasRequiredFfi_WASM_RELEASE_SYNC = 1;
  Object.defineProperty(ffi_WASM_RELEASE_SYNC, "__esModule", { value: true });
  ffi_WASM_RELEASE_SYNC.QuickJSFFI = void 0;
  class QuickJSFFI {
    constructor(module2) {
      this.module = module2;
      this.DEBUG = false;
      this.QTS_Throw = this.module.cwrap("QTS_Throw", "number", ["number", "number"]);
      this.QTS_NewError = this.module.cwrap("QTS_NewError", "number", ["number"]);
      this.QTS_RuntimeSetMemoryLimit = this.module.cwrap("QTS_RuntimeSetMemoryLimit", null, ["number", "number"]);
      this.QTS_RuntimeComputeMemoryUsage = this.module.cwrap("QTS_RuntimeComputeMemoryUsage", "number", ["number", "number"]);
      this.QTS_RuntimeDumpMemoryUsage = this.module.cwrap("QTS_RuntimeDumpMemoryUsage", "number", ["number"]);
      this.QTS_RecoverableLeakCheck = this.module.cwrap("QTS_RecoverableLeakCheck", "number", []);
      this.QTS_BuildIsSanitizeLeak = this.module.cwrap("QTS_BuildIsSanitizeLeak", "number", []);
      this.QTS_RuntimeSetMaxStackSize = this.module.cwrap("QTS_RuntimeSetMaxStackSize", null, ["number", "number"]);
      this.QTS_GetUndefined = this.module.cwrap("QTS_GetUndefined", "number", []);
      this.QTS_GetNull = this.module.cwrap("QTS_GetNull", "number", []);
      this.QTS_GetFalse = this.module.cwrap("QTS_GetFalse", "number", []);
      this.QTS_GetTrue = this.module.cwrap("QTS_GetTrue", "number", []);
      this.QTS_NewRuntime = this.module.cwrap("QTS_NewRuntime", "number", []);
      this.QTS_FreeRuntime = this.module.cwrap("QTS_FreeRuntime", null, ["number"]);
      this.QTS_NewContext = this.module.cwrap("QTS_NewContext", "number", ["number"]);
      this.QTS_FreeContext = this.module.cwrap("QTS_FreeContext", null, ["number"]);
      this.QTS_FreeValuePointer = this.module.cwrap("QTS_FreeValuePointer", null, ["number", "number"]);
      this.QTS_FreeValuePointerRuntime = this.module.cwrap("QTS_FreeValuePointerRuntime", null, ["number", "number"]);
      this.QTS_FreeVoidPointer = this.module.cwrap("QTS_FreeVoidPointer", null, ["number", "number"]);
      this.QTS_FreeCString = this.module.cwrap("QTS_FreeCString", null, ["number", "number"]);
      this.QTS_DupValuePointer = this.module.cwrap("QTS_DupValuePointer", "number", ["number", "number"]);
      this.QTS_NewObject = this.module.cwrap("QTS_NewObject", "number", ["number"]);
      this.QTS_NewObjectProto = this.module.cwrap("QTS_NewObjectProto", "number", ["number", "number"]);
      this.QTS_NewArray = this.module.cwrap("QTS_NewArray", "number", ["number"]);
      this.QTS_NewFloat64 = this.module.cwrap("QTS_NewFloat64", "number", ["number", "number"]);
      this.QTS_GetFloat64 = this.module.cwrap("QTS_GetFloat64", "number", ["number", "number"]);
      this.QTS_NewString = this.module.cwrap("QTS_NewString", "number", ["number", "number"]);
      this.QTS_GetString = this.module.cwrap("QTS_GetString", "number", ["number", "number"]);
      this.QTS_NewSymbol = this.module.cwrap("QTS_NewSymbol", "number", ["number", "number", "number"]);
      this.QTS_GetSymbolDescriptionOrKey = this.module.cwrap("QTS_GetSymbolDescriptionOrKey", "number", ["number", "number"]);
      this.QTS_IsGlobalSymbol = this.module.cwrap("QTS_IsGlobalSymbol", "number", ["number", "number"]);
      this.QTS_IsJobPending = this.module.cwrap("QTS_IsJobPending", "number", ["number"]);
      this.QTS_ExecutePendingJob = this.module.cwrap("QTS_ExecutePendingJob", "number", ["number", "number", "number"]);
      this.QTS_GetProp = this.module.cwrap("QTS_GetProp", "number", ["number", "number", "number"]);
      this.QTS_SetProp = this.module.cwrap("QTS_SetProp", null, ["number", "number", "number", "number"]);
      this.QTS_DefineProp = this.module.cwrap("QTS_DefineProp", null, ["number", "number", "number", "number", "number", "number", "boolean", "boolean", "boolean"]);
      this.QTS_Call = this.module.cwrap("QTS_Call", "number", ["number", "number", "number", "number", "number"]);
      this.QTS_ResolveException = this.module.cwrap("QTS_ResolveException", "number", ["number", "number"]);
      this.QTS_Dump = this.module.cwrap("QTS_Dump", "number", ["number", "number"]);
      this.QTS_Eval = this.module.cwrap("QTS_Eval", "number", ["number", "number", "string", "number", "number"]);
      this.QTS_Typeof = this.module.cwrap("QTS_Typeof", "number", ["number", "number"]);
      this.QTS_GetGlobalObject = this.module.cwrap("QTS_GetGlobalObject", "number", ["number"]);
      this.QTS_NewPromiseCapability = this.module.cwrap("QTS_NewPromiseCapability", "number", ["number", "number"]);
      this.QTS_TestStringArg = this.module.cwrap("QTS_TestStringArg", null, ["string"]);
      this.QTS_BuildIsDebug = this.module.cwrap("QTS_BuildIsDebug", "number", []);
      this.QTS_BuildIsAsyncify = this.module.cwrap("QTS_BuildIsAsyncify", "number", []);
      this.QTS_NewFunction = this.module.cwrap("QTS_NewFunction", "number", ["number", "number", "string"]);
      this.QTS_ArgvGetJSValueConstPointer = this.module.cwrap("QTS_ArgvGetJSValueConstPointer", "number", ["number", "number"]);
      this.QTS_RuntimeEnableInterruptHandler = this.module.cwrap("QTS_RuntimeEnableInterruptHandler", null, ["number"]);
      this.QTS_RuntimeDisableInterruptHandler = this.module.cwrap("QTS_RuntimeDisableInterruptHandler", null, ["number"]);
      this.QTS_RuntimeEnableModuleLoader = this.module.cwrap("QTS_RuntimeEnableModuleLoader", null, ["number", "number"]);
      this.QTS_RuntimeDisableModuleLoader = this.module.cwrap("QTS_RuntimeDisableModuleLoader", null, ["number"]);
    }
  }
  ffi_WASM_RELEASE_SYNC.QuickJSFFI = QuickJSFFI;
  return ffi_WASM_RELEASE_SYNC;
}
var emscriptenModule_WASM_RELEASE_SYNC = { exports: {} };
var hasRequiredEmscriptenModule_WASM_RELEASE_SYNC;
function requireEmscriptenModule_WASM_RELEASE_SYNC() {
  if (hasRequiredEmscriptenModule_WASM_RELEASE_SYNC) return emscriptenModule_WASM_RELEASE_SYNC.exports;
  hasRequiredEmscriptenModule_WASM_RELEASE_SYNC = 1;
  (function(module2, exports) {
    var QuickJSRaw = (() => {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined")
        _scriptDir = _scriptDir || __filename;
      return function(QuickJSRaw2 = {}) {
        var a;
        a || (a = typeof QuickJSRaw2 !== "undefined" ? QuickJSRaw2 : {});
        var m2, n;
        a.ready = new Promise(function(b, c) {
          m2 = b;
          n = c;
        });
        var p = Object.assign({}, a), t2 = "./this.program", u2 = "object" == typeof window, v = "function" == typeof importScripts, w2 = "object" == typeof process && "object" == typeof process.versions && "string" == typeof process.versions.node, x = "", y2, z, A2;
        if (w2) {
          var fs2 = require$$0$7, B = require$$1$2;
          x = v ? B.dirname(x) + "/" : __dirname + "/";
          y2 = (b, c) => {
            var d2 = C(b);
            if (d2)
              return c ? d2 : d2.toString();
            b = b.startsWith("file://") ? new URL(b) : B.normalize(b);
            return fs2.readFileSync(b, c ? void 0 : "utf8");
          };
          A2 = (b) => {
            b = y2(b, true);
            b.buffer || (b = new Uint8Array(b));
            return b;
          };
          z = (b, c, d2) => {
            var e = C(b);
            e && c(e);
            b = b.startsWith("file://") ? new URL(b) : B.normalize(b);
            fs2.readFile(b, function(f, g) {
              f ? d2(f) : c(g.buffer);
            });
          };
          !a.thisProgram && 1 < process.argv.length && (t2 = process.argv[1].replace(/\\/g, "/"));
          process.argv.slice(2);
          a.inspect = function() {
            return "[Emscripten Module object]";
          };
        } else if (u2 || v)
          v ? x = self.location.href : "undefined" != typeof document && document.currentScript && (x = document.currentScript.src), _scriptDir && (x = _scriptDir), 0 !== x.indexOf("blob:") ? x = x.substr(0, x.replace(/[?#].*/, "").lastIndexOf("/") + 1) : x = "", y2 = (b) => {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", b, false);
              c.send(null);
              return c.responseText;
            } catch (f) {
              if (b = C(b)) {
                c = [];
                for (var d2 = 0; d2 < b.length; d2++) {
                  var e = b[d2];
                  255 < e && (e &= 255);
                  c.push(String.fromCharCode(e));
                }
                return c.join("");
              }
              throw f;
            }
          }, v && (A2 = (b) => {
            try {
              var c = new XMLHttpRequest();
              c.open("GET", b, false);
              c.responseType = "arraybuffer";
              c.send(null);
              return new Uint8Array(c.response);
            } catch (d2) {
              if (b = C(b))
                return b;
              throw d2;
            }
          }), z = (b, c, d2) => {
            var e = new XMLHttpRequest();
            e.open("GET", b, true);
            e.responseType = "arraybuffer";
            e.onload = () => {
              if (200 == e.status || 0 == e.status && e.response)
                c(e.response);
              else {
                var f = C(b);
                f ? c(f.buffer) : d2();
              }
            };
            e.onerror = d2;
            e.send(null);
          };
        var aa = a.print || console.log.bind(console), D3 = a.printErr || console.warn.bind(console);
        Object.assign(a, p);
        p = null;
        a.thisProgram && (t2 = a.thisProgram);
        var E;
        a.wasmBinary && (E = a.wasmBinary);
        a.noExitRuntime || true;
        "object" != typeof WebAssembly && F("no native wasm support detected");
        var G, H = false, I2, J, K, L2;
        function M2() {
          var b = G.buffer;
          a.HEAP8 = I2 = new Int8Array(b);
          a.HEAP16 = new Int16Array(b);
          a.HEAP32 = K = new Int32Array(b);
          a.HEAPU8 = J = new Uint8Array(b);
          a.HEAPU16 = new Uint16Array(b);
          a.HEAPU32 = L2 = new Uint32Array(b);
          a.HEAPF32 = new Float32Array(b);
          a.HEAPF64 = new Float64Array(b);
        }
        var ba = [], ca = [], da = [];
        function ea() {
          var b = a.preRun.shift();
          ba.unshift(b);
        }
        var N = 0, P = null;
        function F(b) {
          if (a.onAbort)
            a.onAbort(b);
          b = "Aborted(" + b + ")";
          D3(b);
          H = true;
          b = new WebAssembly.RuntimeError(b + ". Build with -sASSERTIONS for more info.");
          n(b);
          throw b;
        }
        var Q = "data:application/octet-stream;base64,", R;
        R = "data:application/octet-stream;base64,AGFzbQEAAAAB9QZxYAJ/fwBgA39/fwF/YAR/fn9/AX5gAn9/AX9gAX8Bf2AFf35/f38BfmADf39/AGAEf39/fwF/YAJ/fgF+YAF/AGAFf39/f38Bf2ABfAF8YAJ/fgBgAn9/AX5gAn9+AX9gA39/fgF/YAN/fn8BfmADf35/AGAGf35/f39/AX5gBn9/f39/fwF/YAR/f39/AGADf35/AX9gBn9+fn9/fwF+YAR/f35/AX9gA39+fgF+YAN/f38BfmAFf39/fn4Bf2AEf39/fgF/YAR/f35+AX9gBX9+fn5+AGABfwF+YAN/fn4Bf2AEf39/fwF+YAd/f39/f39/AX9gBX9/f39/AX5gAnx8AXxgAAF/YAV/f39/fwBgBX9+f35/AX9gBX9+fn9/AX5gAX4Bf2AEf35+fwBgB39+f35+fn8Bf2AIf39/f39/f38Bf2AFf35+fn8Bf2AGf35/fn5/AX9gBH9+f34BfmAEf35/fwBgBH9+f34AYAZ/f39/f38BfmAEf35+fwF/YAl/f39/f39/f38Bf2AEf35+fwF+YAR/fn9/AX9gA39+fgBgA35/fwF/YAV/fn5/fwBgA39/fgF+YAd/fn9/f39/AX5gAABgA39/fgBgBH9+f34Bf2AFf39+f38Bf2AEf35+fgF/YAd/f39/f39/AGACfH8BfGABfAF/YAN8fH8BfGACf38BfGAEf39+fwBgBH9+fn4BfmABfgF+YAJ/fAF/YAZ/fH9/f38Bf2AAAXxgBX9+f35/AX5gBn9/fn5+fgF/YAJ+fwBgAn98AGAEf39+fwF+YAV/f39/fgF+YAd/fn5+f39/AX5gBH5+fn4Bf2AHf39/f39/fgF+YAp/f39/f39/f39/AX9gB39/fn5/f38Bf2AFf3x/f38BfmACfn8Bf2AGfH9/f39/AGAFf35/f38AYAV/f35/fwBgBn9+fn5+fwF/YAV/f35+fwF/YAZ/fn9/f38Bf2ADf3x/AX9gBX9+f39/AX9gBX9/fn5+AX5gBX9+fn5+AX9gBn9/fn5/fwF/YAd/f39+fn5/AX9gBH9/f34BfmACfH8Bf2AGf39/f39/AGAIf39/f39/f38AYAN/fnwBfmAAAX5gAnx8AX9gAn5+AXxgAX8BfGADfn5+AX9gA39/fABgCH9+fn5+f35+AX5gCX9/f39/f39/fwACWw8B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rgitCKcIqAimCKUIpAj0B44JjQmKCYgJjAnwB/EH7gfrB+QH4gfhB9MHwQeaB/EEvAmbCZoJmQmYCZcJlgmVCZQJkwmSCZEJiwntCOwInQicCJsImgiZCKAFmAiXCJYIlQiUCJMIkQiQCI8IjgiNCIwIiwiKCIkIiAiHCIYI6QOFCOkDhAiDCIIIgQieCKEIoAifCKII2QP/B/4HkQeQB5kHmAeWB5UHlAeTB5IH4AffB94H6QPdB6AF3AfbB9oH2AerCKoIqQj/BooHiQeIB4cHhgeFB4QHgweCB4EHgAfoB4sHjweOB5sHpAehB6MHogefB54HnQecB6UH5wfmB+UH/gHsB+kH7QfvB/IH9QbPBPQG8wbyBvEGyATwBu8G9wbRBPYG9gf1B/sH+gf5B/gH/QeoCeMGpwnmBqYJpQmkCaMJ4QbfBsYEogmhCaAJsQafCZ4JnQmwBrIJsQmwCa8JrgmtCawJqwmqCbgJnQO3CbYJtQm0CbMJxgnJB8gHxQnECcMJwgnWA8EJwAn3BPgEvwm+CbsJugm5CckJyAnHCdAJzwm9BLwEzgnNCcwJywnKCbQG1AnTCdIJ0Qm4BrcGtga1BroGuQa9BrwGuwbSBtEG0AbPBs4GzQbMBssGygbJBsgGxwbGBsUGxAbDBsEGwAa/Br4G0wbcBoAJ+gj7CNsGgwmECYEJnQT+CPkI6wPMAtoG9QjxCO8I2Qb4CPQI8AiCCf8I/QiXAqcD1gnyCPwI2AbXBtYG1QbUBugG5wblBuQG4gbgBt4G3QbrBuoG6QbtBuwG7gapB6cHpgfPB4EF1weABc4HzQfMB8sHxwfGB8UHxAfDB8IHwAe/B9IH0AfWB9QHtAezB7EHsAevB64HrQesB6sHqge+B70HvAe7B7oHuQe4B7cHtge1B4cJhQmGCdgD8wgK15YXyAk1AQF/AkAgAUIgiKdBdUkNACABpyICIAIoAgAiAkEBazYCACACQQFKDQAgACgCECABEJYECwtNAQJ/IAAoAkAiAkGAAmohAyACKAKcAiAAKAIERwRAIANBwgEQESADIAAoAgQQHSACIAAoAgQ2ApwCCyACIAIoAoQCNgKYAiADIAEQEQsmAQF/IwBBEGsiAiQAIAIgAToADyAAIAJBD2pBARByIAJBEGokAAv/FwIGfwJ+IwBBEGsiAiQAAn8CQCAAKAIAKAIQKAJ4IAJLBEAgAEGNIkEAEBYMAQsgACAAQRBqIgQQ/wEgACAAKAI4IgE2AjQgAiABNgIMIABBADYCMCAAIAAoAhQ2AgQDQCAAIAE2AhggACAAKAIIIgM2AhQCQAJAAkACQAJAAkACQAJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgASwAACIFQf8BcSIGDn0AFxcXFxcXFxcEAwQEAhcXFxcXFxcXFxcXFxcXFxcXFwQSGggHDBMaFxcLDRcOCQUKHR0dHR0dHR0dFxcPERAWFwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHFwYXFAcBBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcHBwcXFRcLQQAhBSABIAAoAjxJDRggBEGsfzYCAAwgCyAAIAFBAWoQzwMNHSACIAAoAjg2AgwMHwsgAUEBaiABIAEtAAFBCkYbIQELIAIgAUEBajYCDAweCyACIAFBAWo2AgwMHgsCQAJAIAEtAAEiA0EqRwRAIANBL0YNASADQT1HDQIgAiABQQJqNgIMIARBhn82AgAMHgsgAiABQQJqIgE2AgwDQAJAAkACQAJAAkACQCABLQAAIgNBCmsOBAEDAwIACyADQSpHBEAgAw0DIAEgACgCPEkNBCAAQdUsQQAQFgwiCyABLQABQS9HDQMgAiABQQJqNgIMDCULIABBATYCMCAAIAAoAghBAWo2AgggAiABQQFqNgIMDAMLIABBATYCMCACIAFBAWo2AgwMAgsgA8BBAE4NACABQQYgAkEMahBYIgFBfnFBqMAARgRAIABBATYCMAwCCyABQX9HDQEgAiACKAIMQQFqNgIMDAELIAIgAUEBajYCDAsgAigCDCEBDAALAAsgAUECaiEBQQAMFwsgAiABQQFqNgIMIARBLzYCAAwbC0HcACEFIAEtAAFB9QBHDRIgAiABQQFqNgIEIAJBBGpBARD5ASIGQQBIDRIgBhDvAkUNEiACIAIoAgQ2AgwgAkEBNgIIDBcLIAJBADYCCCACIAFBAWo2AgwMFgsgAiABQQJqNgIEQdwAIQMCQCABLQABIgVB3ABGBEAgAS0AAkH1AEcNASACQQRqQQEQ+QEhAwwBCyAFIgPAQQBODQAgAUEBakEGIAJBBGoQWCEDCyADEO8CRQRAIABBxOcAQQAQFgwXCyACIAIoAgQ2AgwgACACQQxqIAJBCGogA0EBEOoEIgFFDRYgAEGrfzYCECAAIAE2AiAMGAtBLiEFIAEtAAEiA0EuRw0OIAEtAAJBLkcNDyACIAFBA2o2AgwgBEGnfzYCAAwXCyABLQABQTprQXZJDRIgACgCQC0AbkEBcUUNEiAAQfvsAEEAEBYMFAtBKiEFIAEtAAEiA0EqRwRAIANBPUcNDiACIAFBAmo2AgwgBEGFfzYCAAwWCyABLQACQT1GBEAgAiABQQNqNgIMIARBkX82AgAMFgsgAiABQQJqNgIMIARBpX82AgAMFQtBJSEFIAEtAAFBPUcNDCACIAFBAmo2AgwgBEGHfzYCAAwUC0ErIQUgAS0AASIDQStHBEAgA0E9Rw0MIAIgAUECajYCDCAEQYh/NgIADBQLIAIgAUECajYCDCAEQZZ/NgIADBMLQS0hBSABLQABIgZBLUcEQCAGQT1HDQsgAiABQQJqNgIMIARBiX82AgAMEwsCQCAAKAJIRQ0AIAEtAAJBPkcNACAAKAIEIANHDQ0LIAIgAUECajYCDCAEQZV/NgIADBILAkACQAJAIAEtAAEiA0E8aw4CAQACCyACIAFBAmo2AgwgBEGbfzYCAAwTCyABLQACQT1GBEAgAiABQQNqNgIMIARBin82AgAMEwsgAiABQQJqNgIMIARBl382AgAMEgtBPCEFIANBIUcNCSAAKAJIRQ0JIAEtAAJBLUcNCSABLQADQS1GDQsMCQtBPiEFAkACQCABLQABQT1rDgIAAQoLIAIgAUECajYCDCAEQZ1/NgIADBELAkACQAJAIAEtAAJBPWsOAgEAAgsgAS0AA0E9RgRAIAIgAUEEajYCDCAEQYx/NgIADBMLIAIgAUEDajYCDCAEQZl/NgIADBILIAIgAUEDajYCDCAEQYt/NgIADBELIAIgAUECajYCDCAEQZh/NgIADBALQT0hBQJAAkAgAS0AAUE9aw4CAAEJCyABLQACQT1GBEAgAiABQQNqNgIMIARBn382AgAMEQsgAiABQQJqNgIMIARBnn82AgAMEAsgAiABQQJqNgIMIARBpn82AgAMDwtBISEFIAEtAAFBPUcNBiABLQACQT1GBEAgAiABQQNqNgIMIARBoX82AgAMDwsgAiABQQJqNgIMIARBoH82AgAMDgtBJiEFIAEtAAEiA0EmRwRAIANBPUcNBiACIAFBAmo2AgwgBEGNfzYCAAwOCyABLQACQT1GBEAgAiABQQNqNgIMIARBkn82AgAMDgsgAiABQQJqNgIMIARBon82AgAMDQsCQCABLQABIgNB3gBHBEAgA0E9Rw0BIAIgAUECajYCDCAAKAJALQBuQQRxBEAgBEGQfzYCAAwPCyAEQY5/NgIADA4LIAEtAAJBPUYEQCACIAFBA2o2AgwgBEGOfzYCAAwOCyACIAFBAmo2AgwgBEHeADYCAAwNCyACIAFBAWo2AgwgACgCQC0AbkEEcQRAIARBpH82AgAMDQsgBEHeADYCAAwMC0H8ACEFIAEtAAEiA0H8AEcEQCADQT1HDQQgAiABQQJqNgIMIARBj382AgAMDAsgAS0AAkE9RgRAIAIgAUEDajYCDCAEQZN/NgIADAwLIAIgAUECajYCDCAEQaN/NgIADAsLQT8hBSABLQABIgNBLkcEQCADQT9HDQMgAS0AAkE9RgRAIAIgAUEDajYCDCAEQZR/NgIADAwLIAIgAUECajYCDCAEQah/NgIADAsLIAEtAAJBMGtB/wFxQQpJDQIgAiABQQJqNgIMIARBqX82AgAMCgsgBUEATg0BIAFBBiACQQxqEFgiBkF+cUGowABGBEAgACgCCCEDDAsLIAYQhwMNCyAGEO8CBEAgAkEANgIIDAcLIABB0cMAQQAQFgwHCyADQTBrQf8BcUEKSQ0ECyAEIAVB/wFxNgIAIAIgAUEBajYCDAwHCyAAIAZBASABQQFqIAQgAkEMahDzAkUNBgwEC0EBCyEDA0ACfwJAAkACQAJAIANFBEAgAiABNgIMDAELIAEtAAAiA0UNAgJAIANBCmsOBA0AAA0ACyADwEEATg0DIAFBBiACQQxqEFgiA0F+cUGowABGDQwgAigCDCEBIANBf0YNAQtBASEDDAQLIAFBAWoMAgsgASAAKAI8Tw0JCyABQQFqCyEBQQAhAwwACwALIAAoAkAtAG4hAyAAQShqIgVBADYCAAJAIAAoAgAgASACQQxqQQBB9AZB9AAgA0EEcRsgBRC3BSIHQoCAgIBwgyIIQoCAgIDAflIEQCAIQoCAgIDgAFENAyACKAIMQQYgAkEIahBYEMUBRQ0BCyAAKAIAIAcQDyAAQdXVAEEAEBYMAgsgACAHNwMgIABBgH82AhAMAwsgACACQQxqIAJBCGogBkEAEOoEIgFFDQAgACABNgIgIAIoAgghBSAAQQA2AiggACAFNgIkAkAgAUElSQ0AIAFBLU0EQCAAKAJAIgMtAG5BAXENASABQS1HDQMgAy8BbCIGQQFxDQEgBkGA/gNxQYAGRw0DIAMoAmQNAyADKAIEIgNFDQMgAy0AbEEBcQ0BDAMLIAFBLkcNAiAAKAJEDQAgACgCQCIDLwFsIgZBAnENACAGQYD+A3FBgAZHDQIgAygCZA0CIAMoAgQiA0UNAiADLQBsQQJxRQ0CCyAFBEAgAEGDfzYCECAAQQE2AigMAwsgBCABQdQAazYCAAwCCyAEQap/NgIADAULIARBg382AgALIAAgAigCDDYCOEEADAQLIABBATYCMCAAIANBAWo2AggLIAIoAgwhAQwACwALQX8LIQEgAkEQaiQAIAELFQAgAUHeAU4EQCAAKAIQIAEQ6AULC7oHAgZ/AX4jAEEgayIHJABCgICAgOAAIQsCQAJAAkACQAJAAkACQAJAAkACQCABQiCIpyIGQQFqDggDBQUAAQUFCQILIAAgAkGH1AAQjwEMBgsgACACQff4ABCPAQwFCyAGQXlGDQEMAgsgAachBgwCCyABpyEGIAJBAEgEQCACQf////8HcSIFIAYpAgQiC6dB/////wdxTw0BIAZBEGohAiAAAn8gC0KAgICACINQRQRAIAIgBUEBdGovAQAMAQsgAiAFai0AAAtB//8DcRCfAyELDAULIAJBMEcNACAGKQIEQv////8HgyELDAQLIAAgARCNBKciBkUNAgsgAkH/////B3EhCQNAIAYoAhAiBUEwaiEKIAUgBSgCGCACcUF/c0ECdGooAgAhBQJAA0AgBUUNASACIAogBUEBa0EDdCIFaiIIKAIERwRAIAgoAgBB////H3EhBQwBCwsgBigCFCAFaiEFAkACQAJAAkAgCCgCAEEedkEBaw4DAAECAwsgBSgCACICRQ0GIAIgAigCAEEBajYCACAAIAKtQoCAgIBwhCADQQBBABAvIQsMBwsgBSgCACgCECkDACILQoCAgIBwg0KAgICAwABRBEAgACACENkBDAULIAtCIIinQXVJDQYgC6ciACAAKAIAQQFqNgIADAYLIAAgBiACIAUgCBDIAkUNAgwDCyAFKQMAIgtCIIinQXVJDQQgC6ciACAAKAIAQQFqNgIADAQLAkAgBi0ABSIFQQRxRQ0AIAVBCHEEQCACQQBIBEAgBigCKCAJSwRAIAAgBq1CgICAgHCEIAkQsAEhCwwHCyAGLwEGQSBrQf//A3FB9f8DTw0FDAILIAYvAQZBFWtB//8DcUEKSw0BIAAgAhCeAyIFRQ0BQoCAgIDgAEKAgICAMCAFQQBIGyELDAULIAAoAhAoAkQgBi8BBkEYbGooAhQiBUUNACAFKAIUIggEQCAGIAYoAgBBAWo2AgAgACAGrUKAgICAcIQiASACIAMgCBEuACELIAAgARAPDAULIAUoAgAiBUUNACAGIAYoAgBBAWo2AgAgACAHIAatQoCAgIBwhCIBIAIgBREXACEFIAAgARAPIAVBAEgNAiAFRQ0AIActAABBEHEEQCAAIAcpAxgQDyAAIAcpAxAgA0EAQQAQLyELDAULIAcpAwghCwwECyAGKAIQKAIsIgYNAAtCgICAgDAhCyAERQ0CIAAgAhDHAgtCgICAgOAAIQsMAQtCgICAgDAhCwsgB0EgaiQAIAsLDQAgACABIAJBBBDOAgtfAQN/IwBBEGsiBCQAIAAoAgAhAyAEIAI2AgwgA0EDIAEgAkEAEPAFIAMgAygCECkDgAEgACgCDCAAKAIIIAAoAkAiAQR/IAEoAmhBAEdBAXQFQQALEMoCIARBEGokAAsMACAAQYACaiABECoLKwAgAUHeAU4EQCAAKAIQKAI4IAFBAnRqKAIAIgAgACgCAEEBajYCAAsgAQspACAAIAEgAiADQoCAgIAwQoCAgIAwIARBgM4AchBtIQIgACADEA8gAgsZACAAKAIAIAEQGCEBIABBQGsoAgAgARA5Cy0BAX8CQCAAKAIAIgFFDQAgACgCECIARQ0AIAEoAgAgAEEAIAEoAgQRAQAaCwtcAQF/IABBQGsoAgAiAxDmAkUEQEF/DwsgAkEASARAIAMQMiECCyAAIAFB/wFxEBAgAEFAayIAKAIAIAIQOSAAKAIAKAKkAiACQRRsaiIAIAAoAgBBAWo2AgAgAgsmAQF/IwBBEGsiAiQAIAIgATYCDCAAIAJBDGpBBBByIAJBEGokAAs5ACABQQBOBEAgAEG2ARAQIABBQGsiACgCACABEDkgACgCACIAKAKkAiABQRRsaiAAKAKEAjYCBAsLMwEBfyACBEAgACEDA0AgAyABLQAAOgAAIANBAWohAyABQQFqIQEgAkEBayICDQALCyAACxgBAX4gASkDACEDIAEgAjcDACAAIAMQDwsXACAAIAEgAkKAgICAMCADIARBAhDYAQvABQICfgZ/IwBB4ABrIgkkACADQQAgA0EAShshCwNAIAogC0ZFBEAgACACIApBBHRqIgMoAgAQtAUhBiADLQAEIQdCgICAgDAhBAJAAkACQAJAAkACQAJAAkACQAJAIAMtAAUOCgECAgUHAwQIBQAGCyAAIAMoAggQtAUhCAJ+AkACQAJAIAMoAgxBAWoOAwIAAQkLIAAgACkDwAEiBCAIIARBABAUDAILIAAgACgCKCkDECIEIAggBEEAEBQMAQsgACABIAggAUEAEBQLIQQgACAIEBMgBkHQAUYEQEEBIQcMCAsgBkHZAUcNB0EAIQcMBwsCQCAGQdABRgRAQQEhBwwBCyAGQdkBRw0AQQAhBwsgACABIAZBAiADIAcQlQMaDAcLQoCAgIAwIQUgAygCCARAIAkgAygCADYCECAJQSBqIghBwABBzDwgCUEQahBOGiAAIAMoAgggCEEAQQpBCCADLQAFQQJGGyADLgEGEIIBIQULIAMoAgwEQCAJIAMoAgA2AgAgCUEgaiIIQcAAQcU8IAkQThogACADKAIMIAhBAUELQQkgAy0ABUECRhsgAy4BBhCCASEECyAAIAEgBkKAgICAMCAFIAQgB0GAOnIQbRogACAFEA8gACAEEA8MBgsgAykDCCIEQoCAgIAIfEL/////D1gEQCAEQv////8PgyEEDAULQoCAgIDAfiAEub0iBEKAgICAwIGA/P8AfSAEQv///////////wCDQoCAgICAgID4/wBWGyEEDAQLQoCAgIDAfiADKQMIIgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhshBAwDCyAAIAEgBkECIAMgBxCVAxoMAwsQAQALIAM1AgghBAsgACABIAYgBCAHEBkaCyAAIAYQEyAKQQFqIQoMAQsLIAlB4ABqJAALMgEBfwJAIAFCIIinQXVJDQAgAaciAiACKAIAIgJBAWs2AgAgAkEBSg0AIAAgARCWBAsLCwAgAEGAMUEAEBULogICAn4BfwJAAkACQAJAAkACQAJAAkACQAJAAkBBByABQiCIpyIEIARBB2tBbkkbQQtqDhMEAgMIBgAAAAAAAQUHAAAAAAEFAAsgAEGVMEEAEBVCgICAgOAADwsgBEF1SQ0IIAGnIgAgACgCAEEBajYCAAwICyAAQSEQdiECDAYLIABBIhB2IQIMBQsgAEEkEHYhAgwECyAAQQQQdiECDAMLIAAgAEEFEHYiAkEwIAGnKQIEQv////8Hg0EAEBkaDAILIABBBhB2IQIMAQsgAEEHEHYhAgtCgICAgOAAIQMgAkKAgICAcINCgICAgOAAUgR+IARBdU8EQCABpyIEIAQoAgBBAWo2AgALIAAgAiABENsBIAIFQoCAgIDgAAsPCyABC9kBAgJ/AX5BfyECAkACQAJAAkACQAJAAkACQCABQiCIpyIDQQtqDhIHBwcFAgUFBQUFBAABAQEFBQYFCyABp0EARw8LIAGnDwsgAacpAgQhBCAAIAEQDyAEQv////8Hg0IAUg8LAAsgAacsAAUhAiAAIAEQDyACQQBODwsgA0EHa0FtTQRAIAFCgICAgMCBgPz/AHxC////////////AINCAX1CgICAgICAgPj/AFQPCyAAIAEQD0EBIQILIAIPCyABpygCDCECIAAgARAPIAJB/////wdqQX5JC6gEAQt/IAAoAgAhBSMAQRBrIgggAjYCDEF/IQkCQANAAkAgCCACIgNBBGoiAjYCDCADKAIAIgdBf0YNACAAKAIEIQoDQCABIgQgCk4NAyAEIAQgBWoiDC0AACIGQQJ0Ig1BgLgBai0AAGoiASAKSg0DIAZBwgFGBEAgDCgAASEJDAELCyAGIAdHBEAgBiAHQf8BcUYgBiAHQQh2Qf8BcUZyIAYgB0EQdkH/AXFGckUgB0EYdiAGR3EgBkUgB0GAAklycg0DIAAgBjYCEAsgBEEBaiEEAkACQAJAAkACQAJAAkACQCANQYO4AWotAABBBWsOGAAJAAkJAQkJAQkJAQEBAgICAgQFBgcJAwkLIAQgBWotAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCQsgAyAERg0IDAkLIAQgBWovAAAhBCAIIANBCGoiAjYCDCADKAIEIgNBf0YEQCAAIAQ2AhQMCAsgAyAERg0HDAgLIAAgBCAFaigAADYCGAwGCyAAIAQgBWoiAygAADYCGCAAIAMvAAQ2AhwMBQsgACAEIAVqKAAANgIgDAQLIAAgBCAFaiIDKAAANgIgIAAgAy0ABDYCHAwDCyAAIAQgBWoiAygAADYCICAAIAMvAAQ2AhwMAgsgACAEIAVqIgMoAAA2AiAgACADKAAENgIYIAAgAy0ACDYCHAwBCwsgACAJNgIMIAAgATYCCEEBIQsLIAsLCwAgACABQQAQjgQLJAEBfyAAKAIQIgJBEGogASACKAIAEQMAIgFFBEAgABB8CyABCyYBAX8jAEEQayICJAAgAiABOwEOIAAgAkEOakECEHIgAkEQaiQACykBAX8gAgRAIAAhAwNAIAMgAToAACADQQFqIQMgAkEBayICDQALCyAACz8BAX8jAEEQayICJAACfyABIAAoAhBHBEAgAiABNgIAIABBoJgBIAIQFkF/DAELIAAQEgshACACQRBqJAAgAAsLACAAIAFBARDmBQvDCgIFfw9+IwBB4ABrIgUkACAEQv///////z+DIQwgAiAEhUKAgICAgICAgIB/gyEKIAJC////////P4MiDUIgiCEOIARCMIinQf//AXEhBwJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAdB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiC0KAgICAgIDA//8AVCALQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQoMAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhCiADIQEMAgsgASALQoCAgICAgMD//wCFhFAEQCACIAOEUARAQoCAgICAgOD//wAhCkIAIQEMAwsgCkKAgICAgIDA//8AhCEKQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAIAEgC4QhAkIAIQEgAlAEQEKAgICAgIDg//8AIQoMAwsgCkKAgICAgIDA//8AhCEKDAILIAEgC4RQBEBCACEBDAILIAIgA4RQBEBCACEBDAILIAtC////////P1gEQCAFQdAAaiABIA0gASANIA1QIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDWCINQiCIIQ4gBSkDUCEBCyACQv///////z9WDQAgBUFAayADIAwgAyAMIAxQIggbeSAIQQZ0rXynIghBD2sQZyAGIAhrQRBqIQYgBSkDSCEMIAUpA0AhAwsgA0IPhiILQoCA/v8PgyICIAFCIIgiBH4iECALQiCIIhMgAUL/////D4MiAX58Ig9CIIYiESABIAJ+fCILIBFUrSACIA1C/////w+DIg1+IhUgBCATfnwiESAMQg+GIhIgA0IxiIRC/////w+DIgMgAX58IhQgDyAQVK1CIIYgD0IgiIR8Ig8gAiAOQoCABIQiDH4iFiANIBN+fCIOIBJCIIhCgICAgAiEIgIgAX58IhAgAyAEfnwiEkIghnwiF3whASAHIAlqIAZqQf//AGshBgJAIAIgBH4iGCAMIBN+fCIEIBhUrSAEIAQgAyANfnwiBFatfCACIAx+fCAEIAQgESAVVK0gESAUVq18fCIEVq18IAMgDH4iAyACIA1+fCICIANUrUIghiACQiCIhHwgBCACQiCGfCICIARUrXwgAiACIBAgElatIA4gFlStIA4gEFatfHxCIIYgEkIgiIR8IgJWrXwgAiACIA8gFFStIA8gF1atfHwiAlatfCIEQoCAgICAgMAAg1BFBEAgBkEBaiEGDAELIAtCP4ghAyAEQgGGIAJCP4iEIQQgAkIBhiABQj+IhCECIAtCAYYhCyADIAFCAYaEIQELIAZB//8BTgRAIApCgICAgICAwP//AIQhCkIAIQEMAQsCfiAGQQBMBEBBASAGayIHQf8ATQRAIAVBMGogCyABIAZB/wBqIgYQZyAFQSBqIAIgBCAGEGcgBUEQaiALIAEgBxCOAiAFIAIgBCAHEI4CIAUpAzAgBSkDOIRCAFKtIAUpAyAgBSkDEISEIQsgBSkDKCAFKQMYhCEBIAUpAwAhAiAFKQMIDAILQgAhAQwCCyAEQv///////z+DIAatQjCGhAsgCoQhCiALUCABQgBZIAFCgICAgICAgICAf1EbRQRAIAogAkIBfCIBUK18IQoMAQsgCyABQoCAgICAgICAgH+FhFBFBEAgAiEBDAELIAogAiACQgGDfCIBIAJUrXwhCgsgACABNwMAIAAgCjcDCCAFQeAAaiQACyEAIAAgASACQoCAgIAwIAMgBEECENgBIQIgACABEA8gAgumAQEEfyAAQQA2AgQgAVAEQCAAQYCAgIB4NgIIIABBABBBGkEADwsCQCABQv////8PWARAIABBARBBDQEgACgCECABIAGnZyICrYY+AgAgAEEgIAJrNgIIQQAPCyAAQQIQQQ0AIAAoAhAiAyABpyIEIAFCIIinIgVnIgJ0NgIAIAMgBSACdCAEQSAgAmt2cjYCBCAAQcAAIAJrNgIIQQAPCyAAEDVBIAt/AgJ/AX4gAUIgiKciAyABpyICQQBIckUEQCACQYCAgIB4cg8LIANBeEYEQCAAIAAoAhAgAhDBAhAYDwsgACABEIMEIgFCgICAgHCDIgRCgICAgOAAUQRAQQAPCyAEQoCAgICAf1EEQCAAKAIQIAEQjQIPCyAAKAIQIAGnEPwDCwkAIABBfxDIAwtqAQJ/AkAgACgC2AIiA0UNACAAKALgAiIEIAAoAtwCTg0AIAAoAugCIAFLDQAgACgC5AIgAkYNACADIARBA3RqIgMgAjYCBCADIAE2AgAgACABNgLoAiAAIARBAWo2AuACIAAgAjYC5AILCxAAIAAgACgCKCkDCEEBEEkLGQAgAEEAEEEaIABCgICAgPD/////ADcCBAuDAgIDfwF+QoCAgIDgACEEIAAoAhQEfkKAgICA4AAFIAAoAgQhASAAKAIIIgJFBEAgACgCACgCECICQRBqIAEgAigCBBEAACAAQQA2AgQgACgCAEEvEC0PCyAAKAIMIAJKBEAgACgCACgCECIDQRBqIAEgAiAAKAIQIgF0IAFrQRFqIAMoAggRAQAiAUUEQCAAKAIEIQELIAAgATYCBAsgASAAKAIQIgIEfyACBSABIAAoAghqQQA6ABAgACgCEAtBH3StIAEpAgRC/////3eDhCIENwIEIAEgBEKAgICAeIMgADUCCEL/////B4OENwIEIABBADYCBCABrUKAgICAkH+ECwsUAQF+IAAgARAoIQIgACABEA8gAgtLAQJ/IAFCgICAgHBaBH8gAaciAy8BBiICQQ1GBEBBAQ8LIAJBMEYEQCADKAIgLQAQDwsgACgCECgCRCACQRhsaigCEEEARwVBAAsLDAAgAEGAAmogARAdCywBAX8jAEEQayIDJAAgAyACNgIMIABB3ABqQYABIAEgAhDLAhogA0EQaiQAC2kBAn8CfyAAKAIIIgIgACgCDE4EQEF/IAAgAkEBaiABELcCDQEaIAAoAgghAgsgACACQQFqNgIIIAAoAgRBEGohAwJAIAAoAhAEQCADIAJBAXRqIAE7AQAMAQsgAiADaiABOgAAC0EACws1ACAAIAJBMCACQQAQFCICQoCAgIBwg0KAgICA4ABRBEAgAUIANwMAQX8PCyAAIAEgAhCjAQsNACAAIAEgAkEAEIoDCx8BAX8gACgCJCIBIAEoAgBBAWo2AgAgACABQQIQ7wULaQEDfwJAIAAiAUEDcQRAA0AgAS0AAEUNAiABQQFqIgFBA3ENAAsLA0AgASICQQRqIQEgAigCACIDQX9zIANBgYKECGtxQYCBgoR4cUUNAAsDQCACIgFBAWohAiABLQAADQALCyABIABrCx8AIAAgASAAIAIQqgEiAiADQYCAARDQARogACACEBMLTwEBfwJ/QQAgACgCDCABRg0AGiAAKAIAIgIoAgAgACgCECABQQJ0IAIoAgQRAQAhAiABBEBBfyACRQ0BGgsgACABNgIMIAAgAjYCEEEACwsoAQF/IAJCIIinQXVPBEAgAqciAyADKAIAQQFqNgIACyAAIAEgAhBuC7IEAQh/IwBBIGsiByQAIAEgAiABKAIMIAIoAgxJIgYbIggoAgQgAiABIAYbIgkoAgRzIQoCQAJAIAgoAgwiAkUEQAJAIAkoAggiAUH/////B0cEQCAIKAIIIgJB/////wdHDQELIAAQNUEAIQIMAwsgAUH+////B0cgAkH+////B0dxRQRAAkAgAUH+////B0YEQCACQYCAgIB4Rg0BDAQLIAFBgICAgHhHIAJB/v///wdHcg0DCyAAEDVBASECDAMLIAAgChCJAUEAIQIMAgsgCSgCDCIGIQUgAiEBIARBB3FBBkYEQCACIANBIWpBBXYiBSACIAVIGyEBIAYgBSAFIAZKGyEFCyAIKAIQIAJBAnRqIAFBAnRrIQsgCSgCECAGQQJ0aiAFQQJ0ayEMAn8CQAJAAkAgAUHkAE8EQEEAIQYgACgCACAAIAwgBSALIAEgACAJRiIBQQJyIAEgACAIRhsQnwYNAQwDCwJ/AkAgACAJRg0AQQAhBiAAIAhGDQAgAAwBCyAAKAIAIQIgB0IANwIYIAdCgICAgICAgICAfzcCECAHIAI2AgwgACEGIAdBDGoLIgIgASAFahBBRQ0BIAIhAAsgABA1QSAMAgsgAigCECAMIAUgCyABEJ4GIAIhAAsgACAKNgIEIAAgCCgCCCAJKAIIajYCCCAAIAMgBBCzAgshAiAAIAdBDGpHDQEgBiAHQQxqEKAGDAELIAAgChCMAUEAIQILIAdBIGokACACC0gAIAAgAUcEQCAAIAEoAgwQQQRAIAAQNUEgDwsgACABKAIENgIEIAAgASgCCDYCCCAAKAIQIAEoAhAgASgCDEECdBAfGgtBAAsRACAAIAEgAiADQYCAARDQAQsNACAAIAEgAkEGEM4CCwoAIAAgAUEBEEkLHQAgACABKQMQEA8gACABKQMYEA8gACABKQMIEA8LpgEBA38gACgCECIDKALUASABp0EAIAFC/////29WGyIEQYGA3PF5bEH//6OOBmsiBUEgIAMoAsgBa3ZBAnRqIQMCQAJAA0AgAygCACIDBEACQCADKAIUIAVHDQAgAygCLCAERw0AIAMoAiBFDQMLIANBKGohAwwBCwsgACAEQQIQxQQiAw0BQoCAgIDgAA8LIAMgAygCAEEBajYCAAsgACADIAIQ7wULJgEBfwJAIAAoAhBBg39HDQAgACgCICABRw0AIAAoAiRFIQILIAILOAEBfwJAAkAgAUKAgICAcFQNACABpyIDLwEGIAJHDQAgAygCICIDDQELIAAgAhCGA0EAIQMLIAMLlQUCA38BfgJAAkACQAJAAkACQANAIAIoAhAiBEEwaiEFIAQgBCgCGCADcUF/c0ECdGooAgAhBANAIARFDQQgAyAFIARBAWtBA3QiBmoiBCgCBEcEQCAEKAIAQf///x9xIQQMAQsLIAIoAhQgBmohBSAEKAIAIQYgAUUNASABQoCAgIAwNwMYIAFCgICAgDA3AxAgAUKAgICAMDcDCCABIAZBGnZBB3EiBjYCAAJAAkACQAJAIAQoAgBBHnZBAWsOAwABAgMLIAEgBkEQcjYCACAFKAIAIgAEQCAAIAAoAgBBAWo2AgAgASAArUKAgICAcIQ3AxALIAUoAgQiAEUNCSAAIAAoAgBBAWo2AgAgASAArUKAgICAcIQ3AxhBAQ8LIAUoAgAoAhApAwAiB0KAgICAcINCgICAgMAAUQ0EIAdCIIinQXVPBEAgB6ciACAAKAIAQQFqNgIACyABIAc3AwgMCAsgACACIAMgBSAEEMgCRQ0BDAYLCyAFKQMAIgdCIIinQXVPBEAgB6ciACAAKAIAQQFqNgIACyABIAc3AwgMBQtBASEEIAZBgICAgHxxQYCAgIB4Rw0CIAUoAgAoAhA1AgRCIIZCgICAgMAAUg0CCyAAIAMQ2QEMAgtBACEEIAItAAUiBUEEcUUNACAFQQhxBEAgA0EATg0BIANB/////wdxIgMgAigCKCIFSSEEIAFFIAMgBU9yDQEgAUKAgICAMDcDGCABQoCAgIAwNwMQIAFBBzYCACABIAAgAq1CgICAgHCEIAMQsAE3AwgMAwsgACgCECgCRCACLwEGQRhsaigCFCIFRQ0AIAUoAgAiBUUNACAAIAEgAq1CgICAgHCEIAMgBREXACEECyAEDwtBfw8LQQELoQQBAn8CQAJAIAFCgICAgHBUIAJC/////w9Wcg0AIAKnIgQgAaciAygCKE8NAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAy8BBkECaw4eAAsLCwsLAAsLCwsLCwsLCwsLCwIBAgMEBQYHCAkKCwsgAygCJCAEQQN0aikDACIBQiCIp0F1SQ0LIAGnIgAgACgCAEEBajYCACABDwsgAygCJCAEajAAAEL/////D4MPCyADKAIkIARqMQAADwsgAygCJCAEQQF0ajIBAEL/////D4MPCyADKAIkIARBAXRqMwEADwsgAygCJCAEQQJ0ajUCAA8LIAMoAiQgBEECdGooAgAiAEEATgRAIACtDwtCgICAgMB+IAC4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwsgACADKAIkIARBA3RqKQMAEIcCDwsgACADKAIkIARBA3RqKQMAEPsDDwtCgICAgMB+IAMoAiQgBEECdGoqAgC7vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbDwtCgICAgMB+IAMoAiQgBEEDdGopAwAiAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGw8LIAAgAhAxIQMgACACEA8gA0UEQEKAgICA4AAPCyAAIAEgAyABQQAQFCEBIAAgAxATCyABCyoBAX8jAEEQayIEJAAgBCADNgIMIAAgASACIAMQywIhACAEQRBqJAAgAAuMAQECfyABKAJ8IgRBgIAETgRAIABBjTpBABBGQX8PC0F/IQMgACABQfQAakEQIAFB+ABqIARBAWoQeAR/QX8FIAEgASgCfCIDQQFqNgJ8IAEoAnQgA0EEdGoiA0IANwIAIANCADcCCCADIAAgAhAYNgIA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AwsNACAAIAEgARA/EJMCC20BAX8jAEGAAmsiBSQAIARBgMAEcSACIANMckUEQCAFIAFB/wFxIAIgA2siA0GAAiADQYACSSIBGxArGiABRQRAA0AgACAFQYACEFsgA0GAAmsiA0H/AUsNAAsLIAAgBSADEFsLIAVBgAJqJAALDAAgAEGAAmogARARC74BAgF+AX8CQAJAIAFCgICAgHCDQoCAgIAwUQRAIAAoAiggAkEDdGopAwAiA0IgiKdBdEsNAQwCCyAAIAFBOyABQQAQFCIDQoCAgIBwg0KAgICA4ABRBEAgAw8LIANC/////29WDQEgACADEA8gACABEIADIgRFBEBCgICAgOAADwsgBCgCKCACQQN0aikDACIDQiCIp0F1SQ0BCyADpyIEIAQoAgBBAWo2AgALIAAgAyACEEkhASAAIAMQDyABC3UBAX4gACABIAR+IAIgA358IANCIIgiAiABQiCIIgR+fCADQv////8PgyIDIAFC/////w+DIgF+IgVCIIggAyAEfnwiA0IgiHwgASACfiADQv////8Pg3wiAUIgiHw3AwggACAFQv////8PgyABQiCGhDcDAAtQAQF+AkAgA0HAAHEEQCABIANBQGqthiECQgAhAQwBCyADRQ0AIAIgA60iBIYgAUHAACADa62IhCECIAEgBIYhAQsgACABNwMAIAAgAjcDCAtVAQN/IAEgAkEFdSIESwRAIAAgBEECdGooAgAhAwsgAkEfcSICBH8gASAEQQFqIgRLBH8gACAEQQJ0aigCAAVBAAtBAXQgAkEfc3QgAyACdnIFIAMLC2QAAkACQCABQQBIDQAgACgCrAIgAUwNACAAKAKkAiABQRRsaiIAIAAoAgAgAmoiADYCACAAQQBIDQEgAA8LQYUpQa78AEHIqAFBlNUAEAAAC0GmjgFBrvwAQcuoAUGU1QAQAAALYAAgACABIAJCgICAgAh8Qv////8PWAR+IAJC/////w+DBUKAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLIANBh4ABEL0BCwwAIABBhvsAQQAQFQsLACAAIAFBARDBBQvSEAIMfwF+IwBBEGsiCiQAAkACQCABQv////9vWARAIAAQJAwBCyAGQYAwcSIORSAGIAZBCHYiEHEgEEF/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A6ciAiACKAIAQQFqNgIACyAAIAkgAyAGEMsFIQILIAZBggRxQYAERgRAIAogCSgCECIGQTBqNgIMQX8hByAAIAkgCkEMaiAGKAIwQRp2QT1xEJEDDQULIAIhBwwECyAMBEAgACAIKQMAEA8gA0IgiKdBdU8EQCADpyICIAIoAgBBAWo2AgALIAggAzcDAAsgBkGABHFFDQBBfyEHIAAgCSAKQQxqIAooAgwoAgBBGnZBPXEgBkECcXIQkQMNAwtBf0EBIAAgCSAKQQxqIBBBBXEiAEF/cyAKKAIMKAIAQRp2cSAAIAZxchCRAxshBwwCCyAAIAZB4ekAEG8hBwwBC0F/IQcLIApBEGokACAHC/8BAgJ/AXwjAEEQayIEJAACQCACQiCIpyIDQQJNBEAgASACp7c5AwBBACEADAELIANBB2tBbU0EQCABIAJCgICAgMCBgPz/AHw3AwBBACEADAELAn8gACACEI0BIgJCgICAgHCDQoCAgIDgAFEEQEQAAAAAAAD4fyEFQX8MAQsCfAJAAkBBByACQiCIpyIDIANBB2tBbkkbIgNBCmpBAk8EQCADQQdGDQIgAw0BIAKntwwDCyACp0EEaiAEQQhqELUFIAAgAhAPIAQrAwghBUEADAMLEAEACyACQoCAgIDAgYD8/wB8vwshBUEACyEAIAEgBTkDAAsgBEEQaiQAIAALXQECfyMAQRBrIgMkAAJAIAFBgIABcUUEQCABQYCAAnFFDQEgACgCECgCjAEiAUUNASABLQAoQQFxRQ0BCyADQQA2AgwgAEEEIAJBABCSBEF/IQQLIANBEGokACAEC8YJAgR/BX4jAEHwAGsiBiQAIARC////////////AIMhCQJAAkAgAVAiBSACQv///////////wCDIgpCgICAgICAwP//AH1CgICAgICAwICAf1QgClAbRQRAIANCAFIgCUKAgICAgIDA//8AfSILQoCAgICAgMCAgH9WIAtCgICAgICAwICAf1EbDQELIAUgCkKAgICAgIDA//8AVCAKQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQQgASEDDAILIANQIAlCgICAgICAwP//AFQgCUKAgICAgIDA//8AURtFBEAgBEKAgICAgIAghCEEDAILIAEgCkKAgICAgIDA//8AhYRQBEBCgICAgICA4P//ACAC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IAAgAaciAkEAIAIoAgRB/////wdxEFEhAiAAKAIAIAEQDyACC7UCAQd/IwBBEGsiBSQAAkAgAEFAaygCACIBRQRADAELAkAgAQJ/IAEoAsgBIgQgASgCxAEiAkgEQCABKALMASEDIAQMAQsgBEEBaiIDIAJBA2xBAm0iAiACIANIGyIGQQN0IQIgACgCACEDAkAgASgCzAEiByABQdABakYEQCADQQAgAiAFQQxqEKgBIgNFDQMgAyABKALMASABKALIAUEDdBAfGgwBCyADIAcgAiAFQQxqEKgBIgNFDQILIAUoAgwhAiABIAM2AswBIAEgAkEDdiAGajYCxAEgASgCyAELQQFqNgLIASADIARBA3RqIgIgASgCvAE2AgAgAiABKALAATYCBCAAQbQBEBAgAEFAaygCACAEQf//A3EQFyABIAQ2ArwBDAELQX8hBAsgBUEQaiQAIAQLoQECA38BfiMAIQYCQCACQoCAgIBwVA0AIAKnIgUvAQZBMEcNACAFKAIgIQQLAn8gBiAAKAIQKAJ4SQRAIAAQ6QFBAAwBCyAELQARBEAgABC2AkEADAELQQAgACAEKQMIIgIgAyACQQAQFCIHQoCAgIBwgyICQoCAgIDgAFENABogAUKAgICAMCAHIAJCgICAgCBRGzcDACAECyEFIAYkACAFCxYAIAAgASACIAMgBCAFIAApAzAQ8QELKQEBfyMAQRBrIgIkACACIAA2AgwgAkEMaiABEJMEIQAgAkEQaiQAIAALngICA38BfiACIAEpAgQiB6dB/////wdxIANHckUEQCABIAEoAgBBAWo2AgAgAa1CgICAgJB/hA8LIAFBEGohBSAHQoCAgIAIg1AgAyACayIEQQBMckUEQCADIAIgAiADSBshBkEAIQMgAiEBA0AgASAGRkUEQCAFIAFBAXRqLwEAIANyIQMgAUEBaiEBDAELCyADQf//A3FBgAJPBEAgACAFIAJBAXRqIAQQ7gMPC0EAIQEgACAEQQAQ6gEiAEUEQEKAgICA4AAPCyAAQRBqIQMDQCABIARGRQRAIAEgA2ogBSABIAJqQQF0ai0AADoAACABQQFqIQEMAQsLIAMgBGpBADoAACAArUKAgICAkH+EDwsgACACIAVqIAQQhAMLugEBAn8CQAJAIAJC/////wdYBEAgACABIAKnQYCAgIB4chBx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IANBCGogAhDiA0UEQEEAIQQgASADKQMIIgJCgICAgICAgBBaBH4gAEGAIEEAEFBBfyEEQgAFIAILNwMACyADQRBqJAAgBAsRACAAIAEgASACIANBAhCKBAtTAQF/IAAoAhAiBEEQaiABIAIgBCgCCBEBACIBIAJFckUEQCAAEHwgAQ8LIAMEQCADIAEgACgCECgCDBEEACIAIAJrIgJBACAAIAJPGzYCAAsgAQvAAQAgAAJ/IAEoAggiAEH+////B04EQEEAIAJBAXENARpB/////wcgAEH+////B0cNARogASgCBEH/////B2oMAQtBACAAQQBMDQAaIABBH00EQEEAIAEoAhAgASgCDEECdGpBBGsoAgBBICAAa3YiAmsgAiABKAIEGwwBCyACQQFxRQRAQYCAgIB4Qf////8HIAEoAgQbDAELQQAgASgCECABKAIMIgIgAkEFdCAAaxBoIgJrIAIgASgCBBsLNgIACw0AIAAgASABED8QhQML+QECA34CfyMAQRBrIgUkAAJ+IAG9IgNC////////////AIMiAkKAgICAgICACH1C/////////+//AFgEQCACQjyGIQQgAkIEiEKAgICAgICAgDx8DAELIAJCgICAgICAgPj/AFoEQCADQjyGIQQgA0IEiEKAgICAgIDA//8AhAwBCyACUARAQgAMAQsgBSACQgAgA6dnQSBqIAJCIIinZyACQoCAgIAQVBsiBkExahBnIAUpAwAhBCAFKQMIQoCAgICAgMAAhUGM+AAgBmutQjCGhAshAiAAIAQ3AwAgACACIANCgICAgICAgICAf4OENwMIIAVBEGokAAu2AQEBfyMAQRBrIgMkAAJAAkAgAkEASARAIAEgAkH/////B3E2AgBBASECDAELIAAoAhAiACgCLCACTQ0BAn8CQCAAKAI4IAJBAnRqKAIAIgApAgRCgICAgICAgIBAg0KAgICAgICAgMAAUg0AIANBDGogABC9BUUNAEEBIAMoAgwiAEF/Rw0BGgtBACEAQQALIQIgASAANgIACyADQRBqJAAgAg8LQe/fAEGu/ABBvxhBryAQAAAL1QECAn8DfgJ/IAJFBEBCgICAgDAhBUEADAELIAAoAhAiAykDgAEhBSADQoCAgIAgNwOAAUF/CyEDAkAgACABQQYgAUEAEBQiB0KAgICAcIMiBkKA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BUEgahBGQX8MAQsCQCABKAIEIARODQAgASAENgIEIARB//8DSA0AIAUgAjYCBCAFIAM2AgAgAEGjkwEgBRBGQX8MAQsgASgCCCACQQF0aiIDLwEAIgZB//8DRwRAQQAgBCAGRg0BGiAFIAI2AhggBSAENgIUIAUgBjYCECAAQdSSASAFQRBqEEZBfwwBCyADIAQ7AQBBfyAAIAFBDGpBBCABQRRqIAEoAhBBAWoQeA0AGiABIAEoAhAiAEEBajYCECABKAIMIABBAnRqIAI2AgBBAAshAyAFQTBqJAAgAwsTACAAIAEgAiADIARBAEEAEPgBCzkAIABB/wBNBEAgAEEDdkH8////AXFBoIECaigCACAAdkEBcQ8LIABBfnFBjMAARiAAENIEQQBHcgtmAQF/An9BACAAKAIIIgIgAU8NABpBfyAAKAIMDQAaIAAoAhQgACgCACACQQNsQQF2IgIgASABIAJJGyIBIAAoAhARAQAiAkUEQCAAQQE2AgxBfw8LIAAgATYCCCAAIAI2AgBBAAsLrAECAX8BfiAAKQIEIgSnQf////8HcSEDAkACQCAEQoCAgIAIg1BFBEAgAiADIAIgA0obIQMgAEEQaiEAA0AgAiADRg0CIAAgAkEBdGovAQAgAUYNAyACQQFqIQIMAAsACyABQf8BSw0AIAIgAyACIANKGyEDIABBEGohACABQf8BcSEBA0AgAiADRg0BIAAgAmotAAAgAUYNAiACQQFqIQIMAAsAC0F/IQILIAILpgEBAX8jAEEQayIDJAAgAyACNwMIAkAgACABQYYBIAFBABAUIgJCgICAgHCDQoCAgIDgAFENACAAIAIQOARAIAAgAiABQQEgA0EIahAvIgJC/////29WIAJCgICAgLB/g0KAgICAIFFyDQEgACACEA8gAEGK0wBBABAVQoCAgIDgACECDAELIAAgAhAPIAAgASADIANBCGoQ8QQhAgsgA0EQaiQAIAILowECA38BfiAAQRBqIQIgASgCACIEQQFqIQMCQCAAKQIEIgVCgICAgAiDUEUEQCACIARBAXRqLwEAIgBBgPgDcUGAsANHIAMgBadB/////wdxTnINASACIANBAXRqLwEAIgJBgPgDcUGAuANHDQEgAEEKdEGA+D9xIAJB/wdxckGAgARqIQAgBEECaiEDDAELIAIgBGotAAAhAAsgASADNgIAIAALUQEDfwJAA0AgAUKAgICAcFQNASABpyICLwEGIgRBMEYEQCACKAIgIgJFDQIgAi0AEQRAIAAQtgJBfw8LIAIpAwAhAQwBCwsgBEECRiEDCyADCxIAIAAgASACIAMgBEHKABCkBAtOAQF/IAAoAgwiBEUEQEEADwsgACAAKAIIQf////8DQYGAgIB8IAEgAUGBgICAfEwbIgEgAUH/////A04bajYCCCAAIAIgAyAEQQAQqgMLJQAgACABIAAoAhAoAowBIgAEfyAAKAIoQQJ2QQFxBUEACxCWBQsfAQF/IAAoAgwiA0UEQEEADwsgACABIAIgA0EAEKoDC90BAgJ/An4CQCAAIAApAzBBDxBJIghCgICAgHCDQoCAgIDgAFENACAAIARBA3RBCGoQKSIGRQRAIAAgCBAPDAELIAYgAzsBBiAGIAQ6AAUgBiACOgAEIAYgATYCAEEAIQMgBEEAIARBAEobIQEDQCABIANHBEAgBSADQQN0IgRqKQMAIglCIIinQXVPBEAgCaciByAHKAIAQQFqNgIACyAEIAZqIAk3AwggA0EBaiEDDAELCyAIQoCAgIBwWgRAIAinIAY2AiALIAAgCEEvIAIQlgMgCA8LQoCAgIDgAAuDCwIHfwF+IwBBIGsiCSQAAkACQAJAAkACQAJAAn8CQAJAAkACQAJAIAFCIIinQQFqDgUDAgIAAQILIAAgAxAPIAAgAkHm0wAQjwFBfyEFDAoLIAAgAxAPIAAgAkHR+AAQjwFBfyEFDAkLIAAgARCNBKchBgwBCyABpyEGAkADQCAGKAIQIgdBMGohCCAHIAcoAhggAnFBf3NBAnRqKAIAIQUDQCAFRQRAIAYhB0EADAULIAIgCCAFQQFrQQN0IgdqIgUoAgRHBEAgBSgCAEH///8fcSEFDAELCyAGKAIUIAdqIQcgBSgCACIIQYCAgMB+cUGAgIDAAEYEQCAAIAcgAxAgDAULAkAgCEGAgICAAnEEQCAGLwEGQQJHDQEgAkEwRw0DIAAgBiADIAQQywUhBQwLCyAIQRp2QTBxIghBMEcEQCAIQSBHBEAgCEEQRw0IIAAgBygCBCABIAMgBBCLAyEFDAwLIAYvAQZBC0YNByAAIAcoAgAoAhAgAxAgDAYLIAAgBiACIAcgBRDIAkUNAQwJCwtB2YABQa78AEGPwgBBuNYAEAAAC0HK2ABBrvwAQZDCAEG41gAQAAALQQELIQUDQAJAAkAgBUUEQAJAIAYtAAUiBUEEcUUNAAJAIAVBCHEEQCACQQBIBEAgAkH/////B3EiBSAGKAIoTw0CIAYgB0cNBSAAIAEgBa0gAyAEENcBIQUMDQsgBi8BBkEVa0H//wNxQQpLDQIgACACEJ4DIghFDQJBfyEFIAhBAE4NCQwKCyAAKAIQKAJEIAYvAQZBGGxqKAIUIgVFDQEgBSgCGCIIBEAgBiAGKAIAQQFqNgIAIAAgBq1CgICAgHCEIgwgAiADIAEgBCAIES0AIQUgACAMEA8MCgsgBSgCACIFRQ0BIAYgBigCAEEBajYCACAAIAkgBq1CgICAgHCEIgwgAiAFERcAIQUgACAMEA8gBUEASA0JIAVFDQEgCS0AAEEQcQRAIAAgCSkDGCIMp0EAIAxCgICAgHCDQoCAgIAwUhsgASADIAQQiwMhBSAAIAkpAxAQDyAAIAkpAxgQDwwMCyAAIAkpAwgQDyAJLQAAQQJxRQ0HIAYgB0cNAyAAIAEgAiADQoCAgIAwQoCAgIAwQYDAABBtIQUMCQsgBi8BBkEVa0H//wNxQQtJDQcLIAYoAhAoAiwhBkEBIQUMAwsgBkUNAANAIAYoAhAiBUEwaiEKIAUgBSgCGCACcUF/c0ECdGooAgAhBQNAIAVFDQMgAiAKIAVBAWtBA3QiBWoiCCgCBEcEQCAIKAIAQf///x9xIQUMAQsLIAYoAhQgBWohCgJAIAgoAgAiBUEadkEwcSILQTBHBEAgC0EQRw0BIAAgCigCBCABIAMgBBCLAyEFDAsLQX8hBSAAIAYgAiAKIAgQyAJFDQEMCgsLIAVBgICAwABxDQEMBAsgBEGAgARxBEAgACADEA8gACACEMcCQX8hBQwICyAHRQRAIAAgAxAPIAAgBEGAMRBvIQUMCAsgBy0ABSIGQQFxRQRAIAAgAxAPIAAgBEH36AAQbyEFDAgLIAZBBHEEQAJAIAJBAE4NACAGQQhxRSAHLwEGQQJHcg0AIAcoAiggAkH/////B3FHDQAgACAHIAMgBBD9AyEFDAkLIAAgByACIANCgICAgDBCgICAgDAgBEGHzgByEIEEIQUMBgsgACAHIAJBBxB6IgJFDQYgAiADNwMADAILQQAhBQwACwALQQEhBQwECyAAIAMQDyAAIAQgAhDAAiEFDAMLIAAgACADEI0BIgEQD0F/IQUgAUKAgICAcINCgICAgOAAUQ0CIAAgBEGUIBBvIQUMAgsgACADEA8MAQsgACADEA9BfyEFCyAJQSBqJAAgBQsOACAAQQAgAUEQchDOAQthACAAIAEgAkKAgICACHxC/////w9YBH4gAkL/////D4MFQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsgAyAEQQdyEL0BC6sBAQh/IAAoAggiAyABKAIIIgJHBEBBf0EBIAIgA0obDwsgASgCDCIFIAAoAgwiBiAFIAUgBkgbIgJrIQggBiACayEJAn8DQEEAIAJBAWsiAkEASA0BGkEAIQNBACEEIAIgCWoiByAGSQRAIAAoAhAgB0ECdGooAgAhBAsgAiAIaiIHIAVJBEAgASgCECAHQQJ0aigCACEDCyADIARGDQALQX9BASADIARLGwsLigEBAn8gASgCECIDLQAQRQRAQQAPCwJAIAMoAgBBAUcEQCACBH8gAigCACADa0Ewa0EDdQVBAAshBCAAIAMQzgUiA0UEQEF/DwsgACgCECABKAIQEJECIAEgAzYCECACRQ0BIAIgAyAEQQN0akEwajYCAEEADwsgACgCECADEJAEIANBADoAEAtBAAt7AQF/QX8hBAJAIAAgARAlIgFCgICAgHCDQoCAgIDgAFENACAAIAGnIAIQ+QMhBCAAIAEQDyAEDQAgA0GAgAFxRQRAQQAhBCADQYCAAnFFDQEgACgCECgCjAEiAkUNASACLQAoQQFxRQ0BCyAAQawbQQAQFUF/IQQLIAQLNQAgACACQTAgAkEAEBQiAkKAgICAcINCgICAgOAAUQRAIAFBADYCAEF/DwsgACABIAIQmAELxAUBBH8jAEEgayIIJAACQAJAAkACQAJAIAFCgICAgHBUIAJC/////w9Wcg0AIAKnIQYCQAJAAkACQAJAAkACQAJAAkACQCABpyIFLwEGQQJrDh4ACgoKCgoJCgoKCgoKCgoKCgoKBwYGBQUEBAMDAgEKCyAFKAIoIgcgBksNCyAGIAdHDQkgBS0ABUEJcUEJRw0JIAUoAhAhBgNAAkAgBigCLCIHBEAgBygCECEGAkAgBy8BBkEBaw4CAAINCyAGLQARRQ0CDAwLIAAgBSADIAQQ/QMhBwwPCyAHLQAFQQhxDQALDAkLQX8hByAAIAhBGGogAxBuDQwgBSgCKCAGTQ0GIAUoAiQgBkEDdGogCCsDGDkDAAwLC0F/IQcgACAIQRhqIAMQbg0LIAUoAiggBk0NBSAFKAIkIAZBAnRqIAgrAxi2OAIADAoLIAAgCEEIaiADEMUFDQcgBSgCKCAGTQ0EIAUoAiQgBkEDdGogCCkDCDcDAAwJC0F/IQcgACAIQRRqIAMQmAENCSAFKAIoIAZNDQMgBSgCJCAGQQJ0aiAIKAIUNgIADAgLQX8hByAAIAhBFGogAxCYAQ0IIAUoAiggBk0NAkEBIQcgBSgCJCAGQQF0aiAIKAIUOwEADAgLQX8hByAAIAhBFGogAxCYAQ0HIAUoAiggBk0NASAFKAIkIAZqIAgoAhQ6AAAMBgtBfyEHIAAgCEEUaiADEMQFDQYgBSgCKCAGTQ0AIAUoAiQgBmogCCgCFDoAAAwFCyAAIARBlCAQbyEHDAULIAUoAiggBk0NACAAIAUoAiQgBkEDdGogAxAgDAMLIAAgAhAxIQUgACACEA8gBUUEQCAAIAMQDwwBCyAAIAEgBSADIAQQ0AEhByAAIAUQEwwDC0F/IQcMAgsgACAFKAIkIAZBA3RqIAMQIAtBASEHCyAIQSBqJAAgBwuuyAEDJn8HfgN8IwBBoAFrIgghDiAIJAAgACgCECEWQoCAgIDgACEuAkAgABB7DQACfwJAAkACQAJAAkAgAUL/////b1gEQCAGQQRxRQ0BIAGnIgcoAjwhCCAHKAIYIhooAiQhFCAaKAIgIhMoAjAhBiATLwEqIQ0gB0EANgI8IAcgFigCjAE2AhAgBygCICEVIAcoAjAhCiAHKAIkIREgFiAHQRBqIhI2AowBIBEgDUEDdGohHCAVIRcgCiENIAcoAgxFDQQMBQsgAaciGi8BBiIHQQ1GDQIgFigCRCAHQRhsaigCECIIDQELIABBm8wAQQAQFQwFCyAAIAEgAiAEIAUgBiAIERYAIS4MBAsgFigCeCAOIBooAiAiEy8BLiATLwEqIgtqIBMvASgiByAHQQAgBCAHSBsgBkECcUEBdhsiBmpBA3QiFWtLBEAgABDpAQwECyATLQAQIQogDiAOQcgAaiIXNgJMIA4gBDYCVCAOIAo2AlggDiAXNgJIIA4gATcDOCAaKAIkIRQgCCAVQQ9qQfD//wFxayIXJAAgBSEVIAYEQCAHIAQgByAEIAdIGyIIQQAgCEEAShsiCGsiFUEAIAcgFU8bIREDQAJAIAggCUYEQANAIAggEUYNAiAXIAhBA3RqQoCAgIAwNwMAIAhBAWohCAwACwALIAUgCUEDdCIVaikDACIBQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgFSAXaiABNwMAIBFBAWohESAJQQFqIQkMAQsLIA4gBzYCVCAXIRULIA4gFTYCQCAOIBcgBkEDdGoiETYCREEAIQgDQCAIIAtHBEAgESAIQQN0akKAgICAMDcDACAIQQFqIQgMAQsLIBMoAhQhCiAOIBYoAowBNgIwIBYgDkEwaiISNgKMASATKAIwIQYgESALQQN0aiIIIRwLQQAMAQtBAQshBwNAAkACQAJAAkAgB0UEQCAEQQN0IScgA0KAgICAcIMhMyARQQhqIR0gEUEQaiEeIBFBGGohHyAVQQhqISAgFUEQaiEhIBVBGGohIiASQRhqISggBkHIAWohGyAcQRhqISkgBkHAAWohGSACQiCIpyIkQX5xISogA0IgiKchKyAErSEyIAOnISUgDkEwaiEsIA5B6ABqISYgCCEHAkADQAJAIApBAWohDUIBIS5CgICAgDAhAQJ/AkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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ajYCAAsgCCABNwMIIAhBCGspAwAiAUIgiKdBdU8EQCABpyIHIAcoAgBBAWo2AgALIAggATcDECAIQRhqIQcM2wELIAggCEEIayIHKQMANwMAIAhBEGspAwAiAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2gELIAggCEEIayIHKQMAIgE3AwAgByAIQRBrIgcpAwA3AwAgAUIgiKdBdU8EQCABpyIKIAooAgBBAWo2AgALIAcgATcDACAIQQhqIQcM2QELIAggCEEIayIHKQMAIgE3AwAgCEEQayIKKQMAIS0gCiAIQRhrIgopAwA3AwAgByAtNwMAIAFCIIinQXVPBEAgAaciByAHKAIAQQFqNgIACyAKIAE3AwAgCEEIaiEHDNgBCyAIIAhBCGsiBykDACIBNwMAIAhBEGsiCikDACEtIAogCEEYayIKKQMANwMAIAcgLTcDACAKIAhBIGsiBykDADcDACABQiCIp0F1TwRAIAGnIgogCigCAEEBajYCAAsgByABNwMAIAhBCGohBwzXAQsgCEEQayIHKQMAIQEgByAIQRhrIgcpAwA3AwAgByABNwMADNABCyAIQRhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQQhrIgopAwAhLSAKIAE3AwAgByAtNwMADM8BCyAIQSBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQRBrIgopAwAhLSAKIAhBCGsiCikDADcDACAHIC03AwAgCiABNwMADM4BCyAIQShrIgcpAwAhASAHIAhBIGsiBykDADcDACAIQRhrIgopAwAhLSAKIAhBEGsiCikDADcDACAHIC03AwAgCiAIQQhrIgcpAwA3AwAgByABNwMADM0BCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAIQRhrIgopAwAhLSAKIAE3AwAgByAtNwMADMwBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAE3AwAgByAtNwMADMsBCyAIQRBrIgcpAwAhASAHIAhBGGsiBykDADcDACAIQSBrIgopAwAhLSAKIAhBKGsiCikDADcDACAHIC03AwAgCiABNwMADMoBCyAIQQhrIgcpAwAhASAHIAhBEGsiBykDADcDACAHIAE3AwAMyQEL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ayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSgAACAJakEEawshDSAGEHtFDXUMJwsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gDSwAACAJakEBawUgCQshDSAGEHtFDXQMJgsgCkECaiEJAn8gCEEIayIHKQMAIgFC/////z9YBEAgAacMAQsgBiABECYLBH8gCQUgDSwAACAJakEBawshDSAGEHtFDXMMJQsgCCANIAooAAFqIBMoAhRrrUKAgICA0ACENwMAIApBBWohDSAIQQhqIQcMcgsgCigAASEHIAggCiATKAIUa0EFaq03AwAgByANaiENIAhBCGohBwxxCwJAIAhBCGsiBykDACIBQv////8PVg0AIAGnIgkgEygCGE8NACATKAIUIAlqIQ0McQsgBkH14QBBABBGDHQLIAhBCGsiDykDACItQiCIpyIHQQFqIglBBE1BAEEBIAl0QRlxG0UEQCAGIC0Q3AUhLQsCQCAGQRgQKSIJBEAgBkKAgICAIEEREEkiLkKAgICAcINCgICAgOAAUg0BIAYoAhAiB0EQaiAJIAcoAgQRAAALIC0hLgxlCyAJQQA2AhAgCSAtNwMAIAlBADYCCCAupyAJNgIgIAdBfnFBAkYNZSAtIgFCIIinIgdBdU8EQCAtpyILIAsoAgBBAWo2AgALA0AgBiABEIwCIgFCgICAgHCDIi9CgICAgCBSBEAgL0KAgICA4ABRDWYgBiAOQeAAaiAOQYABaiABp0EREI4BDWUgBiAOKAJgIA4oAoABIgsQWiALBEAgBiABEA8gB0F1SQ1lIC2nIgcgBygCAEEBajYCAAxlCyAGEHtFDQEMZQsLAkACQCAtpyIMLQAFQQhxRQ0AQQAhByAMKAIQIgsoAiAiEEEAIBBBAEobIRAgC0EwaiELA0AgByAQRg0CIAstAANBEHENASALQQhqIQsgB0EBaiEHDAALAAsgBiAOQeAAaiAOQYABaiAMQREQjgENZUEAIQcgDigCYCEKIA4oAoABIQkDQCAHIAlHBEAgBiAuIAogB0EDdGooAgRCgICAgCBBABDQARogB0EBaiEHDAELCyAGIAogCRBaDGYLIAlBATYCCCAJIAwoAig2AgwMZQtCgYCAgBAhLgJAIAhBCGspAwAi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/wB8v6G9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMSAsCfCAIQQhrIgcpAwAiLUIgiKciDCAIQRBrIgspAwAiLkIgiKciD3JFBEAgLcQgLsR+IgFCgICAgAh8QoCAgIAQWgRAIBItAChBBHFBACABQoCAgICAgIAQfUKBgICAgICAYFQbDQUgAbkMAgtEAAAAAAAAAIAgLSAuhEKAgICACINQIAFCAFJyRQ0BGiALIAFC/////w+DNwMADEkLIA9BB2tBbUsgDEEHa0FtS3INAyASLQAoQQRxDQMgLkKAgICAwIGA/P8AfL8gLUKAgICAwIGA/P8AfL+iCyE0IAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMRwsgCEEIayIHKQMAIgEgCEEQayILKQMAIi2EQv////8PVg0BIBItAChBBHENASALAn4gLae3IAGnt6MiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIIt71RBEAgCK0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADEYLIAhBCGsiBykDACIBIAhBEGsiCykDACIthEL/////D1YNACAtpyIMQQBIDQAgAaciD0EATA0AIAsgDCAPcK03AwAMRQsjAEEgayIHJAACfwJAAkACQAJAAn4CQAJAAkACQAJAAkACQEEHIAhBEGsiCykDACIBQiCIpyIMIAxBB2tBbkkbIgxBB0dBByAIQQhrIiMpAwAiLkIgiKciDyAPQQdrQW5JGyIPQQdHckUEQCAHIC5CgICAgMCBgPz/AHw3AwggByABQoCAgIDAgYD8/wB8NwMQDAELAkAgDEF/RiAPQX5xQQJHcUUgDEF+cUECRiAPQX9HcnENACAGIAdBGGogASAuIAlBAUEAEIUCIgxFDQAgBiABEA8gBiAuEA8gDEEASA0MIAsgBykDGDcDAAwJCyAGIAEQbCIBQoCAgIBwg0KAgICA4ABRDQogBiAuEGwiLkKAgICAcINCgICAgOAAUQRAIAYgARAPDAwLQQcgAUIgiKciDCAMQQdrQW5JGyIMQQcgLkIgiKciDyAPQQdrQW5JGyIPckUEQCAupyEMIAGnIQ8CQAJAAkACQAJAAkAgCUGaAWsOBgABAgkFAwQLIC7EIAHEfiEtAkAgBigCECIQKAKMASIYRQ0AIBgtAChBBHFFDQAgLUKAgICAgICAEH1CgYCAgICAgGBUDQgLQgAhASAtQgBSDQogDCAPckEATg0LIAtCgICAgMD+/wM3AwAMDgsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0HCyALQoCAgIDAfiAPtyAMt6O9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMDQsgDEEASiAPQQBOcUUEQCALAn4gD7cgDLcQjgMiNL0iAQJ/IDSZRAAAAAAAAOBBYwRAIDSqDAELQYCAgIB4CyIJt71RBEAgCa0MAQtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLNwMADA0LIA8gDHCtIS0MCAsgBigCECIQKAKMASIYBEAgGC0AKEEEcQ0FCyAPtyE0IAsCfgJ8IAy3IjW9QoCAgICAgID4/wCDQoCAgICAgID4/wBRBEBEAAAAAAAA+H8gNJlEAAAAAAAA8D9hDQEaCyA0IDUQjwMLIjS9IgECfyA0mUQAAAAAAADgQWMEQCA0qgwBC0GAgICAeAsiCbe9UQRAIAmtDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCzcDAAwLCyAJQbIBRg0FDAQLIAHEIC7EfSEtDAULIAxBdUcgD0F1R3FFBEAgBiAJIAsgASAuIAYoAhAoAtgCERoADQwMCQsgDEF3RyAPQXdHcUUEQCAGIAkgCyABIC4gBigCECgCvAIRGgBFDQkMDAsgDEF2RyAPQXZHcUUEQCAGKAIQIRAMAgsgBiAHQRBqIAEQbg0KIAYgB0EIaiAuEG4NCwsCQCAGKAIQIhAoAowBIgxFDQAgDC0AKEEEcUUNACAHKwMQEL0CRQ0AIAcrAwgQvQINAQsCQAJAAkACQAJAAkACQCAJQZoBaw4GAAECCAUEAwsgBysDECAHKwMIoiE0DAULIAcrAxAgBysDCKMhNAwECyAHKwMQIAcrAwgQjgMhNAwDCyAJQbIBRw0EIAcrAxAgBysDCJkiNRCOAyI0RAAAAAAAAAAAY0UNAiA1IDSgITQMAgsgBysDECE1IAcrAwgiNr1CgICAgICAgPj/AINCgICAgICAgPj/AFEEQEQAAAAAAAD4fyE0IDWZRAAAAAAAAPA/YQ0CCyA1IDYQjwMhNAwBCyAHKwMQIAcrAwihITQLIAtCgICAgMB+IDS9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhs3AwAMBwsgBiAJIAsgASAuIBAoAqACERoARQ0GDAkLEAEACyAMRQ0FIAHEIC7EIgGBIi1CAFkNACAMQQBIBEAgLSABfSEtDAELIAEgLXwhLQsgLUKAgICACHxC/////w9WDQEgLSEBCyABQv////8PgwwBC0KAgICAwH4gLbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgCyABNwMAC0EADAMLIAZBAhCEAgwBCyAGIC4QDwsgC0KAgICAMDcDACAjQoCAgIAwNwMAQX8LIQkgB0EgaiQAIAkNSCAIQQhrIQcMRAsgCEEEaygCACIHRSAHQQdrQW5Jcg09IAghByAGIAhBjQEQ5gFFDUMMRwsCQAJ8IAhBCGsiBykDACIBQiCIpyIJRQRARAAAAAAAAACAIAGnIgpFDQEaRAAAAAAAAOBBIApBgICAgHhGDQEaIAdCACABfUL/////D4M3AwAMPwsgCUEHa0FtSw0BIAFCgICAgMD+/wN9vwshNCAHQoCAgIDAfiA0vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbNwMADD0LIAghByAGIAhBjAEQ5gFFDUIMRgsgCEEIayIHKQMAIgFC/////w9WIAFC/////w+DQv////8HUXJFBEAgByABQgF8Qv////8PgzcDAAw8CyAIIQcgBiAIQY8BEOYBRQ1BDEULIAhBCGsiBykDACIBQv////8PViABQv////8Pg0KAgICACFFyRQRAIAcgAUIBfUL/////D4M3AwAMOwsgCCEHIAYgCEGOARDmAUUNQAxECyAGIAhBCGsiBykDABBsIgFCgICAgHCDQoCAgIDgAFEEQCAHQoCAgIAwNwMADEQLIAcgATcDACABQiCIp0F1TwRAIAGnIgcgBygCAEEBajYCAAsgCCABNwMAIAYgCEEIaiIHIAlBAmsQ5gFFDT8MQwsgCkECaiENIBEgCi0AAUEDdGoiBykDACIBQv////8PViABQv////8Pg0L/////B1FyRQRAIAcgAUIBfEL/////D4M3AwAMOQsgAUIgiKdBdU8EQCABpyIJIAkoAgBBAWo2AgALIA4gATcDYCAGICZBjwEQ5gENQiAGIAcgDikDYBAgDDgLIApBAmohDSARIAotAAFBA3RqIgcpAwAiAUL/////D1YgAUL/////D4NCgICAgAhRckUEQCAHIAFCAX1C/////w+DNwMADDgLIAFCIIinQXVPBEAgAaciCSAJKAIAQQFqNgIACyAOIAE3A2AgBiAmQY4BEOYBDUEgBiAHIA4pA2AQIAw3CyAIQQhrIgcpAwAiAUL/////D1gEQCAHIAFC/////w+FNwMADDcLIAghByMAQRBrIgkkAAJ/AkACQAJAIAhBCGsiCykDACIBQoCAgIBwVA0AIAYgCUEIaiABQZUBEMIFIgxBAEgNASAMRQ0AIAYgARAPIAsgCSkDCDcDAAwCCwJAIAYgARBsIgFCgICAgHCDIi1CgICAgOAAUQ0AIAYoAhAiDCgCjAEiDwR/IA8tAChBBHFBAnYFQQALRSAtQoCAgIDgflJxRQRAIAYgC0GVASABIAwoApwCERsADQEMAwsgBiAJQQRqIAEQmAENACALIAk1AgRC/////w+FNwMADAILIAtCgICAgDA3AwALQX8MAQtBAAshCyAJQRBqJAAgC0UNPAxACwJAAkACQCAIQQhrIgcpAwAiASAIQRBrIgspAwAiLYRC/////w9WDQAgAachCSASLQAoQQRxRQ0BIAlBH0sNACAtIAGGQoCAgIAIfEKAgICAEFQNAgsgBiAIQaABEMMCRQ09DEELIAlBH3EhCQsgCyAtpyAJdK03AwAMOwsgCEEIayIHKQMAIgEgCEEQayIJKQMAIi2EQv////8PWARAIAkCfiAtpyABp3YiCEEATgRAIAitDAELQoCAgIDAfiAIuL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGws3AwAMOwsjAEEQayIJJAAgCEEIayIMKQMAIS0CfwJAAkAgBiAIQRBrIgspAwAQbCIBQoCAgIBwgyIuQoCAgIDgAFEEQCAGIC0QDwwBCyAGIC0QbCItQoCAgIBw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gICAgOAAIQEgACACKQMAEOgBIgZCgICAgHCDQoCAgIDgAFEEQCAAIAUQDwwGCyAAIAYQDyAGpyAFp0YNBAsgACAFEA8gAEGE5ABBABAVC0KAgICA4AAhAQwDCyACKAIQKAIsIgBFBEBCgICAgCAhAQwDCyAAIAAoAgBBAWo2AgAgAK1CgICAgHCEIQEMAgsgACABEI0EIgFCIIinQXVJDQEgAaciACAAKAIAQQFqNgIADAELIAUhAQsgA0EQaiQAIAELCwAgAEGNIkEAEEYLGgAgACgCECABIAIQ7wQiAUUEQCAAEHwLIAELgAEBAn8CQAJAIAFFDQAgASgCACICQQBMDQEgASACQQFrIgI2AgAgAg0AIAEtAAVBAXEEQCAAIAEpAxgQIwsgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUIANwIIIABBEGogASAAKAIEEQAACw8LQdaNAUGu/ABB9ChB6t0AEAAACxIAIAFB3gFOBEAgACABEOgFCwvbAQIBfwJ+QQEhBAJAIABCAFIgAUL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFEbDQAgAkIAUiADQv///////////wCDIgZCgICAgICAwP//AFYgBkKAgICAgIDA//8AURsNACAAIAKEIAUgBoSEUARAQQAPCyABIAODQgBZBEBBfyEEIAAgAlQgASADUyABIANRGw0BIAAgAoUgASADhYRCAFIPC0F/IQQgACACViABIANVIAEgA1EbDQAgACAChSABIAOFhEIAUiEECyAECy0BAX9BASEBAkACQAJAIABBDWsOBAIBAQIACyAAQTRGDQELIABBOEYhAQsgAQsfACAAIAEgACACEKoBIgIgAyAEEBkhBCAAIAIQEyAEC0QBAX9BfyEDIAAgACgCBCACahDGAQR/QX8FIAAoAgAgAWoiAyACaiADIAAoAgQgAWsQnAEgACAAKAIEIAJqNgIEQQALC44BAQF/IAAgBkEMEEkiBkKAgICAcINCgICAgOAAUgRAIAAgACgCAEEBajYCACAGpyIHIAU7ASogByAEOgApIAcgAzoAKCAHIAE2AiQgByAANgIgIAcgBy0ABUHvAXEgBEECa0EESUEEdHI6AAUgACAGIAAgAkHMngEgAhsQqgEiASADEJYDIAAgARATCyAGCykBAX9B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IAAgD0ElEEsiCEUNACAAIANB3QEgA0EAEBQiDkKAgICAcIMiDUKAgICA4ABRDQAgDUKAgICAMFEEQCAAIA8QD0EADAILIAAgDkElEEsiC0UNAAJAIAgoAgRFDQAgCygCBEUNACAAIA8QDyAAIA4QD0EADAILIAQQ9wMhBwJ/IAgoAgAiCiALKAIAIgxGBEAgCCAHQQJ0aigCCAwBCyAKIAxLBEAgCEHUAGogDCAHELgFDAELIAtB3ABqIAogBxC4BQsiCkUEQCAJIAdBAnRBwMABajYCACAAQZL6ACAJEBUMAQsCQCAIKAIEBEACfiAFBEAgACACELkCDAELIAAgAiAGEJACCyICQoCAgIBwg0KAgICA4ABSDQEMAgsgAkIgiKdBdUkNACACpyIIIAgoAgBBAWo2AgALAkAgCygCBARAAn4gBQRAIAAgAxC5AgwBCyAAIAMgBhCQAgsiA0KAgICAcINCgICAgOAAUg0BIAAgAhAPDAILIANCIIinQXVJDQAgA6ciBSAFKAIAQQFqNgIACyAKIAooAgBBAWo2AgAgCSACIAMgBEF+cUGkAUYgB0ENRnEiBRs3AxggCSADIAIgBRs3AxAgACAKrUKAgICAcIRCgICAgDBBAiAJQRBqEC8hDSAAIAIQDyAAIAMQDyANQoCAgIBwgyICQoCAgIDgAFENAAJ+IAdBDEYEQCAAIA0QJiAEQaoBRketQoCAgIAQhAwBCyANIAdBDUcNABpCgICAgBAgAkKAgICAMFENABogACANECYgBEF9cUGkAUZHrUKAgICAEIQLIQMgACAPEA8gACAOEA8gASADNwMAQQEMAQsgACAPEA8gACAOEA8gAUKAgICAMDcDAEF/CyEHIAlBIGokACAHC2MCAX8BfiMAQRBrIgIkACAAAn4gAUUEQEIADAELIAIgAa1CACABZyIBQdEAahBnIAIpAwhCgICAgICAwACFQZ6AASABa61CMIZ8IQMgAikDAAs3AwAgACADNwMIIAJBEGokAAvHAQIBfgF/AkAgACgCECgCjAEiA0UgAUL/////////D3xC/v///////x9Wcg0AIAMoAihBBHFFDQAgAUKAgICACHxC/////w9YBEAgAUL/////D4MPC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA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ACAAIAEQiANBH3YLvgEBB38gACgCDCIFIQMCQANAIAMiBEUNASAAKAIQIgkgBEEBayIDQQJ0aiIGKAIARQ0ACyAAIAAoAgggBCAFa0EFdGo2AgggBigCAGciBwRAQSAgB2shBUEAIQMDQCADIARGRQRAIAkgA0ECdGoiBiAIIAV2IAYoAgAiCCAHdHI2AgAgA0EBaiEDDAELCyAAIAAoAgggB2s2AggLIAAgASACIARBABCqAw8LIABBgICAgHg2AgggAEEAEEEaQQALTgIBfwF+An4jACICIAAoAhAoAnhJBEAgABDpAUKAgICA4AAMAQsgACABrSABKQMAQoCAgIAwIAEoAgggASgCIEEEENgBCyEDIAIkACADCwwAIABB+swAQQAQFQsLACAAQcMaQQAQFQvVAQEDfyMAQRBrIgUkAEF/IQMCQCAAKAIUDQACQAJAIAFBgICAgAROBEAgACgCAEHA2gBBABBGDAELIAEgACgCDEEDbEECbSIEIAEgBEobIQEgACgCECIEIAJBgAJIckUEQCAAIAEQ9QMhAwwDCyAAKAIAIAAoAgQgASAEdCAEa0ERaiAFQQxqEKgBIgINAQsgABCDAwwBCyAFKAIMIQMgACACNgIEIABB/////wMgAyAAKAIQdiABaiIAIABB/////wNOGzYCDEEAIQMLIAVBEGokACADCxEAIAAgASACIAMgBEEAELcFCyYBAX8gAUIgiKdBdU8EQCABpyICIAIoAgBBAWo2AgALIAAgARBsCycBAX8gAUIAUwRAIABCACABfRAwIQIgAEEBNgIEIAIPCyAAIAEQMAvsAQEBfwJAAkACQAJAAkACQAJAQQcgAkIgiKciAyADQQdrQW5JGyIDDggAAAAEBAQEAQMLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACxBC6Ag0BDAQLIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgASACQoCAgIDAgYD8/wB8vxC6BUUNAwsgARAbQQAPCyADQQpqQQJJDQILIAAoAtgBIQAgAUIANwIMIAFCgICAgICAgICAfzcCBCABIAA2AgAgARA1CyABDwsgAqdBBGoL5AEBBH8jAEEQayICJAAgACACQQhqIAEQ5QEhAyAAIAEQDwJAIANFBEBC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IAMoAgAgAygCBHEMBAsgAygCACADKAIEcgwDCyADKAIAIAMoAgRzDAILEAEACyADKAIEIAMoAgB0C603AwAMAQsgAUKAgICAMDcDACAGQoCAgIAwNwMAQX8MAQtBAAshACADQRBqJAAgAAuGBQIHfwJ+AkAgAUKAgICAcINCgICAgJB/UgRAQoCAgIDgACEKIAAgARA3IgFCgICAgHCDQoCAgIDgAFENAQsCQCACQoCAgIBwg0KAgICAkH9RDQBCgICAgOAAIQogACACEDciAkKAgICAcINCgICAgOAAUg0AIAEhAgwBCwJAIAKnIgUpAgQiCkL/////B4NQDQAgAaciAykCBCELAkAgAygCAEEBRyAKIAuFQoCAgIAIg0IAUnINACADIAAoAhAoAgwRBAAgBSkCBCIKpyIEQf////8HcSIHIAMpAgQiC6ciBkH/////B3EiCGogBEEfdnQgBkEfdiIJQRFzakkNACAFQRBqIQYgA0EQaiEEIAkEQCAEIAhBAXRqIAYgB0EBdBAfGiADIAMpAgQiCiAFKQIEfEL/////B4MgCkKAgICAeIOENwIEDAILIAQgCGogBiAHEB8aIAMgAykCBCIKIAUpAgR8Qv////8HgyILIApCgICAgHiDhDcCBCAEIAunakEAOgAADAELAn4CQAJAIAunQf////8HcSAKp0H/////B3FqIgdBgICAgARPBEAgAEHA2gBBABBGDAELIAAgByAKIAuEpyIGQR92EOoBIggNAQtCgICAgOAADAELIAhBEGohBAJAIAZBAE4EQCAEIANBEGogAygCBEH/////B3EQHyIEIAMoAgRB/////wdxaiAFQRBqIAUoAgRB/////wdxEB8aIAQgB2pBADoAAAwBCyAEIAMgAygCBEH/////B3EQwwUgBCADKAIEQQF0aiAFIAUoAgRB/////wdxEMMFCyAIrUKAgICAkH+ECyEKIAAgARAPDAELIAEhCgsgACACEA8gCgtAACAAAn8CfyADBEAgASgCJCACQQN0akEEagwBC0EAIAEoAiAiA0UNARogAyABLwEoIAJqQQR0agsoAgALENkBCw0AIAAgASACQQIQzgILNQEBfyMAQdAAayICJAAgAiAAKAIQIAJBEGogARCQATYCACAAQef5ACACEMYCIAJB0ABqJAALowECAX8BfiMAQRBr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AiAAKAIQQf0ARw0ACyAAEPMBC0F/QQAgABASGyEBCyABC2gAIAAgASACEE8iAEEATgRAIAEoAnQgAEEEdGoiAiACKAIMQYd/cSADQQN0QfgAcXI2AgwgAiABKAK8ASIDNgIEIAIgASgCwAE2AgggASgCzAEgA0EDdGogADYCBCABIAA2AsABCyAAC20BAX8gACABQfwBakEQIAFB+AFqIAEoAvQBQQFqEHhFBEAgASABKAL0ASIDQQFqNgL0ASABKAL8ASADQQR0aiIDQX82AgAgAyADLQAEQfgBcToABCADIAEoArwBNgIIIAMgACACEBg2AgwLIAMLxgMBBH8gAEFAayIFKAIAQbACaiEDA0BBACECAkADQCADKAIAIgNFDQEgAygCHARAIAFFBEAgAEEGEBALIABBhAEQEEGDASECIAAgBSgCAC0AbEEDRgR/IABBDhAQIABBDhAQIABBwgAQECAAQQYQGiAAQREQECAAQbABEBAgAEHqAEF/EBwhASAAQSQQECAFKAIAQQAQFyAAQYEBEBAgAEGLARAQIABB6wBBfxAcIQQgACABEB4gAEEOEBAgACAEEB5BDgVBgwELEBBBfSECQQEhAQsgAygCECACaiECIAMoAhRBf0YNAAtBD0EOIAEbIQQDQCACBEAgACAEEBAgAkEBayECDAELCyABRQRAIABBBhAQCyAAQe0AIAMoAhQQHBpBASEBDAELCwJAIABBQGsoAgAiAigCYARAAkAgAUUEQEF/IQIMAQsgAEEqEBAgAEHpAEF/EBwhAiAAQQ4QEAsgAEG4ARAQIABBCBAaIABBQGsoAgBBABAXIAAgAhAeQSghAgwBCyACLQBsIgMEQCABRQRAIABBBhAQQS4hAgwCC0EuIQIgA0EDRw0BIABBiwEQEAwBC0EoQSkgARshAgsgACACEBALXQECfwJAAkAgACgCmAIiAUEASA0AIAAoAoACIAFqLQAAIgBBI2siAUENTUEAQQEgAXRB5fAAcRsNAQJAIABB6wBrDgQCAQECAAsgAEHsAWtBAkkNAQtBASECCyACCy8AIAAgASACIAMQ4wIiAEEATgRAIAEoAnQgAEEEdGoiASABKAIMQQNyNgIMCyAACy4AIABBDBApIgAEQCAAIAM2AgggACACNgIEIAAgASgCEDYCACABIAA2AhALIAALawEBfwJA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CyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAvwBIQMgAiABKAL0AU5FBEAgACADIAJBBHRqKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAQQAhAgNAIAEoAsgCIQMgAiABKALAAk5FBEAgACADIAJBA3RqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAEoAswBIgIgAUHQAWpHBEAgACgCECIDQRBqIAIgAygCBBEAAAsgACABKALsAhATIAFB9AJqEPYBIAAoAhAiAkEQaiABKAKMAyACKAIEEQAAIAEoAgQEQCABKAIYIgIgASgCHCIDNgIEIAMgAjYCACABQgA3AhgLIAAoAhAiAEEQaiABIAAoAgQRAAALggEBAn8gACABQRBqEM8FAkAgASgCICICBEAgASgCPCIDRQ0BA0AgAiADT0UEQCAAIAIpAwAQIyACQQhqIQIgASgCPCEDDAELCyAAQRBqIAEoAiAgACgCBBEAAAsgACABKQMYECMgACABKQMAECMPC0GEhAFBrvwAQYmUAUHC6wAQAAALaAEBfgJAAkAgABA0IgNCgICAgHCDQoCAgIDgAFEEQCABIQMMAQsgACADQcAAIAFBBxAZQQBIDQAgACADQekAIAJBAEetQoCAgIAQhEEHEBlBAE4NAQsgACADEA9CgICAgOAAIQMLIAMLjAEBAn8CQANAIAFCgICAgHBUDQECQAJAAkACQAJAAkAgAaciAi8BBiIDQQxrDgUFAQMHAQALIANBMEYNASADQTRrDgUABgYGAAYLIAIoAiAoAjAPCyACKAIgIgJFDQQgAi0AEUUNASAAELYCQQAPCyACKAIgIQILIAIpAwAhAQwBCwsgAigCICEACyAACyIAIAAgAkEBahApIgAEQCAAIAEgAhAfIAJqQQA6AAALIAALjQMCA34EfwJAIAEoAggiBkH+////B04EQEEBIQcgAkEBcQ0BQv///////////wAhAyAGQf7///8HRw0BIAE0AgRC////////////AHwhAwwBCyAGQQBMBEAMAQsgBkE/TQRAIAEoAhAiCSABKAIMIgJBAnRqQQRrKAIAIQhCACAGQSBNBH4gCEEgIAZrdq0FIAJBAk8EfiACQQJ0IAlqQQhrNQIABUIACyAIrUIghoRBwAAg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LQAFQf4BcToABSABIAs3A0ALIAtCIIinQXVPBEAgC6ciACAAKAIAQQFqNgIACyALIQwLIANBIGokACAMC4kEAgR+An8CQAJAIAG9IgRCAYYiA1ANACABvSECIAC9IgVCNIinQf8PcSIGQf8PRg0AIAJC////////////AINCgYCAgICAgPj/AFQNAQsgACABoiIAIACjDwsgAyAFQgGGIgJaBEAgAEQAAAAAAAAAAKIgACACIANRGw8LIARCNIinQf8PcSEHAn4gBkUEQEEAIQYgBUIMhiICQgBZBEADQCAGQQFrIQYgAkIBhiICQgBZDQALCyAFQQEgBmuthgwBCyAFQv////////8Hg0KAgICAgICACIQLIQICfiAHRQRAQQAhByAEQgyGIgNCAFkEQANAIAdBAWshByADQgGGIgNCAFkNAAsLIARBASAHa62GDAELIARC/////////weDQoCAgICAgIAIhAshBCAGIAdKBEADQAJAIAIgBH0iA0IAUw0AIAMiAkIAUg0AIABEAAAAAAAAAACiDwsgAkIBhiECIAZBAWsiBiAHSg0ACyAHIQYLAkAgAiAEfSIDQgBTDQAgAyICQgBSDQAgAEQAAAAAAAAAAKIPCwJAIAJC/////////wdWBEAgAiEDDAELA0AgBkEBayEGIAJCgICAgICAgARUIQcgAkIBhiIDIQIgBw0ACwsgBUKAgICAgICAgIB/gyADQoCAgICAgIAIfSAGrUI0hoQgA0EBIAZrrYggBkEAShuEvwvoDwMHfAh/An5EAAAAAAAA8D8hAwJAAkACQCABvSIRQiCIpyIPQf////8HcSIJIBGnIgxyRQ0AIAC9IhJCIIinIQogEqciEEUgCkGAgMD/A0ZxDQAgCkH/////B3EiC0GAgMD/B0sgC0GAgMD/B0YgEEEAR3FyIAlBgIDA/wdLckUgDEUgCUGAgMD/B0dycUUEQCAAIAGgDwsCQAJAAkACQAJAAn9BACASQgBZDQAaQQIgCUH///+ZBEsNABpBACAJQYCAwP8DSQ0AGiAJQRR2IQ0gCUGAgICKBEkNAUEAIAxBswggDWsiDnYiDSAOdCAMRw0AGkECIA1BAXFrCyEOIAwNAiAJQYCAwP8HRw0BIAtBgIDA/wNrIBByRQ0FIAtBgIDA/wNJDQMgAUQAAAAAAAAAACARQgBZGw8L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A38jAEFAaiIGJAACQCAEIANrIghBAUYEQAJAIANFBEAgAUIDEDAaDAELIAEgA60QMBogAUEBNgIECyACIANBAXRBAXKtEDAaIAIgAigCCEECajYCCCAAIAEQRBoMAQsgACgCACEHIAAgASACIAMgCEEBdiADaiIDQQEQoAQgBkIANwI4IAZCgICAgICAgICAfzcCMCAGIAc2AiwgBkIANwIkIAZCgICAgICAgICAfzcCHCAGIAc2AhggBkIANwIQIAZCgICAgICAgICAfzcCCCAGIAc2AgQgBkEsaiIHIAZBGGogBkEEaiIIIAMgBCAFEKAEIAAgACAIQf////8DQQEQQxogByAHIAFB/////wNBARBDGiAAIAAgB0H/////A0EBEMsBGiAFBEAgASABIAZBGGpB/////wNBARBDGgsgAiACIAZBBGoiAEH/////A0EBEEMaIAZBLGoQGyAGQRhqEBsgABAbCyAGQUBrJAALzgUCB38DfiMAQTBrIggkAAJ/AkACQAJAAkACQCADDgMAAQIDC0HcjAFB1PwAQbUaQZb8ABAAAAsgASACKAIQIAIoAgwiACAAQQV0IAIoAghrEGg2AgAMAgsgAigCECIDIAIoAgwiACAAQQV0IAIoAghrIgJBIGoQaK1CIIYgAyAAIAIQaK2EIQ8gBkGAlOvcA0YEQCABIA9CgJTr3AOAIhA+AgQgASAQQoDslKMMfiAPfD4CAAwCCyABIA8gBq0iEIAiET4CBCABIA8gECARfn0+AgAMAQsgAigCACEKIAhCADcCKCAIQoCAgICAgICAgH83AiAgCCAKNgIcIAhCADcCFCAIQoCAgICAgICAgH83AgwgCCAKNgIIIAMgBUEBdCAEQQFqIgt2QQFqQQF2IgprIQwgACAEQQF0QQFyQRRsaiENQQAhAyAAIARBKGxqIgQoAgxFBEAgBCAGIApB/////wNBARD8AiAIQQhqIglCARAwciANIAkgBCAKQQFqIAdsQQJqQQAQlQFyIQkLAkACQCAIQRxqIg4gAiANIAcgDGxBABBDIAlyIA5BARDRAXIgCEEIaiIJIA4gBEH/////A0EBEENyIAkgAiAJQf////8DQQEQ5AFyQSBxDQADQAJAIAgoAgxFDQAgCCgCFEUNACAIQQhqIgIgAiAEQf////8DQQEQywENAiADQQFrIQMM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3gQBCX8jAEEQayIGJAAgACAAKQOAARAjIABBEGohAyAAQaABaiEEIAAoAqQBIQEDQCABIARGRQRAIAEoAgQhBUEAIQIDQCACIAEoAhBORQRAIAAgASACQQN0aikDGBAjIAJBAWohAgwBCwsgAyABIAAoAgQRAAAgBSEBDAELCyAAIAQ2AqQBIAAgAEGgAWo2AqABIAAQogUgACgCVCAAQdAAakYEQEEAIQIDQAJAIAAoAkQhASACIAAoAkBODQAgASACQRhsaiIBKAIABEAgACABKAIEEOwBCyACQQFqIQIMAQsLIAMgASAAKAIEEQAAIAAoApACIgQEQEEAIQEDQEEAIQUgAUEFRkUEQANAQQAhAiAFQQJGRQRAA0AgAkEURwRAIAQgAUGgAWxqIAVB0ABsaiACQQJ0akGoDWoiBygCACIIBEAgBCgCACIJKAIAIAhBACAJKAIEEQEAGiAHQQA2AgALIAJBAWohAgwBCwsgBUEBaiEFDAELCyABQQFqIQEMAQsLIAAoAtgBIARBACAAKALcAREBABogAEEANgKQAgsgAEHgAWoQoQUgAEH4AWoQoQVBACECA0ACQCAAKAI4IQEgAiAAKAIsTg0AIAEgAkECdGooAgAiAUEBcUUEQCADIAEgACgCBBEAAAsgAkEBaiECDAELCyADIAEgACgCBBEAACADIAAoAjQgACgCBBEAACADIAAoAtQBIAAoAgQRAAAgBiADKQIINwMIIAYgAykCADcDACAGIAAgACgCBBEAACAGQRBqJAAPC0GNkQFBrvwAQb8PQaTlABAAAAtDAQJ/IAAoAogBIQJBfyEDAkADQCACQQBMDQEgACgCgAEgAkEBayICQQR0aigCACABRw0ACyACQYCAgIACciEDCyADC8YBAgR/AX4jAEEQayIDJAAgACABEC0iB0KAgICAcINCgICAgOAAUgRAAkAgACADQQxqIAcQ5QEiBkUEQAwBCwJAIAAgAhA/IgEgAygCDGpBAWoQKSIERQRAQQAhBAwBCyAEIAYgAygCDBAfIgUgAygCDGogAiABEB8aIAUgAygCDCABampBADoAACAAIAUgAygCDCABahCFAyEEIAAoAhAiAUEQaiAFIAEoAgQRAAALIAAgBhBUCyAAIAcQDwsgA0EQaiQAIAQLvwEBAX8gASADai0AAEE8RgRAIAAgBEH/AXEQESAAIAVB//8DcRAqIANBAWohAwsgASACKAIEIgBBBWsiAmoiBi0AAEG2AUYEQCAAIAFqLQAAQRZGBEAgBkEROgAAIABBBGshAgsgAEECaiEAIAEgAmoiBiAFOwABIAYgBEEBajoAACACQQNqIQIDQCAAIAJMRQRAIAEgAmpBswE6AAAgAkEBaiECDAELCyADDwtBodUAQa78AEHs5QFBtd4AEAAAC0IBAX8CQCAAIAFqIgAtAAFBPUcNAEEBIQICQAJAIAAtAAAiAEEWaw4EAgEBAgALIABBswFGDQELIABBHUYhAgsgAguzAQEBf0F/IQMCQCABKAJMRQ0AAkACQAJAAkAgAkHxAGsOAwIBAAMLIAEoArQBIgNBAE4NAyABIAAgAUHzABBPIgA2ArQBIAAPCyABKAKwASIDQQBODQIgASAAIAFB8gAQTyIANgKwASAADwsgASgCrAEiA0EATg0BIAEgACABQfEAEE8iADYCrAEgAA8LIAJBCEcNACABKAKoASIDQQBODQAgASAAIAEQygMiAzYCqAELIAMLRQAgACgCzAEgAUEDdGpBBGohAQNAIAEoAgAiAUEASEUEQCAAKAJ0IAFBBHRqIgEgASgCDEEEcjYCDCABQQhqIQEMAQsLCzAAA0AgAUGAAUlFBEAgACABQYABckH/AXEQESABQQd2IQEMAQsLIAAgAUH/AXEQEQsNACAAIAFB2ogBEOEEC/kCAQR/QQEhCSADIQcCQANAIAcoAswBIAVBA3RqQQRqIQUCQAJAA0AgBSgCACIFQQBIDQEgBCAHKAJ0IgYgBUEEdGoiCCgCAEcEQCAIQQhqIQUMAQsLIAYgBUEEdGooAgxBA3ZBD3EhCEEBIQYgCQRAQQAhBgwCCyAAIAMgB0EAIAUgBEEBQQFBABCfASIFQQBODQEMAwsgBygCBCIGRQRAAkAgBygCIEUNAEEAIQUgBygCwAIiBkEAIAZBAEobIQYDQCAFIAZGDQEgBCAHKALIAiIIIAVBA3RqKAIERgRAIAggBUEDdGotAAAiCUEEdiEIIAMgB0YEQEEBIQYMBQtBASEGIAAgAyAHQQAgCUEBdkEBcSAFIAQgCUECdkEBcSAJQQN2QQFxIAgQ9QEiBUEASA0GDAQFIAVBAWohBQwBCwALAAsgACAEQaGXARD/AwwDCyAHKAIMIQVBACEJIAYhBwwBCwsgASAGNgIAIAIgCDYCACAFDwtBfwvGFwEGfyMAQRBrIgwkACAMQX82AgwCf0EBIAJB8QBrQQNJDQAaQQEgAkEIRg0AGkEACyELIAEoAswBIANBA3RqQQRqIQMCQAJAAkACQAJAAkADQCADKAIAIgNBAE4EQCACIAEoAnQiCiADQQR0aiIJKAIAIg1GBEAgBEF9cUG5AUcEQCADIQkMBAsgCiADIglBBHRqLQAMQQFxRQ0DIAVBMBARIAUgACACEBgQHSAFQQAQEQwHCyALIA1B1ABHckUEQCAFQdgAEBEgBSADQf//A3EQKiAAIAEgAiAEIAUgDEEMakEBEOABCyAJQQhqIQMMAQsLQX8hCSADQX5HBEAgASACEPQBIQkLIAtBAXMgCUEATnJFBEAgACABIAIQ5AQhCQsCQCACQc0ARyAJQQBOckUEQCABKAJIRQ0BIAAgARDqAiEJCyAJQQBODQELAkAgASgCLARAIAEoAnAgAkYNAQsgA0F+Rw0DDAQLIAAgASACEOkCIglBAEgNAQsCQAJAAkACQCAEQbcBaw4HAgIAAwABAgcLAkAgCUGAgICAAnEiAw0AIAEoAnQgCUEEdGotAAxBAXFFDQAgBUEwEBEgBSAAIAIQGBAdIAVBABARDAcLAkAgBEG5AWsOAwIDAAcLAkAgAw0AIAEoAnQgCUEEdGooAgxB+ABxQSBHDQAgBUELEBEgBUHYABARIAUgCUH//wNxECogBUHMABARIAUgACACEBgiAhAdIAVBBBARIAUgACACEBgQHQwHCwJAIAwoAgxBf0cNACAGIAcoAgQQ4wRFDQAgBSAGIAcgCAJ/IAMEQCAJQYCAgIACayEJQdsADAELQeIAQdgAIAEoAnQgCUEEdGotAAxBAnEbCyAJEOIEIQgMBwsgAwRAIAVB+QAQESAFIAAgAhAYEB0gBSAJQf//A3EQKgwHCyAFQfgAEBEgBSAAIAIQGBAdIAUgCUH//wNxECoMBgsgBUEGEBELIAlBgICAgAJxBEAgBUHcAEHcAEHbACAEQb0BRhsgBEG5AUYbEBEgBSAJQf//A3EQKgwFCwJAAkACQCAEQbkBaw4FAAEBAQABC0HjAEHZACABKAJ0IAlBBHRqKAIMQQJxIgBBAXYbIQMgAEUgBEG9AUdyDQFB5ABB2QAgAkEIRhshAwwBC0HiAEHYACABKAJ0IAlBBHRqLQAMQQJxGyEDCyAFIAMQESAFIAlB//8DcRAqDAQLIAVBCRARDAMLIANBfkYNAQsgCyABKAKQAUEASHINACAFQdgAEBEgBSABLwGQARAqIAAgASACIAQgBSAMQQxqQQAQ4AELIAsgASIDKAKUAUEASHJFBEAgBUHYABARIAUgAS8BlAEQKiAAIAEgAiAEIAUgDEEMakEAEOABCwJAAkACfwJAAkACQANAIAMoAgQiCkUEQCADIQoMAwsgCigCzAEgAygCDEEDdGpBBGohAwNAIAMoAgAiCUEATgRAIAIgCigCdCINIAlBBHRqIgMoAgAiDkYEQCAEQX1xQbkBRwRAIAkhAwwFCyANIAkiA0EEdGotAAxBAXFFDQQgBUEwEBEgBSAAIAIQGBAdIAVBABARDAoFAkAgCyAOQdQAR3INACADIAMoAgxBBHI2AgwgACABIApBACAJQdQAQQBBAEEAEJ8BIglBAEgNACAFQd4AEBEgBSAJQf//A3EQKiAAIAEgAiAEIAUgDEEMakEBEOABCyADQQhqIQMMAgsACwsgCUF+RwRAIAogAhD0ASIDQQBODQILIAsEQCAAIAogAhDkBCIDQQBODQILAkACQCACQc0ARw0AIAooAkhFDQAgACAKEOoCIQMMAQsCQCAKKAIsRQ0AIAooAnAgAkcNACAAIAogAhDpAiEDDAELAkAgCUF+Rg0AIAsgCigCkAEiA0EASHINACAKKAJ0IANBBHRqIgMgAygCDEEEcjYCDCAAIAEgCkEAIAooApABIAMoAgBBAEEAQQAQnwEhAyAFQd4AEBEgBSADQf//A3EQKiAAIAEgAiAEIAUgDEEMakEAEOABCyALIAooApQBIgNBAEhyRQRAIAooAnQgA0EEdGoiAyADKAIMQQRyNgIMIAAgASAKQQAgCigClAEgAygCAEEAQQBBABCfASEDIAVB3gAQESAFIANB//8DcRAqIAAgASACIAQgBSAMQQxqQQAQ4AELIAoiAygCIEUNAQwDCwsgA0EASA0BCyADQYCAgIACcUUNASAKKAKAASADQYCAgIACayIDQQR0aiIJIAkoAgxBBHI2AgwgACABIApBASADIAJBAEEAQQAQnwEMAgsgCigCIEUNA0EAIQMDQCADIAooAsACTg0EIAIgCigCyAIgA0EDdGoiDigCBCINRgRAIAEgCkYNBCAAIAEgCkEAIA4tAAAiCkEBdkEBcSADIAIgCkECdkEBcSAKQQN2QQFxIApBBHYQ9QEhAwwEBQJAAkAgDUF+cUHSAEcEQCALIA1B1ABHckUNAQwCCyALDQELIAMhCSABIApHBEAgACABIApBACAOLQAAQQF2QQFxIAMgDUEAQQBBABD1ASEJCyAFQd4AEBEgBSAJQf//A3EQKiAAIAEgAiAEIAUgDEEMaiANQdQARhDgAQsgA0EBaiEDDAELAAsACyADQQR0IgkgCigCdGoiCyALKAIMQQRyNgIMIAAgASAKQQAgAyACIAooAnQgCWooAgwiA0EBcSADQQF2QQFxIANBA3ZBD3EQnwELIgNBAEgNAQsCQAJAAkACQAJAAkACQCAEQbcBaw4HAQEABgADAQgLIAEoAsgCIANBA3RqLQAAIglBBHEEQCAFQTAQESAFIAAgAhAYEB0gBUEAEBEMCAtBACEKAkAgBEG5AWsOAwIGAAgLIAlB8AFxQcAARgRAIAVBCxARIAVB3gAQESAFIANB//8DcRAqIAVBzAAQESAFIAAgAhAYIgIQHSAFQQQQESAFIAAgAhAYEB0MCAsCQCAMKAIMQX9HDQAgBiAHKAIEEOMERQ0AIAUgBiAHIAhB5QBB3gAgCUEIcRsgAxDiBCEIDAgLIAVB+gAQESAFIAAgAhAYEB0gBSADQf//A3EQKgwHCyAEQb0BRiEKIARBuQFrDgUAAgICAAILQeYAQd8AIAEoAsgCIANBA3RqLQAAQQhxIgBBA3YbIQkgAEUgCkVyDQJB5wBB3wAgAkEIRhshCQwCCyAFQQYQEQtB5QBB3gAgASgCyAIgA0EDdGotAABBCHEbIQkLIAUgCRARIAUgA0H//wNxECoMAgsgBUEJEBEMAQsCQAJAAkACQAJAIARBtwFrDgcCAgIEAAEDBQsCQCAMKAIMQX9HDQAgBygCBCAGaiIDLQABQT1HDQACQAJAIAMtAAAiA0EZaw4FAQICAgEACyADQbMBRg0AIANBFkcNAQsgAS0AbkEBcSIEBEAgBUE2EBEgBSAAIAIQGBAdCyAGIAhqLQAAQTxGBEAgBUE4EBEgBSAAIAIQGBAdIAhBAWohCAsgBiAHKAIEIgdBBWsiCmoiCS0AAEG2AUcNBiAGIAdqLQAAIQMCQAJAIAQEQEE7IQsCQAJAAkACQCADQRlrDgUCAQEBAwALQRUhBCADQRZGDQQgA0GzAUYNBQsQAQALQRghBAwCC0EbIQQMAQtBOSELQREhBCADQRZHDQELIAkgBDoAACAHQQRrIQoLIAdBAmohBCAGIApqIgMgCzoAACADIAAgAhAYNgABIApBBWohAwNAIAMgBE4NBiADIAZqQbMBOgAAIANBAWohAwwACwALIAVB+wAQESAFIAAgAhAYEB0MBAsgBUEGEBEgBUE4EBEgBSAAIAIQGBAdDAMLIAUgBEGAAXNB/wFxEBEgBSAAIAIQGBAdDAILIAVBOhARIAUgACACEBgQHQwBCyAFQZkBEBEgBSAAIAIQGBAdCyAMKAIMIgBBAE4EQCAFQbYBEBEgBSAAEB0gASgCpAIgAEEUbGogBSgCBDYCCAsgDEEQaiQAIAgPC0Gh1QBBrvwAQZ3mAUH33QAQAAAL1gIBBH8jAEGgAWsiBSQAIAEoAgAhBiAFQYABNgIIIAUgBUEQajYCDCAEBH8gBUEjOgAQQQEFQQALIQQCfwJAA0ACfyADQf8ATARAIAUoAgwiByAEaiADOgAAIARBAWoMAQsgBSgCDCIHIARqIAMQoQMgBGoLIQQgBSAGQQFqNgKcAUHcACEDAkAgBi0AACIIQdwARgRAIAYtAAFB9QBHDQEgBUGcAWpBARD5ASEDIAJBATYCAAwBCyAIIgPAQQBODQAgBkEGIAVBnAFqEFghAwsgAxDFAUUNASAFKAKcASEGIAQgBSgCCEEGa0kNACAAKAIAIAVBDGogBUEIaiAFQRBqEPUERQ0ACyAFKAIMIQdBAAwBCyAAKAIAIAcgBBCFAwshAyAFQRBqIAdHBEAgACgCACgCECIAQRBqIAcgACgCBBEAAAsgASAGNgIAIAVBoAFqJAAgAwuaBgEEf0EBIQkgAkEBdEHg9wJqLwEAIQIgBUUEQCAAIAI2AgBBAQ8LIAJB0IIDaiEGQRIhBwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAVBAWsOIgAAAAAAAAABAQICAgICBAMDAwMDAwUFBQUFBQUFBgcICQkLCyAGIAEgA2sgBWxBAXRqIQFBACECA0AgAiAFRgRAIAUPCyAAIAJBAnRqIAEgAkEBdGovAAAiAzYCACACQQFqIQIgAw0ACwwLCyAFQQdrIgggASADa2whAiAEIAhsQQF0IQFBACEHA0AgByAIRg0KIAYgAkEBdCIDai8AACAGIAJBAnYgAWpqLQAAIANBBnF2QRB0QYCADHFyIgNFDQsgACAHQQJ0aiADNgIAIAdBAWohByACQQFqIQIMAAsACyAGIAVBCWsiCCABIANrbGohAUEAIQIDQCACIAhGDQkgACACQQJ0aiABIAJqLQAAEKsDIgM2AgAgAkEBaiECIAMNAAsMCQsgBUEBcSAFQRBrIgJBAUtqIQggAkEBdkECaiEJCyABIANrIQFBACECA0AgAiAJRgRAIAkPBSAAIAJBAnRqIAYgAkEBdGovAAAgAUEAIAIgCEYbajYCACACQQFqIQIMAQsACwALIAVBFWshBwsgByABIANrbCAGakECaiEBIAYvAAAhA0EAIQIDQCACIAdGBEAgBw8FIAAgAkECdGpBICADIAEgAmotAAAiBGogBEH/AUYbNgIAIAJBAWohAgwBCwALAAsgACAGIAEgA2tBA2xqIgEvAAAiAjYCACACRQ0DIAAgAS0AAhCrAzYCBAwCCyAAIAYvAAI2AgggACAGLwAANgIAIAAgASADa0EBdCAGai8ABDYCBEEDDwsgASADayEBAn8gBUEhRgRAIAYgAUF+cWoiAkEBaiEDIAItAAAQqwMMAQsgBiABQQF2QQNsaiICQQJqIQMgAi8AAAshAiAAQSBBIEEBIAJBkAhrQSBJGyACQYACSRsgAmogAiABQQFxGzYCACAAIAMtAAAQqwM2AgQLQQIhCAsgCA8LQQALtAIBCH8jAEHQAGsiByQAIAJBACACQQBKGyELA0ACQAJAIAYgC0cEQCABIAZBAnRqKAIAIgVBgNgCayICQaPXAE0NAUGxBSECQQAhBAJAA0AgAiAESA0BIAUgAiAEakECbSIIQQJ0QZDiAmooAgAiCUEOdiIKSQRAIAhBAWshAgwBCyAFIAlBB3ZB/wBxIgQgCmpPBEAgCEEBaiEEDAELCyAJQQFxIANLDQAgByAFIAggCiAEIAlBAXZBP3EQ6wQiAkUNACAAIAcgAiADEOwEDAMLIAAgBRAdDAILIAdB0ABqJAAPCyAAIAJB//8DcSIFQcwEbiIEQYAichAdIAAgBEG0e2wgAmpB//8DcUEcbkHhImoQHSAFQRxwIgJFDQAgACACQacjahAdCyAGQQFqIQYMAAsAC9sGAgx/Bn4jAEEwayICJAACfgJAAkAgASkDKCIOQoCAgIBwg0KAgICAkH9RBEAgASkDCCIQQoCAgIBwg0KAgICAkH9RDQELIABBotsAQQAQFQwBCyABKQMgIRIgASkDGCEPIAEpAwAhEyAAIAJBDGpBABA9GiACQQA2AiQCQCAPQoCAgIBwg0KAgICAMFIEQCAAIAJBJGogDxDWAQ0BCyAAIAJBKGogExDWAQ0AIAAgAkEsaiABKQMQEHdBAEgNACAQpyEIIBJCgICAgHCDIRAgAigCLCIMIAIoAihqIQ0gDqciBEEQaiEHIAQoAgRB/////wdxIQogAigCJCELQQAhAQNAAkACQAJAIARBJCABEMcBIgZBAEgNACAGQQFqIgMgCk8NACACQQxqIAQgASAGEFEaIAZBAmohAQJAAkACQAJAAn8gBCkCBEKAgICACINQIglFBEAgByADQQF0ai8BAAwBCyADIAdqLQAACyIDQSRrDgQAAwUBAgsgAkEMakEkEDsaDAYLIAJBDGogCCANIAgoAgRB/////wdxEFEaDAULIANB4ABGDQMLAkAgA0EwayIFQQlNBEACQCABIApPDQACfyAJRQRAIAcgAUEBdGovAQAMAQsgASAHai0AAAsiA0Ewa0EJSw0AIAZBA2ogASADIAVBCmxqIgFBMEsgAUEwayIDIAtJcSIJGyEBIAMgBSAJGyEFCyAFRSAFIAtPcg0BIAAgDyAFrRBzIg5CgICAgHCDIhFCgICAgDBRDQUgEUKAgICA4ABRDQYgAkEMaiAOEH9FDQUMBgsgA0E8RyAQQoCAgIAwUXINACAEQT4gARDHASIDQQBIDQAgACAEIAEgAxCEASIOQoCAgIBwg0KAgICA4ABRDQUgACASIA4QTSIOQoCAgIBwgyIRQoCAgIAwUgRAIBFCgICAgOAAUQ0GIAJBDGogDhB/DQYLIANBAWohAQwECyACQQxqIAQgBiABEFEaDAMLIAJBDGoiACAEIAEgBCgCBEH/////B3EQURogABA2DAULIAJBDGogExCHAUUNAQwCCyACQQxqIAhBACAMEFEaDAALAAsgAigCDCgCECIAQRBqIAIoAhAgACgCBBEAAAtCgICAgOAACyEPIAJBMGokACAPC28BA38DQCAAKAIoIgFBAExFBEAgACABQQFrIgE2AiggACgCACAAKAIEIAFBA3RqKQMAEA8MAQsLIAAoAgQiASAAQQhqIgJHBEAgACgCACgCECIDQRBqIAEgAygCBBEAAAsgAEEENgIsIAAgAjYCBAtEACAAQRBqIAEgAnQgAmtBEWogACgCABEDACIABEAgAEEANgIMIABBATYCACAAIAFB/////wdxIAJBH3RyrTcCBAsgAAupAgEEfyMAQUBqIgckACAHIAEtAAAiCEEBdkEBcTYCJCAHIAhBAnZBAXE2AiAgByAIQQR2QQFxIgg2AiggByABLQABIgk2AhggAS0AAiEKIAdBADYCPCAHIAY2AiwgByAFQQIgBSAIGyAFQQFHGzYCFCAHIAIgBCAFdGo2AhAgByACNgIMIAcgCjYCHCAHQgA3AjQgByAKQQJ0IgYgCUEDdGpBEGo2AjAgCUEBdCEEQQAhCANAIAQgCEZFBEAgACAIQQJ0akEANgIAIAhBAWohCAwBCwsgByAGQQ9qQfAPcWsiBCQAIAdBDGogACAEQQAgAUEHaiACIAMgBXRqQQAQpQYhASAHKAIsKAIQIgBBEGogBygCNEEAIAAoAggRAQAaIAdBQGskACABC/wGAgh/A34jAEEQayIGJAACQAJAIAAgARDwAiICRQ0AIAAgAykDABAoIg5CgICAgHCDQoCAgIDgAFEEQCAOIQEMAgsCQCAAIAFB1QAgAUEAEBQiDEKAgICAcINCgICAgOAAUQ0AIAAgBkEIaiAMEKMBDQAgAigCBCIFLQAQQSFxIgNFBEAgBkIANwMICwJAIAUtABEiCUUEQEEAIQIMAQsgACAJQQN0ECkiAkUNAQsCQAJ+AkACQAJAAkACQAJAAkAgBikDCCIMIA6nIgopAgQiDUL/////B4NVDQAgAiAFQRBqIApBEGoiByAMpyANpyIEQf////8HcSAEQR92IgggABDwBCIEQQFGDQMgBEEASA0BIAMNACAEQQJHDQILIAAgAUHVAEIAEEVBAE4NAQwFCyAAQYvLAEEAEEYMBAsgACAOEA9CgICAgCAhAQwBCyADBEAgACABQdUAIAIoAgQgB2sgCHWtEEVBAEgNAwtCgICAgDAhDUKAgICA4AAgABA+IgFCgICAgHCDQoCAgIDgAFENAxpBACEDQQAhBCAFLAAQQQBIBEAgBSgAEyEEIABCgICAgCAQRyINQoCAgIBwg0KAgICA4ABRBEBCgICAgOAAIQ0MAwsgBCAFakEXaiEECwNAIAMgCUcEQEKAgICAMCEMAkAgAiADQQN0aigCACIFRQ0AIAIgA0EDdEEEcmooAgAiC0UNACAAIAogBSAHayAIdSALIAdrIAh1EIQBIgxCgICAgHCDQoCAgIDgAFENBAsgBEUgA0VyRQRAAkAgBC0AAEUNACAMQiCIp0F1TwRAIAynIgUgBSgCAEEBajYCAAsgACANIAQgDEGHgAEQ7wFBAE4NACAAIAwQDwwFCyAEED8gBGpBAWohBAsgACABIAMgDEGHgAEQrwEhBSADQQFqIQMgBUEATg0BDAMLCyAAIAFBhwEgDUGHgAEQGUEASA0BIAAgAUHXACACKAIAIAdrIAh1rUGHgAEQGUEASA0BIAEhDCAAIAFB2AAgDkGHgAEQGUEASA0ECyAAKAIQIgBBEGogAiAAKAIEEQAADAYLIAEMAQtCgICAgDAhDUKAgICAIAshDCAAIA0QDyAAIA4QDwsgACAMEA8gACgCECIAQRBqIAIgACgCBBEAAAwBCyAAIA4QDwtCgICAgOAAIQELIAZBEGokACABC/UBAQh/QX8hAiABIAFBAWtxRQRAIABBEGoiCCABQQJ0IgMgACgCABEDACIFBH8gBUEAIAMQKyEGIAFB/////wNqQf////8DcSEJIAAoAjQhBwNAIAQgACgCJE9FBEAgByAEQQJ0aigCACECA0AgAgRAIAAoAjggAkECdGooAgAiAygCDCEFIAMgBiAJIAMoAghxQQJ0aiIDKAIANgIMIAMgAjYCACAFIQIMAQsLIARBAWohBAwBCwsgCCAHIAAoAgQRAAAgACABQQF0NgIwIAAgATYCJCAAIAY2AjRBAAVBfwsPC0HujwFBrvwAQYAUQc3ZABAAAAsYACAAKAIQIgBBEGogASACIAAoAggRAQALEwAgAEEQaiABIAIgACgCCBEBAAtuAQR/QX8hBkF/IAIoAgAiBEEBdiAEaiAEQanVqtV6SxshBQJAAkAgAyABKAIAIgdGBEAgACAFECkiAEUNAiAAIAMgBBAfGgwBCyAAIAcgBRCJAiIARQ0BCyABIAA2AgAgAiAFNgIAQQAhBgsgBguNAwEDfyMAQUBqIgIkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAIAAgAkEkaiABpyIEKAIEQf////8HcUECahA9DQAgAkEkakEiEDsNACACQQA2AjwDQCAEKAIEQf////8HcSADSgRAAkACQAJAAkACQAJAAkACQAJAAkAgBCACQTxqEMkBIgNBCGsOBgUCBAEGAwALIANBIkYgA0HcAEZyDQYLIANBgPD/AHFBgLADRyADQSBPcQ0GIAIgAzYCACACQRBqIgNBEEGBISACEE4aIAJBJGogAxCIAQ0KDAcLQfQAIQMMBAtB8gAhAwwDC0HuACEDDAILQeIAIQMMAQtB5gAhAwsgAkEkakHcABA7DQQgAkEkaiADEDtFDQEMBAsgAkEkaiADELkBDQMLIAIoAjwhAwwBCwsgAkEkakEiEDsNACAAIAEQDyACQSRqEDYhAQwBCyAAIAEQDyACKAIkKAIQIgBBEGogAigCKCAAKAIEEQAAQoCAgIDgACEBCyACQUBrJAAgAQuKAwIDfgJ/IwBBEGsiAiQAQoCAgIAwIQYCQAJAIAAgAkEIaiAAIAEQJSIBEDwNAAJAIAIpAwgiB0IAVwRADAELIAdCAX0hBQJAAkACQAJAIAEgAkEEaiACEIoCRQ0AIAcgAigCACIIrVINACABpyEJIAIoAgQhAyAERQ0BIAMpAwAhBiADIANBCGogCEEDdEEIaxCcAQwCCwJAIAQEQCAAIAFCABBNIgZCgICAgHCDQoCAgIDgAFENBiAAIAFCAEIBIAVBARD0AkUNAQwGCyAAIAEgBRBzIgZCgICAgHCDQoCAgIDgAFENBQsgACABIAUQ+gFBAE4NAgwECyAIQQN0IANqQQhrKQMAIQYLIAkgCSgCKEEBazYCKAsgB0KBgICACFQNAEKAgICAwH4gBbm9IgVCgICAgMCBgPz/AH0gBUL///////////8Ag0KAgICAgICA+P8AVhshBQsgACABQTAgBRBFQQBODQELIAAgBhAPQoCAgIDgACEGCyAAIAEQDyACQRBqJAAgBgvkBQIGfgR/IwBBEGsiDCQAAn4CQAJAAkAgACABECUiBkKAgICAcFQNACAGpyILLwEGQQJHDQAgCy0ABUEJcUEJRw0AIAsoAhAtADNBCHFFDQAgCygCFCkDACIBQv////8PVg0AIAwgAcQiBzcDCCAHIAs1AihSDQAgByACrHwiBUL/////B1UNACALNQIgIAVTBEAgACALIAWnEKwFDQMLAn8gBEUgAkEATHJFBEAgCygCJCIEIAJBA3RqIAQgAadBA3QQnAFBAAwBCyABpwshDUEAIQQgAkEAIAJBAEobIQIDQCACIARHBEAgAyAEQQN0aikDACIBQiCIp0F1TwRAIAGnIg4gDigCAEEBajYCAAsgCygCJCAEIA1qQQN0aiABNwMAIARBAWohBAwBCwsgCyAFPgIoIAsoAhQgBUL/////D4M3AwAgBUKAgICACHwhAQwBCyAAIAxBCGogBhA8DQEgDCkDCCIBIAKsIgh8IgVCgICAgICAgBBZBEAgAEHQ2gBBABAVDAILAkAgBEUgAkEATHJFBEBCACEHIAAgBiAIQgAgAUF/EPQCDQMMAQsgASEHCyACQQAgAkEAShutIQlCACEBA0AgASAJUgRAIAMgAadBA3RqKQMAIghCIIinQXVPBEAgCKciAiACKAIAQQFqNgIACyABIAd8IQogAUIBfCEBIAAgBiAKIAgQhgFBAE4NAQwDCwsgACAGQTAgBUKAgICACHwiAUL/////D1gEfiAFQv////8PgwVCgICAgMB+IAW5vSIHQoCAgIDAgYD8/wB9IAdC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQELIAAgBhAPIAVC/////w+DIAFC/////w9YDQEaQoCAgIDAfiAFub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwwBCyAAIAYQD0KAgICA4AALIQEgDEEQaiQAIAEL0gMCB38DfiMAQSBrIgQkACAEQQA2AgwgBEEANgIIAkACQCAEIAAoAhAoAnhJBEAgABDpAQwBCyAAIAEgAiABQQAQFCILQoCAgIBwg0KAgICA4ABRBEAgCyEBDAILAkACQCALQoCAgIBwVA0AIAAgCxDKASIKQQBIDQECQCAKBEAgACAEQQxqIAsQ1gFFDQEMAwsgACAEQQhqIARBDGogC6dBERCOASEJIAQoAgghBSAJQQBIDQILIAQoAgwhCANAIAcgCEYNAQJAIAoEQCAAIAcQqQUiBkUNBAwBCyAAIAUgB0EDdGooAgQQGCEGCwJ/AkAgACALIAYgAxD5BCINQoCAgIBwgyIMQoCAgIAwUgRAIAxCgICAgOAAUg0BIAAgBhATDAULIAAgCyAGQQAQ1QEMAQsgACALIAYgDUEHEBkLIQkgACAGEBMgB0EBaiEHIAlBAE4NAAsMAQsgACAFIAgQWkEAIQUgACACEFwiDEKAgICAcINCgICAgOAAUQ0AIAQgCzcDGCAEIAw3AxAgACADIAFBAiAEQRBqECEhASAAIAwQDyAAIAsQDwwCCyAAIAUgBCgCDBBaIAAgCxAPC0KAgICA4AAhAQsgBEEgaiQAIAELPwEBfyABQQAgAUEAShshAQNAAkAgASADRgRAQX8hAwwBCyAAIANBA3RqKAIEIAJGDQAgA0EBaiEDDAELCyADC/8EAgJ/BH4CQCACQv////9vWARAIAAQJAwBCwJAIAAgAkE9EHEEf0KAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPSACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBgQJBgAIgACAHECYbBUEACyEDIAAgAkE+EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPiACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBggRBgAQgACAHECYbIANyIQMLIAAgAkE/EHEEQEKAgICAMCEFQoCAgIAwIQZCgICAgDAhCCAAIAJBPyACQQAQFCIHQoCAgIBwg0KAgICA4ABRDQFBhAhBgAggACAHECYbIANyIQMLQoCAgIAwIQYCQCAAIAJBwAAQcUUEQEKAgICAMCEIDAELQoCAgIAwIQUgACACQcAAIAJBABAUIghCgICAgHCDQoCAgIDgAFEEQAwCCyADQYDAAHIhAwsCQAJAIAAgAkHBABBxRQ0AQoCAgIAwIQUgA0GAEHIhAyAAIAJBwQAgAkEAEBQiBkKAgICAcIMiB0KAgICAMFENAEHDwgAhBCAHQoCAgIDgAFENASAAIAYQOEUNAQsCQCAAIAJBwgAQcUUEQEKAgICAMCEFDAELIANBgCByIQMgACACQcIAIAJBABAUIgVCgICAgHCDIgJCgICAgDBRDQBBtMIAIQQgAkKAgICA4ABRDQEgACAFEDhFDQELIANBgDBxBEBBsekAIQQgA0GAxABxDQELIAEgBTcDGCABIAY3AxAgASAINwMIIAEgAzYCAEEADwsgACAEQQAQFQsgACAIEA8gACAGEA8gACAFEA8LQX8LwgEBAn8gAigCBEUEQCACKAIYIgMgAigCHCIENgIEIAQgAzYCACACQgA3AhgCQCABKAIABEAgAhCfBQwBCyAAIAIpAyAQIwsgACACKQMoECMgAiACKAIAQQFrIgM2AgACQCADRQRAIAIoAhAiAyACKAIUIgQ2AgQgBCADNgIAIAJCADcCECAAQRBqIAIgACgCBBEAAAwBCyACQoCAgIAwNwMoIAJCgICAgDA3AyAgAkEBNgIECyABIAEoAgxBAWs2AgwLC5UBAQN+IAG9IgJC////////////AIMhAyAAvSIEQv///////////wCDQoGAgICAgID4/wBaBEAgA0KBgICAgICA+P8AVA8LAn9BfyADQoCAgICAgID4/wBWIAAgAWNyDQAaQQEgACABZA0AGkEAIABEAAAAAAAAAABiDQAaIARCAFMEQCACQj+Hp0F/cw8LIAJCP4inCwswACABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgACABEDcPCyAAIAFBOEEAQQAQrQILKQEBfyACQiCIp0F1TwRAIAKnIgMgAygCAEEBajYCAAsgACABIAIQxQULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCEAVCgICAgOAACws4ACAAIAEgAhCTASIARQRAQoCAgIDgAA8LIAAoAiAoAgwiACAAKAIAQQFqNgIAIACtQoCAgIBwhAtRAgF+AX8gACAAKQOQAUEDEEkiAkKAgICAcINCgICAgOAAUgRAIAFCIIinQXVPBEAgAaciAyADKAIAQQFqNgIACyAAIAJBNCABQQMQGRoLIAILlQEBA38jAEEQayIEJAAgBCACNwMIIAEoAgAiBSABKAIEIgY2AgQgBiAFNgIAIAFCADcCACAAIAAgAUEgaiADQQN0aikDAEKAgICAMEEBIARBCGoQIRAPIAAgASkDEBAPIAAgASkDGBAPIAAgASkDIBAPIAAgASkDKBAPIAAoAhAiAEEQaiABIAAoAgQRAAAgBEEQaiQAC40BAQN/IwBBEGsiBCQAIAQgATcDCCADQQF0IQZBACEDA0ACQAJAIANBAkYNACAAQcwAQQEgAyAGakEBIARBCGoQzwEiAUKAgICAcINCgICAgOAAUg0BQX8hBSADQQFHDQAgACACKQMAEA8LIARBEGokACAFDwsgAiADQQN0aiABNwMAIANBAWohAwwACwALyAYC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IARuDAILIARBACABQQJPGyADbAwBCyAAQX9zQR92IQQgAUECayEBIAQCfiACBEAgA60iBiABQQN0IgFB5KEEajUCAH5CIIggAUHgoQRqNQIAIAZ+fEIfiAwBCyABQQJ0QYCkBGo1AgAgA61+Qh2IC6dqCyIBayABIABBAEgbC0gBAn8jAEEQayICJABBfyEDAkAgACACQQxqIAEQugENACACKAIMIgNBJWtBXEsNACAAQdmJAUEAEFBBfyEDCyACQRBqJAAgAwt1AQF/AkAgAUKAgICAcINCgICAgOB+UQRADAELAkAgAUKAgICAcFQNACABpyICLwEGQSFHDQAgAikDICIBQoCAgIBwg0KAgICA4H5SDQAMAQsgAEGiLEEAEBVCgICAgOAADwsgAaciACAAKAIAQQFqNgIAIAELrgICAXwBfwJAA0ACQAJAAkACQAJAQQcgAkIgiKciBCAEQQdrQW5JG0EJag4RAgMDAwMDAwMDAAAAAAMDBAEDCyABIALENwMADAULIAJCgICAgMCBgPz/AHwiAkL///////////8Ag0KBgICAgICA+P8AWgRAIAFCADcDAAwFCyACvyIDRAAAAAAAAODDYwRAIAFCgICAgICAgICAfzcDAAwFCyADRAAAAAAAAOBDZARAIAFC////////////ADcDAAwFCyABAn4gA5lEAAAAAAAA4ENjBEAgA7AMAQtCgICAgICAgICAfws3AwAMBAsgASACp0EEakEAEIIDGiAAIAIQDwwDCyAAIAIQjQEiAkKAgICAcINCgICAgOAAUg0BCwsgAUIANwMAQX8PC0EAC7ECAQJ/IwBBIGsiBCQAAkACQAJAIAIoAgxFBEACQAJAAkACQCACKAIIQf7///8Haw4CAQACCyAAEDUMAgsgAigCBA0DCyAAIAIQRBoLQQAhAiABRQ0DIAFCABAwGgwDCyACKAIERQ0BCyAAEDVBASECIAFFDQEgAUIAEDAaDAELIAAgAiACKAIIQQFqQQJtQQEQkQYgAEEBENEBGiABIgNFBEAgACgCACEDIARCADcCGCAEQoCAgICAgICAgH83AhAgBCADNgIMIARBDGohAwsgAyAAIABB/////wNBARBDGiADIAMoAgRBAXM2AgQgAyADIAJB/////wNBARDLARpBICECIAMoAghB/////wdHBEAgAygC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AkEAEI0FIQVBECEEA0AgA0E0aiILIAJBACAEIAVqIglBAWoiB0HgDxD8AiALIAsgA0EgaiAHQeAPEENyIgdBIHENAyAHQRBxRQ0CIANBNGogAygCPEEBIAkQ4QMNAiAEQQJtIARqIQQMAAsACyADQTRqIANBIGoQRA0BDAMLIANBNGpBARDRAUEgcUUNAgsgA0E0ahAbDAQLIANByABqIANBNGogAiAFIAUQjAUMAQsgAygCTCEFIANByABqIANBNGogAiAIIAgQjAUgAygCTCIJIAVBAWoiAiACIAlJG0EBayEIIAMoAkghByAFIQQDQAJAIAkgBCICQQFqIgRNBEAgCCECDAELIAIgB2otAABBMEcNACAEIAdqLQAAQS5HDQELCyACIAVNDQAgBSAHaiACIAdqIAkgAmsQnAEgAyAFIAJrIAlqNgJMCyADQTRqEBsLIANByABqQQAQESADKAJUDQAgAygCSAwBC0EAIAMoAkgiAkUNABogCigCACACQQAgCigCBBEBABpBAAshBCAGIAw2AgQgACAGIANBDGoQXiAERQRAIAAQfAwBCyAAIAQQYiENIAAoAtgBIgAoAgAgBEEAIAAoAgQRAQAaCyADQeAAaiQAIA0Lw3UCEn8BfiMAQaAGayIDJAAgASgCyAEiBEEAIARBAEobIQYDQCACIAZGRQRAIAEoAswBIAJBA3RqQX82AgQgAkEBaiECDAELCyABKAI8BEAgASgCzAFBfjYCDAtBACECIAEoAnwiBkEAIAZBAEobIQYCfgJAAkADQCACIAZGBEACQEECIQJBAiAEIARBAkwbIQgDQAJAIAIgCEYEQEEAIQIDQCACIAZGDQICQCABKAJ0IAJBBHRqIgQoAghBAE4NACAEKAIEIghBAkgNACAEIAEoAswBIgQgBCAIQQN0aigCAEEDdGooAgQ2AggLIAJBAWohAgwACwALIAEoAswBIgcgAkEDdGoiBCgCBEEASARAIAQgByAEKAIAQQN0aigCBDYCBAsgAkEBaiECDAELCwJAIAEoAkRFDQACQCABKAIgDQAgAS0AbkEBcQ0AIAEgACABQdIAEE82ApABIAEoAjxFDQAgASAAIAFB0wAQTzYClAELAkAgASgCTCIIRQ0AIAEoAqgBQQBIBEAgASAAIAEQygM2AqgBCyABKAKsAUEASARAIAEgACAB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KAIAEB0gAkHAABARIAIgACAJKAIMEBgQHSACIBEQEQsgACAJKAIMEBMgBEEBaiEEDAALAAtBhSlBrvwAQYzyAUH7ORAAAAtBmoIBQa78AEHY6wFB3/QAEAAAC0GuhAFBrvwAQZvrAUHf9AAQAAALA0AgAiAOTkUEQCADQYAGaiACIA1qIgQgBC0AAEECdEGAuAFqLQAAIgQQciACIARqIQIMAQsLIAwQ9gEgDCADKQOQBjcCECAMIAMpA4gGNwIIIAwgAykDgAY3AgAMDAsgDBD2ASAMIAMpA5AGNwIQIAwgAykDiAY3AgggDCADKQOABjcCAAJAIAEoAowCDQAgASgCpAIhDSADIAEoAvACNgKYBiADIAEoAoACIgk2AtwFIAMgASgChAIiCzYC4AUgACgCECECIANCADcDiAYgA0IANwOABiADIAI2ApQGIANBOzYCkAYgASgC0AIiAgRAIAEgASgCACACQQR0EF8iAjYCzAIgAkUNDQsCQCABKALcAiICRQ0AIAEtAG5BAnENACABIAEoAgAgAkEDdBBfIgI2AtgCIAJFDQ0gAUEANgLoAiABIAEoAvACNgLkAgsgASgCtAFBAE4EQCADQYAGaiICQQwQESACQQQQESACQdkAIAEoArQBEF0LIAEoArABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKwARBdCyABKAKsAUEATgRAIANBgAZqIgJBDBARIAJBAxARIAJB2QAgASgCrAEQXQsCQCABKAKoAUEASA0AIAEoAmAEQCADQYAGaiICQeEAEBEgAiABLwGoARAqDAELIANBgAZqIgJBCBARIAJB2QAgASgCqAEQXQsgASgCmAFBAE4EQEEAIQIgAS0AbkEBcUUEQCABKAI4QQBHIQILIANBgAZqIgRBDBARIAQgAhARIAEoApwBIgJBAE4EQCADQYAGakHaACACEF0LIANBgAZqQdkAIAEoApgBEF0LIAEoAqABQQBOBEAgA0GABmoiAkEMEBEgAkECEBEgAkHZACABKAKgARBdCyABKAKQAUEATgRAIANBgAZqIgJBDBARIAJBBRARIAJB2QAgASgCkAEQXQsgASgClAFBAE4EQCADQYAGaiICQQwQESACQQUQESACQdkAIAEoApQBEF0LQQAhAgJAA0ACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAiALTgRAQQAhAiABKAKsAiIEQQAgBEEAShshBANAIAIgBEYNAiACQRRsIQYgAkEBaiECIAYgDWooAhBFDQALQdWDAUGu/ABB/foBQZQ4EAAACyACIAIgCWoiBi0AACIFQQJ0QYC4AWotAAAiB2ohBAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBUHYAGsOIBASGhESGhESGhoaGhoaGhoaBAQBAwIaGgwMBQUFBQUFAAsCQCAFQQFrDhUJCgoLGg0HGggIGhoaBhoaDxoaGg4ACyAFQSJrIghBH0sNGEEBIAh0IgpBwOEBcQ0SIApBBXFFBEAgCEEfRw0ZIAYoAAFBMEcNGiABIAMoAoQGIAMoApgGEDMgA0GABmpB6QEQESAEIQIMIwsgBi8AASECIANCqICAgHA3A1AgA0HcBWogBCADQdAAahAnBEACQCADKALoBSIEQQBIBEAgAygCmAYhBAwBCyADIAQ2ApgGCyABIAMoAoQGIAQQMyADQYAGaiAFQQFqIAIQXSABIAkgCyADKALkBSADQZgGahCkAiECDCMLIAEgAygChAYgAygCmAYQMyADQYAGaiAFIAIQXSAEIQIMIgsgBigAASEFIAQhBgwWCyAGKAABIQdB7QAhBQwUCyAGKAABIQdB7AAhBQwTCyABIAYoAAEgA0GcBmpBABDHAyEHIAMoAtwFIAMoAuAFIAQgBxDGAwRAIAEgB0F/EGkaIANBgAZqQQ4QESAEIQIMHwsgA0LrgICAcDcDYCADQdwFaiAEIANB4ABqECdFDRIgAygC6AUhCCADKALcBSADKALgBSADKALkBSIGIAcQxgNFDRIgCEEATgRAIAMgCDYCmAYLIAEgB0F/EGkaIAVBA3MhBSADKAL0BSEHDBwLIAYtAAkhCCAGKAABIQcgASAGKAAFIANBnAZqQQAQxwMiAkEASA0PIAIgASgCrAJODQ8gASADKAKEBiADKAKYBhAzIAEgASgC1AIiBkEBajYC1AIgASgCzAIgBkEEdGoiBkEENgIEIAYgBTYCACADKAKEBiEKIAYgAjYCDCAGIApBBWo2AgggA0GABmoiBiAFEBEgBiAHEB0gBiANIAJBFGxqIgIoAgwgAygChAZrEB0gAigCDEF/RgRAIAAgAiADKAKEBkEEa0EEEOgCRQ0dCyADQYAGaiAIEBEgBCECDB0LIANCqYCAgHA3A3AgA0HcBWogBCADQfAAahAnRQ0TIAQhAiADKALoBSIEQQBIDRwgAyAENgKYBgwcCyADQquBgIBwNwOgASADQdwFaiAEIANBoAFqECcEQAJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqQfMBEBEMGAsgA0F/NgKYASADQqyBgICQzRo3A5ABIANB3AVqIAQgA0GQAWoQJ0UNAAJAIAMoAugFIgVBAEgEQCADKAKYBiEFDAELIAMgBTYCmAYLIAEgAygChAYgBRAzIANBgAZqQfMBEBEgAygC7AVBA3MhBQwYCyADQunUgYBwNwOAASADQdwFaiAEIANBgAFqECdFDREgBUEKRiEKDA0LAkAgBigAASIGQYCAgIB4ckGAgICAeEYNACADQoyBgIBwNwPgASADQdwFaiAEIANB4AFqECdFDQAgAygC6AUiAkEATgRAIAMgAjYCmAYLIANCjoCAgHA3A9ABIANB3AVqIAMoAuQFIANB0AFqECcEQCADKALoBSICQQBIDRcgAyACNgKYBgwXCyABIAMoAoQGIAMoApgGEDMgA0GABmpBACAGaxDFAwwWCyADQo6AgIBwNwPAASADQdwFaiAEIANBwAFqECcEQCADKALoBSICQQBIDRYgAyACNgKYBgwWCyADQunUgYBwNwOwASADQdwFaiAEIANBsAFqECcEQCAGQQBHIQoMDQsgASADKAKEBiADKAKYBhAzIANBgAZqIAYQxQMgBCECDBkLIAYoAAEiAkH/AUoNDyABIAMoAoQGIAMoApgGEDMgA0GABmoiBiAFQcMAa0H/AXEQESAGIAJB/wFxEBEgBCECDBgLIAYoAAEhAiADQo6AgIBwNwPwASADQdwFaiAEIANB8AFqECcEQCAAIAIQEyADKALoBSICQQBIDRQgAyACNgKYBgwUCyACQS9HDQ4gASADKAKEBiADKAKYBhAzIANBgAZqQcEBEBEgBCECDBcLIANCyYCAgHA3A6gCIANC2Lb5gnA3A6ACIANB3AVqIAQiAiADQaACahAnDRYgA0F/NgKYAiADQoGEkICQCTcDkAIgA0HcBWogAiADQZACahAnDRYgA0F/NgKIAiADQoaO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DQMgAyAGKAABNgKYBiAEIQIMDAsgBigAASICQQBIDQMgAiABKAKsAk4NAyANIAJBFGxqIggoAgxBf0cNBCAIIAMoAoQGNgIMIAgoAhAhBwNAIAciAgRAIAgoAgwgAigCBCIFayEGIAIoAgAhBwJAAkACQAJAIAIoAghBAWsOBAIBAwADCyADKAKABiAFaiAGNgAADAILIAZBgIACakGAgARPDQkgAygCgAYgBWogBjsAAAwBCyAGQYABakGAAk8NCSADKAKABiAFaiAGOgAACyAAKAIQIgZBEGogAiAGKAIEEQAADAELCyAIQQA2AhAgBCECDAsLIANCjoCAgHA3A6gFIANC2bj9gnA3A6AFIANB3AVqIAQgA0GgBWoQJwRAIAMoAugFIgJBAE4EQCADIAI2ApgGCyADIAMoAvAFIgY2ApQFIANBfzYCmAUgAyADKALsBSIEQQFrNgKQBSADQdwFaiADKALkBSICIANBkAVqECcEQCADKALoBSICQQBOBEAgAyACNgKYBgsgBEEBaiEEIAMoAuQFIQILIAEgAygChAYgAygCmAYQMyADQYAGaiIHIAVBAmtB/wFxEBEgByAEIAYQXQwLCyADQo6AgIBwNwOIBSADQpiAgICw6A43A4AFIANB3AVqIAQgA0GABWoQJwRAAkAgAygC6AUiAkEASARAIAMoApgGIQIMAQsgAyACNgKYBgsgASADKAKEBiACEDMgA0GABmoiAiAFQQJrQf8BcRARIAIgAy0A7AUQESACIAMoAvwFEB0MBwsgA0KOgICAcDcD+AQgA0KZgICAkAk3A/AEIANB3AVqIAQgA0HwBGoQJ0UNAQJAIAMoAugFIgJBAEgEQCADKAKYBiECDAELIAMgAjYCmAYLIAEgAygChAYgAhAzIANBgAZqIgIgBUECa0H/AXEQESACQckAEBEMBgsgA0F/NgLIBSADQoSAgICwlevUqn83A8AFIANB3AVqIAQgA0HABWoQJ0UNACADKALoBSIIQQBOBEAgAyAINgKYBgsgAygC7AUhCCADKAL8BSIFQcUARgR/QfQBBSAFQRtHDQFB9QELIQogCEF9cUGpAUYEQCABIAMoAoQGIAMoApgGEDMgA0GABmogChARIAAgAygC/AUQEwwGCyADQumAgIBwNwOwBSADQdwFaiADKALkBSADQbAFahAnRQ0A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DAELIAEgAzYCACACIAY2AgBBACEECyAHQRBqJAAgBAvCAwEJfyABKAIIIgZBACAGQQBKGyEFAkACQANAIAQgBUYNASAEQQJ0IQcgBEEBaiEEIAcgASgCAGooAgAgAkcNAAtBACEFDAELQX8hBSAAIAFBBCABQQRqIAZBAWoQeA0AIAEgASgCCCIEQQFqNgIIIAEoAgAgBEECdGogAjYCACABQRBqIQkgAUEMaiEHQQAhBQNAAkAgAigCICAFTARAQQAhBUEAIQQDQCAEIAIoAixODQQgBEECdCEDIARBAWohBCAAIAEgAigCECADIAIoAihqKAIAQQN0aigCBEEBEK8FRQ0ACwwBCwJAIANBACACKAIcIAVBFGxqIgYoAhAiCkEWRhsNAEEAIQQgASgCFCIIQQAgCEEAShshCwJAAkADQCAEIAtGDQEgCiAHKAIAIARBDGxqIgwoAgBHBEAgBEEBaiEEDAELCyAEQQBODQELIAAgB0EMIAkgCEEBahB4DQIgASABKAIUIgRBAWo2AhQgASgCDCAEQQxsaiIEIAYoAhA2AgACQCADRQRAIAYoAghFDQELIARBADYCCAwCCyAEIAY2AggMAQsgDEEANgIICyAFQQFqIQUMAQsLQX8PCyAFC2gCAn8BfiAAQRBqIQIgACkCBCIEp0H/////B3EhAwJAIARCgICAgAiDUEUEQEEAIQADQCAAIANGDQIgAiAAQQF0ai8BACABQYcCbGohASAAQQFqIQAMAAsACyACIAMgARCyBSEBCyABCxIAIAAgASACIANBgIABENABGgssAQF/A0AgASADRkUEQCAAIANqLQAAIAJBhwJsaiECIANBAWohAwwBCwsgAgvOAQIDfwF+IAEgAkEBELIFIgNB/////wNxIQUgACgCNCAAKAIkQQFrIANxQQJ0aiEDA0AgAygCACIERQRAQQAPCwJAIAAoAjggBEECdGooAgAiAykCBCIGQiCIp0H/////A3EgBUcgBkKAgICAgICAgECDQoCAgICAgICAwABSciAGp0H/////B3EgAkcgBkKAgICACINCAFJycg0AIANBEGogASACEGENACAEQd4BTgRAIAMgAygCAEEBajYCAAsgBA8LIANBDGohAwwACwALfwEEfyABLQAAQdsARgRAIAFBAWoiAxA/QQFrIQIgACgCECgCOCEEQdABIQEDQCABQd4BRwRAAkAgBCABQQJ0aigCACIFKAIEQf////8HcSACRw0AIAVBEGogAyACEGENACAAIAEQGA8LIAFBAWohAQwBCwsQAQALIAAgARCqAQusAgMCfwJ+AXwjAEEgayICJABEAAAAAAAA+H8hBiAAKAIIQf////8HRwRAIAAoAgAhAyACQgA3AhggAkKAgICAgICAgIB/NwIQIAIgAzYCDCACQQxqIAAQRBoCfiACKAIUIgBB/f///wdMBEAgAkEMakE1QcgEEM4BGiACKAIUIQALQoCAgICAgID4/wAgAEH+////B0YNABogAEGAgICAeEYEQEIADAELIAIoAhwhAwJ+IAIoAhhBAkYEQCADKQIADAELIAM1AgBCIIYLIQQgAEGCeEwEQCAEQY54IABrrYghBEIADAELIARCC4hC/////////weDIQQgAEH+B2qtQjSGCyEFIAQgBYQgAjUCEEI/hoS/IQYgAkEMahAbCyABIAY5AwAgAkEgaiQACw4AIABCgICAgPB+EIAGC+4PAwt/A34BfCMAQUBqIhAkAEHfAEGAAiAEQSBxGyEJIARBgANxIQsCQAJAAkACfwJAAkACQAJAAkACQAJAAkACQCABLQAAIgZBK2sOAwEDAAMLQQEhDiABQQFqIQEMAQsgAUEBaiEBCyAEQYAIcUUNASABLQAAIQYLIAZB/wFxQTBHDQACQAJAAkAgAS0AASIHQfgARwRAIAdB7wBGDQIgB0HYAEcNAQsgA0FvcQ0FIAFBAmohB0EQIQMMCQsgAyAHQc8AR3INAQwFCyADRQ0EDAMLAkACQCAHQeIARwRAIANFIAdBwgBGcQ0BIAMgB0Ewa0H/AXFBCUtyDQQgBEEQcQ0CDAcLIAMNBAsgBEEEcUUNBUECIQMgAUECaiEHDAcLIAFBAWohB0EBIQYDQCABIAZqIQMgBkEBaiEGIAMtAAAiCEH4AXFBMEYNAAtBCCEDQYACIQlBASEKIAhB/gFxQThGDQQMBgsgBEEBcSALQYACckGAAkdyDQAgAUEIaiEHQfUcIQYgASEIA0AgBkH9HEcEQCAILQAAIAYtAABHDQIgBkEBaiEGIAhBAWohCAwBCwsgC0GAAkYEQCAAELYFIhFCgICAgHCDQoCAgIDgAFEEQEKAgICA4AAhEQwJCyARp0EEaiAOEIwBDAgLRAAAAAAAAPD/RAAAAAAAAPB/IA4bIhS9IhECfyAUmUQAAAAAAADgQWMEQCAUqgwBC0GAgICAeAsiBre9UQRAIAatIREMCAtCgICAgMB+IBFCgICAgMCBgPz/AH0gEUL///////////8Ag0KAgICAgICA+P8AVhshEQwHCyABIgcgA0UNAxoMBQsgASEHDAQLIARBBHFFDQAgAUECaiEHQQghAwwCCyABCyEHQQohAwwBC0KAgICAwH4hESAHLQAAEJYBIANPDQELQQAhBiADQQpHIQwgByEBA0ACQCAGIAdqIg0tAAAiCMAhDyAIEJYBIANOBEAgCSAPRw0BAkAgDCAGQQFHcg0AIA1BAWstAABBMEcNAEEBIQYMAgsgDS0AARCWASADTg0BCyAHIAZBAWoiBmohAQwBCwtBACEMAkACQCAEQQFxDQACQCAIQS5HDQAgDS0AASEIIAZFBEAgCBCWASADTg0BCyANQQFqIQFCgICAgMB+IREgCSAIwEYNAgNAAkAgCEH/AXEQlgEgA0gEQCABLQABIQgMAQtBASEMIAkgCMBHDQIgAS0AASIIEJYBIANODQILIAFBAWohAQwACwALIAEgB00NAAJAIAEtAAAiBkHlAEcEQCADQQpGIAZBxQBGcQ0BIAZBIHJB8ABHIANBEEtyDQJBASADdEGEggRxDQEMAgsgA0EKRw0BC0EBIQwgAUEBaiEGAkACQAJAIAEtAAFBK2sOAwACAQILIAFBAmohBgwBCyABQQJqIQYLIAYtAABBOmtBdkkNACAGIQEDQCABIgZBAWohASAGLQABIgjAIQ0gCEE6a0F1Sw0AIAkgDUcNASAGLQACQTprQXVLDQALCyABIAdGBEBCgICAgMB+IREMAQsgECEJAkAgASAHayINQQJqIg9BwQBPBEAgACgCECIGQRBqIA8gBigCABEDACIJRQ0BC0EAIQZBACEIIA4EQCAJQS06AABBASEICyANQQAgDUEAShshDgNAIAYgDkZFBEAgBiAHai0AACINQd8ARwRAIAggCWogDToAACAIQQFqIQgLIAZBAWohBgwBCwsgCCAJakEAOgAAAn4CQAJAIARBwABxBEACQAJAAkACQCABLQAAQewAaw4DAQIAAwsgAUEBaiEBQYABIQsMBQsgAUEBaiEBQYACIQsMBAsgAUEBaiEBQYADIQsMAwsgBEGABHEEQEKAgICAwH4gCg0EGiALQYABIAwbIQsMAwsgA0EKRw0BDAILIAsNASAEQYAEcQRAQoCAgIDAfiAKDQMaIAxFQQd0IQsMAgtBACELIANBCkYNAQtCgICAgMB+IAwNARoLAkACQAJAAkACQAJAIAtBGXcOBAABAgMECwJ8IAwgA0EKRnFFBEAgCSAJLQAAIgRBLUZqIQcDQCAHIgZBAWohByAGLQAAIghBMEYNAAtCmLPmzJmz5swZIRIgA0EKRwRAQQAgA2usIAOsgCESCyADrSETQQAhB0IAIREDQAJAIAhB/wFxIgVFDQAgBRCWASIFIANODQAgESAFrSARIBN+fCARIBJWIgUbIREgBSAHaiEHIAYtAAEhCCAGQQFqIQYMAQsLIBG6IRQgBwRAIAO3IAe3EI8DIBSiIRQLIBSaIBQgBEEtRhsMAQsgCRDkBQsiFL0hESARAn8gFJlEAAAAAAAA4EFjBEAgFKoMAQtBgICAgHgLIga3vVINBCAGrQwFC0KAgICAwH4gCiAMcg0EGiAAIAkgAyAEQQAgACgCECgCmAIRIgAMBAtCgICAgMB+IAoNAxogACAJIAMgBCAFIAAoAhAoArQCESIADAMLQoCAgIDAfiADQQpHDQIaIAAgCUEKIARBACAAKAIQKALQAhEiAAwCCxABAAtCgICAgMB+IBFCgICAgMCBgPz/AH0gEUL///////////8Ag0KAgICAgICA+P8AVhsLIREgD0HBAEkNASAAKAIQIgBBEGogCSAAKAIEEQAADAELIAAQfEKAgICA4AAhEQsgASEHCyACBEAgAiAHNgIACyAQQUBrJAAgEQtbAQR/IAAoAgAiA0EAIANBAEobIQVBACEDA0ACQCADIAVHBH8gACgCBCIGIANBPGxqKAIAIAFHDQEgBiADQTxsaiACQQJ0aigCBAVBAAsPCyADQQFqIQMMAAsAC0gBA38gAkEAIAJBAEobIQIDQCACIANGBEBBAA8LIAEgA2ohBCADQQF0IQUgA0EBaiEDIAAgBWovAQAgBC0AAGsiBEUNAAsgBAu/AQICfgJ/IAG9IgNC/////////weDIQIgA0I/iKchBAJAAkAgA0I0iKdB/w9xIgUEQCAFQf8PRw0BIAJQRQRAIAAQNUEADwsgACAEEIwBQQAPCyACUARAIAAgBBCJAUEADwsgAkIMhiICIAJ5IgOGIQJBACADp2shBQwBCyACQguGQoCAgICAgICAgH+EIQILIAAgBUH+B2s2AgggAEECEEFFBEAgACgCECACNwIAIAAgBDYCBEEADwsgABA1QSALqwECAX4CfyABKQIEQoCAgIAIgyEDIAAtAAdBgAFxRQRAIANQBEAgAEEQaiABQRBqIAIQYQ8LQQAgAUEQaiAAQRBqIAIQuQVrDwsgAUEQaiEEIABBEGohACADUARAIAAgBCACELkFDwsgAkEAIAJBAEobIQVBACEBA0AgASAFRgRAQQAPCyABQQF0IQIgAUEBaiEBIAAgAmovAQAgAiAEai8BAGsiAkUNAAsgAgvTBAEIfyADIAEoAgAiBCgCHEEDbEECbSIFIAMgBUobIQgCQCACBEAgACACKAIUIAhBA3QQiQIiA0UNASACIAM2AhQLIAQoAhgiBkEBaiIFIQMDQCADIgJBAXQhAyACIAhJDQALAkAgAiAFRwRAIAAgAkECdCIHIAhBA3RqQTBqECkiCkUNAiAEKAIIIgMgBCgCDCIFNgIEIAUgAzYCACAEQgA3AgggByAKaiIGIAQgBCgCIEEDdEEwahAfIQUgACgCECIDKAJQIgkgBUEIaiILNgIEIAUgA0HQAGo2AgwgBSAJNgIIIAMgCzYCUCAFIAJBAWsiCTYCGEEAIQMgCkEAIAcQKxogBUEwaiECA0AgAyAFKAIgT0UEQAJAIAIoAgQiB0UEQCADQQFqIQMMAQsgAiACKAIAQYCAgGBxIAUgByAJcUF/c0ECdGoiBygCAEH///8fcXI2AgAgByADQQFqIgM2AgALIAJBCGohAgwBCwsgACgCECIAQRBqIAQgBCgCGEF/c0ECdGogACgCBBEAAAwBCyAEKAIIIgIgBCgCDCIDNgIEIAMgAjYCACAEQgA3AgggACAEIAZBf3NBAnRqIAVBAnQiAiAIQQN0akEwahCJAiIDRQRAIAAoAhAiACgCUCIBIARBCGoiAjYCBCAEIABB0ABqNgIMIAQgATYCCCAAIAI2AlBBfw8LIAAoAhAiACgCUCIEIAIgA2oiBkEIaiICNgIEIAYgAEHQAGo2AgwgBiAENgIIIAAgAjYCUAsgASAGNgIAIAYgCDYCHEEADwtBfwvTAQIFfwF+AkAgASkCBCIHp0H/////B3EiBEELa0F2SQ0AIAFBEGohAgJ/IAdCgICAgAiDUCIFRQRAIAIvAQAMAQsgAi0AAAsiAUEwayIDQQlLDQACfwJAIAFBMEcEQEEBIQEDQCABIARGDQICfyAFRQRAIAIgAUEBdGovAQAMAQsgASACai0AAAtBMGsiBkEJSw0EIAFBAWohASAGrSADrUIKfnwiB6chAyAHQoCAgIAQVA0ACwwDC0EAIgMgBEEBRw0BGgsgACADNgIAQQELDwtBAAupAgIDfwF+AkAgACACEDhFDQAgAqciBC8BBkEORgRAIAAgASAEKAIgKQMAENAFDwsgAUKAgICAcFQNAAJAIAAgAkE7IAJBABAUIgJC/////29YBEBBfyEDIAJCgICAgHCDQoCAgIDgAFENASAAQcYwQQAQFQwBCyABpyEEIAKnIQUCQANAAkAgBCgCECgCLCIDRQRAQQAhAyAELwEGQTBHDQQgBCAEKAIAQQFqNgIAIAStQoCAgIBwhCEBA0AgACABEIwCIgFCgICAgHCDIgZCgICAgCBRDQRBfyEDIAZCgICAgOAAUQ0FIAGnIAVGBEAgACABEA8MAwsgABB7RQ0ACyAAIAEQDwwECyADIgQgBUcNAQsLQQEhAwwBC0EAIQMLIAAgAhAPCyADC9IDAgJ+An8jAEEgayIEJAACQCABQv///////////wCDIgNCgICAgICAwIA8fSADQoCAgICAgMD/wwB9VARAIAFCBIYgAEI8iIQhAyAAQv//////////D4MiAEKBgICAgICAgAhaBEAgA0KBgICAgICAgMAAfCECDAILIANCgICAgICAgIBAfSECIABCgICAgICAgIAIUg0BIAIgA0IBg3whAgwBCyAAUCADQoCAgICAgMD//wBUIANCgICAgICAwP//AFEbRQRAIAFCBIYgAEI8iIRC/////////wODQoCAgICAgID8/wCEIQIMAQtCgICAgICAgPj/ACECIANC////////v//DAFYNAEIAIQIgA0IwiKciBUGR9wBJDQAgBEEQaiAAIAFC////////P4NCgICAgICAwACEIgIgBUGB9wBrEGcgBCAAIAJBgfgAIAVrEI4CIAQpAwhCBIYgBCkDACIAQjyIhCECIAQpAxAgBCkDGIRCAFKtIABC//////////8Pg4QiAEKBgICAgICAgAhaBEAgAkIBfCECDAELIABCgICA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cINCgICAgJB/UXFFBEAgAEGN9wBBABAVDAELIAAgAUESEGUiAUKAgICAcINCgICAgOAAUQ0AIAGnIgQgAz4CJCAEIAI+AiAgACABQdUAQgBBAhAZGiABDwsgACADEA8gACACEA9CgICAgOAACw0AIAAgAUHOlQEQ/wMLZwEBfwJAIAFBAE4EQCAAKAIQIgIoAiwgAU0NASACKAI4IAFBAnRqKAIAIgEgASgCAEEBajYCACAAIAFBBBCABA8LQfKRAUGu/ABBzhdBmdIAEAAAC0HZ3wBBrvwAQc8XQZnSABAAAAtEAQF/IABB+AFqIQIgAEH0AWohAAN/IAAgAigCACICRgRAQQAPCyABIAJBBGsoAgBGBH8gAkEIawUgAkEEaiECDAELCwtSAgJ/AX4CQCAAKAIQKAKMASIBRQ0AIAEpAwgiA0KAgICAcFQNACADpyIBLwEGEO4BRQ0AIAEoAiAiAS0AEkEEcUUNACAAIAEoAkAQGCECCyACC6oPAgV/D34jAEHQAmsiBSQAIARC////////P4MhCyACQv///////z+DIQogAiAEhUKAgICAgICAgIB/gyENIARCMIinQf//AXEhCAJAAkAgAkIwiKdB//8BcSIJQf//AWtBgoB+TwRAIAhB//8Ba0GBgH5LDQELIAFQIAJC////////////AIMiDEKAgICAgIDA//8AVCAMQoCAgICAgMD//wBRG0UEQCACQoCAgICAgCCEIQ0MAgsgA1AgBEL///////////8AgyICQoCAgICAgMD//wBUIAJCgICAgICAwP//AFEbRQRAIARCgICAgICAIIQhDSADIQEMAgsgASAMQoCAgICAgMD//wCFhFAEQCADIAJCgICAgICAwP//AIWEUARAQgAhAUKAgICAgIDg//8AIQ0MAwsgDUKAgICAgIDA//8AhCENQgAhAQwCCyADIAJCgICAgICAwP//AIWEUARAQgAhAQwCCyABIAyEUARAQoCAgICAgOD//wAgDSACIAOEUBshDUIAIQEMAgsgAiADhFAEQCANQoCAgICAgMD//wCEIQ1CACEBDAILIAxC////////P1gEQCAFQcACaiABIAogASAKIApQIgYbeSAGQQZ0rXynIgZBD2sQZ0EQIAZrIQYgBSkDyAIhCiAFKQPAAiEBCyACQv///////z9WDQAgBUGw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AgQLIBIgFHwhEgwDCyADRSEFIABBAEgNAQsgAikDcEIAUw0AIAIgAigCBEEBazYCBAsgBUUNAEGg1ARBHDYCACACEJoEQgAhE0IADAELIAEoApAGIgBFBEAgASAGt0QAAAAAAAAAAKIQqwEgASkDACETIAEpAwgMAQsgEiATUiATQglVckUEQCABQTBqIAYQeSABQSBqIAAQhgIgAUEQaiABKQMwIAEpAzggASkDICABKQMoEC4gASkDECETIAEpAxgMAQsgEkKaBFkEQEGg1ARBxAA2AgAgAUHgAGogBhB5IAFB0ABqIAEpA2AgASkDaEJ/Qv///////7///wAQLiABQUBrIAEpA1AgASkDWEJ/Qv///////7///wAQLiABKQNAIRMgASkDSAwBCyASQut1VwRAQaDUBEHEADYCACABQZABaiAGEHkgAUGAAWogASkDkAEgASkDmAFCAEKAgICAgIDAABAuIAFB8ABqIAEpA4ABIAEpA4gBQgBCgICAgICAwAAQLiABKQNwIRMgASkDeAwBCyAKBEAgCkEITARAIAFBkAZqIAdBAnRqIgAoAgAhCQNAIAlBCmwhCSAKQQFqIgpBCUcNAAsgACAJNgIACyAHQQFqIQcLAkAgCyASpyIISiALQQhKciAIQRFKcg0AIAhBCUYEQCABQcABaiAGEHkgAUGwAWogASgCkAYQhgIgAUGgAWogASkDwAEgASkDyAEgASkDsAEgASkDuAEQLiABKQOgASETIAEpA6gBDAILIAhBCEwEQCABQZACaiAGEHkgAUGAAmogASgCkAYQhgIgAUHwAWogASkDkAIgASkDmAIgASkDgAIgASkDiAIQLiABQeABakEAIAhrQQJ0QeDBBGooAgAQeSABQdABaiABKQPwASABKQP4ASABKQPgASABKQPoARDjBSABKQPQASETIAEpA9gBDAILIAhBEU5BACABKAKQBiIAIAhBfWxB0ABqdhsNACABQeACaiAGEHkgAUHQAmogABCGAiABQcACaiABKQPgAiABKQPoAiABKQPQAiABKQPYAhAuIAFBsAJqIAhBAnRBmMEEaigCABB5IAFBoAJqIAEpA8ACIAEpA8gCIAEpA7ACIAEpA7gCEC4gASkDoAIhEyABKQOoAgwBCwNAIAFBkAZqIAciAEEBayIHQQJ0aigCAEUNAAsCQCAI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AAEiAjoAASAAQQFqIQAgAUEBaiEBIAINAAsLC/UBAgF/AX4jAEHQAGsiAyQAAkACfiABQQBIBEAgAyABQf////8HcTYCACADQRBqIgFBwABB3CIgAxBOGiAAIAEQYgwBCyAAKAIQIgAoAiwgAU0NAQJAAkAgACgCOCIAIAFBAnRqKAIAIgEpAgQiBEKAgICAgICAgECDQoCAgICAgICAwABRDQAgAkUNASAEp0GAgICAeEcNACAAKAK8ASEBCyABIAEoAgBBAWo2AgAgAa1CgICAgJB/hAwBCyABIAEoAgBBAWo2AgAgAa1CgICAgIB/hAshBCADQdAAaiQAIAQPC0Hv3wBBrvwAQZgYQYfiABAAAAvrAgECfyAAIAEoAgQQEwNAIAEoAhAhAyACIAEoAhRORQRAIAAgAyACQQN0aigCABATIAJBAWohAgwBCwsgACgCECICQRBqIAMgAigCBBEAAEEAIQIDQAJAIAEoAhwhAyACIAEoAiBODQAgAyACQRRsaiIDKAIIRQRAIAAoAhAgAygCBBDrAQsgACADKAIQEBMgACADKAIMEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAoAhAiAkEQaiABKAIoIAIoAgQRAABBACECA0AgASgCNCEDIAIgASgCOE5FBEAgACADIAJBDGxqKAIEEBMgAkEBaiECDAELCyAAKAIQIgJBEGogAyACKAIEEQAAIAAgASkDQBAPIAAgASkDSBAPIAAgASkDYBAPIAAgASkDaBAPIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFCADcCCCAAKAIQIgBBEGogASAAKAIEEQAACzABAX8gACgCOCABQQJ0aigCACIBIAEoAgAiAkEBazYCACACQQFMBEAgACABEKIDCwvAAQIBfwJ+QX8hAwJAIABCAFIgAUL///////////8AgyIEQoCAgICAgMD//wBWIARCgICAgICAwP//AFEbDQAgAkL///////////8AgyIFQoCAgICAgMD//wBWIAVCgICAgICAwP//AFJxDQAgACAEIAWEhFAEQEEADwsgASACg0IAWQRAIAEgAlIgASACU3ENASAAIAEgAoWEQgBSDwsgAEIAUiABIAJVIAEgAlEbDQAgACABIAKFhEIAUiEDCyADCwoAIABBfHEQpAMLZQEEfwNA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sgEhAyAAIAIQDyAAIAAgA0HdwAAQsgEiAiADQQEgARAhIQQgACACEA8gACADEA8gBAsMACAAIAEpAwAQswELygYCBH8DfiMAQYABayIFJAACQAJAAkAgAyAEQgBCABDtAUUNAAJ/IARC////////P4MhCgJ/IARCMIinQf//AXEiBkH//wFHBEBBBCAGDQEaQQJBAyADIAqEUBsMAgsgAyAKhFALCyEGIAJCMIinIghB//8BcSIHQf//AUYNACAGDQELIAVBEGogASACIAMgBBAuIAUgBSkDECICIAUpAxgiASACIAEQ4wUgBSkDCCECIAUpAwAhBAwBCyABIAJC////////////AIMiCiADIARC////////////AIMiCRDtAUEATARAIAEgCiADIAkQ7QEEQCABIQQMAgsgBUHwAGogASACQgBCABAuIAUpA3ghAiAFKQNwIQQMAQsgBEIwiKdB//8BcSEGIAcEfiABBSAFQeAAaiABIApCAEKAgICAgIDAu8AAEC4gBSkDaCIKQjCIp0H4AGshByAFKQNgCyEEIAZFBEAgBUHQAGogAyAJQgBCgICAgICAwLvAABAuIAUpA1giCUIwiKdB+ABrIQYgBSkDUCEDCyAJQv///////z+DQoCAgICAgMAAhCELIApC////////P4NCgICAgICAwACEIQogBiAHSARAA0ACfiAKIAt9IAMgBFatfSIJQgBZBEAgCSAEIAN9IgSEUARAIAVBIGogASACQgBCABAuIAUpAyghAiAFKQMgIQQMBQsgCUIBhiAEQj+IhAwBCyAKQgGGIARCP4iECyEKIARCAYYhBCAHQQFrIgcgBkoNAAsgBiEHCwJAIAogC30gAyAEVq19IglCAFMEQCAKIQkMAQsgCSAEIAN9IgSEQgBSDQAgBUEwaiABIAJCAEIAEC4gBSkDOCECIAUpAzAhBAwBCyAJQv///////z9YBEADQCAEQj+IIQEgB0EBayEHIARCAYYhBCABIAlCAYaEIglCgICAgICAwABUDQALCyAIQYCAAnEhBiAHQQBMBEAgBUFAayAEIAlC////////P4MgB0H4AGogBnKtQjCGhEIAQoCAgICAgMDDPxAuIAUpA0ghAiAFKQNAIQQMAQsgCUL///////8/gyAGIAdyrUIwhoQhAgsgACAENwMAIAAgAjcDCCAF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QCABQQlrDhIACgsMCgsCAwQFDAsMDAoLBwgJCyACIAIoAgAiAUEEajYCACAAIAEoAgA2AgAPCwALIAIgAigCACIBQQRqNgIAIAAgATIBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATMBADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATAAADcDAA8LIAIgAigCACIBQQRqNgIAIAAgATEAADcDAA8LAAsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKwMAOQMADwsgACACIAMRAAALDwsgAiACKAIAIgFBBGo2AgAgACABNAIANwMADwsgAiACKAIAIgFBBGo2AgAgACABNQIANwMADwsgAiACKAIAQQdqQXhxIgFBCGo2AgAgACABKQMANwMAC14BBH8gACgCACECA0AgAiwAACIDENECBEBBfyEEIAAgAkEBaiICNgIAIAFBzJmz5gBNBH9BfyADQTBrIgMgAUEKbCIEaiADIARB/////wdzShsFQX8LIQEMAQsLIAEL3BICEn8BfiMAQdAAayIIJAAgCCABNgJMIAhBN2ohFyAIQThqIRICQAJAAkACQANAIAEhDCAHIA5B/////wdzSg0BIAcgDmohDgJAAkACQCAMIgctAAAiCQRAA0ACQAJAIAlB/wFxIgFFBEAgByEBDAELIAFBJUcNASAHIQkDQCAJLQABQSVHBEAgCSEBDAILIAdBAWohByAJLQACIQogCUECaiIBIQkgCkElRg0ACwsgByAMayIHIA5B/////wdzIhhKDQcgAARAIAAgDCAHEFsLIAcNBiAIIAE2AkwgAUEBaiEHQX8hDwJAIAEsAAEiChDRAkUNACABLQACQSRHDQAgAUEDaiEHIApBMGshD0EBIRMLIAggBzYCTEEAIQ0CQCAHLAAAIglBIGsiAUEfSwRAIAchCgwBCyAHIQpBASABdCIBQYnRBHFFDQADQCAIIAdBAWoiCjYCTCABIA1yIQ0gBywAASIJQSBrIgFBIE8NASAKIQdBASABdCIBQYnRBHENAAsLAkAgCUEqRgRAAn8CQCAKLAABIgEQ0QJFDQAgCi0AAkEkRw0AIAFBAnQgBGpBwAFrQQo2AgAgCkEDaiEJQQEhEyAKLAABQQN0IANqQYADaygCAAwBCyATDQYgCkEBaiEJIABFBEAgCCAJNgJMQQAhE0EAIRAM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IAgoAgRBAWsiBzYCBCAEIAlqQRBqIQQgBw0JIAAgACgCMEEBazYCMAwJCyAHCyEFIARBAWohBAwACwALIANBACAEQQFGGw0EQQAhCSADDQAgBEECRg0DCyAAIAU2AjAMAAsACyAJDwsgASAIQRBqIAAoAgxBA3QQHxoLIAgoAgghBSAIKAIMIQQgAiAIIAAoAgxBA3RqQRBqIAgtAAEiA0ECdBAfGiAAIAAoAjBBAWs2AjAMAAsAC4sCAQd/IAFBAnRBwP4DaigCACICIAFBAXRBkIAEai8BAGohCEEAIQECQANAIAIgCE8NASACQQFqIQYCQAJAIAItAAAiBEE/TQRAIAMgBEEDdmpBAWohAiABBEAgACADIAIQfg0DCyABQQFzIQEgBEEHcSACakEBaiEFDAELAn8gAyAEakH/AGsgBMBBAEgNABogBi0AACEFIARB3wBNBEAgAkECaiEGIAMgBEEIdGogBWpB//8AawwBCyACQQNqIQYgAi0AAiADIARBEHRqIAVBCHRqakH///8CawshBSADIQILIAEEQCAAIAIgBRB+DQELIAFBAXMhASAGIQIgBSEDDAELC0F/IQcLIAcLOABBsNQCIAEQrwQiAUEASARAQX4PCyAAIAFBHU0Ef0IBIAGthqcFIAFBAnRB2NgCaigCAAsQoQYLNQEBfyMAQRBrIgMkACADIAE2AgggAyACQQFqNgIMIAAgA0EIakECELEEIQAgA0EQaiQAIAALlwIBA38gASgCACICQf7/B08EQCAAQYY7QQAQOkF/DwsCQCACQQFNBEAgAEECQX8QuAEaDAELIAEoAgggAkECdGoiBEEEaygCACIDQX9GBEAgBEEIaygCACEDCyACQQF2IQIgA0H//wNNBEAgAEEVIAIQsgRBACECA0AgAiABKAIATg0CIAAgAkECdCIDIAEoAghqLwEAECogAEF/IAEoAgggA0EEcmooAgBBAWsiAyADQX5GG0H//wNxECogAkECaiECDAALAAsgAEEWIAIQsgRBACECA0AgAiABKAIATg0BIAAgAkECdCIDIAEoAghqKAIAEB0gACABKAIIIANBBHJqKAIAQQFrEB0gAkECaiECDAALAAtBAAsmAQF/IAAoAjgiAUEASARAIAAgACAAQTxqQQAQqwYiATYCOAsgAQvgAgEFfyMAQZABayIEJAAg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IgMgAkohBEKAgICAECEBIAMhAiAERQ0BDAILIAYoAgwgBWsiAyECC0KAgICAECEBIANBAEggAiADSHINAANAIAkgByADQQAgBRCzA0UEQEKBgICAECEBDAILIAIgA0chBCADQQFqIQMgBA0ACwsgACAKEA8gACALEA8LIAZBEGokACABC7ADAwd/AXwBfiMAQRBrIgUkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAAkAgACADKQMAECgiDUKAgICAcINCgICAgOAAUQ0AIA2nIgkoAgRB/////wdxIQYgAaciCigCBEH/////B3EhBwJAIAQEQCAFIAcgBmsiCzYCDEF/IQhBACEEIAJBAkgNASAAIAUgAykDCBBCDQIgBSsDACIMvUL///////////8Ag0KAgICAgICA+P8AVg0BIAxEAAAAAAAAAABlBEAgBUEANgIMDAILIAwgC7djRQ0BIAUCfyAMmUQAAAAAAADgQWMEQCAMqgwBC0GAgICAeAs2AgwMAQsgBUEANgIMIAJBAk4EQCAAIAVBDGogAykDCCAHQQAQVw0CCyAHIAZrIQRBASEIC0F/IQIgBiAHSw0BIAQgBSgCDCIDayAIbEEASA0BA0AgCiAJIANBACAGELMDRQRAIAMhAgwDCyADIARGDQIgAyAIaiEDDAALAAsgACABEA8gACANEA9CgICAgOAAIQEMAQsgACABEA8gACANEA8gAq0hAQsgBUEQaiQAIAELkwECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AQoCAgIAwIQQgAigCDCIDQQBIDQAgAyABpyIFKAIEQf////8HcU8NACAFIAJBDGoQyQGtIQQLIAAgARAPCyACQRBqJAAgBAtpAgJ/AX4gACABEFkhAQNAIAIgBEwgAUKAgICAcINCgICAgOAAUXJFBEAgAyAEQQN0aikDACIGQiCIp0F1TwRAIAanIgUgBSgCAEEBajYCAAsgBEEBaiEEIAAgASAGEMQCIQEMAQsLIAELyAECAX4BfyMAQRBrIgIkAEKAgICA4AAhBAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsCQCAAIAJBDGogAykDABC6AQ0AAkAgAigCDCIDQQBOBEAgAyABpyIFKQIEIgSnQf////8HcUkNAQsgAEEvEC0hBAwBCyAFQRBqIQUgAAJ/IARCgICAgAiDUEUEQCAFIANBAXRqLwEADAELIAMgBWotAAALQf//A3EQnwMhBAsgACABEA8LIAJBEGokACAEC7gBAgJ+AX8jAEEQayICJABCgICAgOAAIQQCQCAAIAEQWSIBQoCAgIBwg0KAgICA4ABRBEAgASEEDAELAkAgACACQQxqIAMpAwAQugENAEKAgICAwH4hBCACKAIMIgNBAEgNACADIAGnIgYpAgQiBadB/////wdxTw0AIAZBEGohBiAFQoCAgIAIg1BFBEAgBiADQQF0ajMBACEEDAELIAMgBmoxAAAhBAsgACABEA8LIAJBEGokACAEC+MBAgF+An8jAEEQayICJAACQCAAIAFBLRBLIgNFBEAgBEEANgIAQoCAgIDgACEBDAELQoCAgIAwIQECQCADKQMAIgZCgICAgHCDQoCAgIAwUgRAIAIgAygCDCIFNgIMIAUgBqciBygCBEH/////B3FJDQEgACAGEA8gA0KAgICAMDcDAAsgBEEBNgIADAELIAcgAkEMahDJASEIIAMgAigCDDYCDCAEQQA2AgAgCEH//wNNBEAgACAIQf//A3EQnwMhAQwBCyAAIAcgBUEBdGpBEGpBAhDuAyEBCyACQRBqJAAgAQs3ACMAQRBrIgIkACAAIAJBDGogAykDABB3IQAgAigCDCEDIAJBEGokAEKAgICA4AAgA2etIAAbC04AIwBBEGsiAiQAQoCAgIDgACEBAkAgACACQQxqIAMpAwAQdw0AIAAgAkEIaiADKQMIEHcNACACKAIIIAIoAgxsrSEBCyACQRBqJAAgAQsGACAAtrsLfwAgACAAKQPQASIBQgyIIAGFIgFCGYYgAYUiAUIbiCABhSIBNwPQAUKAgICAwH4gAUKdurP7lJL9oiV+QgyIQoCAgICAgID4P4S/RAAAAAAAAPC/oL0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwujBAMDfAV/A34jAEEQayIIJAAgCEIANwMIAkACQCACQQBMDQBCgICAgOAAIQEgACAIQQhqIAMpAwAQQg0BQQEhCSAIKwMIIQQgAkEBRwRAA0AgAiAJRg0CIAAgCCADIAlBA3RqKQMAEEINAyAJQQFqIQkgCCsDACEFIwBBIGsiByQAIAS9Qv///////////wCDIg0gBb1C////////////AIMiDCAMIA1WGyIOvyEEAkAgDkI0iKciCkH/D0YNACANIAwgDCANVBsiDL8hBQJAIA5QDQAgDEI0iKciC0H/D0YNACALIAprQcEATgRAIAUgBKAhBAwCCwJ8IAtB/gtPBEAgBEQAAAAAAAAwFKIhBCAFRAAAAAAAADAUoiEFRAAAAAAAALBrDAELRAAAAAAAAPA/IApBvARLDQAaIAREAAAAAAAAsGuiIQQgBUQAAAAAAACwa6IhBUQAAAAAAAAwFAshBiAHQRhqIAdBEGogBRCKBiAHQQhqIAcgBBCKBiAGIAcrAwAgBysDEKAgBysDCKAgBysDGKCfoiEEDAELIAUhBAsgB0EgaiQADAALAAsgBJkhBAsgBL0iAQJ/IASZRAAAAAAAAOBBYwRAIASqDAELQYCAgIB4CyIAt71RBEAgAK0hAQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGyEBCyAIQRBqJAAgAQtOACAAIABEAAAAAAAA8L9EAAAAAAAA8D8gAEQAAAAAAAAAAGMbIAC9Qv///////////wCDQoCAgICAgID4/wBWGyAARAAAAAAAAAAAYRsLQwACfCABvUKAgICAgICA+P8Ag0KAgICAgICA+P8AUQRARAAAAAAAAPh/IACZRAAAAAAAAPA/YQ0BGgsgACABEI8DCwuDAQICfgF/IAC9IgFCNIinQf8PcSIDQf4HTQRAIAFCgICAgICAgICAf4MhAiADQf4HRyABQoCAgICAgIDwv39RckUEQCACQoCAgICAgID4P4S/DwsgAr8PCyADQbIITQR8IAFCP4cgAXxCAUGzCCADa62GIgFCAYh8QgAgAX2DvwUgAAsLggUDAnwFfwF+IwBBEGsiCSQAAn5CgICAgMD+//v/AEKAgICAwP7/eyAEGyACRQ0AGgJ8IAMpAwAiAUL/////D1gEQEEBIAIgAkEBTBshCiABpyEIQQEhBwNAIAcgCkcEQCAItyADIAdBA3RqKQMAIgFCgICAgBBaDQMaIAggAaciCyAIIAtKGyAIIAsgCCALSBsgBBshCCAHQQFqIQcMAQsLIAitDAILQoCAgIDgACAAIAlBCGogARBCDQEaQQEhByAJKwMICyEFIAcgAiACIAdIGyECA0AgAiAHRwRAQoCAgIDgACAAIAkgAyAHQQN0aikDABBCDQIaAkAgBb0iDEL///////////8Ag0KAgICAgICA+P8AVg0AIAkrAwAiBr0iAUL///////////8Ag0KAgICAgICA+P8AVgRAIAYhBQwBCyAFRAAAAAAAAAAAYSAGRAAAAAAAAAAAYXEhCiAEBEAgCgRAIAEgDIO/IQUMAgsgBSAFIAalIAa9Qv///////////wCDQoCAgICAgID4/wBWGyAGIAW9Qv///////////wCDQoCAgICAgID4/wBYGyEFDAELIAoEQCABIAyEvyEFDAELIAUgBSAGpCAGvUL///////////8Ag0KAgICAgICA+P8AVhsgBiAFvUL///////////8Ag0KAgICAgICA+P8AWBshBQsgB0EBaiEHDAELCyAFvSIBAn8gBZlEAAAAAAAA4EFjBEAgBaoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASAJQRBqJAAgAQstAEKAgICA4AAgACADKQMAIAMpAwhBABCLAiIAQQBHrUKAgICAEIQgAEEASBsLoAEBA34gAykDACIFIQQgAkEETgRAIAMpAxghBAsgBUL/////b1gEQCAAECRCgICAgOAADwsgAykDECEBQoCAgIDgACEGAkAgACADKQMIEDEiAkUNACABQiCIp0F1TwRAIAGnIgMgAygCAEEBajYCAAsgACAFIAIgASAEQQAQhgQhAyAAIAIQEyADQQBIDQAgA0EAR61CgICAgBCEIQYLIAYLjwEAAkACQCADKQMAIgFC/////29YBEAgBARAIAAQJAwDCyABQiCIp0F1SQ0BIAGnIgAgACgCAEEBajYCACABDwsgACABELYDIgJBAEgNASAEBEAgAkEAR61CgICAgBCEDwsgAkUEQCAAQfjiAEEAEBUMAgsgAaciACAAKAIAQQFqNgIACyABDwtCgICAgOAACyoAIAMpAwAiAUL/////b1gEQCAAECRCgICAgOAADwsgACABQQNBABCqAgtPAAJAAkAgAykDACIBQv////9vWARAIARFBEBCgICAgBAPCyAAECQMAQsgACABEJkBIgBBAE4NAQtCgICAgOAADwsgAEEAR61CgICAgBCEC2MBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAIQcSEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQs2ACADKQMAIgFCIIinIgJBf0YgBEUgAkF+cUECR3FyRQRAIAAQJEKAgICA4AAPCyAAIAEQ6AELYwECfgJAAkAgAykDACIBQv////9vWARAIAAQJAwBCyADKQMIIQUgASEEIAJBA04EQCADKQMQIQQLIAAgBRAxIgINAQtCgICAgOAADwsgACABIAIgBEEAEBQhASAAIAIQEyABC2YBAX4gAykDACIEQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhAQJAIAAgAykDCBAxIgJFDQAgACAEIAJBABDVASEDIAAgAhATIANBAEgNACADQQBHrUKAgICAEIQhAQsgAQuLAQECfiADKQMAIgFC/////29YBEAgABAkQoCAgIDgAA8LIAMpAxAhBkKAgICA4AAhBQJAIAAgAykDCBAxIgJFDQAgACABIAIgBiAERUEOdBDHBCEDIAAgAhATIANBAEgNACAEBEAgA0EAR61CgICAgBCEDwsgAaciACAAKAIAQQFqNgIAIAEhBQsgBQuaAQIBfwJ+IwBBEGsiBCQAIAMpAwghBSADKQMAIgYhAQJAAkACQAJAIAJBA0gNACADKQMQIgFCgICAgHBaBEAgAactAAVBEHENAQsgAEGiPkEAEBUMAQsgACAEQQxqIAUQiQQiAg0BC0KAgICA4AAhAQwBCyAAIAYgASAEKAIMIgMgAhCQAyEBIAAgAiADEJsDCyAEQRBqJAAgAQsVACAAIAMpAwAgAyADQQhqQQIQnQMLVgIBfgF/IAAgARC0AyIBQoCAgIBwg0KAgICA4ABRBEAgAQ8LQoCAgIAwIQIgAaciAygCBEGAgICAeEcEQCAAIAAoAhAgAxDBAhAtIQILIAAgARAPIAILCQAgACABELQDC1sBAX4jAEEQayICJAAgAiAAIAEQtAMiATcDCAJAIAFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgAEKAgICAMEEBIAJB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IQMCQAJAAkAgAkHGAGsOBgIDAQMDAgALIAJBFkcNAgtBECEDCyAAIAEgAxCQAg8LIABBtitBABAVC0KAgICA4AALlgEBAXwjAEEQayICJAACfkKAgICA4AAgACACQQhqIAEQmwINABogAisDCCIEvSIBAn8gBJlEAAAAAAAA4EFjBEAgBKoMAQtBgICAgHgLIgC3vVEEQCAArQwBC0KAgICAwH4gAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwshASACQRBqJAAgAQvsAgIDfwF8IwBB0ABrIgQkACAEQRBqQQBBOBArGiAEQoCAgICAgID4PzcDIEKAgICAwH4hAQJAIAJFDQBBByACIAJBB04bIgJBACACQQBKGyECA0AgAiAFRwRAIAAgBEEIaiADIAVBA3QiBmopAwAQQgRAQoCAgIDgACEBDAMLIAQrAwgiB71CgICAgICAgPj/AINCgICAgICAgPj/AFENAiAEQRBqIAZqIAedOQMAAkAgBQ0AIAQrAxAiB0QAAAAAAAAAAGZFIAdEAAAAAAAAWUBjRXINACAEIAdEAAAAAACwnUCgOQMQCyAFQQFqIQUMAQsLIARBEGpBABDgAiIHvSIBAn8gB5lEAAAAAAAA4EFjBEAgB6oMAQtBgICAgHgLIgW3vVEEQCAFrSEBDAELQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQELIARB0ABqJAAgAQtWABDQBCIBQoCAgIAIfEL/////D1gEQCABQv////8Pgw8LQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsIAEKAgICAMAuqHQIGfwR+IwBB0ABrIgYkAAJAAkAgAEEQaiIDQYgCIAAoAgARAwAiAUUNACABQQVqQQBBgwIQKxogAUEFOgAEIAFBATYCACAAKAJQIgQgAUEIaiIFNgIEIAEgAEHQAGo2AgwgASAENgIIIAAgBTYCUCABIAMgACgCQEEDdCAAKAIAEQMAIgQ2AiggBEUEQCADIAEgACgCBBEAAAwBCyABIAA2AhAgACgCSCIDIAFBFGoiBTYCBCABIABByABqNgIYIAEgAzYCFCAAIAU2AkggAULxgICAgDk3AtwBIAEgAEHYAWo2AtgBIAAoAkAiAEEAIABBAEobIQADQCAAIAJGRQRAIAQgAkEDdGpCgICAgCA3AwAgAkEBaiECDAELCyABQoCAgIAgNwNQIAFCgICAgCA3A0ggAUKAgICAIDcDQCABIAFB9AFqIgA2AvgBIAEgADYC9AEgAUKAgICAIBBHIQcgASgCKCAHNwMIQQAhAiABIAFBEUHMngFBAEEAQQAgBxDxASIHNwMwIAdCIIinQXVPBEAgB6ciACAAKAIAQQFqNgIACyABKAIoIAc3A2ggARA0IQcgASgCKCAHNwMYIAEgB0GQ1QFBAxAiA0AgASgCKCEAIAJBCEZFBEAgAkECdEGQpgFqKAIAIQMgASABIAApAxgQRyIHQTYgASADEMoEQQMQGRogASAHQTMgAUEvEC1BAxAZGiABIAJBA3RqIAc3A1ggAkEBaiECDAELCyABIAApAwhBAhBJIQcgASgCKCAHNwMQQQAhAiABIAEgB6dBACAHQv////9vVhtBARDFBDYCJCABIAFBJGpBAEEwQQoQwwQaIAEgAUESQQBBABDeAjcDsAEgAUETQQBBABDeAiEHIAEgASkDMEHPAEKAgICAMCAHIAEpA7ABQYEyEG0aIAEgASkDMEHNAEKAgICAMCAHIAEpA7ABQYEyEG0aIAEgBxAPIAEgASAHIAEgAUGwAWpBARCxBhAPIAEgARA0NwPAASABIAFCgICAgCAQRzcDyAEgASABQc4xQRRBASABKAIoKQMIEL8BQcDVAUEWECIgASABKAIoKQMIQaDYAUELECIgASABKQMwQdDZAUEHECIgASABQRVB38wAQQFBBUEAEIIBIgc3AzggB0IgiKdBdU8EQCAHpyIAIAAoAgBBAWo2AgALIAEgB0HfzAAgASkDMBDeASABIAFBFkG8wABBAUEFQX8QggEiB0G8wAAgASgCKCkDGBDeAQNAIAJBCEZFBEAgASABQRYgAkECdEGQpgFqKAIAIgBBAkEBIAJBB0YbQQUgAiAHEPEBIAAgASACQQN0aikDWBDeASACQQFqIQIMAQsLIAEgARA0Igc3A5gBIAEgB0HA2gFBARAiIAEgASgCKCkDEEHQ2gFBIBAiIAFB1x9BF0EBIAEoAigpAxAQvwEiB0IgiKdBdU8EQCAHpyIAIAAoAgBBAWo2AgALIAEgBzcDQCABIAdB0N4BQQQQIiAGQbCmAUHKABAfIgMhAkHjACEAIAFCgICAgCAQRyEHA0AgAEH/AXEEQCABIAcgAkKBgICAEEEHEO8BGiACED8gAmpBAWoiAi0AACEADAELCyABIAEoAigpAxBB2wEgB0EBEBkaIAEgASABKAIoKQMQIgdB6wAgB0EAEBQ3A6gBIAEgASkDmAEQRyEHIAEoAiggBzcD4AIgASAHQZDfAUECECIgASABKQPAAUGw3wFBDhAiIAEgASgCKCkDCEEEEEkhByABKAIoIAc3AyAgASAHQgAQ2wEgASABKAIoKQMgQeDhAUEGECIgASABQYfIAEEYQQEgASgCKCkDIBC/AUHA4gFBDhAiIAEgASgCKCkDCEEGEEkhByABKAIoIAc3AzAgASAHQoCAgIAQENsBIAEgASgCKCkDMEGg5AFBAhAiIAFB8tEAQRlBASABKAIoKQMwEL8BGiABIAEoAigpAwhBBRBJIQcgASgCKCAHNwMoIAEgByABQS8QLRDbASABIAFB0NwAQRpBASABKAIoKQMoEL8BQcDkAUEDECIgASABKAIoKQMoQfDkAUExECIgASABKQOYARBHIQcgASgCKCAHNwPoAiABIAdB8OsBQQIQIiADEKMEIAFCASADNAIIIAMpAwBCwIQ9fnwiByAHQgFYGzcD0AEgASABKQPAAUGQ7AFBARAiIAEgASkDwAFB4PEBQQEQIiABEDQhByABKAIoIAc3AzggASAHQdDzAUEFECIgASABQYPTAEEbQQAgASgCKCkDOBC/ASIHQaD0AUECECJB0AEhAiABIQADQCACQd4BRkUEQCAAIAcgACgCECADIAIQkAEiBEEuEKYDIgVBAWogBCAFGyAAIAIQXEEAEO8BGiACQQFqIQIMAQsLIAAgACkDmAEQRyEHIAAoAiggBzcD+AIgACAHQcD0AUEEECIgACAAKQMwEEchByAAKAIoIAc3A4ABIABBFUHIzABBAUEFQQEQggEhByAAIAAoAigpA4ABQYD1AUEBECIgACAAKAIoIgIpA4ABIAIpA/gCQQFBARCWAiAAIAcgACgCKCkDgAFBAEEBEJYCIAAgBxAPIAAgAEEcQbnVAEEBEN4CIgc3A7gBIAApA8ABIQggB0IgiKdBdU8EQCAHpyICIAIoAgBBAWo2AgALIAAgCEE6IAdBAxAZGiAAKQPAASIHQiCIp0F1TwRAIAenIgIgAigCAEEBajYCAAsgACAHQYoBIAdBAxAZGiAAEDQhByAAKAIoIAc3A1AgACAHQdDLAUEvECIgACAAQeXiAEEdQQcgACgCKCkDUBC/AUHA0gFBAxAiIABBHjYCgAIgACAAKAIoKQMoQZDBAUEBECIgAEEfNgL8ASAAEDQhByAAKAIoIAc3A5ABIAAgB0GgwQFBERAiIABBtskAQSBBAiAAKAIoKQOQARC/ASIHQiCIp0F1TwRAIAenIgIgAigCAEEBajYCAAsgACAHNwNIIAAgB0GwwwFBARAiIAAgACkDmAEQRyEHIAAoAiggBzcD8AIgACAHQcDDAUECECIgACAAKQPAAUHgwwFBARAiAkAgACgCECICKAJAQTFPBEAgAigCRCgCgAkNAQsgAkHYpAFBMEEBEM0DGiACKAJEIgJBkAlqQSE2AgAgAkGUCWpB5KQBNgIACyAAQSJB0RpBAkECQQAQggEiB0KAgICAcFoEQCAHpyICIAItAAVBEHI6AAULIAAgB0GgxAFBARAiIAAgACkDwAFB0RogB0EDEO8BGkEAIQIDQAJAIAJBBEYEQEEAIQIDQCACQQJGDQIgACAAKQOYARBHIQcgACgCKCACQQN0aiAHNwPQAiAAIAcgAkECdEGQpQFqKAIAIAJBnKUBai0AABAiIAJBAWohAgwACwALIAAoAhAgAyACQbUBahCQASEEIAAQNCEHIAJBJmpBA3QiBSAAKAIoaiAHNwMAIAAgByACQQJ0QYClAWooAgAgAkGYpQFqLQAAECIgAEEjIARBAEEDIAIQggEhByACQQFNBEAgACAHQfDIAUEBECILIAAgByAEIAAoAiggBWopAwAQ3gEgAkEBaiECDAELCyAAEDQhByAAKAIoIAc3A5gBIAAgB0GQ9QFBAxAiIAAgAEHkxgBBJCAAKAIoKQOYARCXBEHA9QFBAhAiIAAQNCEHIAAoAiggBzcDoAEgACAHQeD1AUEDECIgACAAQb3GAEElIAAoAigpA6ABEJcEQZD2AUEBECIgACAAEDQiB0Gg9gFBHhAiIAAgB0E3IAAgACgCKCkDECIIQTcgCEEAEBRBAxAZGiAAIABBJkHSH0EAEN4CIghBgPoBQQMQIiAAIAggBxD7BUEVIQIDQCACQSBGRQRAIAEgBxBHIQkgAkEDdCIAIAEoAihqIAk3AwAgASAJQcWBAUEBIAJB5aYBai0AAHStIglBABDvARogASABQScgASgCECADIAJBjgFqEJABIgRBA0EDIAIgCBDxASIKIAQgASgCKCAAaikDABDeASABIApBxYEBIAlBABDvARogAkEBaiECDAELCyABIAcQDyABIAgQDyABEDQhByABKAIoIAc3A4ACIAEgB0Gw+gFBGBAiIAFBuyJBKCABKAIoKQOAAhCXBBoCQCABKAIQIgAoAkBBMk8EQCAAKAJEKAKYCQ0BCyAAQaClAUExQQkQzQMaIAAoAkQiAEHQCmpBKTYCACAAQaAKakEqNgIAIABBiApqQSo2AgAgAEHwCWpBKzYCACAAQdgJakEsNgIAIABBwAlqQSw2AgALIAEQNCEHIAEoAiggBzcDiAMgASAHQYDJAUEEECIgAUEtQafjAEEBQQJBABCCASIHQiCIp0F1TwRAIAenIgAgACgCAEEBajYCAAsgASAHNwNQIAEgB0HAyQFBBxAiIAEgB0Gn4wAgASgCKCkDiAMQ3gEgASABKQMwEEchByABKAIoIAc3A6ADIAFBFUHazABBAUEFQQIgASkDOBDxASEHIAEgASgCKCkDoANBsMoBQQEQIiABIAcgASgCKCkDoANBAEEBEJYCIAEgBxAPIAEgARA0Igc3A6ABIAEgB0HAygFBARAiIAEgASkDoAEQRyEHIAEoAiggBzcDuAMgASAHQdDKAUEDECIgASABKQOgARBHIQcgASgCKCAHNwPIAyABIAdBgMsBQQQQIiABIAEpAzAQRyEHIAEoAiggBzcDwAMgAUEVQcPMAEEBQQVBAyABKQM4EPEBIQcgASABKAIoKQPAA0HAywFBARAiIAEgASgCKCIAKQPAAyAAKQPIA0EBQQEQlgIgASAHIAEoAigpA8ADQQBBARCWAiABIAcQDyABKAIQIgBBLjYClAIgAEEvNgKkAiAAQTA2AqACIABBMTYCnAIgAEEyNgKYAiABEDQhByABKAIoIAc3A4gCIAEgB0GA0wFBAxAiIAEgAUGILUEzQQEgASgCKCkDiAIQvwFBsNMBQQ4QIgwBC0EAIQELIAZB0ABqJAAgAQsHACAAEN8EC4cCAQh/An4gACgCECgCeCMAIgciDCABpygCICIIKAIQIgkgA2oiC0EDdCIKa0sEQCAAEOkBQoCAgIDgAAwBCyAJQQAgCUEAShshDSAHIApBD2pBcHFrIgckAAN+IAYgDUYEfkEAIQYgA0EAIANBAEobIQMDQCADIAZGRQRAIAcgBiAJakEDdGogBCAGQQN0aikDADcDACAGQQFqIQYMAQsLIAVBAXEEQCAAIAEgAhBSIQMgACAIKQMAIgEgASACIAMbIAsgBxCQAwwDCyAAIAgpAwAgCCkDCCALIAcQIQUgByAGQQN0IgpqIAggCmopAxg3AwAgBkEBaiEGDAELCwshASAMJAAgAQuxAQEBfyAAQcgAEF8iBQRAIAVBADYCAAJAIAAgBUEIaiIGIAEgAiADIAQQ7QMEQCAFQQQ2AgAMAQsgACAGELQCIgJCgICAgHCDQoCAgIDgAFENACAAIAIQDyAAIAFBLxBlIgFCgICAgHCDQoCAgIDgAFENACABQoCAgIBwWgRAIAGnIAU2AiALIAEPCyAAKAIQIAUQ7AMgACgCECIAQRBqIAUgACgCBBEAAAtCgICAgOAAC4gHAgl/AXwjAEFAaiIGJAACQCAAKAIQIgooAnggBiABpyIILQAoIgtBA3QiDGtLBEAgABDpAUKAgICA4AAhAQwBCyAILQApIQ0gBiAKKAKMASIANgIQIAogBkEQajYCjAEgAAR/IAAoAihBBHEFQQALIQAgCCgCICEHIAYgATcDGCAGIAA2AjggBiADNgI0AkAgAyALTgRAIAQhAAwBCyADQQAgA0EAShshDiAGIAxBD2pB8B9xayIAJAADQCAJIA5GBEAgAyEEA0AgBCALRkUEQCAAIARBA3RqQoCAgIAwNwMAIARBAWohBAwBCwsgBiALNgI0BSAAIAlBA3QiDGogBCAMaikDADcDACAJQQFqIQkMAQsLCyAGIAA2AiAgCCgCJCEEAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIA0ODQsCAAEAAQcIAwQFBgkKCyAFQQFxDQpCgICAgDAhAiANQQJHDQoMCwsgBUEBcQ0AQoCAgIAwIQIgDUEDRg0KCyAHIAIgAyAAIAguASogBBEFACEBDAsLIAcgAiAEEQgAIQEMCgsgByACIAApAwAgBBEYACEBDAkLIAcgAiAILgEqIAQREAAhAQwICyAHIAIgACkDACAILgEqIAQRNAAhAQwHCyAHIAZBCGogACkDABBCDQUgBisDCCAEEQsAIg+9IgECfyAPmUQAAAAAAADgQWMEQCAPqgwBC0GAgICAeAsiALe9UQRAIACtIQEMBwtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhshAQwGC0KAgICA4AAhASAHIAZBCGogACkDABBCDQUgByAGIAApAwgQQg0FIAYrAwggBisDACAEESMAIg+9IgECfyAPmUQAAAAAAADgQWMEQCAPqgwBC0GAgICAeAsiALe9UQRAIACtIQEMBgtCgICAgMB+IAFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhshAQwFCyAHIAIgAyAAIAZBCGogCC4BKiAEERIAIgFCgICAgHCDQoCAgIDgAFENBCAGKAIIIgBBAkYNBCAHIAEgABD/AiEBDAQLEAEACyAHIAIgAyAAIAQRAgAhAQwCCyAHQZwiQQAQFQtCgICAgOAAIQELIAogBigCEDYCjAELIAZBQGskACABC9UBAQV/IwAiBSEIAkAgAUKAgICAcFQNACABpyIGLwEGQQ9HDQAgBigCICEHCyAAIAIgAyADIActAAQiAEgEf0EAIQYgA0EAIANBAEobIQkgBSAAQQN0QQ9qQfAfcWsiBSQAA38gBiAJRgR/IAMhBAN/IAAgBEYEfyAFBSAFIARBA3RqQoCAgIAwNwMAIARBAWohBAwBCwsFIAUgBkEDdCIKaiAEIApqKQMANwMAIAZBAWohBgwBCwsFIAQLIAcvAQYgB0EIaiAHKAIAERIAIQEgCCQAIAEL0woCD38BfiMAQTBrIgUkAAJAIAAgARBZIgFCgICAgHCDQoCAgIDgAFENAAJAIAAgARAoIhNCgICAgHCDQoCAgIDgAFEEQEF/IQQMAQsCQCAAQQEgE6ciDCgCBEH/////B3EiBiAGQQFNG0ECdBApIgtFBEBBfyEEDAELIAVBADYCEANAIAYgB0wNASALIARBAnRqIAwgBUEQahDJATYCACAEQQFqIQQgBSgCECEHDAALAAsgACATEA8LIAAgARAPQoCAgIDgACEBIARBAEgNAAJAAkAgAkUNACADKQMAIhNCgICAgHCDQoCAgIAwUQ0AAkAgACAFQQxqIBMQ5QEiAgRAAkAgAi0AAEHOAEcNACACLQABQcYARw0AIAJBA0ECIAItAAJBywBGIgMbai0AACIGQcMAa0H/AXFBAUsNACAFKAIMIAJBA2ogAkECaiADGyACa0EBakYNAgsgACACEFQgAEGC0gBBABBQCyAAQRBqIRAgCyEGDAILIAAgAhBUIAYgA0EBdGpBwwBrIQgLIAAoAhAhAiAFQgA3AxggBUIANwMQIAUgAjYCJCAFQTs2AiAgACIMQRBqIRBBfyEAAkAgBUEQaiAEQQJ0IgIQxgEEQEEAIQYMAQsCQCAIRQRAQQAhByAEQQAgBEEAShshAwNAIAMgB0YNAiAHQQJ0IQYgB0EBaiEHIAYgC2ooAgBB/wFNDQALCyAFQRBqIAsgBCAIQQF2EOwEQQAhBiAFKAIcDQEgBSgCFCIHQQJ2IgBBAWshCkEAIQIgBSgCECEGA0ACQCAAIAJKBEAgBiACIgRBAnRqKAIAEKYCRQ0BA0AgBCAKRgRAIAAhAgwDCyAGIARBAWoiA0ECdGooAgAiDRCmAiIJBEADQAJAIAIgBEoNACAGIARBAnRqIg4oAgAiDxCmAiAJTA0AIA4gDzYCBCAEQQFrIQQMAQsLIARBAnQgBmogDTYCBCADIQQMAQUgAyECDAMLAAsACyAIQQFxIAdBCElyDQNBASAAIABBAU0bIQ5BASEIQQEhAANAIAggDkYNBCAGIAhBAnRqKAIAIgMQpgIhByAAIQQCQAJAA0AgBEEATA0BIAYgBEEBayIEQQJ0aiIPKAIAIgIQpgIiCgRAIAcgCkohAkGAAiEHIAINAQwCCwsCQCADQeEia0EUSyACQYAia0ESS3JFBEAgA0EcbCACQcwEbGpBnI2hAWshBwwBCwJAIAJBgNgCayIEQaPXAEsNACAEQf//A3FBHHAgA0GnI2siBEEbS3INACACIARqIQcMAQtBsAchBEEAIQoDQCAEIApIDQIgBUEoaiAEIApqQQJtIg1BAXRB8NEDai8BACIHQQZ2IhFBAnRBkOICaigCACIJQQ52IhIgB0E/cWoiByARIBIgCUEHdkH/AHEgCUEBdkE/cRDrBBogAyAFKAIsayACIAUoAigiCWsgAiAJRhsiCUEASARAIA1BAWshBAwBCyAJBEAgDUEBaiEKDAELCyAHRQ0BCyAPIAc2AgAMAQsgBiAAQQJ0aiADNgIAIABBAWohAAsgCEEBaiEIDAALAAsgAkEBaiECDAALAAsgBSgCECIGIAsgAhAfGiAEIQALIAwoAhAiAkEQaiALIAIoAgQRAAAgAEEASA0BIAwgBUEQaiAAED0NAEEAIQQCQANAIAAgBEYNASAEQQJ0IQIgBEEBaiEEIAVBEGogAiAGaigCABC5AUUNAAsgBSgCECgCECIAQRBqIAUoAhQgACgCBBEAAAwBCyAFQRBqEDYhAQsgECgCACIAQRBqIAYgACgCBBEAAAsgBUEwaiQAIAEL7AcCC34EfyMAQTBrIg8kAAJAIAFC/////29YBEAgABAkQoCAgIDgACEBDAELQoCAgIAwIQYCQAJAIAAgAykDABAoIgtCgICAgHCDQoCAgIDgAFEEQEKAgICAMCEHQoCAgIAwIQFCgICAgDAhCUKAgICAMCEMDAELIAAgASAAKQNIEOMBIgxCgICAgHCDQoCAgIDgAFEEQEKAgICAMCEHQoCAgIAwIQFCgICAgDAhCQwBCwJAAkAgACAAIAFB7QAgAUEAEBQQNyIJQoCAgIBwg0KAgICA4ABRDQAgCaciAkH1AEEAEMcBIRIgAkH5AEEAEMcBQQBIBEAgAEHMngEgCUHsHxC+ASIJQoCAgIBwg0KAgICA4ABRDQELIA8gCTcDKCAPIAE3AyAgACAMQQIgD0EgahCnASIHQoCAgIBwg0KAgICA4ABRDQEgABA+IgFCgICAgHCDQoCAgIDgAFEEQEKAgICA4AAhAQwDC0F/IQICQCADKQMIIgRCgICAgHCDQoCAgIAwUQ0AIAAgD0EcaiAEEHdBAEgNAyAPKAIcIgINAAwECwJ+IAunIhApAgQiBKdB/////wdxIhEEQCASQX9zQR92IRIgBEL/////B4MhDSACrSEOQQAhAgNAIAKtIQQgAiEDA0AgAyARTwRAIAAgECACIBEgAiARSRsgERCEAQwECyAAIAdB1QAgA60iChBFQQBIDQYgACAGEA8CQCAAIAcgCxDIASIGQoCAgIBwgyIFQoCAgIAgUgRAIAVCgICAgOAAUQ0IIAAgD0EQaiAAIAdB1QAgB0EAEBQQowENCCAPIA8pAxAiBSANIAUgDVMbIgU3AxAgBCAFUg0BCyAQIAogEhDxAqchAwwBCwsgACAQIAIgAxCEASIEQoCAgIBwg0KAgICA4ABRDQUgACABIAggBBBqQQBIDQUgCEIBfCIEIA5RDQYgACAPQQhqIAYQPA0FIAWnIQJCASEFIAhCASAPKQMIIgogCkIBVxt8IQgDQCAEIAhRBEAgBCEIDAILIAAgACAGIAUQcxA3IgpCgICAgHCDQoCAgIDgAFENBiAAIAEgBCAKEGpBAEgNBiAFQgF8IQUgBEIBfCIEIA5SDQALCwwFCyAAIAcgCxDIASIGQoCAgIBwgyIEQoCAgIDgAFENAyAEQoCAgIAgUg0EIAAgEEEAQQAQhAELIgRCgICAgHCDQoCAgIDgAFENAiAAIAEgCCAEEGpBAE4NAwwCC0KAgICAMCEHC0KAgICAMCEBCyAAIAEQD0KAgICA4AAhAQsgACALEA8gACAMEA8gACAHEA8gACAJEA8gACAGEA8LIA9BMGokACABC+ACAQZ+IAFC/////29YBEAgABAkQoCAgIDgAA8LQoCAgIDgACEIQoCAgIAwIQYCQAJAAkAgACADKQMAECgiB0KAgICAcINCgICAgOAAUQRAQoCAgIAwIQQMAQsgACABQdUAIAFBABAUIgRCgICAgHCDQoCAgIDgAFENACAAIARCABBSRQRAIAAgAUHVAEIAEEVBAEgNAQsgACABIAcQyAEiBUKAgICAcIMiCUKAgICA4ABRDQEgACABQdUAIAFBABAUIgZCgICAgHCDQoCAgIDgAFENAQJAIAAgBiAEEFIEQCAAIAQQDwwBCyAAIAFB1QAgBBBFQQBODQBCgICAgDAhBAwCCyAAIAcQDyAAIAYQD0L/////DyEIIAlCgICAgCBRDQIgACAFQdcAIAVBABAUIQEgACAFEA8gAQ8LQoCAgIAwIQULIAAgBRAPIAAgBxAPIAAgBhAPIAAgBBAPCyAIC80EAgZ+AX8jAEEgayICJAACQCABQv////9vWARAIAAQJEKAgICA4AAhBwwBC0KAgICA4AAhB0KAgICAMCEIAkAgACADKQMAECgiCUKAgICAcINCgICAgOAAUQRAQoCAgIAwIQRCgICAgDAhBUKAgICAMCEGDAELAkACQCAAIAEgACkDSBDjASIGQoCAgIBwg0KAgICA4ABRBEBCgICAgDAhBAwBCyAAIAAgAUHtACABQQAQFBA3IgRCgICAgHCDQoCAgIDgAFINAQtCgICAgDAhBQwBCyACIAQ3AxggAiABNwMQIAAgBkECIAJBEGoQpwEiBUKAgICAcINCgICAgOAAUQ0AIAAgAkEIaiAAIAFB1QAgAUEAEBQQowENACAAIAVB1QACfiACKQMIIgFCgICAgAh8Qv////8PWARAIAFC/////w+DDAELQoCAgIDAfiABub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0AQoCAgIDgACEIIABBLhB2IgFCgICAgHCDQoCAgIDgAFENACAAQSAQKSIDRQRAIAEhCAwBCyADIAk3AwggAyAFNwMAIAMgBKciCkHnAEEAEMcBQX9zQR92NgIQIApB9QBBABDHASEKIANBADYCGCADIApBf3NBH3Y2AhQgAUKAgICAcFoEQCABpyADNgIgCyAAIAYQDyAAIAQQDyABIQcMAQsgACAJEA8gACAGEA8gACAEEA8gACAFEA8gACAIEA8LIAJBIGokACAHC74EAgd+An8jAEEQayICJAACQCABQv////9vWARAIAAQJEKAgICA4AAhBgwBC0KAgICA4AAhBkKAgICAMCEFAkAgAAJ+AkAgACADKQMAECgiB0KAgICAcINCgICAgOAAUQ0AIAAgACABQe4AIAFBABAUECYiA0EASA0AIANFBEAgACABIAcQyAEhBgwDCyAAIAAgAUHvACABQQAQFBAmIgtBAEgNACAAIAFB1QBCABBFQQBIDQBCgICAgOAAIAAQPiIIQoCAgIBwg0KAgICA4ABRDQEaIAenIQwCQANAIAAgBRAPIAAgASAHEMgBIgVCgICAgHCDIgRCgICAgCBRDQECQCAEQoCAgIDgAFENAAJ/IAAgACAFQgAQTRA3IgRCgICAgHCDIgpCgICAgJB/UgRAQQAgCkKAgICA4ABSDQEaDAILIASnKAIEQf////8HcUULIQMgACAIIAkgBBCGAUEASA0AIAlCAXwhCSADRQ0BIAAgAkEIaiAAIAFB1QAgAUEAEBQQowFBAEgNACAAIAFB1QACfiAMIAIpAwggCxDxAiIEQoCAgIAIfEL/////D1gEQCAEQv////8PgwwBC0KAgICAwH4gBLm9IgRCgICAgMCBgPz/AH0gBEL///////////8Ag0KAgICAgICA+P8AVhsLEEVBAE4NAQsLIAgMAgsgCacEQCAIIQYMAwsgACAIEA9CgICAgCAhBgwCC0KAgICAMAsQDwsgACAFEA8gACAHEA8LIAJBEGokACAG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/////w+DEGpBAEgNDSADRQRAIAkgCSgCAEEBajYCAAsgACABIAZBAWqtIBQQakEASA0NIA5CgICAgDBSBEAgEUIgiKdBdU8EQCARpyICIAIoAgBBAWo2AgALIAAgASAGQQJqrSAREGpBAEgNDgsgBCABNwNYIARCgICAgDA3A1AgACATEA8gACAAIBkgBCAEQdAAakEAEJ0DEDchEwwBC0KAgICAMCEVIA5CgICAgDBSBEAgACARECUiFUKAgICAcINCgICAgOAAUQ0NCyAEIBc3A3ggBCAVNwNwIAQgATcDaCAEIBQ3A1ggBCAPNwNQIAQgEkL/////D4M3A2AgACATEA8gACAEQdAAahDtBCETIAAgFRAPCyATQoCAgIBwg0KAgICA4ABRDQsgB6wgElcEQCAEQThqIgIgCSAHIBKnEFEaIAIgExCHARogD6cpAgRC/////weDIBJ8pyEHCyAFQQFqIQUMAQsLIARBOGoiAiAJIAcgCSgCBEH/////B3EQURogAhA2IRAMCgsgACAPEA9CgICAgDAhEwJAAn8CQCAAIAAgEkIAEE0QNyIPQoCAgIBwgyIOQoCAgICQf1IEQCAOQoCAgIDgAFINASAOIRAMAwsgD6coAgRB/////wdxDQAgACAEQdAAaiAAIAFB1QAgAUEAEBQQowFBAEgNAiAAIAFB1QACfiAJIAQpA1AgDRDxAiIOQoCAgIAIfEL/////D1gEQCAOQv////8PgwwBC0KAgICAwH4gDrm9Ig5CgICAgMCBgPz/AH0gDkL///////////8Ag0KAgICAgICA+P8AVhsLEEUiAkEATg0AIAJBHnZBAnEMAQtBAAtFDQELCwwCCwwGC0KAgICAMCETC0KAgICAMCEBDAQLIARB0ABqIAsgCCALKAIEQf////8HcRBRDQAgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEQdAAahA2IRAMAQsgACASEA8gACgCECICQRBqIAMgAigCBBEAACAEKAJQKAIQIgJBEGogBCgCVCACKAIEEQAAC0KAgICAMCERC0KAgICAMCETQoCAgIAwIQFCgICAgDAhDwsgBCgCOCgCECICQRBqIAQoAjwgAigCBBEAAAsgBBDuBCAAIBcQDyAAIA8QDyAAIAEQDyAAIBMQDyAAIBEQDyAAIBQQDwsgBEGQAWokACAQC6IBACMAQSBrIgIkAAJ+AkAgAUL/////b1gEQCAAECQMAQsgACACQQhqIgNBABA9GiADQS8QOxoCQCADIAAgAUHsACABQQAQFBB/DQAgAkEIaiIDQS8QOxogAyAAIAFB7QAgAUEAEBQQfw0AIAJBCGoQNgwCCyACKAIIKAIQIgBBEGogAigCDCAAKAIEEQAAC0KAgICA4AALIQEgAkEgaiQAIAELTgECfkKAgICA4AAhBCAAIAEgAykDABDIASIBQoCAgIBwgyIFQoCAgIDgAFIEfiAAIAEQDyAFQoCAgIAgUq1CgICAgBCEBUKAgICA4AALC/gCAgN+AX8CQAJAIAAgARDwAiICRQ0AIAMpAwghBgJAAkACQCADKQMAIgRCgICAgHBUDQAgBKciAy8BBkESRw0AIAZCgICAgHCDQoCAgIAwUgRAIABBnvkAQQAQFUKAgICA4AAPCyADKAIgIgcgBygCAEEBajYCACADKAIkIgMgAygCAEEBajYCACAHrUKAgICAkH+EIQQgA61CgICAgJB/hCEFDAELQoCAgIAwIQUCfiAEQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAQQKAsiBEKAgICAcINCgICAgOAAUQ0BIAAgBCAGEJgEIgVCgICAgHCDQoCAgIDgAFENAQsgACACNQIAQoCAgICQf4QQDyAAIAI1AgRCgICAgJB/hBAPIAIgBT4CBCACIAQ+AgAgACABQdUAQgAQRUEASA0BIAFCIIinQXVJDQIgAaciACAAKAIAQQFqNgIADAILIAAgBBAPIAAgBRAPC0KAgICA4AAPCyABC2oBAX8gAUL/////b1gEQCAAECRCgICAgOAADwsCfiABpyIDLwEGQRJHBEBCgICAgDAgACABIAAoAigpA5ABEFINARogAEESEIYDQoCAgIDgAA8LIAMoAiQtABAgAnFBAEetQoCAgIAQhAsLvQQBCX8jAEEgayIHJAACQAJAAkACQAJAIAFC/////29YBEAgABAkDAELIAAgASAAKAIoKQOQARBSDQIgACABEPACIgINAQtCgICAgOAAIQEMAwsgAigCACIIKAIEIgJB/////wdxIgMNAQsgAEH+kwEQYiEBDAELIAAgB0EIaiADIAJBH3YQigMaIAhBEGohBiAIKAIEQf////8HcSEJQQAhAANAAkACQCAAIAlIBEAgAEEBaiECQX8hBQJAAn8CQAJAAkACQAJAAkACQAJ/IAgpAgRCgICAgAiDIgFQIgpFBEAgBiAAQQF0ai8BAAwBCyAAIAZqLQAACyIDQdsAaw4DAwECAAsgAiEAAkAgA0EKaw4EBAsLBQALIANBL0cNByAERQ0FQQEhBEEvIQMMBwtB3AAhAyACIAlODQYgAEECaiEAIApFBEAgBiACQQF0ai8BACEFDAoLIAIgBmotAAAhBQwJC0EAIQRB3QAhAwwFC0HbACEDIAQgAiAJTnINBiAAQQJqIQAgAVAEQEHdAEF/IAIgBmotAABB3QBGIgQbIQUgACACIAQbIQBBASEEDAgLQQEhBEHdAEF/IAYgAkEBdGovAQBB3QBGIgobIQUgACACIAobIQAMBwtB7gAMAgtB8gAMAQtBACEEQS8LIQVB3AAhAwsgAiEADAILIAdBCGoQNiEBDAMLIAIhAEEBIQQLIAdBCGogAxCLARogBUEASA0AIAdBCGogBRCLARoMAAsACyAHQSBqJAAgAQvWAgIDfwF+IwBBEGsiBCQAAkAgAUL/////b1gEQCAAECRCgICAgOAAIQUMAQtCgICAgOAAIQUgACAAIAFB7gAgAUEAEBQQJiICQQBIDQAgAgR/IARB5wA6AAggBEEJagUgBEEIagshAiAAIAAgAUHr4wAQsgEQJiIDQQBIDQAgAwRAIAJB6QA6AAAgAkEBaiECCyAAIAAgAUGL5QAQsgEQJiIDQQBIDQAgAwRAIAJB7QA6AAAgAkEBaiECCyAAIAAgAUH01AAQsgEQJiIDQQBIDQAgAwRAIAJB8wA6AAAgAkEBaiECCyAAIAAgAUHvACABQQAQFBAmIgNBAEgNACADBEAgAkH1ADoAACACQQFqIQILIAAgACABQfsdELIBECYiA0EASA0AIAAgBEEIaiIAIAMEfyACQfkAOgAAIAJBAWoFIAILIABrEJMCIQULIARBEGokACAFC6UDAQR+IwBBEGsiAyQAIAQCfwJAAkACQAJAIAAgAUEuEEsiAkUEQEKAgICAMCEBDAELIAIoAhgEQEKAgICAMCEBQQEMBQsgACACKQMAIgggAikDCCIGEMgBIgFCgICAgHCDIgdCgICAgOAAUg0BC0KAgICAMCEHDAELIAdCgICAgCBRBEAgAkEBNgIYQoCAgIAwIQFBAQwDCyACKAIQBEAgACAAIAFCABBNEDciB0KAgICAcIMiCUKAgICA4ABRDQECQCAJQoCAgICQf1INACAHpygCBEH/////B3ENACAAIANBCGogACAIQdUAIAhBABAUEKMBQQBIDQIgACAIQdUAAn4gBqcgAykDCCACKAIUEPECIgZCgICAgAh8Qv////8PWARAIAZC/////w+DDAELQoCAgIDAfiAGub0iBkKAgICAwIGA/P8AfSAGQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0CCyAAIAcQDwwCCyACQQE2AhgMAQsgACABEA8gACAHEA9CgICAgOAAIQELQQALNgIAIANBEGokACABCw4AIAAQtQJCgICAgOAACwkAQoCAgIDAfgsWACAAIAMpAwAgAykDCCADKQMQEJQEC9EBAgN+An8jAEEQayIHJAACQCAAIAdBDGogAykDABDlASIIRQRAQoCAgIDgACEEDAELIAAgCCAHKAIMQdKIARD1BSEBIAAgCBBUAkAgAkECSCABQoCAgIBwg0KAgICA4ABRcg0AIAAgAykDCCIGEDhFDQBCgICAgOAAIQQCQCAAEDQiBUKAgICAcINCgICAgOAAUQRAIAEhBQwBCyAAIAVBLyABQQcQGUEASA0AIAAgBUEvIAYQ+QQhBAsgACAFEA8MAQsgASEECyAHQRBqJAAgBAsNACAAIAEgAkEwEP0FCwsAIAAgAUEwEP4FC7QDAgN/An4jAEHQAGsiBiQAQX8hBwJAIAAgBkHIAGogAUHCABCBASIIRQ0AIAYpA0giAUKAgICAcINCgICAgDBRBEAgCCkDACEBIANCIIinQXVPBEAgA6ciByAHKAIAQQFqNgIACyAAIAEgAiADIAQgBRCGBCEHDAELIAAgAhBcIglCgICAgHCDQoCAgIDgAFEEQCAAIAEQDwwBCyAIKQMAIQogBiAENwM4IAYgAzcDMCAGIAk3AyggBiAKNwMgIAAgASAIKQMIQQQgBkEgahAvIQEgACAJEA8gAUKAgICAcINCgICAgOAAUQ0AAkACQCAAIAEQJiIHBEAgACAGIAgoAgAgAhBMIgJBAEgNASACRQ0DAkAgBigCACICQRNxRQRAIAAgBikDCCADEFJFDQEMBAsgAkERcUEQRw0DIAY1AhxCIIZCgICAgDBSDQMLIAAgBhBI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gICAwH4gALi9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLOQEBfkKAgICAwH4gASkDACICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCzsBAX5CgICAgMB+IAEqAgC7vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCwwAIAAgASkDABD7AwsMACAAIAEpAwAQhwILSQEBfiABKAIAIgBBAE4EQCAArQ8LQoCAgIDAfiAAuL0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsHACABNQIACwcAIAEzAQALDgAgATIBAEL/////D4MLCQAgABC1AkF/Cw4AIAEwAABC/////w+DCwcAIAExAAALDwAgACsDACABKwMAEP0ECxEAIAAqAgC7IAEqAgC7EP0ECxkBAn4gASkDACIDIAApAwAiBFQgAyAEVmsLGQECfiABKQMAIgMgACkDACIEUyADIARVawsXACABKAIAIgEgACgCACIASSAAIAFJawsXACABKAIAIgEgACgCACIASCAAIAFIawsNACAALwEAIAEvAQBrCw0AIAAuAQAgAS4BAGsLDQAgACwAACABLAAAawsNACAALQAAIAEtAABrC8wNBAd/AXwBfgF9IwBBIGsiBiQAQoCAgIDgACENAkAgACABEJIBIgpBAEgNAEF/IQUCQAJAAkAgCkUNAEEBIQgCQAJAIARBAUYEQEF/IQggBiAKQQFrIgU2AhwgAkECSA0BIAAgBkEIaiADKQMIEEINBiAGKwMIIgy9Qv///////////wCDQoGAgICAgID4/wBaBEAgBkEANgIcDAILIAxEAAAAAAAAAABmBEAgDCAFt2NFDQIgBgJ/IAyZRAAAAAAAAOBBYwRAIAyqDAELQYCAgIB4CzYCHAwCC0F/IQUgDCAKt6AiDEQAAAAAAAAAAGMNBCAGAn8gDJlEAAAAAAAA4EFjBEAgDKoMAQtBgICAgHgLNgIcDAELIAZBADYCHCACQQJIBEAgCiECDAILIAAgBkEcaiADKQMIIAoiAiACEFcNBQwBC0F/IQILIAGnIgkoAiAoAgwoAiAtAAQEQEF/IQUgBEF/Rw0CQX9BACADNQIEQiCGQoCA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IA1CgICAgDBBBCAFQRBqECEhCiAAIAsQDyAAIA8QDyAFQoCAgIAwNwM4IApCgICAgHCDQoCAgIDgAFENASAAIAkQDyAKIQkLIAhCAXwhCAwBCwsgBSAJNwMwIAUpAzghCwsgACAFKQMwEA8gACALEA9CgICAgOAAIQkLIAAgARAPIAVBQGskACAJC6wIAgN/CX4jAEEwayIFJABCgICAgDAhCSAFQoCAgIAwNwMoAkACQAJAAkAgBEEIcSIHBEAgAUIgiKdBdU8EQCABpyIGIAYoAgBBAWo2AgALIAUgACABEJIBIgasNwMIIAZBAE4NAQwCCyAAIAVBCGogACABECUiARA8DQELIAMpAwAhD0KAgICAMCEOIAJBAk4EQCADKQMIIQ4LIAAgDxBgDQACQAJAAkACQAJAAkACQCAEDg0FAAYBAgYGBgUABgMEBgtCgICAgBAhCQwFCyAAIAECfiAFKQMIIghCgICAgAh8Qv////8PWARAIAhC/////w+DDAELQoCAgIDAfiAIub0iCEKAgICAwIGA/P8AfSAIQv///////////wCDQoCAgICAgID4/wBWGwsQqwIiCUKAgICAcINCgICAgOAAUg0EDAULIAAgAUIAEKsCIglCgICAgHCDQoCAgIDgAFINAwwECyAFIAE3AxAgBSAFNQIINwMYIABBAiAFQRBqEPYCIglCgICAgHCDQoCAgIDgAFINAgwDCyAAED4iCUKAgICAcINCgICAgOAAUg0BQoCAgIDgACEJDAILQoGAgIAQIQkLQgAhCCAFKQMIIgpCACAKQgBVGyEQA0AgCCAQUgRAAkACQCAHBEAgBSAAIAEgCBBzIgo3AyggCkKAgICAcINCgICAgOAAUg0BDAULIAAgASAIIAVBKGoQhQEiAkEASA0EIAJFDQELIAghCiAIQoCAgIAIWgRAQoCAgIDAfiAIub0iCkKAgICAwIGA/P8AfSAKQv///////////wCDQoCAgICAgID4/wBWGyEKCyAKQoCAgIBwg0KAgICA4ABRDQMgBSABNwMgIAUgCjcDGCAFIAUpAygiDTcDECAAIA8gDkEDIAVBEGoQISELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENAwJAAkACQAJAAkACQAJAIAQODQABBQIEBQUFAAEFAwQFCyAAIAsQJg0FQoCAgIAQIQgM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AUL///////////8Ag0KAgICAgICA+P8AVhshBQwCCxABAAsgAjAAAEL/////D4MhBQsgB0EQaiQAIAULUgIBfwF+QoCAgIDgACEEIAAgASACEJMBIgMEfiADKAIgIgMoAgwoAiAtAAQEQCACRQRAQgAPCyAAEGtCgICAgOAADwsgAzUCFAVCgICAgOAACwvXAQEDfwJAIAFCgICAgHBUDQAgAaciAy8BBkE5Rw0AIAMoAiAiBEUNACAEQcwAaiEDIARByABqIQUDQCAFIAMoAgAiA0cEQCADKQMQIgFCgICAgGBaBEAgACABpyACEQAACyADKQMYIgFCgICAgGBaBEAgACABpyACEQAACyADKQMgIgFCgICAgGBaBEAgACABpyACEQAACyADKQMoIgFCgICAgGBaBEAgACABpyACEQAACyADQQRqIQMMAQsLIAQoAgRBfnFBBEYNACAAIARBCGogAhDvAwsLBgBB4MYECzABAX8CQCABQoCAgIBwVA0AIAGnIgIvAQZBOUcNACACKAIgIgJFDQAgACACEIcFCwsNACAAIAEgAkE3EP0FCwsAIAAgAUE3EP4FCxYBAX8gAacoAiAiAgRAIAAgAhCIBQsLMQEBfyABpygCICICBEAgACACKAIIEKMFIAAgAikDABAjIABBEGogAiAAKAIEEQAACwvcAQEEfwJAIAFCgICAgHBUDQAgAaciBC8BBkExRw0AIAQoAiAiBkUNAEEAIQQDQCAEQQJGRQRAIAYgBEEDdGoiBUEIaiEDIAVBBGohBQNAIAUgAygCACIDRwRAIAMpAwgiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAxgiAUKAgICAYFoEQCAAIAGnIAIRAAALIANBBGohAwwBCwsgBEEBaiEEDAELCyAGKQMYIgFCgICAgGBUDQAgACABpyACEQAACwuMAQEFfwJAIAFCgICAgHBUDQAgAaciAi8BBkExRw0AIAIoAiAiBEUNAANAIANBAkZFBEAgBCADQQN0aiICQQRqIQUgAigCCCECA0AgAiAFRkUEQCACKAIEIQYgACACEK4CIAYhAgwBCwsgA0EBaiEDDAELCyAAIAQpAxgQIyAAQRBqIAQgACgCBBEAAAsLJQAgBSkDACIBQiCIp0F1TwRAIAGn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IAMpAwAQpgENACAAEJcBIgVCgICAgHCDQoCAgIDgAFENACAAIAJBFGogAykDCBC7ASIGRQRAIAAgBRAPDAELIAAoAtgBIQMgAkIANwIMIAJCgICAgICAgICAfzcCBCACIAM2AgAgAkIBEDAaIAIgAikDKCIBpyIHQf////8DQQEQzAEaIAIgAkJ/Qf////8DQQEQdRogBadBBGoiAyAGIAIQkwUaAkAgBEUgAVByDQAgAkIBEDAaIAIgB0EBa0H/////A0EBEMwBGiADIAIQ0wFBAEgNACACQgEQMBogAiAHQf////8DQQEQzAEaIAMgAyACQf////8DQQEQ5AEaCyACEBsgACAGIAJBFGoQXiAAIAUQzQEhAQsgAkEwaiQAIAEL6hMCAn4BfyMAQdABayIEJAAgACAEEJgFIAEgARA0IgNBqi0CfiAEKQMIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB3+AAAn4gBCkDECICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQboqAn4gBCkDGCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQagqAn4gBCkDICICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfooAn4gBCkDKCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQfrfAAJ+IAQpAzAiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HYKAJ+IAQpAzgiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G23wACfiAEKQNAIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBzSkCfiAEKQNIIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBl+AAAn4gBCkDUCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeIoAn4gBCkDWCICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQc/fAAJ+IAQpA2AiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0GGKgJ+IAQpA2giAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0Gt4AACfiAEKQNwIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBxyoCfiAEKQN4IgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB8OAAAn4gBCkDgAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HN4AACfiAEKQOIASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQZIqAn4gBCkDkAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0G44AACfiAEKQOYASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQdUqAn4gBCkDoAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0HvJwJ+IAQpA6gBIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANB6icCfiAEKQOwASICQoCAgIAIfEL/////D1gEQCACQv////8PgwwBC0KAgICAwH4gArm9IgJCgICAgMCBgPz/AH0gAkL///////////8Ag0KAgICAgICA+P8AVhsLEEAgASADQeszAn4gBCkDuAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAEgA0H7JwJ+IAQpA8ABIgJCgICAgAh8Qv////8PWARAIAJC/////w+DDAELQoCAgIDAfiACub0iAkKAgICAwIGA/P8AfSACQv///////////wCDQoCAgICAgID4/wBWGwsQQCABIANBo98AAn4gBCkDyAEiAkKAgICACHxC/////w9YBEAgAkL/////D4MMAQtCgICAgMB+IAK5vSICQoCAgIDAgYD8/wB9IAJC////////////AINCgICAgICAgPj/AFYbCxBAIAMQUyEAIARB0AFqJAAgAAufAgEDfiABQv////9vWARAIAAQJEKAgICA4AAPC0KAgICA4AAhBQJ+IAAgAUE2IAFBABAUIgRCgICAgHCDQoCAgIAwUQRAIABBlAEQLQwBCyAAIAQQNwsiBEKAgICAcIMiBkKAgICA4ABSBH4CfiAAIAFBMyABQQAQFCIBQoCAgIBwg0KAgICAMFEEQCAAQS8QLQwBCyAAIAEQNwsiAUKAgICAcIMiBUKAgICA4ABRBEAgACAEEA9CgICAgOAADwsCQCAGQoCAgICQf1EEQCAEpygCBEH/////B3FFDQELIAVCgICAgJB/UQRAIAGnKAIEQf////8HcUUNAQsgAEHMngEgBEH4mQEQvgEhBAsgACAEIAEQxAIFQoCAgIDgAAsLXwEBfwJAIAFFBEAgAkUNASAAIAIQ2QMPCyACRQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQwBCyAAKAIIIAAoAgQgAmpPBH8gASACEPMFBUEACw8LQQALJgAgAQRAIAAgACgCAEEBazYCACAAIAAoAgRBCGs2AgQgARCbAQsLCQAgACABNgIYCygBAX8CQCABpygCICIDRQ0AIAMoAgBBBEYNACAAIANBCGogAhDvAwsLPwEBfwJAIAFCgICAgHBUDQAgAaciAi8BBkEvRw0AIAIoAiAiAkUNACAAIAIQ7AMgAEEQaiACIAAoAgQRAAALC0cBAX8CQCABpygCICIDRQ0AIAMpAwAiAUKAgICAYFoEQCAAIAGnIAIRAAALIAMpAwgiAUKAgICAYFQNACAAIAGnIAIRAAALCzABAX8gAacoAiAiAgRAIAAgAikDABAjIAAgAikDCBAjIABBEGogAiAAKAIEEQAACwsnAQF/IAGnKAIgIgIEQCAAIAIpAwAQIyAAQRBqIAIgACgCBBEAAAsLWgECfyABpygCICICBEACQCACKQMAIgFCgICAgHBUDQAgAactAAVBAnENACACKAIMIgNFDQAgACADEOoDIAIpAwAhAQsg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ACIGRQ0AIAYtAAVBAXFFDQAgACAGIAIRAAALIANBAWohAwwACwALIAAgBCACEQAACwt8AQN/IAGnIgIoAigiAwRAIAAgA61CgICAgHCEECMLIAIoAiAiAwRAIAIoAiQiBARAQQAhAgNAIAIgAygCPE5FBEAgACAEIAJBAnRqKAIAEOsBIAJBAWohAgwBCwsgAEEQaiAEIAAoAgQRAAALIAAgA61CgICAgGCEECMLCxIAIAGnKAIgIgAEQCAAEKQDCwseACABpykDICIBQoCAgIBgWgRAIAAgAacgAhEAAAsLGQAgACABpyIAKQMgECMgAEKAgICAMDcDIAtEAQJ/IAGnIQQDQCAEKAIoIANLBEAgBCgCJCADQQN0aikDACIBQoCAgIBgWgRAIAAgAacgAhEAAAsgA0EBaiEDDAELCwtGAQN/IAGnIQMDQCADKAIkIQQgAiADKAIoT0UEQCAAIAQgAkEDdGopAwAQIyACQQFqIQIMAQsLIABBEGogBCAAKAIEEQAAC2kBAn8jAEEQayIHJAACfwJAIAGnIggtAAVBCHFFDQAgACAHQQxqIAIQrAFFDQAgBygCDCAIKAIoTw0AQX8gACAIEJIDDQEaCyAAIAEgAiADIAQgBSAGQYCACHIQbQshACAHQRBqJAAgAAuBAgIDfwF+AkACQCACQQBODQAgAacpAyAiCkKAgICAcINCgICAgJB/Ug0AIAJB/////wdxIgggCqciBykCBCIKp0H/////B3FPDQACQEEEIAYQkwNFDQBBASECIAZBgMAAcUUNAiADQoCAgIBwg0KAgICAkH9SDQAgA6ciCSkCBCIBQv////8Hg0IBUg0AIAdBEGohBwJ/IApCgICAgAiDUEUEQCAHIAhBAXRqLwEADAELIAcgCGotAAALAn8gAUKAgICACINQRQRAIAkvARAMAQsgCS0AEAtGDQILIAAgBkHh6QAQbw8LIAAgASACIAMgBCAFIAZBgIAIchBtIQILIAILRgACfwJAIAJBAE4NACABpykDICIBQoCAgIBwg0KAgICAkH9SDQBBACACQf////8HcSABpygCBEH/////B3FJDQEaC0EBCwuzAQECfwJAIANBAE4NACACpykDICICQoCAgIBwg0KAgICAkH9SDQAgA0H/////B3EiAyACpyIEKQIEIgKnQf////8HcU8NAEEBIQUgAUUNACAEQRBqIQQCfyACQoCAgIAIg1BFBEAgBCADQQF0ai8BAAwBCyADIARqLQAACyEDIAFBBDYCACAAIANB//8DcRCfAyECIAFCgICAgDA3AxggAUKAgICAMDcDECABIAI3AwgLIAULWwECfyABpygCECIAQTBqIQMgACAAKAIYIAJxQX9zQQJ0aigCACEAA0ACQCAARQ0AIAMgAEEBa0EDdGoiBCgCBCACRg0AIAQoAgBB////H3EhAAwBCwsgAEEARws1AQF+IAEpAwAiAkIgiKdBdU8EQCACpyIBIAEoAgBBAWo2AgALIAAgAhCKAUKAgICA4AAQUwuOAQECfyABKAIAIgJBAEoEQCABIAJBAWsiAjYCAAJAIAINACABLQAEQfABcUEQRw0AIAEoAggiAiABKAIMIgM2AgQgAyACNgIAIAFBADYCCCAAKAJgIgIgAUEIaiIDNgIEIAEgAEHgAGo2AgwgASACNgIIIAAgAzYCYAsPC0HFjQFBrvwAQbAsQc/0ABAAAAtvAQJ/IAEgASgCACICQQFqNgIAIAJFBEAgASgCCCICIAEoAgwiAzYCBCADIAI2AgAgAUEANgIIIAAoAlAiAiABQQhqIgM2AgQgASAAQdAAajYCDCABIAI2AgggACADNgJQIAEgAS0ABEEPcToABAsLDwAgASABKAIAQQFqNgIAC4gBAgF+AX9BACECQoCAgIAwIQEDQAJAIAJBAkcEfiAFIAJBA3QiBGoiBzUCBEIghkKAgICAMFENASAAQawuQQAQFUKAgICA4AAFQoCAgIAwCw8LIAMgBGopAwAiBkIgiKdBdU8EQCAGpyIEIAQoAgBBAWo2AgALIAcgBjcDACACQQFqIQIMAAsAC1wBAn4gAiAAKAIAEC0hA0EAIQAgA0KAgICAcINCgICAgOAAUSACIAEoAgAQLSIEQoCAgIBwg0KAgICA4ABRckUEQCADpyAEpxCDAiEACyACIAMQDyACIAQQDyAAC2sBAX4CQAJAAkACQAJAIAMtAAUiAQ4EAwICAAELIAAgAygCCBDKBA8LIAFBCEYNAgsQAQALIAAgAygCDCADKAIAIAMtAAggAy0ACSADLgEGEIIBDwsgACAAEDQiBCADKAIIIAMoAgwQIiAECwkAIAAgAxCNAwtTAQF+IAAQNCIEQoCAgIBwg0KAgICA4ABSBEAgASABKAIAQQFqNgIAIAAgBEE8IAGtQoCAgIBwhEEDEBlBAE4EQCAEDwsgACAEEA8LQoCAgIDgAAsDAAELagEBfyMAQRBrIgMkACABKAIEIQEgAiADQQxqIAAoAgQQrAFBACACIANBCGogARCsARtFBEBB0MUAQa78AEGDOkH8yQAQAAALIAMoAgghACADKAIMIQEgA0EQaiQAQX8gACABRyAAIAFLGwvaAwICfgF/IwBBIGsiBSQAAkACQCAAIAFBLBBLIgJFDQBCgICAgDAhAQJAIAIpAwAiBkKAgICAcINCgICAgDBSBEACfwJAIAanIgMvAQZBFWtB//8DcUEKTQRAIAMoAiAoAgwoAiAtAARFDQEgABBrDAULIAAgBUEcaiAGENYBDQQgBUEcagwBCyADQShqCyEIIAIoAgwiAyAIKAIASQ0BIAAgAikDABAPIAJCgICAgDA3AwALIARBATYCAAwCCyACIANBAWo2AgwgBEEANgIAIAIoAghFBEAgA0EATgRAIAOtIQEMAwtCgICAgMB+IAO4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbIQEMAgtCgICAgOAAIQEgACACKQMAIAMQsAEiBkKAgICAcINCgICAgOAAUQ0BIAIoAghBAUYEQCAGIQEMAgsgBSAGNwMIIAUgA0EATgR+IAOtBUKAgICAwH4gA7i9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIgc3AwAgAEECIAUQiQMhASAAIAYQDyAAIAcQDwwBCyAEQQA2AgBCgICAgOAAIQELIAVBIGokACABCxAAIwAgAGtBcHEiACQAIAALBgAgACQACwQAIwAL7gICBH8CfiMAQRBrIgMkAAJAAkAgAikDECIHQoCAgIBwg0KAgICAkH9SBEAgAEGDlAFBABAVDAELIAIpAxghCCAAIAcQswEiBEUEQEEAIQQMAQsgACAIELMBIgZFDQACQCAAIAQgBhDJBSIBRQ0AIAAgARD+A0EASARAIABBARCPBAwBCyABIAEoAgBBAWo2AgAgACABrUKAgICAUIQgACkDwAFBAEEAEMgFIgdCgICAgHCDQoCAgIDgAFENACAAIAcQDyABIQULIAAgBhBUIAVFDQAgAyAAIAUQjQMiBzcD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ACEEIANCADcCaCADQoCAgICAgICAgH83AmAgAyAENgJcIANB3ABqIgUgARBEGiADQgA3AlQgA0KAgICAgICAgIB/NwJMIAMgBDYCSCADKAJkIQYgA0EANgJkIANByABqIgFCqtWq1QoQMBogA0EANgJQIAUgARCyAgRAIAMgAygCZEEBajYCZCAGQQFrIQYLIANByABqEBsgAkEBakEBdhCVBiEFIANCADcCVCADQoCAgICAgICAgH83AkwgAyAENgJIIANCADcCQCADQoCAgICAgICAgH83AjggAyAENgI0IANB3ABqIgEgAUJ/Qf////8DQQAQdRogBUEAIAVBAEobIQkgAiAFaiACIAVBAXRuQQFqIgpBAXRqQSBqIQJBACEBA0AgASAJRkUEQCADQcgAaiIHIANB3ABqIghCASACQQAQdRogA0E0aiILIAcgAkEGEJEGIAcgC0IBIAJBABB1GiAIIAggByACQQAQlQEaIAFBAWohAQwBCwsgA0IANwIsIANCgICAgICAgICAfzcCJCADIAQ2AiAgA0IANwIYIANCgICAgICAgICAfzcCECADIAQ2AgwgA0EgaiIBIANB3ABqIgRCAiACQQAQdRogASAEIAEgAkEAEJUBGiADQQxqIAEgASACQQAQQxogAEIAEDAaIAqsIQwDQCAMQgBXRQRAIANByABqIgFCARAwGiADQTRqIgQgDKdBAXRBAXKsEDAaIAEgASAEIAJBABCVARogACAAIAEgAkEAEMsBGiAAIAAgA0EMaiACQQAQQxogDEIBfSEMDAELCyAAIABCASACQQAQdRogACAAIANBIGoiASACQQAQQxogARAbIANBDGoQGyADQTRqEBsgA0HIAGoQGyAAIAVBAWpB/////wNBARDMARogA0HcAGoiASACQQYQ0wIgASABIAasIAJBABDUAiAAIAAgASACQQAQywEaIAEQGyADQfAAaiQAQRAPC0HY/QBB1PwAQdciQajWABAAAAsRACAAIAEgAiADIARBABCWBgsRACAAIAEgAiADIARBARCWBgvYAwEHfyACKAIEIAEoAgRzIQcCQAJAAkACQAJAAkACQCABKAIIIgZB/f///wdMBEAgAigCCCIFQf3///8HSg0BIAZBgICAgHhHDQYgBUGAgICAeEYNBAwHCyAGQf////8HRg0BIAIoAggh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gICAMEEBENQFDQIgACABEA8LIAJBAWohAgwACwALIAAgBBAPIAAgARAPQoCAgIDgAAsYACAAIAMpAwAgAykDCBBSrUKAgICAEIQL4gICA34DfyMAQSBrIgIkAEKAgICA4AAhBCAAIAMpAwAQJSIFQoCAgIBwg0KAgICA4ABSBEBCgICAgDAhAQJAAkAgACACQRxqIAJBGGogBadBAxCOAQ0AQoCAgIDgACEBIAAQNCIEQoCAgIBwg0KAgICA4ABRDQAgAigCHCEHIAIoAhghCEEAIQMDQCADIAhHBEACQAJAIAAgByADQQN0aiIJKAIEEFwiAUKAgICAcINCgICAgOAAUQ0AIAIgATcDCCACIAU3AwAgACAEIAAgAkEAEMYEIQYgACABEA8gBkKAgICAcIMiAUKAgICAMFENASABQoCAgIDgAFENACAAIAQgCSgCBCAGQYeAARAZQQBODQELIAQhAQwDCyADQQFqIQMMAQsLIAAgByAIEFogBSEBDAELIAAgAigCHCACKAIYEFogACAFEA9CgICAgOAAIQQLIAAgARAPCyACQSBqJAAgBAsQACAAIAMpAwBBESAEEKoCCxAAIAAgAykDAEECQQAQqgILEAAgACADKQMAQQFBABCqAgtHAQF+QoCAgIDgACEEIAAgAykDACIBIAMpAwgQrgYEfkKAgICA4AAFIAFCIIinQXVPBEAgAaciACAAKAIAQQFqNgIACyABCwtBACAAIAMpAwAiASADKQMIQQEQiwJBAEgEQEKAgICA4AAPCyABQiCIp0F1TwRAIAGnIgAgACgCAEEBajYCAAsgAQuJAQEBfiADKQMAIgFC/////29WIAFCgICAgHCDQoCAgIAgUXJFBEAgAEG35ABBABAVQoCAgIDgAA8LAkAgACABEEciAUKAgICAcINCgICAgOAAUgRAIAMpAwgiBEKAgICAcINCgICAgDBRDQEgACABIAQQrgZFDQEgACABEA8LQoCAgIDgAA8LIAELpQQCBX8CfiMAQSBrIgUkACAAIAVBCGoiBkEAED0aIAZBKBA7GiAEQX5xQQJGBEAgBUEIakHxmQEQiAEaCyAFQQhqQbrMABCIARogBEF9cUEBRgRAIAVBCGpBKhA7GgsgBUEIakGvlAEQiAEaQQAhBiACQQFrIgdBACAHQQBKGyEIAkACQAJAA0AgBiAIRwRAIAYEQCAFQQhqQSwQOxoLIAZBA3QhCSAGQQFqIQYgBUEIaiADIAlqKQMAEIcBRQ0BDAILCyAFQQhqQYaaARCIARogAkEASgRAIAVBCGogAyAHQQN0aikDABCHAQ0BCyAFQQhqIgJBiZEBEIgBGkKAgICAMCELIAIQNiIKQoCAgIBwg0KAgICA4ABRDQEgACAAKQPAASAKQQNBfxCcAyELIAAgChAPIAtCgICAgHCDQoCAgIDgAFENASABQoCAgIBwg0KAgICAMFENAiAAIAFBOyABQQAQFCIKQoCAgIBwg0KAgICA4ABRDQECQCAKQv////9vVg0AIAAgChAPIAAgARCAAyICRQ0CIAIoAiggBEEBdEGuwAFqLwEAQQN0aikDACIKQiCIp0F1SQ0AIAqnIgIgAigCAEEBajYCAAsgACALIApBARCLAiECIAAgChAPIAJBAE4NAgwBCyAFKAIIKAIQIgJBEGogBSgCDCACKAIEEQAAQoCAgIAwIQsLIAAgCxAPQoCAgIDgACELCyAFQSBqJAAgCwuAAgICfgF/IwBBIGsiByQAQoCAgIDgACEFAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNAANAIAAgByABpyADEEwiAkEASA0CIAIEQEKAgICAMCEFAkAgBy0AAEEQcUUNACAHQRhBECAEG2opAwAiBUIgiKdBdUkNACAFpyICIAIoAgBBAWo2AgALIAAgBxBIDAMLIAAgARCMAiIBQoCAgIBwgyIGQoCAgIAgUgRAIAZCgICAgOAAUQRAIAYhBQwECyAAEHtFDQEMAwsLQoCAgIAwIQUMAQtBACEDCyAAIAMQEyAAIAEQDyAHQSBqJAAgBQuxAQEDfiADKQMIIQUgAykDACEGQoCAgIDgACEHAkAgACABECUiAUKAgICAcINCgICAgOAAUgR+IAAgBRBgDQEgACAGEDEiAkUNASAAIAEgAkKAgICAMEKAgICAMCAFIAQbIAVCgICAgDAgBBtBhaoBQYWaASAEGxBtIQMgACABEA8gACACEBNCgICAgOAAQoCAgIAwIANBAEgbBUKAgICA4AALDwsgACABEA9CgICAgOAAC3IBAX5CgICAgDAhAyABQoCAgIAQhEKAgICAcINCgICAgDBRBEAgABAkQoCAgIDgAA8LIAJCgICAgHCDQoCAgIAgUiACQv////9vWHEEfkKAgICAMAVCgICAgOAAQoCAgIAwIAAgASACQQEQiwJBAEgbCwsyAQF+IAAgARAlIgFCgICAgHCDQoCAgIDgAFEEQCABDwsgACABEOgBIQIgACABEA8gAgugAQIBfgF/IwBBIGsiAiQAQoCAgIDgACEEAkACQCAAIAEQJSIBQoCAgIBwg0KAgICA4ABRDQAgACADKQMAEDEiA0UNACAAIAIgAacgAxBMIgVBAEgNASAFRQRAQoCAgIAQIQQMAgsgAjUCACEEIAAgAhBIIARCAohCAYNCgICAgBCEIQQMAQtBACEDCyAAIAMQEyAAIAEQDyACQSBqJAAgBAvBAQECfgJAAn5CgICAgBAgAykDACIEQoCAgIBwVA0AGkKAgICA4AAgACABECUiAUKAgICAcINCgICAgOAAUQ0AGiAEpyICIAIoAgBBAWo2AgAgAachAgNAIAAgBBCMAiIEQoCAgIBwgyIFQoCAgIDgAFIEQCACIASnRiAFQoCAgIAgUXINAyAAEHtFDQELCyAAIAQQDyAAIAEQD0KAgICA4AALDwsgACAEEA8gACABEA8gBUKAgICAIFKtQoCAgIAQhAt6AQF+IAAgAykDABAxIgJFBEBCgICAgOAADwtCgICAgOAAIQQgACABECUiAUKAgICAcINCgICAgOAAUQRAIAAgAhATIAEPCyAAQQAgAacgAhBMIQMgACACEBMgACABEA9CgICAgOAAIANBAEetQoCAgIAQhCADQQBIGwsIACAAIAEQJQsPACAAIAFBN0EAQQAQrAILLQEBfkKAgICAMCECAkAgARCjAyIARQ0AIAAtABJBBHFFDQAgADUCRCECCyACCzMCAX4Bf0KAgICAMCECAkAgARCjAyIDRQ0AIAMtABJBBHFFDQAgACADKAJAEC0hAgsgAgsoAEKAgICA4AAgACADKQMAIAEQvgUiAEEAR61CgICAgBCEIABBAEgbC7cBAgF+An9CgICAgOAAIQQgACABEGAEfkKAgICA4AAFQcqZASECAkAgAaciAy8BBhDuAUUNAAJAIAMoAiAiAy8AESIFQYAIcUUNACADKAJUIgZFDQAgACAGIAMoAkgQkwIPCyAFQQR2QQNxQQFrIgNBAksNACADQQJ0QfT/AWooAgAhAgsgACACIAAgAUE2IAFBABAUIgFCgICAgHCDQoCAgIAwUQR+IABBLxAtBSABC0G+GRC+AQsL6QUDA34GfwN8AkACfkKAgICA4AAgACABEGANABpCgICAgOAAIAAgACkDMEEOEEkiBUKAgICAcINCgICAgOAAUQ0AGiAFpyIKIAFCgICAgHBaBH8gAactAAVBEHEFQQALIAotAAVB7wFxcjoABSAAQQEgAiACQQFMGyILQQFrIghBA3RBGGoQKSIHRQ0BIAFCIIinQXVPBEAgAaciAiACKAIAQQFqNgIACyAHIAE3AwAgAykDACIEQiCIp0F1TwRAIASnIgIgAigCAEEBajYCAAsgByAINgIQIAcgBDcDCEEAIQIDQCACIAhHBEAgAyACQQFqIglBA3RqKQMAIgRCIIinQXVPBEAgBKciDCAMKAIAQQFqNgIACyAHIAJBA3RqIAQ3AxggCSECDAELCyAKIAc2AiAgAUL/////b1gEQCAAECQMAgsgAEEAIAGnQTAQTCICQQBIDQFCACEEAkAgAkUNACAAIAFBMCABQQAQFCIGQoCAgIBwg0KAgICA4ABRDQIgBkL/////D1gEQCAGpyICIAhrQQAgAiALThutIQQMAQsgBkIgiKdBB2tBbU0EQAJAIAZCgICAgMCBgPz/AHwiBEL///////////8Ag0KAgICAgICA+P8AVg0AIAS/nSIOIAi3Ig9lDQAgDiAPoSENCyANvSIEAn8gDZlEAAAAAAAA4EFjBEAgDaoMAQtBgICAgHgLIgK3vVEEQCACrSEEDAILQoCAgIDAfiAEQoCAgIDAgYD8/wB9IARC////////////AINCgICAgICAgPj/AFYbIQQMAQsgACAGEA8LIAAgBUEwIARBARAZGiAAQdSZASAAIAFBNiABQQAQFCIEQoCAgIBwgyIBQoCAgICQf1IEfiABQoCAgIDgAFENAiAAIAQQDyAAQS8QLQUgBAtBzJ4BEL4BIgFCgICAgHCDQoCAgIDgAFENASAAIAVBNiABQQEQGRogBQsPCyAAIAUQD0KAgICA4AALMAAgAkEATARAIAAgAUKAgICAMEEAQQAQIQ8LIAAgASADKQMAIAJBAWsgA0EIahAhC6MCAgF/BH4jAEEQayIFJABCgICAgDAhBgJAAkAgACAFQQhqIAAgARAlIgkQPA0AIAVBATYCBAJAIAQEQCAD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gDBSBEAgB0KAgICA4ABRDQcgACABECYMAQsgACAFEMoBCyICQQBIDQUgAkUNACAAIAkgBRA8DQUgCSkDACIHIAR8Qv////////8PVQ0EQgAhASAHQgAgB0IAVRshBwNAIAEgB1ENAiAAIAUgASAJQQhqEIUBIgJBAEgNBiACBEAgACAGIAQgCSkDCBBqQQBIDQcLIARCAXwhBCABQgF8IQEMAAsACyAEQv7///////8PVQ0DIAVCIIinQXVPBEAgBaciAiACKAIAQQFqNgIACyAAIAYgBCAFEGpBAEgNBCAEQgF8IQQLIApBAWohCgwBCwsgACAGQTAgBEKAgICACHxC/////w9YBH4gBEL/////D4MFQoCAgIDAfiAEub0iAUKAgICAwIGA/P8AfSABQv///////////wCDQoCAgICAgID4/wBWGwsQRUEASA0BDAILIABB0NoAQQAQFQsgACAGEA9CgICAgOAAIQYLIAAgCBAPIAlBEGokACAGC7ECAgR+An8jAEEQayIIJABCgICAgOAAIQUCQAJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAIIAKtNwMIIAAgAUEBIAhBCGoQpwEMAQsgABA+CyIEQoCAgIBwg0KAgICA4ABRDQAgAkEAIAJBAEobrSEHQgAhAQJAA0AgASAHUgRAIAMgAadBA3RqKQMAIgZCIIinQXVPBEAgBqciCSAJKAIAQQFqNgIACyAAIAQgASAGQYCAARDSASEJIAFCAXwhASAJQQBODQEMAgsLIAAgBEEwIAJBAE4EfiACrQVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBIDQAgBCEFDAELIAAgBBAPCyAIQRBqJAAgBQu6CQICfwh+IwBBMGsiBCQAIAMpAwAhBiAEQoCAgIAwNwMYQQEhBQJAAkACfiACQQJIBEBCgICAgDAhDEKAgICAMAwBC0KAgICAMCADKQMIIgxCgICAgHCDQoCAgIAwUQ0AGkKAgICAMCEKQoCAgIAwIQlCgICAgDAhCEKAgICAMCELIAAgDBBgDQFBACEFQoCAgIAwIAJBA0kNABogAykDEAshDQJAAkACQAJAIAAgBkHRASAGQQAQFCIHQoCAgIBwgyIIQoCAgIAwUgRAAkACQCAIQoCAgIDgAFEEQEKAgICAMCEKQoCAgIAwIQlCgICAgDAhCAwBCyAAIAcQDwJ+AkAgAUKAgICAcFQNACABpy0ABUEQcUUNACAAIAFBAEEAEKcBDAELIAAQPgsiCEKAgICAcINCgICAgOAAUQRAQoCAgIAwIQpCgICAgDAhCQwBCyAGQiCIp0F1TwRAIAanIgIgAigCAEEBajYCAAsgBCAGNwMQIAAgBEEQakEIckEAEJkDIQIgBCkDGCEKIAQpAxAhCSACRQ0BC0KAgICAMCELDAYLQgAhBwNAIAAgCSAKIARBCGoQrgEiBkKAgICAcINCgICAgOAAUQ0CIAQoAggEQEKAgICAMCELDAYLAkAgBQRAIAYhAQwBCyAEIAY3AyAgBCAHQv////8PgzcDKCAAIAwgDUECIARBIGoQISEBIAAgBhAPIAFCgICAgHCDQoCAgIDgAFENAwsgACAIIAcgARBqQQBIDQIgB0IBfCEHDAALAAsgACAGECUiC0KAgICAcINCgICAgOAAUQ0CIAAgBEEIaiALEDxBAEgNAiAEAn4gBCkDCCIGQoCAgIAIfEL/////D1gEQCAGQv////8PgwwBC0KAgICAwH4gBrm9IgdCgICAgMCBgPz/AH0gB0L///////////8Ag0KAgICAgICA+P8AVhsLIgc3AyACfgJAIAFCgICAgHBUDQAgAactAAVBEHFFDQAgACABQQEgBEEgahCnAQwBCyAAQoCAgIAwQQEgBEEgahCuAwshCCAAIAcQDyAIQoCAgIBwg0KAgICA4ABRBEBCgICAgDAhCgwCC0IAIQcgBkIAIAZCAFUbIQkDQCAHIAlRBEBCgICAgDAhCkKAgICAMCEJDAULQoCAgIAwIQogACALIAcQcyIGQoCAgIBwg0KAgICA4ABRDQICQCAFBEAgBiEBDAELIAQgBjcDICAEIAdC/////w+DNwMoIAAgDCANQQIgBEEgahAhIQEgACAGEA8gAUKAgICAcINCgICAgOAAUQ0DCyAAIAggByABEGpBAEgNAiAHQgF8IQcMAAsAC0KAgICAMCELIAlCgICAgHCDQoCAgIAwUQ0DIAAgCUEBEK0BGgwDC0KAgICAMCEJDAILQoCAgIAwIQpCgICAgDAhCUKAgICAMCEIDAELIAAgCEEwIAenIgJBAE4EfiAHQv////8PgwVCgICAgMB+IAK4vSIBQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbCxBFQQBODQELIAAgCBAPQoCAgIDgACEICyAAIAsQDyAAIAkQDyAAIAoQDyAEQTBqJAAgCAsmAEKAgICA4AAgACADKQMAEMoBIgBBAEetQoCAgIAQhCAAQQBIGwuAAQAjAEEQayIAJAAgABCjBAJ+IAA0AgggACkDAELAhD1+fCIBQoCAgIAIfEL/////D1gEQCABQv////8PgwwBC0KAgICAwH4gAbm9IgFCgICAgMCBgPz/AH0gAUL///////////8Ag0KAgICAgICA+P8AVhsLIQEgAEEQaiQAIAELxwIBBX8jAEEgayIEJAAgACADKQMAECgiAUKAgICAcINCgICAgOAAUgRAIAAgBEEIakEAED0aIAGnIgVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB05FBEACQAJ/IAUpAgRCgICAgAiDUCIIRQRAIAYgA0EBdGovAQAMAQsgAyAGai0AAAsiAkElRw0AAkAgA0EGaiAHSg0AIANBAWohAgJ/IAhFBEAgBiACQQF0ai8BAAwBCyACIAZqLQAAC0H1AEcNACAFIANBAmpBBBC4BCICQQBIDQAgA0EFaiEDDAELQSUhAiADQQNqIAdKDQAgBSADQQFqQQIQuAQiAkElIAJBAE4iCBshAiADQQJqIAMgCBshAwsgBEEIaiACEIsBGiADQQFqIQMMAQsLIAAgARAPIARBCGoQNiEBCyAEQSBqJAAgAQvkAQEEfyMAQSBrIgIkACAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABSBEAgACACQQhqIAGnIgUoAgRB/////wdxED0aIAVBEGohBiAFKAIEQf////8HcSEHQQAhAwNAIAMgB0ZFBEACQAJAAkAgBS0AB0GAAXFFBEAgAyAGai0AACEEDAELIAYgA0EBdGovAQAiBEH/AUsNAQtBkOEBIARBxQAQ+wFFDQAgAkEIaiAEEIsBGgwBCyACQQhqIAQQmgILIANBAWohAwwBCwsgACABEA8gAkEIahA2IQELIAJBIGokACABC84EAgZ/AX4jAEEgayIGJAACQCAAIAMpAwAQKCIBQoCAgIBwg0KAgICA4ABRDQAgACAGQQhqIAGnIgkoAgRB/////wdxED0aIAlBEGohCEEAIQICQANAIAkpAgQiC6dB/////wdxIgogAkoEQCACQQFqIQUCQAJAIAtCgICAgAiDIgtQBEAgAiAIai0AACEDDAELIAggAkEBdGovAQAiA0H/AUsNAQsCQCADQTBrQQpJIANB3/8DcUHBAGtBGklyDQBBpZQBIANBCRD7AQ0AIAQNASADELIGRQ0BCyAGQQhqIAMQiwEaIAUhAgwCCwJ/An8CQCADQYD4A3EiB0GAsANHBEAgB0GAuANHDQFBv8MAIQcMBgtB5MAAIQcgBSAKTg0FAn8gC1BFBEAgCCAFQQF0ai8BAAwBCyAFIAhqLQAACyIFQYDAA2tBgHhJDQUgBkEIaiAFQf8HcSADQQp0QYD4P3FyQYCABGoiA0ESdkHwAXIQmgIgA0EMdkE/cUGAAXIhByACQQJqDAELIANB/wBNBEAgBkEIaiADEJoCIAUhAgwECyADQf8PTQRAIAUhAiADQQZ2QcABcgwCCyADQQx2QeABciEHIAULIQIgBkEIaiAHEJoCIANBBnZBP3FBgAFyCyEHIAZBCGoiBSAHEJoCIAUgA0E/cUGAAXIQmgIMAQsLIAAgARAPIAZBCGoQNiEBDAELIAAgBxC5BCAAIAEQDyAGKAIIKAIQIgBBEGogBigCDCAAKAIEEQAAQoCAgIDgACEBCyAGQSBqJAAgAQuVBAIGfwF+IwBBIGsiBSQAAkAgACADKQMAECgiAUKAgICAcINCgICAgOAAUQ0AIAAgBUEIakEAED0aIAGnIghBEGohCUEAIQIDQAJAAkACQCAIKQIEIgunQf////8HcSACSgRAAn8gC0KAgICACINQRQRAIAkgAkEBdGovAQAMAQsgAiAJai0AAAsiA0ElRgRAIAAgCCACELMGIgNBAEgNAyACQQNqIQYgA0H/AE0EQCAEBEAgBiECDAYLQSUgAyADELIGIgcbIQMgAkEBaiAGIAcbIQIMBQsCfyADQWBxQcABRgRAIANBH3EhA0GAASEHQQEMAQsgA0FwcUHgAUYEQCADQQ9xIQNBgBAhB0ECDAELIANBeHFB8AFHBEBBASEHQQAhA0EADAELIANBB3EhA0GAgAQhB0EDCyECA0AgAkEATA0DIAAgCCAGELMGIgpBAEgNBCAGQQNqIQYgCkHAAXFBgAFHBEBBACEDDAQFIAJBAWshAiAKQT9xIANBBnRyIQMMAQsACwALIAJBAWohAgwDCyAAIAEQDyAFQQhqEDYhAQwECyAGIQIgAyAHSCADQf//wwBKckUgA0GAcHFBgLADR3ENASAAQcmJARC5BAsgACABEA8gBSgCCCgCECIAQRBqIAUoAgwgACgCBBEAAEKAgICA4AAhAQwCCyAFQQhqIAMQuQEaDAALAAsgBUEgaiQAIAELNwAgACADKQMAELMBIgJFBEBCgICAgOAADwsgACACEIECIAJqQQBBCkEAELgCIQEgACACEFQgAQuHAQEBfyMAQRBrIgIkAAJAIAAgAykDABCzASIERQRAQoCAgIDgACEBDAELAn5CgICAgOAAIAAgAkEMaiADKQMIEHcNABogAigCDCIDBEBCgICAgMB+IANBJWtBXUkNARoLIAAgBBCBAiAEakEAIANBgQgQuAILIQEgACAEEFQLIAJBEGokACABCwkAIAAgARDdAgujAQIBfgF/IwBBEGsiAiQAAn4gACABEN0CIgVCgICAgHCDQoCAgIDgAFEEQCAFDAELQQohBgJAAkAgBA0AIAMpAwAiAUKAgICAcINCgICAgDBRDQAgACABEI4FIgZBAEgNAQtCgICAgOAAIAAgAkEIaiAFEG4NARogACACKwMIIAZBAEEAEI8CDAELIAAgBRAPQoCAgIDgAAshASACQRBqJAAgAQuMAgIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AAkACQCADKQMAIgFCgICAgHCDQoCAgIAwUQRAIAIpAwAhAQwBCyAAIAJBDGogARC6AQ0CIAIrAwAiBb0iAUKAgICAgICA+P8Ag0KAgICAgICA+P8AUg0BCyAAQoCAgIDAfiABQoCAgIDAgYD8/wB9IAFC////////////AINCgICAgICAgPj/AFYbEDchBAwBCyACKAIMIgNB5QBrQZt/TQRAIABBijRBABBQDAELIAAgBUEKIANBARCPAiEECyACQRBqJAAgBAvYAQIBfgF8IwBBEGsiAiQAQoCAgIDgACEEAkAgACABEN0CIgFCgICAgHCDQoCAgIDgAFEEQCABIQQMAQsgACACIAEQbg0AIAAgAkEMaiADKQMAELoBDQAgAigCDCIDQeUATwRAIABBijRB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LUiv7z8IIKpBvMOOPCdaYe4buu8/Muupw5QrhDyXums3K8XvP+6F0TGpZIo8QEVuW3bQ7z/t4zvkujeOvBS+nK392+8/nc2RTTuJdzzYkJ6BwefvP4nMYEHBBVM88XGPK8Lz7z8AAAAAAADwPwAAAAAAAPg/AAAAAAAAAAAG0M9D6/1MPgBBmxkL54UBQAO44j8oKXt9ACgpe3N1cGVyKC4uLmFyZ3VtZW50cyk7fQAoKSB7CiAgICBbbmF0aXZlIGNvZGVdCn0AY2Fubm90IG1peCA/PyB3aXRoICYmIG9yIHx8AGN0egBwcm94eTogcHJvcGVydHkgbm90IHByZXNlbnQgaW4gdGFyZ2V0IHdlcmUgcmV0dXJuZWQgYnkgbm9uIGV4dGVuc2libGUgcHJveHkAcmV2b2tlZCBwcm94eQBQcm94eQBhZGRfcHJvcGVydHkAcHJveHk6IGNhbm5vdCBzZXQgcHJvcGVydHkAbm8gc2V0dGVyIGZvciBwcm9wZXJ0eQB2YWx1ZSBoYXMgbm8gcHJvcGVydHkAY291bGQgbm90IGRlbGV0ZSBwcm9wZXJ0eQBwcm94eTogZHVwbGljYXRlIHByb3BlcnR5AEpTX0RlZmluZUF1dG9Jbml0UHJvcGVydHkAaGFzT3duUHJvcGVydHkAcHJveHk6IGluY29uc2lzdGVudCBkZWxldGVQcm9wZXJ0eQBwcm94eTogaW5jb25zaXN0ZW50IGRlZmluZVByb3BlcnR5AEpTX0RlZmluZVByb3BlcnR5ACFtci0+ZW1wdHkAaW5maW5pdHkASW5maW5pdHkAb3V0IG9mIG1lbW9yeQB1bmtub3duIHVuaWNvZGUgZ2VuZXJhbCBjYXRlZ29yeQBHZW5lcmFsX0NhdGVnb3J5AGV2ZXJ5AGFueQBhcHBseQAnJXMnIGlzIHJlYWQtb25seQBleHBlY3RpbmcgY2F0Y2ggb3IgZmluYWxseQBzdGlja3kAYmlnaW50IGFyZSBmb3JiaWRkZW4gaW4gSlNPTi5zdHJpbmdpZnkAc3ViYXJyYXkAZW1wdHkgYXJyYXkAbm9uIGludGVnZXIgaW5kZXggaW4gdHlwZWQgYXJyYXkAbmVnYXRpdmUgaW5kZXggaW4gdHlwZWQgYXJyYXkAb3V0LW9mLWJvdW5kIGluZGV4IGluIHR5cGVkIGFycmF5AGNhbm5vdCBjcmVhdGUgbnVtZXJpYyBpbmRleCBpbiB0eXBlZCBhcnJheQBpc0FycmF5AFR5cGVkQXJyYXkAZ2V0RGF5AGdldFVUQ0RheQBqc19nZXRfYXRvbV9pbmRleABpbnZhbGlkIGFycmF5IGluZGV4AG91dC1vZi1ib3VuZCBudW1lcmljIGluZGV4AEpTX0F0b21Jc0FycmF5SW5kZXgAZmluZEluZGV4AGludmFsaWQgZXhwb3J0IHN5bnRheABpbnZhbGlkIGFzc2lnbm1lbnQgc3ludGF4AG1heABcdSUwNHgAaW52YWxpZCBvcGNvZGU6IHBjPSV1IG9wY29kZT0weCUwMngALSsgICAwWDB4AC0wWCswWCAwWC0weCsweCAweABsaW5lIHRlcm1pbmF0b3Igbm90IGFsbG93ZWQgYWZ0ZXIgdGhyb3cAYmZfcG93AG5vdwBpbnRlZ2VyIG92ZXJmbG93AHN0YWNrIG92ZXJmbG93AG11c3QgYmUgY2FsbGVkIHdpdGggbmV3AGlzVmlldwBEYXRhVmlldwByYXcAdGRpdgBmZGl2AGVkaXYAY2RpdgAldQBjbGFzcyBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABmdW5jdGlvbiBkZWNsYXJhdGlvbnMgY2FuJ3QgYXBwZWFyIGluIHNpbmdsZS1zdGF0ZW1lbnQgY29udGV4dABsZXhpY2FsIGRlY2xhcmF0aW9ucyBjYW4ndCBhcHBlYXIgaW4gc2luZ2xlLXN0YXRlbWVudCBjb250ZXh0AGR1cGxpY2F0ZSBhcmd1bWVudCBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAZHVwbGljYXRlIHBhcmFtZXRlciBuYW1lcyBub3QgYWxsb3dlZCBpbiB0aGlzIGNvbnRleHQAaW1wb3J0Lm1ldGEgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGNvbnRleHQASlNfRnJlZUNvbnRleHQASlNDb250ZXh0AGpzX21hcF9pdGVyYXRvcl9uZXh0AGpzX2FzeW5jX2dlbmVyYXRvcl9yZXN1bWVfbmV4dAB1bmV4cGVjdGVkIGVuZCBvZiBpbnB1dAB0dABleHBvcnRlZCB2YXJpYWJsZSAnJXMnIGRvZXMgbm90IGV4aXN0AHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBkb2VzIG5vdCBleGlzdAB0ZXN0AGFzc2lnbm1lbnQgcmVzdCBwcm9wZXJ0eSBtdXN0IGJlIGxhc3QAYmZfc3FydABzb3J0AGNicnQAdHJpbVN0YXJ0AHBhZFN0YXJ0AHVua25vd24gdW5pY29kZSBzY3JpcHQAU2NyaXB0AGh5cG90AGZyZWVfemVyb19yZWZjb3VudABmYXN0X2FycmF5X2NvdW50AGJpbmFyeV9vYmplY3RfY291bnQAc3RyX2luZGV4ID09IG51bV9rZXlzX2NvdW50ICsgc3RyX2tleXNfY291bnQAbnVtX2luZGV4ID09IG51bV9rZXlzX2NvdW50AHN0cl9jb3VudABwcm9wX2NvdW50AHN5bV9pbmRleCA9PSBhdG9tX2NvdW50AGxhYmVsID49IDAgJiYgbGFiZWwgPCBzLT5sYWJlbF9jb3VudABsYWIxID49IDAgJiYgbGFiMSA8IHMtPmxhYmVsX2NvdW50AG9ial9jb3VudAB2YWwgPCBzLT5jYXB0dXJlX2NvdW50AHZhbDIgPCBzLT5jYXB0dXJlX2NvdW50AHNoYXBlX2NvdW50AGpzX2Z1bmNfcGMybGluZV9jb3VudABtZW1vcnlfdXNlZF9jb3VudABtYWxsb2NfY291bnQAanNfZnVuY19jb3VudABjX2Z1bmNfY291bnQAaW52YWxpZCByZXBlYXQgY291bnQAaW52YWxpZCByZXBldGl0aW9uIGNvdW50AGZvbnQAaW52YWxpZCBjb2RlIHBvaW50AGZyb21Db2RlUG9pbnQAaW52YWxpZCBoaW50AGNhbm5vdCBjb252ZXJ0IE5hTiBvciBJbmZpbml0eSB0byBiaWdpbnQAY2Fubm90IGNvbnZlcnQgdG8gYmlnaW50AGJvdGggb3BlcmFuZHMgbXVzdCBiZSBiaWdpbnQAbm90IGEgYmlnaW50AGVuY29kZVVSSUNvbXBvbmVudABkZWNvZGVVUklDb21wb25lbnQAdW5leHBlY3RlZCBlbmQgb2YgY29tbWVudABpbnZhbGlkIHN3aXRjaCBzdGF0ZW1lbnQAQmlnSW50AHBhcnNlSW50AGR1cGxpY2F0ZSBkZWZhdWx0AG1hbGxvY19saW1pdABzcGxpdABleHBlY3RpbmcgaGV4IGRpZ2l0AHRyaW1SaWdodAByZWR1Y2VSaWdodAB1bnNoaWZ0AHRyaW1MZWZ0AGludmFsaWQgb2Zmc2V0AGludmFsaWQgYnl0ZU9mZnNldABnZXRUaW1lem9uZU9mZnNldAByZXNvbHZpbmcgZnVuY3Rpb24gYWxyZWFkeSBzZXQAcHJveHk6IGluY29uc2lzdGVudCBzZXQAZmluZF9qdW1wX3RhcmdldABleHBlY3RpbmcgdGFyZ2V0AGludmFsaWQgZGVzdHJ1Y3R1cmluZyB0YXJnZXQAcHJveHk6IGluY29uc2lzdGVudCBnZXQAV2Vha1NldABjb25zdHJ1Y3QASlNfRnJlZUF0b21TdHJ1Y3QAdXNlIHN0cmljdABSZWZsZWN0AHJlamVjdABub3QgYW4gQXN5bmNHZW5lcmF0b3Igb2JqZWN0AGNhbm5vdCBjb252ZXJ0IHRvIG9iamVjdABpbnZhbGlkIGJyYW5kIG9uIG9iamVjdABvcGVyYW5kICdwcm90b3R5cGUnIHByb3BlcnR5IGlzIG5vdCBhbiBvYmplY3QAcmVjZWl2ZXIgaXMgbm90IGFuIG9iamVjdABpdGVyYXRvciBtdXN0IHJldHVybiBhbiBvYmplY3QAbm90IGEgRGF0ZSBvYmplY3QAbm90IGEgb2JqZWN0AEpTT2JqZWN0AGJpZ2Zsb2F0AHBhcnNlRmxvYXQAZmxhdABub3RoaW5nIHRvIHJlcGVhdABjb25jYXQAY29kZVBvaW50QXQAY2hhckF0AGNoYXJDb2RlQXQAa2V5cwBwcm94eTogdGFyZ2V0IHByb3BlcnR5IG11c3QgYmUgcHJlc2VudCBpbiBwcm94eSBvd25LZXlzACAgZmFzdCBhcnJheXMAZXhwb3J0ICclcycgaW4gbW9kdWxlICclcycgaXMgYW1iaWd1b3VzAHByaXZhdGUgY2xhc3MgZmllbGQgJyVzJyBhbHJlYWR5IGV4aXN0cwB0b28gbWFueSBhcmd1bWVudHMAVG9vIG1hbnkgY2FsbCBhcmd1bWVudHMAZmFzdF9hcnJheV9lbGVtZW50cwAgIGVsZW1lbnRzAGludmFsaWQgbnVtYmVyIG9mIGRpZ2l0cwBiaW5hcnkgb2JqZWN0cwBpbnZhbGlkIHByb3BlcnR5IGFjY2VzcwBqc19vcF9kZWZpbmVfY2xhc3MAZmQtPmJ5dGVfY29kZS5idWZbZGVmaW5lX2NsYXNzX3Bvc10gPT0gT1BfZGVmaW5lX2NsYXNzAF9fZ2V0Q2xhc3MAc2V0SG91cnMAZ2V0SG91cnMAc2V0VVRDSG91cnMAZ2V0VVRDSG91cnMAZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycwB0b28gbWFueSBpbWJyaWNhdGVkIHF1YW50aWZpZXJzAHVuaWNvZGVfcHJvcF9vcHMAYWNvcwBmb3IgYXdhaXQgaXMgb25seSB2YWxpZCBpbiBhc3luY2hyb25vdXMgZnVuY3Rpb25zAG5ldy50YXJnZXQgb25seSBhbGxvd2VkIHdpdGhpbiBmdW5jdGlvbnMAYnl0ZWNvZGUgZnVuY3Rpb25zAEMgZnVuY3Rpb25zAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJldmVudEV4dGVuc2lvbnMAU2NyaXB0X0V4dGVuc2lvbnMAYXRvbXMAcHJveHk6IHByb3BlcnRpZXMgbXVzdCBiZSBzdHJpbmdzIG9yIHN5bWJvbHMAZ2V0T3duUHJvcGVydHlTeW1ib2xzAHJlc29sdmVfbGFiZWxzAEpTX0V2YWxUaGlzAHN0cmluZ3MAaW52YWxpZCBkZXNjcmlwdG9yIGZsYWdzAGludmFsaWQgcmVndWxhciBleHByZXNzaW9uIGZsYWdzAHZhbHVlcwBzZXRNaW51dGVzAGdldE1pbnV0ZXMAc2V0VVRDTWludXRlcwBnZXRVVENNaW51dGVzAHRvbyBtYW55IGNhcHR1cmVzACAgc2hhcGVzAGdldE93blByb3BlcnR5TmFtZXMAZ2NfZnJlZV9jeWNsZXMAYWRkX2V2YWxfdmFyaWFibGVzAHJlc29sdmVfdmFyaWFibGVzAHRvbyBtYW55IGxvY2FsIHZhcmlhYmxlcwB0b28gbWFueSBjbG9zdXJlIHZhcmlhYmxlcwBjb21wYWN0X3Byb3BlcnRpZXMAICBwcm9wZXJ0aWVzAGRlZmluZVByb3BlcnRpZXMAZW50cmllcwBmcm9tRW50cmllcwB0b28gbWFueSByYW5nZXMAaW5jbHVkZXMAc2V0TWlsbGlzZWNvbmRzAGdldE1pbGxpc2Vjb25kcwBzZXRVVENNaWxsaXNlY29uZHMAZ2V0VVRDTWlsbGlzZWNvbmRzAHNldFNlY29uZHMAZ2V0U2Vjb25kcwBzZXRVVENTZWNvbmRzAGdldFVUQ1NlY29uZHMAaXRhbGljcwBhYnMAcHJveHk6IGluY29uc2lzdGVudCBoYXMAJS4qcwAgKCVzAHNldCAlcwBnZXQgJXMAICAgIGF0ICVzAG5vIG92ZXJsb2FkZWQgb3BlcmF0b3IgJXMAbm90IGEgJXMAdW5zdXBwb3J0ZWQga2V5d29yZDogJXMAc3Vic3RyAHByb3h5OiBpbmNvbnNpc3RlbnQgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yAHN1cGVyKCkgaXMgb25seSB2YWxpZCBpbiBhIGRlcml2ZWQgY2xhc3MgY29uc3RydWN0b3IAcGFyZW50IGNsYXNzIG11c3QgYmUgY29uc3RydWN0b3IAbm90IGEgY29uc3RydWN0b3IAQXJyYXkgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAE1hcCBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAG5vdCBhbiBBc3luYy1mcm9tLVN5bmMgSXRlcmF0b3IAY2Fubm90IGludm9rZSBhIHJ1bm5pbmcgZ2VuZXJhdG9yAG5vdCBhIGdlbmVyYXRvcgBBc3luY0dlbmVyYXRvcgBzeW50YXggZXJyb3IAU3ludGF4RXJyb3IARXZhbEVycm9yAEludGVybmFsRXJyb3IAQWdncmVnYXRlRXJyb3IAVHlwZUVycm9yAFJhbmdlRXJyb3IAUmVmZXJlbmNlRXJyb3IAVVJJRXJyb3IAZmxvb3IAZm9udGNvbG9yAGFuY2hvcgBmb3IAa2V5Rm9yAGV4cGVjdGluZyBzdXJyb2dhdGUgcGFpcgBhIGRlY2xhcmF0aW9uIGluIHRoZSBoZWFkIG9mIGEgZm9yLSVzIGxvb3AgY2FuJ3QgaGF2ZSBhbiBpbml0aWFsaXplcgAnYXJndW1lbnRzJyBpZGVudGlmaWVyIGlzIG5vdCBhbGxvd2VkIGluIGNsYXNzIGZpZWxkIGluaXRpYWxpemVyAGludmFsaWQgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgZ2V0dGVyIG9yIHNldHRlcgBpbnZhbGlkIHNldHRlcgBpbnZhbGlkIGdldHRlcgBmaWx0ZXIAbWlzc2luZyBmb3JtYWwgcGFyYW1ldGVyACJ1c2Ugc3RyaWN0IiBub3QgYWxsb3dlZCBpbiBmdW5jdGlvbiB3aXRoIGRlZmF1bHQgb3IgZGVzdHJ1Y3R1cmluZyBwYXJhbWV0ZXIAaW52YWxpZCBjaGFyYWN0ZXIAdW5leHBlY3RlZCBjaGFyYWN0ZXIAcHJpdmF0ZSBjbGFzcyBmaWVsZCBmb3JiaWRkZW4gYWZ0ZXIgc3VwZXIAaW52YWxpZCByZWRlZmluaXRpb24gb2YgbGV4aWNhbCBpZGVudGlmaWVyACdsZXQnIGlzIG5vdCBhIHZhbGlkIGxleGljYWwgaWRlbnRpZmllcgBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllcgB5aWVsZCBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAJyVzJyBpcyBhIHJlc2VydmVkIGlkZW50aWZpZXIAb3RoZXIAYXRvbTFfaXNfaW50ZWdlciAmJiBhdG9tMl9pc19pbnRlZ2VyAGNhbm5vdCBjb252ZXJ0IHRvIGJpZ2ludDogbm90IGFuIGludGVnZXIAaXNJbnRlZ2VyAGlzU2FmZUludGVnZXIAYnVmZmVyAFNoYXJlZEFycmF5QnVmZmVyAGNhbm5vdCB1c2UgaWRlbnRpY2FsIEFycmF5QnVmZmVyAGNhbm5vdCBjb252ZXJ0IGJpZ2ludCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZmxvYXQgdG8gbnVtYmVyAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBudW1iZXIAY2Fubm90IGNvbnZlcnQgYmlnZGVjaW1hbCB0byBudW1iZXIAbm90IGEgbnVtYmVyAGxpbmVOdW1iZXIAbWFsZm9ybWVkIHVuaWNvZGUgY2hhcgBjbGVhcgBzZXRZZWFyAGdldFllYXIAc2V0RnVsbFllYXIAZ2V0RnVsbFllYXIAc2V0VVRDRnVsbFllYXIAZ2V0VVRDRnVsbFllYXIAcSAhPSByAHVuZXhwZWN0ZWQgbGluZSB0ZXJtaW5hdG9yIGluIHJlZ2V4cAB1bmV4cGVjdGVkIGVuZCBvZiByZWdleHAAUmVnRXhwAHN1cABpbnZhbGlkIGdyb3VwAHBvcABjb250aW51ZSBtdXN0IGJlIGluc2lkZSBsb29wAGJmX2xvZ2ljX29wAG51bV9rZXlzX2NtcAB1c2Ugc3RyaXAAbWFwAGZsYXRNYXAAV2Vha01hcABleHBlY3RpbmcgJ3snIGFmdGVyIFxwAGxvZzFwAGRpdmlzaW9uIGJ5IHplcm8AdW5rbm93bgBpdGVyYXRvcl9jbG9zZV9yZXR1cm4AcHJvbWlzZSBzZWxmIHJlc29sdXRpb24Ab3V0IG9mIG1lbW9yeSBpbiByZWdleHAgZXhlY3V0aW9uAGRlc2NyaXB0aW9uAHByb3h5OiBkZWZpbmVQcm9wZXJ0eSBleGNlcHRpb24AanNfYXN5bmNfZ2VuZXJhdG9yX3Jlc29sdmVfZnVuY3Rpb24AanNfY3JlYXRlX2Z1bmN0aW9uAHNldC9hZGQgaXMgbm90IGEgZnVuY3Rpb24AcmV0dXJuIG5vdCBpbiBhIGZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yRnVuY3Rpb24AQXN5bmNGdW5jdGlvbgBpbnZhbGlkIG9wZXJhdGlvbgB1bnN1cHBvcnRlZCBvcGVyYXRpb24AYXdhaXQgaW4gZGVmYXVsdCBleHByZXNzaW9uAHlpZWxkIGluIGRlZmF1bHQgZXhwcmVzc2lvbgBpbnZhbGlkIGRlY2ltYWwgZXNjYXBlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBiYWNrIHJlZmVyZW5jZSBvdXQgb2YgcmFuZ2UgaW4gcmVndWxhciBleHByZXNzaW9uAGludmFsaWQgZXNjYXBlIHNlcXVlbmNlIGluIHJlZ3VsYXIgZXhwcmVzc2lvbgBleHBlY3RlZCAnb2YnIG9yICdpbicgaW4gZm9yIGNvbnRyb2wgZXhwcmVzc2lvbgB0b28gY29tcGxpY2F0ZWQgZGVzdHJ1Y3R1cmluZyBleHByZXNzaW9uAGV4cGVjdGVkICd9JyBhZnRlciB0ZW1wbGF0ZSBleHByZXNzaW9uAHRvUHJlY2lzaW9uAGFzaW4Aam9pbgBtaW4AY29weVdpdGhpbgB0ZW1wbGF0ZSBsaXRlcmFsIGNhbm5vdCBhcHBlYXIgaW4gYW4gb3B0aW9uYWwgY2hhaW4AY2lyY3VsYXIgcHJvdG90eXBlIGNoYWluAGFzc2lnbgAheS0+c2lnbgBpc0Zyb3plbgBtYXJrX2NoaWxkcmVuAChwb3MgKyBsZW4pIDw9IGJjX2J1Zl9sZW4AdW5leHBlY3RlZCBlbGxpcHNpcyB0b2tlbgB0aGVuAHNldHRlciBpcyBmb3JiaWRkZW4AbnVsbCBvciB1bmRlZmluZWQgYXJlIGZvcmJpZGRlbgBhdGFuAG5hbgBub3QgYSBib29sZWFuAEJvb2xlYW4AZ2Nfc2NhbgBiYWQgbm9ybWFsaXphdGlvbiBmb3JtAEpTX05ld1N5bWJvbEZyb21BdG9tAGZyb20AcmFuZG9tAHRyaW0AdGRpdnJlbQBmZGl2cmVtAGVkaXZyZW0AY2RpdnJlbQBiZl9kaXZyZW0Ac3FydHJlbQBpbXVsAG5vdCBhIHN5bWJvbABTeW1ib2wAUmVnRXhwIGV4ZWMgbWV0aG9kIG11c3QgcmV0dXJuIGFuIG9iamVjdCBvciBudWxsAHBhcmVudCBwcm90b3R5cGUgbXVzdCBiZSBhbiBvYmplY3Qgb3IgbnVsbABjYW5ub3Qgc2V0IHByb3BlcnR5ICclcycgb2YgbnVsbABjYW5ub3QgcmVhZCBwcm9wZXJ0eSAnJXMnIG9mIG51bGwATnVsbABmaWxsAG5ldyBBcnJheUJ1ZmZlciBpcyB0b28gc21hbGwAVHlwZWRBcnJheSBsZW5ndGggaXMgdG9vIHNtYWxsAGNhbGwAZG90QWxsAG1hdGNoQWxsAHJlcGxhY2VBbGwAY2VpbAB1cGRhdGVfbGFiZWwAYmNfYnVmW3Bvc10gPT0gT1BfbGFiZWwAZXZhbABpbnZhbGlkIGJpZ2ludCBsaXRlcmFsAGludmFsaWQgbnVtYmVyIGxpdGVyYWwAbWFsZm9ybWVkIGVzY2FwZSBzZXF1ZW5jZSBpbiBzdHJpbmcgbGl0ZXJhbABiZl9leHBfaW50ZXJuYWwAYmZfbG9nX2ludGVybmFsAEpTX1NldFByb3BlcnR5SW50ZXJuYWwASlNfR2V0T3duUHJvcGVydHlOYW1lc0ludGVybmFsAF9fSlNfRXZhbEludGVybmFsAGJpZ2RlY2ltYWwAbnR0X2ZmdF9wYXJ0aWFsAHRvRXhwb25lbnRpYWwAc2VhbABnbG9iYWwAYmxpbmsAX19kYXRlX2Nsb2NrAHN0YWNrAGxyZV9leGVjX2JhY2t0cmFjawBzLT5pc193ZWFrAGJmX3Bvd191aQBzZXRNb250aABnZXRNb250aABzZXRVVENNb250aABnZXRVVENNb250aABpbnZhbGlkIGtleXdvcmQ6IHdpdGgAc3RhcnRzV2l0aABlbmRzV2l0aABwcm9wID09IEpTX0FUT01fbGVuZ3RoAGludmFsaWQgYXJyYXkgbGVuZ3RoAGludmFsaWQgYXJyYXkgYnVmZmVyIGxlbmd0aABpbnZhbGlkIGxlbmd0aABpbnZhbGlkIGJ5dGVMZW5ndGgAdXNlIG1hdGgATWF0aABwdXNoAGFjb3NoAEpTX1Jlc2l6ZUF0b21IYXNoAGFzaW5oAGF0YW5oAGJyZWFrIG11c3QgYmUgaW5zaWRlIGxvb3Agb3Igc3dpdGNoAG1hdGNoAGNhdGNoAHNlYXJjaABmb3JFYWNoAGJmX2xvZwBBcnJheSB0b28gbG9uZwBzdHJpbmcgdG9vIGxvbmcAQXJyYXkgbG9vIGxvbmcAc3Vic3RyaW5nAGNhbm5vdCBjb252ZXJ0IHN5bWJvbCB0byBzdHJpbmcAdW5leHBlY3RlZCBlbmQgb2Ygc3RyaW5nAG5vdCBhIHN0cmluZwBpbnZhbGlkIGNoYXJhY3RlciBpbiBhIEpTT04gc3RyaW5nAHRvU3RyaW5nAHRvRGF0ZVN0cmluZwB0b0xvY2FsZURhdGVTdHJpbmcAdG9UaW1lU3RyaW5nAHRvTG9jYWxlVGltZVN0cmluZwB0b0xvY2FsZVN0cmluZwB0b0dNVFN0cmluZwBKU1N0cmluZwB0b0lTT1N0cmluZwB0b1VUQ1N0cmluZwBkdXBsaWNhdGUgaW1wb3J0IGJpbmRpbmcAaW52YWxpZCBpbXBvcnQgYmluZGluZwBiaWcAcmVnZXhwIG11c3QgaGF2ZSB0aGUgJ2cnIGZsYWcAb2YAaW5mAGRpZmYgPT0gKGludDhfdClkaWZmAGRpZmYgPT0gKGludDE2X3QpZGlmZgBocmVmAGdjX2RlY3JlZgBmcmVlX3Zhcl9yZWYAb3B0aW1pemVfc2NvcGVfbWFrZV9nbG9iYWxfcmVmAHJlc2V0X3dlYWtfcmVmAGRlbGV0ZV93ZWFrX3JlZgBvcHRpbWl6ZV9zY29wZV9tYWtlX3JlZgBpbmRleE9mAGxhc3RJbmRleE9mAHZhbHVlT2YAc2V0UHJvdG90eXBlT2YAZ2V0UHJvdG90eXBlT2YAaXNQcm90b3R5cGVPZgAlLipmAGZvbnRzaXplAGJpbmFyeV9vYmplY3Rfc2l6ZQBzdHJfc2l6ZQBuZXdfc2l6ZSA8PSBzaC0+cHJvcF9zaXplAGRlc2NyIDwgcnQtPmF0b21fc2l6ZQBhdG9tIDwgcnQtPmF0b21fc2l6ZQBjb21wdXRlX3N0YWNrX3NpemUAb2JqX3NpemUAbiA8IGJ1Zl9zaXplAHNoYXBlX3NpemUAanNfZnVuY19wYzJsaW5lX3NpemUAanNfZnVuY19jb2RlX3NpemUAbWVtb3J5X3VzZWRfc2l6ZQBqc19mdW5jX3NpemUAbm9ybWFsaXplAGZyZWV6ZQByZXNvbHZlAHRvUHJpbWl0aXZlAHB1dF9sdmFsdWUAdW5rbm93biB1bmljb2RlIHByb3BlcnR5IHZhbHVlAHJlc3QgZWxlbWVudCBjYW5ub3QgaGF2ZSBhIGRlZmF1bHQgdmFsdWUAaW52YWxpZCByZXQgdmFsdWUAX19KU19BdG9tVG9WYWx1ZQBfX3F1b3RlAGlzRmluaXRlAGRlbGV0ZQBjcmVhdGUAc2V0RGF0ZQBnZXREYXRlAHNldFVUQ0RhdGUAZ2V0VVRDRGF0ZQBJbnZhbGlkIERhdGUAcmV2ZXJzZQBwYXJzZQBwcm94eSBwcmV2ZW50RXh0ZW5zaW9ucyBoYW5kbGVyIHJldHVybmVkIGZhbHNlAFByb21pc2UAdG9Mb3dlckNhc2UAdG9Mb2NhbGVMb3dlckNhc2UAdG9VcHBlckNhc2UAdG9Mb2NhbGVVcHBlckNhc2UAaWdub3JlQ2FzZQBsb2NhbGVDb21wYXJlAHByb3h5OiBpbmNvbnNpc3RlbnQgcHJvdG90eXBlAHByb3h5OiBiYWQgcHJvdG90eXBlAG5vdCBhIHByb3RvdHlwZQBpbnZhbGlkIG9iamVjdCB0eXBlAHVuZXNjYXBlAG5vbmUAcmVzdCBlbGVtZW50IG11c3QgYmUgdGhlIGxhc3Qgb25lAG11bHRpbGluZQAgIHBjMmxpbmUAc29tZQBKU19GcmVlUnVudGltZQBKU1J1bnRpbWUAc2V0VGltZQBnZXRUaW1lAHNldF9vYmplY3RfbmFtZQBleHBlY3RpbmcgcHJvcGVydHkgbmFtZQB1bmtub3duIHVuaWNvZGUgcHJvcGVydHkgbmFtZQBpbnZhbGlkIHByb3BlcnR5IG5hbWUAZHVwbGljYXRlIF9fcHJvdG9fXyBwcm9wZXJ0eSBuYW1lAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIHBhcmFtZXRlciBuYW1lAGV4cGVjdGluZyBncm91cCBuYW1lAGR1cGxpY2F0ZSBncm91cCBuYW1lAGludmFsaWQgZ3JvdXAgbmFtZQBkdXBsaWNhdGUgbGFiZWwgbmFtZQBpbnZhbGlkIGZpcnN0IGNoYXJhY3RlciBvZiBwcml2YXRlIG5hbWUAaW52YWxpZCBsZXhpY2FsIHZhcmlhYmxlIG5hbWUAaW52YWxpZCBtZXRob2QgbmFtZQBleHBlY3RpbmcgZmllbGQgbmFtZQBpbnZhbGlkIGZpZWxkIG5hbWUAY2xhc3Mgc3RhdGVtZW50IHJlcXVpcmVzIGEgbmFtZQBmaWxlTmFtZQBjb21waWxlAG9iamVjdCBpcyBub3QgZXh0ZW5zaWJsZQBwcm94eTogaW5jb25zaXN0ZW50IGlzRXh0ZW5zaWJsZQBjYW5ub3QgaGF2ZSBzZXR0ZXIvZ2V0dGVyIGFuZCB2YWx1ZSBvciB3cml0YWJsZQBwcm9wZXJ0eSBpcyBub3QgY29uZmlndXJhYmxlAHZhbHVlIGlzIG5vdCBpdGVyYWJsZQBwcm9wZXJ0eUlzRW51bWVyYWJsZQBtaXNzaW5nIGluaXRpYWxpemVyIGZvciBjb25zdCB2YXJpYWJsZQBsZXhpY2FsIHZhcmlhYmxlAGludmFsaWQgcmVkZWZpbml0aW9uIG9mIGEgdmFyaWFibGUAcmV2b2NhYmxlAHN0cmlrZQBtcF9kaXZub3JtX2xhcmdlAGludmFsaWQgY2xhc3MgcmFuZ2UAbWVzc2FnZQBhc3luY19mdW5jX2ZyZWUAaW52YWxpZCBsdmFsdWUgaW4gc3RyaWN0IG1vZGUAaW52YWxpZCB2YXJpYWJsZSBuYW1lIGluIHN0cmljdCBtb2RlAGNhbm5vdCBkZWxldGUgYSBkaXJlY3QgcmVmZXJlbmNlIGluIHN0cmljdCBtb2RlAG9jdGFsIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCBhbGxvd2VkIGluIHN0cmljdCBtb2RlAG9jdGFsIGxpdGVyYWxzIGFyZSBkZXByZWNhdGVkIGluIHN0cmljdCBtb2RlAHVuaWNvZGUAICBieXRlY29kZQBKU0Z1bmN0aW9uQnl0ZWNvZGUAc2tpcF9kZWFkX2NvZGUAaW52YWxpZCBhcmd1bWVudCBuYW1lIGluIHN0cmljdCBjb2RlAGludmFsaWQgZnVuY3Rpb24gbmFtZSBpbiBzdHJpY3QgY29kZQBpbnZhbGlkIHJlZGVmaW5pdGlvbiBvZiBnbG9iYWwgaWRlbnRpZmllciBpbiBtb2R1bGUgY29kZQBpbXBvcnQubWV0YSBvbmx5IHZhbGlkIGluIG1vZHVsZSBjb2RlAGZyb21DaGFyQ29kZQBpbnZhbGlkIGZvciBpbi9vZiBsZWZ0IGhhbmQtc2lkZQBpbnZhbGlkIGFzc2lnbm1lbnQgbGVmdC1oYW5kIHNpZGUAcmVkdWNlAHNvdXJjZQAndGhpcycgY2FuIGJlIGluaXRpYWxpemVkIG9ubHkgb25jZQBwcm9wZXJ0eSBjb25zdHJ1Y3RvciBhcHBlYXJzIG1vcmUgdGhhbiBvbmNlAGludmFsaWQgVVRGLTggc2VxdWVuY2UAY2lyY3VsYXIgcmVmZXJlbmNlAHNsaWNlAHNwbGljZQByYWNlAHJlcGxhY2UAJSsuKmUAdW5leHBlY3RlZCAnYXdhaXQnIGtleXdvcmQAdW5leHBlY3RlZCAneWllbGQnIGtleXdvcmQAbWFwX2RlY3JlZl9yZWNvcmQAaXRlcmF0b3IgZG9lcyBub3QgaGF2ZSBhIHRocm93IG1ldGhvZABvYmplY3QgbmVlZHMgdG9JU09TdHJpbmcgbWV0aG9kACdzdXBlcicgaXMgb25seSB2YWxpZCBpbiBhIG1ldGhvZABmcm91bmQAX19iZl9yb3VuZABicmVhay9jb250aW51ZSBsYWJlbCBub3QgZm91bmQAb3V0IG9mIGJvdW5kAGZpbmQAYmluZABpbnZhbGlkIGluZGV4IGZvciBhcHBlbmQAZXh0cmFuZW91cyBjaGFyYWN0ZXJzIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBkYXRhIGF0IHRoZSBlbmQAdW5leHBlY3RlZCBlbmQAaW52YWxpZCBpbmNyZW1lbnQvZGVjcmVtZW50IG9wZXJhbmQAaW52YWxpZCAnaW5zdGFuY2VvZicgcmlnaHQgb3BlcmFuZABpbnZhbGlkICdpbicgb3BlcmFuZAB0cmltRW5kAHBhZEVuZABib2xkACVsbGQAZ2NfZGVjcmVmX2NoaWxkAHJlc29sdmVfc2NvcGVfcHJpdmF0ZV9maWVsZABjYW5ub3QgZGVsZXRlIGEgcHJpdmF0ZSBjbGFzcyBmaWVsZABleHBlY3RpbmcgPGJyYW5kPiBwcml2YXRlIGZpZWxkACVzIGlzIG5vdCBpbml0aWFsaXplZABmaXhlZAB0b0ZpeGVkAHNldF9vYmplY3RfbmFtZV9jb21wdXRlZAByZWdleCBub3Qgc3VwcG9ydGVkAGV2YWwgaXMgbm90IHN1cHBvcnRlZABSZWdFeHAgYXJlIG5vdCBzdXBwb3J0ZWQAaW50ZXJydXB0ZWQAJXMgb2JqZWN0IGV4cGVjdGVkAGlkZW50aWZpZXIgZXhwZWN0ZWQAYnl0ZWNvZGUgZnVuY3Rpb24gZXhwZWN0ZWQAc3RyaW5nIGV4cGVjdGVkAGZyb20gY2xhdXNlIGV4cGVjdGVkAGZ1bmN0aW9uIG5hbWUgZXhwZWN0ZWQAdmFyaWFibGUgbmFtZSBleHBlY3RlZABtZXRhIGV4cGVjdGVkAHJlamVjdGVkAG1lbW9yeSBhbGxvY2F0ZWQAbWVtb3J5IHVzZWQAZGVyaXZlZCBjbGFzcyBjb25zdHJ1Y3RvciBtdXN0IHJldHVybiBhbiBvYmplY3Qgb3IgdW5kZWZpbmVkAGNhbm5vdCBzZXQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAY2Fubm90IHJlYWQgcHJvcGVydHkgJyVzJyBvZiB1bmRlZmluZWQAZmxhZ3MgbXVzdCBiZSB1bmRlZmluZWQAVW5kZWZpbmVkAHByaXZhdGUgY2xhc3MgZmllbGQgaXMgYWxyZWFkeSBkZWZpbmVkACclcycgaXMgbm90IGRlZmluZWQAZ3JvdXAgbmFtZSBub3QgZGVmaW5lZABvcGVyYXRvciAlczogbm8gZnVuY3Rpb24gZGVmaW5lZABhbGxTZXR0bGVkAGZ1bGZpbGxlZABjYW5ub3QgYmUgY2FsbGVkAGlzU2VhbGVkACFzaC0+aXNfaGFzaGVkAHZhcl9yZWYtPmlzX2RldGFjaGVkAEFycmF5QnVmZmVyIGlzIGRldGFjaGVkAGFkZAAlKzA3ZAAlMDRkACUwMmQlMDJkACUwMmQvJTAyZC8lMCpkACUuM3MgJS4zcyAlMDJkICUwKmQAOiVkAGludmFsaWQgdGhyb3cgdmFyIHR5cGUgJWQAc2MAanNfZGVmX21hbGxvYwB0cnVuYwBnYwBleGVjAGJmX2ludGVnZXJfdG9fcmFkaXhfcmVjAHF1aWNranMvcXVpY2tqcy5jAHF1aWNranMvbGlicmVnZXhwLmMAcXVpY2tqcy9saWJiZi5jAHF1aWNranMvbGlidW5pY29kZS5jAHN1YgBwcm9taXNlX3JlYWN0aW9uX2pvYgBqc19wcm9taXNlX3Jlc29sdmVfdGhlbmFibGVfam9iAHIgIT0gYSAmJiByICE9IGIAcSAhPSBhICYmIHEgIT0gYgByd2EAciAhPSBhAF9fbG9va3VwU2V0dGVyX18AX19kZWZpbmVTZXR0ZXJfXwBfX2xvb2t1cEdldHRlcl9fAF9fZGVmaW5lR2V0dGVyX18AX19wcm90b19fAFtTeW1ib2wuc3BsaXRdAFtTeW1ib2wuc3BlY2llc10AW1N5bWJvbC5pdGVyYXRvcl0AW1N5bWJvbC5hc3luY0l0ZXJhdG9yXQBbU3ltYm9sLm1hdGNoQWxsXQBbU3ltYm9sLm1hdGNoXQBbU3ltYm9sLnNlYXJjaF0AW1N5bWJvbC50b1N0cmluZ1RhZ10AW1N5bWJvbC50b1ByaW1pdGl2ZV0AW3Vuc3VwcG9ydGVkIHR5cGVdAFtmdW5jdGlvbiBieXRlY29kZV0AW1N5bWJvbC5oYXNJbnN0YW5jZV0AW1N5bWJvbC5yZXBsYWNlXQBbACUwMmQ6JTAyZDolMDJkLiUwM2RaAFBPU0lUSVZFX0lORklOSVRZAE5FR0FUSVZFX0lORklOSVRZAHAtPmNsYXNzX2lkID09IEpTX0NMQVNTX0FSUkFZAHN0YWNrX2xlbiA8IFBPUF9TVEFDS19MRU5fTUFYAC0lMDJkLSUwMmRUAEpTX0F0b21HZXRTdHJSVABvcGNvZGUgPCBSRU9QX0NPVU5UAEJZVEVTX1BFUl9FTEVNRU5UACUwMmQ6JTAyZDolMDJkIEdNVABKU19WQUxVRV9HRVRfVEFHKHNmLT5jdXJfZnVuYykgPT0gSlNfVEFHX09CSkVDVAB2YXJfa2luZCA9PSBKU19WQVJfUFJJVkFURV9TRVRURVIATUFYX1NBRkVfSU5URUdFUgBNSU5fU0FGRV9JTlRFR0VSAGFzVWludE4AYXNJbnROAGlzTmFOAERhdGUgdmFsdWUgaXMgTmFOAHRvSlNPTgBFUFNJTE9OAE5BTgAlMDJkOiUwMmQ6JTAyZCAlY00Acy0+bGFiZWxfc2xvdHNbbGFiZWxdLmZpcnN0X3JlbG9jID09IE5VTEwAbGFiZWxfc2xvdHNbaV0uZmlyc3RfcmVsb2MgPT0gTlVMTABwcnMgIT0gTlVMTABzZi0+Y3VyX3NwICE9IE5VTEwAc2YgIT0gTlVMTABtcjEgIT0gTlVMTAB2YXJfa2luZCAhPSBKU19WQVJfTk9STUFMAGItPmZ1bmNfa2luZCA9PSBKU19GVU5DX05PUk1BTABlbmNvZGVVUkkAZGVjb2RlVVJJAFBJAHNwZWNpYWwgPT0gUFVUX0xWQUxVRV9OT0tFRVAgfHwgc3BlY2lhbCA9PSBQVVRfTFZBTFVFX05PS0VFUF9ERVBUSABzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfRVhFQ1VUSU5HAHByZWMxICE9IEJGX1BSRUNfSU5GADAxMjM0NTY3ODlBQkNERUYAU0laRQBNQVhfVkFMVUUATUlOX1ZBTFVFAE5BTUUAZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9HTE9CQUwgfHwgZXZhbF90eXBlID09IEpTX0VWQUxfVFlQRV9NT0RVTEUAcC0+Z2Nfb2JqX3R5cGUgPT0gSlNfR0NfT0JKX1RZUEVfSlNfT0JKRUNUIHx8IHAtPmdjX29ial90eXBlID09IEpTX0dDX09CSl9UWVBFX0ZVTkNUSU9OX0JZVEVDT0RFAExPRzJFAExPRzEwRQBzLT5zdGF0ZSA9PSBKU19BU1lOQ19HRU5FUkFUT1JfU1RBVEVfQVdBSVRJTkdfUkVUVVJOIHx8IHMtPnN0YXRlID09IEpTX0FTWU5DX0dFTkVSQVRPUl9TVEFURV9DT01QTEVURUQAVVRDADxpbnB1dD4APHNldD4APGFub255bW91cz4APGR1bXA+ADxudWxsPgBiaWdpbnQgb3BlcmFuZHMgYXJlIGZvcmJpZGRlbiBmb3IgPj4+ACZxdW90OwBzZXRVaW50OABnZXRVaW50OABzZXRJbnQ4AGdldEludDgAbWFsZm9ybWVkIFVURi04AHJhZGl4IG11c3QgYmUgYmV0d2VlbiAyIGFuZCAzNgBzZXRVaW50MTYAZ2V0VWludDE2AHNldEludDE2AGdldEludDE2AGFyZ2MgPT0gNQBzZXRCaWdVaW50NjQAZ2V0QmlnVWludDY0AHNldEJpZ0ludDY0AGdldEJpZ0ludDY0AHNldEZsb2F0NjQAZ2V0RmxvYXQ2NABhcmdjID09IDMAYXRhbjIAbG9nMgBmbG9vckxvZzIAU1FSVDFfMgBTUVJUMgBMTjIAY2x6MzIAc2V0VWludDMyAGdldFVpbnQzMgBzZXRJbnQzMgBnZXRJbnQzMgBzZXRGbG9hdDMyAGdldEZsb2F0MzIAc3RhY2tfbGVuID49IDIASlNfQXRvbUlzTnVtZXJpY0luZGV4MQBqc19mY3Z0MQBKU19Db21wYWN0QmlnSW50MQBleHBtMQByICE9IGExICYmIHIgIT0gYjEAbHMtPmFkZHIgPT0gLTEAbnEgPj0gMQBzdGFja19sZW4gPj0gMQBwLT5oZWFkZXIucmVmX2NvdW50ID09IDEAcC0+c2hhcGUtPmhlYWRlci5yZWZfY291bnQgPT0gMQBzdGFja19sZW4gPT0gMQBqc19mcmVlX3NoYXBlMABsb2cxMABMTjEwAHAtPnJlZl9jb3VudCA+IDAAdmFyX3JlZi0+aGVhZGVyLnJlZl9jb3VudCA+IDAAc3RhY2tfc2l6ZSA+IDAAY3Bvb2xfaWR4ID49IDAAcnQtPmF0b21fY291bnQgPj0gMABscy0+cmVmX2NvdW50ID49IDAAcy0+aXNfZXZhbCB8fCBzLT5jbG9zdXJlX3Zhcl9jb3VudCA9PSAwAHAtPnJlZl9jb3VudCA9PSAwAGN0eC0+aGVhZGVyLnJlZl9jb3VudCA9PSAwAHNoLT5oZWFkZXIucmVmX2NvdW50ID09IDAAcC0+bWFyayA9PSAwAChuMiAlIHN0cmlwX2xlbikgPT0gMAAocHItPnUuaW5pdC5yZWFsbV9hbmRfaWQgJiAzKSA9PSAwAChuZXdfaGFzaF9zaXplICYgKG5ld19oYXNoX3NpemUgLSAxKSkgPT0gMABpICE9IDAAc2l6ZSAhPSAwAF4kXC4qKz8oKVtde318LwA8LwAwLgBtaXNzaW5nIGJpbmRpbmcgcGF0dGVybi4uLgBiaWdpbnQgYXJndW1lbnQgd2l0aCB1bmFyeSArAGFzeW5jIGZ1bmN0aW9uICoACn0pAGxpc3RfZW1wdHkoJnJ0LT5nY19vYmpfbGlzdCkAaiA9PSAoc2gtPnByb3BfY291bnQgLSBzaC0+ZGVsZXRlZF9wcm9wX2NvdW50KQBKU19Jc1VuZGVmaW5lZChmdW5jX3JldCkAIV9fSlNfQXRvbUlzVGFnZ2VkSW50KGRlc2NyKQAhYXRvbV9pc19mcmVlKHApAChudWxsKQAgKG5hdGl2ZSkAanNfY2xhc3NfaGFzX2J5dGVjb2RlKHAtPmNsYXNzX2lkKQB1bmNvbnNpc3RlbnQgc3RhY2sgc2l6ZTogJWQgJWQgKHBjPSVkKQBieXRlY29kZSBidWZmZXIgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgb3ZlcmZsb3cgKG9wPSVkLCBwYz0lZCkAc3RhY2sgdW5kZXJmbG93IChvcD0lZCwgcGM9JWQpAGludmFsaWQgb3Bjb2RlIChvcD0lZCwgcGM9JWQpACg/OikAbm8gZnVuY3Rpb24gZmlsZW5hbWUgZm9yIGltcG9ydCgpAC1fLiF+KicoKQAgYW5vbnltb3VzKABTeW1ib2woAGV4cGVjdGluZyAnfScAY2xhc3MgY29uc3RydWN0b3JzIG11c3QgYmUgaW52b2tlZCB3aXRoICduZXcnAGV4cGVjdGluZyAnYXMnAHVuZXhwZWN0ZWQgdG9rZW4gaW4gZXhwcmVzc2lvbjogJyUuKnMnAHVuZXhwZWN0ZWQgdG9rZW46ICclLipzJwByZWRlY2xhcmF0aW9uIG9mICclcycAZHVwbGljYXRlIGV4cG9ydGVkIG5hbWUgJyVzJwBjaXJjdWxhciByZWZlcmVuY2Ugd2hlbiBsb29raW5nIGZvciBleHBvcnQgJyVzJyBpbiBtb2R1bGUgJyVzJwBDb3VsZCBub3QgZmluZCBleHBvcnQg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AJYAAADBAAAAlwAAAJgAAADCAAAAlwAAAJgAAADDAAAAawAAAGwAAADEAAAAmQAAAJoAAADFAAAAmQAAAJoAAAAvAAAAmwAAAJwAAADGAAAAawAAAGwAAADHAAAAnQAAAJ4AAAAAAAAA7h8AAB8gAAAqIAAA4h8AABUgAAA5IAAA+B8AAAYgAABjb3B5V2l0aGluAGVudHJpZXMAZmlsbABmaW5kAGZpbmRJbmRleABmbGF0AGZsYXRNYXAAaW5jbHVkZXMAa2V5cwB2YWx1ZXMAAAAAAAEBAgIDAwIDAEGQpwEL3xBudWxsAGZhbHNlAHRydWUAaWYAZWxzZQByZXR1cm4AdmFyAHRoaXMAZGVsZXRlAHZvaWQAdHlwZW9mAG5ldwBpbgBpbnN0YW5jZW9mAGRvAHdoaWxlAGZvcgBicmVhawBjb250aW51ZQBzd2l0Y2gAY2FzZQBkZWZhdWx0AHRocm93AHRyeQBjYXRjaABmaW5hbGx5AGZ1bmN0aW9uAGRlYnVnZ2VyAHdpdGgAY2xhc3MAY29uc3QAZW51bQBleHBvcnQAZXh0ZW5kcwBpbXBvcnQAc3VwZXIAaW1wbGVtZW50cwBpbnRlcmZhY2UAbGV0AHBhY2thZ2UAcHJpdmF0ZQBwcm90ZWN0ZWQAcHVibGljAHN0YXRpYwB5aWVsZABhd2FpdAAAbGVuZ3RoAGZpbGVOYW1lAGxpbmVOdW1iZXIAbWVzc2FnZQBlcnJvcnMAc3RhY2sAbmFtZQB0b1N0cmluZwB0b0xvY2FsZVN0cmluZwB2YWx1ZU9mAGV2YWwAcHJvdG90eXBlAGNvbnN0cnVjdG9yAGNvbmZpZ3VyYWJsZQB3cml0YWJsZQBlbnVtZXJhYmxlAHZhbHVlAGdldABzZXQAb2YAX19wcm90b19fAHVuZGVmaW5lZABudW1iZXIAYm9vbGVhbgBzdHJpbmcAb2JqZWN0AHN5bWJvbABpbnRlZ2VyAHVua25vd24AYXJndW1lbnRzAGNhbGxlZQBjYWxsZXIAPGV2YWw+ADxyZXQ+ADx2YXI+ADxhcmdfdmFyPgA8d2l0aD4AbGFzdEluZGV4AHRhcmdldABpbmRleABpbnB1dABkZWZpbmVQcm9wZXJ0aWVzAGFwcGx5AGpvaW4AY29uY2F0AHNwbGl0AGNvbnN0cnVjdABnZXRQcm90b3R5cGVPZgBzZXRQcm90b3R5cGVPZgBpc0V4dGVuc2libGUAcHJldmVudEV4dGVuc2lvbnMAaGFzAGRlbGV0ZVByb3BlcnR5AGRlZmluZVByb3BlcnR5AGdldE93blByb3BlcnR5RGVzY3JpcHRvcgBvd25LZXlzAGFkZABkb25lAG5leHQAdmFsdWVzAHNvdXJjZQBmbGFncwBnbG9iYWwAdW5pY29kZQByYXcAbmV3LnRhcmdldAB0aGlzLmFjdGl2ZV9mdW5jADxob21lX29iamVjdD4APGNvbXB1dGVkX2ZpZWxkPgA8c3RhdGljX2NvbXB1dGVkX2ZpZWxkPgA8Y2xhc3NfZmllbGRzX2luaXQ+ADxicmFuZD4AI2NvbnN0cnVjdG9yAGFzAGZyb20AbWV0YQAqZGVmYXVsdCoAKgBNb2R1bGUAdGhlbgByZXNvbHZlAHJlamVjdABwcm9taXNlAHByb3h5AHJldm9rZQBhc3luYwBleGVjAGdyb3VwcwBzdGF0dXMAcmVhc29uAGdsb2JhbFRoaXMAYmlnaW50AGJpZ2Zsb2F0AGJpZ2RlY2ltYWwAcm91bmRpbmdNb2RlAG1heGltdW1TaWduaWZpY2FudERpZ2l0cwBtYXhpbXVtRnJhY3Rpb25EaWdpdHMAdG9KU09OAE9iamVjdABBcnJheQBFcnJvcgBOdW1iZXIAU3RyaW5nAEJvb2xlYW4AU3ltYm9sAEFyZ3VtZW50cwBNYXRoAEpTT04ARGF0ZQBGdW5jdGlvbgBHZW5lcmF0b3JGdW5jdGlvbgBGb3JJbkl0ZXJhdG9yAFJlZ0V4cABBcnJheUJ1ZmZlcgBTaGFyZWRBcnJheUJ1ZmZlcgBVaW50OENsYW1wZWRBcnJheQBJbnQ4QXJyYXkAVWludDhBcnJheQBJbnQxNkFycmF5AFVpbnQxNkFycmF5AEludDMyQXJyYXkAVWludDMyQXJyYXkAQmlnSW50NjRBcnJheQBCaWdVaW50NjRBcnJheQBGbG9hdDMyQXJyYXkARmxvYXQ2NEFycmF5AERhdGFWaWV3AEJpZ0ludABCaWdGbG9hdABCaWdGbG9hdEVudgBCaWdEZWNpbWFsAE9wZXJhdG9yU2V0AE9wZXJhdG9ycwBNYXAAU2V0AFdlYWtNYXAAV2Vha1NldABNYXAgSXRlcmF0b3IAU2V0IEl0ZXJhdG9yAEFycmF5IEl0ZXJhdG9yAFN0cmluZyBJdGVyYXRvcgBSZWdFeHAgU3RyaW5nIEl0ZXJhdG9yAEdlbmVyYXRvcgBQcm94eQBQcm9taXNlAFByb21pc2VSZXNvbHZlRnVuY3Rpb24AUHJvbWlzZVJlamVjdEZ1bmN0aW9uAEFzeW5jRnVuY3Rpb24AQXN5bmNGdW5jdGlvblJlc29sdmUAQXN5bmNGdW5jdGlvblJlamVjdABBc3luY0dlbmVyYXRvckZ1bmN0aW9uAEFzeW5jR2VuZXJhdG9yAEV2YWxFcnJvcgBSYW5nZUVycm9yAFJlZmVyZW5jZUVycm9yAFN5bnRheEVycm9yAFR5cGVFcnJvcgBVUklFcnJvcgBJbnRlcm5hbEVycm9yADxicmFuZD4AU3ltYm9sLnRvUHJpbWl0aXZlAFN5bWJvbC5pdGVyYXRvcgBTeW1ib2wubWF0Y2gAU3ltYm9sLm1hdGNoQWxsAFN5bWJvbC5yZXBsYWNlAFN5bWJvbC5zZWFyY2gAU3ltYm9sLnNwbGl0AFN5bWJvbC50b1N0cmluZ1RhZwBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlAFN5bWJvbC5oYXNJbnN0YW5jZQBTeW1ib2wuc3BlY2llcwBTeW1ib2wudW5zY29wYWJsZXMAU3ltYm9sLmFzeW5jSXRlcmF0b3IAU3ltYm9sLm9wZXJhdG9yU2V0AEGAuAELtQgBAAAABQABFAUAARUFAAEVBQABFwUAARcBAAEAAQABAAEAAQABAAEAAQABAAEAAQACAAEFAwABCgEBAAABAgEAAQMCAAEBAgABAgMAAQIEAAEDBgABAgMAAQMEAAEEBQABAwMAAQQEAAEFBQABAgIAAQQEAAEDAwABAwMAAQQEAAEFBQADAgENAwEBDQMBAA0DAgENAwIADQMAAQ0DAwEKAQEAAAEAAAABAQIAAQAAAAECAgABAgAAAQEAAAEBAAAGAAAYBQEBDwMCAQoBAgEAAQEBAAEBAQAFAAEXBQABFwUAARcFAQAXBQEAFwUCABcBAgMAAQMAAAYAABgGAAAYBgEAGAUBARcFAQIXBQIAFwECAQABAwAAAQMBAAECAQABAgIAAQMAAAEDAQABBAAABQIBFwUBARcBAgIAAQIB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AAABADAAOgBB0IECCxEEADAAOgBBAFsAXwBgAGEAewBB8IECC8QLAQMFAQEBAQUFBQECAgMFBQEBAQICAwMFBQEFAREAAAAwmiAAAJowAHOBWgAwF2AAMAdsALOBbwAAF3AAAAd8AACBfwBAMIAAwwGYAJCBmABABpkAQJCcALSBpABALqUAMAG8AECGvABwgb8AAAHAADCBwABABMEAMAHDAECCwwAwgsQAQILFADABxwAwgccAMAHIAECCyAAwgckAMAHKAACBygAwAcsAMIHLAEACzAAAAc0AMAHOADCBzgAAAc8AMIHPAEAG0AAwAdMAQILTADCB1ABAAtYAMAHXAECC1wAwgtgAQITZADCB2wBAAtwAQALeAACB3wBQA+IAUIPjAFAD5QBAkOYAAIHuAEAS7wC0AfgAUIP4AEAC+gAwAfsAMIH7AEAo/AAwARABQBIRATEBHQFAgh0BMIEeATEBHwEBgh8BQIIgATCBIQEwASIBMIEiAUAKIwEBASgBAYEoAQEBKQEAgSkBAAEqAQACKwEAgSwBAIEtAQEBLgEAATABAYEwAQCBMQEBgTIBAQEzAQABNAEAgTQBAQE1AQGBNQEBATYBAIE3AQGBOAEAATkBAIE6AQGBPgEAAUABAQFBAQCBQQEBgUMBAAFEAQCBRAEAAkUBAAFGAQABSQEBgU4BAQFPAXOBogFABLgBQAK7AQCDvQEwgb8BMAHDATADxAEwAcYBMALHAdAByAEwkcgBMInRAQAB1gEAg9YB0wHYAQCR2AFzAeEBAInhAQAB5gEAguYBMIHnAXMB6AFzgegBc4HqAXMB6wEAgesBQBjsAXMB+AFzgfgBAAH5AQCB+QGgAfoBc4H6AUCC+wEwgfwBQAL9ATCD/gEwEAACMCAIAgAgGAIAECgCQCIwAkA2RQIwAWACQI5gAgCBZwJAYGgCMKaYAgCmsAK1gcMCMSZQCDGBYwgxgWYIACtoCACDfggRUNAJEAb4CSAG/Al0AUAOdIFADnQBQQ50gUEOdAFCDnSBQg50AUMOgIFDDoABRA4wK0gOMINeDgGBvA4Bgb4OAQHHDkB+AA9AGD8PtQFLD7aBSw+2AUwPtoFMD7cBTQ+AgU0PMAFPD0BgUA8ACIAPMAiEDwAGiA8wBowPAAiQDzAIlA8ACJgPMAicDwAGoA8wBqQPsAGoDwCBqA/T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iaCCsQARDAiAqCSBQOs4CYlgTyOAQuCPj48Rl4JAv4mkgEK8gEDhgECUhEEkiUVWEAyDpxOAQKSBQjwfiUFwgUCYikCugrSOnomOg6yKtIkqo42AiSGrgIuCr407gIvRiyhAn4uEiSu2CDEJgoiAiQkyhEC/kYiJGNCTi4lA1DGImoHRkI6J0IyHidKOg4lA8Y5ApInFKAkYAIGLifYxMoCbiacwH4CIiq2PQZQ4h4+Jt5WAjfkqAAgwB4mvIAgniUFIg2BLaIlAhYS6hpiJQ/QAtjPQgIqBYEyqgVTFIi85hp2DQJOCRYixQf+2g7E4jYCVII5FTzCQDgEEQQSGiIlBoY1F1YbsNIlSlYlsBQVA7wBBoKcCC6MS+gYAhAkA8AoAcAwA9A0AShAgGhggdBsg3SAADKgAWqogGv8ArQ4BOBIhwRUh5Rkhqh0hjNFBSuEh8AEOAAAAAEFkbGFtLEFkbG0AQWhvbSxBaG9tAEFuYXRvbGlhbl9IaWVyb2dseXBocyxIbHV3AEFyYWJpYyxBcmFiAEFybWVuaWFuLEFybW4AQXZlc3RhbixBdnN0AEJhbGluZXNlLEJhbGkAQmFtdW0sQmFtdQBCYXNzYV9WYWgsQmFzcwBCYXRhayxCYXRrAEJlbmdhbGksQmVuZwBCaGFpa3N1a2ksQmhrcwBCb3BvbW9mbyxCb3BvAEJyYWhtaSxCcmFoAEJyYWlsbGUsQnJhaQBCdWdpbmVzZSxCdWdpAEJ1aGlkLEJ1aGQAQ2FuYWRpYW5fQWJvcmlnaW5hbCxDYW5zAENhcmlhbixDYXJpAENhdWNhc2lhbl9BbGJhbmlhbixBZ2hiAENoYWttYSxDYWttAENoYW0sQ2hhbQBDaGVyb2tlZSxDaGVyAENob3Jhc21pYW4sQ2hycwBDb21tb24sWnl5eQBDb3B0aWMsQ29wdCxRYWFjAEN1bmVpZm9ybSxYc3V4AEN5cHJpb3QsQ3BydABDeXJpbGxpYyxDeXJsAERlc2VyZXQsRHNydABEZXZhbmFnYXJpLERldmEARGl2ZXNfQWt1cnUsRGlhawBEb2dyYSxEb2dyAER1cGxveWFuLER1cGwARWd5cHRpYW5fSGllcm9nbHlwaHMsRWd5cABFbGJhc2FuLEVsYmEARWx5bWFpYyxFbHltAEV0aGlvcGljLEV0aGkAR2VvcmdpYW4sR2VvcgBHbGFnb2xpdGljLEdsYWcAR290aGljLEdvdGgAR3JhbnRoYSxHcmFuAEdyZWVrLEdyZWsAR3VqYXJhdGksR3VqcgBHdW5qYWxhX0dvbmRpLEdvbmcAR3VybXVraGksR3VydQBIYW4sSGFuaQBIYW5ndWwsSGFuZwBIYW5pZmlfUm9oaW5neWEsUm9oZwBIYW51bm9vLEhhbm8ASGF0cmFuLEhhdHIASGVicmV3LEhlYnIASGlyYWdhbmEsSGlyYQBJbXBlcmlhbF9BcmFtYWljLEFybWkASW5oZXJpdGVkLFppbmgsUWFhaQBJbnNjcmlwdGlvbmFsX1BhaGxhdmksUGhsaQBJbnNjcmlwdGlvbmFsX1BhcnRoaWFuLFBydGkASmF2YW5lc2UsSmF2YQBLYWl0aGksS3RoaQBLYW5uYWRhLEtuZGEAS2F0YWthbmEsS2FuYQBLYXlhaF9MaSxLYWxpAEtoYXJvc2h0aGksS2hhcgBLaG1lcixLaG1yAEtob2praSxLaG9qAEtoaXRhbl9TbWFsbF9TY3JpcHQsS2l0cwBLaHVkYXdhZGksU2luZABMYW8sTGFvbwBMYXRpbixMYXRuAExlcGNoYSxMZXBjAExpbWJ1LExpbWIATGluZWFyX0EsTGluYQBMaW5lYXJfQixMaW5iAExpc3UsTGlzdQBMeWNpYW4sTHljaQBMeWRpYW4sTHlkaQBNYWthc2FyLE1ha2EATWFoYWphbmksTWFoagBNYWxheWFsYW0sTWx5bQBNYW5kYWljLE1hbmQATWFuaWNoYWVhbixNYW5pAE1hcmNoZW4sTWFyYwBNYXNhcmFtX0dvbmRpLEdvbm0ATWVkZWZhaWRyaW4sTWVkZgBNZWV0ZWlfTWF5ZWssTXRlaQBNZW5kZV9LaWtha3VpLE1lbmQATWVyb2l0aWNfQ3Vyc2l2ZSxNZXJjAE1lcm9pdGljX0hpZXJvZ2x5cGhzLE1lcm8ATWlhbyxQbHJkAE1vZGksTW9kaQBNb25nb2xpYW4sTW9uZwBNcm8sTXJvbwBNdWx0YW5pLE11bHQATXlhbm1hcixNeW1yAE5hYmF0YWVhbixOYmF0AE5hbmRpbmFnYXJpLE5hbmQATmV3X1RhaV9MdWUsVGFsdQBOZXdhLE5ld2EATmtvLE5rb28ATnVzaHUsTnNodQBOeWlha2VuZ19QdWFjaHVlX0htb25nLEhtbnAAT2doYW0sT2dhbQBPbF9DaGlraSxPbGNrAE9sZF9IdW5nYXJpYW4sSHVuZwBPbGRfSXRhbGljLEl0YWwAT2xkX05vcnRoX0FyYWJpYW4sTmFyYgBPbGRfUGVybWljLFBlcm0AT2xkX1BlcnNpYW4sWHBlbwBPbGRfU29nZGlhbixTb2dvAE9sZF9Tb3V0aF9BcmFiaWFuLFNhcmIAT2xkX1R1cmtpYyxPcmtoAE9yaXlhLE9yeWEAT3NhZ2UsT3NnZQBPc21hbnlhLE9zbWEAUGFoYXdoX0htb25nLEhtbmcAUGFsbXlyZW5lLFBhbG0AUGF1X0Npbl9IYXUsUGF1YwBQaGFnc19QYSxQaGFnAFBob2VuaWNpYW4sUGhueABQc2FsdGVyX1BhaGxhdmksUGhscABSZWphbmcsUmpuZwBSdW5pYyxSdW5yAFNhbWFyaXRhbixTYW1yAFNhdXJhc2h0cmEsU2F1cgBTaGFyYWRhLFNocmQAU2hhdmlhbixTaGF3AFNpZGRoYW0sU2lkZABTaWduV3JpdGluZyxTZ253AFNpbmhhbGEsU2luaABTb2dkaWFuLFNvZ2QAU29yYV9Tb21wZW5nLFNvcmEAU295b21ibyxTb3lvAFN1bmRhbmVzZSxTdW5kAFN5bG90aV9OYWdyaSxTeWxvAFN5cmlhYyxTeXJjAFRhZ2Fsb2csVGdsZwBUYWdiYW53YSxUYWdiAFRhaV9MZSxUYWxlAFRhaV9UaGFtLExhbmEAVGFpX1ZpZXQsVGF2dABUYWtyaSxUYWtyAFRhbWlsLFRhbWwAVGFuZ3V0LFRhbmcAVGVsdWd1LFRlbHUAVGhhYW5hLFRoYWEAVGhhaSxUaGFpAFRpYmV0YW4sVGlidABUaWZpbmFnaCxUZm5nAFRpcmh1dGEsVGlyaABVZ2FyaXRpYyxVZ2FyAFZhaSxWYWlpAFdhbmNobyxXY2hvAFdhcmFuZ19DaXRpLFdhcmEAWWV6aWRpLFllemkAWWksWWlpaQBaYW5hYmF6YXJfU3F1YXJlLFphbmIAQdC5AguxFMAZmUWFGZlFrhmARY4ZgEWEGZZFgBmeRYAZ4WBFphmERYQZgQ2TGeAPN4MrgBmCKwGDK4AZgCsDgCuAGYArgBmCKwCAKwCT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ayxNb2RpZmllcl9TeW1ib2wAU28sT3RoZXJfU3ltYm9sAFBjLENvbm5lY3Rvcl9QdW5jdHVhdGlvbgBQZCxEYXNoX1B1bmN0dWF0aW9uAFBzLE9wZW5fUHVuY3R1YXRpb24AUGUsQ2xvc2VfUHVuY3R1YXRpb24AUGksSW5pdGlhbF9QdW5jdHVhdGlvbgBQZixGaW5hbF9QdW5jdHVhdGlvbgBQbyxPdGhlcl9QdW5jdHVhdGlvbgBacyxTcGFjZV9TZXBhcmF0b3IAWmwsTGluZV9TZXBhcmF0b3IAWnAsUGFyYWdyYXBoX1NlcGFyYXRvcgBDYyxDb250cm9sLGNudHJsAENmLEZvcm1hdABDcyxTdXJyb2dhdGUAQ28sUHJpdmF0ZV9Vc2UATEMsQ2FzZWRfTGV0dGVyAEwsTGV0dGVyAE0sTWFyayxDb21iaW5pbmdfTWFyawBOLE51bWJlcgBTLFN5bWJvbABQLFB1bmN0dWF0aW9uLHB1bmN0AFosU2VwYXJhdG9yAEMsT3RoZXIAQdDZAguwCA4AAAA+AAAAwAEAAAAOAAAA8AAAAAB/AAAAgAMBAAA8QVNDSUlfSGV4X0RpZ2l0LEFIZXgAQmlkaV9Db250cm9sLEJpZGlfQwBEYXNoAERlcHJlY2F0ZWQsRGVwAERpYWNyaXRpYyxEaWEARXh0ZW5kZXIsRXh0AEhleF9EaWdpdCxIZXgASURTX0JpbmFyeV9PcGVyYXRvcixJRFNCAElEU19UcmluYXJ5X09wZXJhdG9yLElEU1QASWRlb2dyYXBoaWMsSWRlbwBKb2luX0NvbnRyb2wsSm9pbl9DAExvZ2ljYWxfT3JkZXJfRXhjZXB0aW9uLExPRQBOb25jaGFyYWN0ZXJfQ29kZV9Qb2ludCxOQ2hhcgBQYXR0ZXJuX1N5bnRheCxQYXRfU3luAFBhdHRlcm5fV2hpdGVfU3BhY2UsUGF0X1dTAFF1b3RhdGlvbl9NYXJrLFFNYXJrAFJhZGljYWwAUmVnaW9uYWxfSW5kaWNhdG9yLFJJAFNlbnRlbmNlX1Rlcm1pbmFsLFNUZXJtAFNvZnRfRG90dGVkLFNEAFRlcm1pbmFsX1B1bmN0dWF0aW9uLFRlcm0AVW5pZmllZF9JZGVvZ3JhcGgsVUlkZW8AVmFyaWF0aW9uX1NlbGVjdG9yLFZTAFdoaXRlX1NwYWNlLHNwYWNlAEJpZGlfTWlycm9yZWQsQmlkaV9NAEVtb2ppAEVtb2ppX0NvbXBvbmVudCxFQ29tcABFbW9qaV9Nb2RpZmllcixFTW9kAEVtb2ppX01vZGlmaWVyX0Jhc2UsRUJhc2UARW1vamlfUHJlc2VudGF0aW9uLEVQcmVzAEV4dGVuZGVkX1BpY3RvZ3JhcGhpYyxFeHRQaWN0AERlZmF1bHRfSWdub3JhYmxlX0NvZGVfUG9pbnQsREkASURfU3RhcnQsSURTAENhc2VfSWdub3JhYmxlLENJAEFTQ0lJAEFscGhhYmV0aWMsQWxwaGEAQW55AEFzc2lnbmVkAENhc2VkAENoYW5nZXNfV2hlbl9DYXNlZm9sZGVkLENXQ0YAQ2hhbmdlc19XaGVuX0Nhc2VtYXBwZWQsQ1dDTQBDaGFuZ2VzX1doZW5fTG93ZXJjYXNlZCxDV0wAQ2hhbmdlc19XaGVuX05GS0NfQ2FzZWZvbGRlZCxDV0tDRgBDaGFuZ2VzX1doZW5fVGl0bGVjYXNlZCxDV1QAQ2hhbmdlc19XaGVuX1VwcGVyY2FzZWQsQ1dVAEdyYXBoZW1lX0Jhc2UsR3JfQmFzZQBHcmFwaGVtZV9FeHRlbmQsR3JfRXh0AElEX0NvbnRpbnVlLElEQwBMb3dlcmNhc2UsTG93ZXIATWF0aABVcHBlcmNhc2UsVXBwZXIAWElEX0NvbnRpbnVlLFhJREMAWElEX1N0YXJ0LFhJRFMAQZDiAgu0IIEAKACXACoAgYAqAJfAKwAVgSwAlwAtAIFALQCXAC4AFUEuAJkBLwAWIDAAQghAAEKKRABCBEoAlgBMABeBTABCAk0AQkNOAC/BTwBCw1AAv0BSAEIDUwBCCVUAQghaAJYAXgBCQ14AgcBfAEIBaABCwWsAhQFxABfDcQBESHMARIN3AEKDeQC+AnsAl0F8AEIBfQBEBH4AQg6AAEKBhwBEh4kAgwSsABcDtgCDArgAFALQAJYA0QCAAN0Al4DeAICA3wCXAOEAPkHhAIDA4QC+BOIAroPqAK6C8gCtAfQALsH0AANB9QADA/wAgUD+AD4CAAG+wAEBvgEDAb5ABgG+QA4BPgIUAb7AFQG+ARcBRIEdAURBMAFEAjQBRIE1AUSDNgFEgzgBRIY6AUQBPgGFwGEB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SHpUSHq8AxMhbQATIWQAEyFrABMhZgBtbgBtvANtbQBtYwBtawBtYwAKCk8ACk9tALIAYwAICk8KClAAClBtALMAawBtALMAbQAVInMAbQAVInMAsgBQYWtQYU1QYUdQYXJhZHJhZNFzcgBhAGQAFSJzALIAcABzbgBzvANzbQBzcABWbgBWvANWbQBWawBWTQBWcABXbgBXvANXbQBXawBXTQBXawCpA00AqQNhLm0uQnFjY2NkQ9FrZ0NvLmRCR3loYUhQaW5LS0tNa3RsbWxubG9nbHhtYm1pbG1vbFBIcC5tLlBQTVBSc3JTdldiVtFtQdFtMQDlZTEAMADlZTIAMADlZTMAMADlZWdhbEoETAQmAVMBJ6c3q2sCUqtIjPRmyo7IjNFuMk7lU5yfnJ9RWdGRh1VIWfZhaXaFfz+Guof4iI+QAmobbdlw3nM9hGqR8ZmCTnVTBGsbci2GHp5QXetvzYVkicli2IEfiMpeF2dqbfxyzpCGT7dR3lLEZNNqEHLndgGABoZchu+NMpdvm/qdjHh/eaB9yYMEk3+e1orfWARfYHx+gGJyynjCjPeW2FhiXBNq2m0Pby99N35LltJSi4DcUcxRHHq+ffGDdZaAi89iAmr+ijlO51sSYIdzcHUXU/t4v0+pXw1OzGx4ZSJ9w1NeWAF3SYSqirprsI+IbP5i5YKgY2V1rk5pUclRgWjnfG+C0orPkfVSQlRzWexexWX+byp5rZVqmpeezp6bUsZmd2tij3RekGEAYppkI29JcYl0ynn0fW+AJo/uhCOQSpMXUqNSvVTIcMKIqorJXvVfe2Ouaz58dXPkTvlW51u6XRxgsnNpdJp/RoA0kvaWSJcYmItPrnm0kbiW4WCGTtpQ7ls/XJllAmrOcUJ2/IR8kI2fiGYulolSe2fzZ0FtnG4JdFl1a3gQfV6YbVEuYniWK1AZXeptKo+LX0RhF2iHc4aWKVIPVGVcE2ZOZ6ho5WwGdOJ1eX/PiOGIzJHilj9Tum4dVNBxmHT6haOWV5yfnpdny23ogct6IHuSfMBymXBYi8BONoM6UgdSpl7TYtZ8hVsebbRmO49MiE2Wi4nTXkBRwFUAAAAAWlgAAHRmAAAAAN5RKnPKdjx5XnlleY95Vpe+fL1/AAAShgAA+IoAAAAAOJD9kO+Y/JgombSd3pC3lq5P51BNUclS5FJR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";
        if (!R.startsWith(Q)) {
          var fa = R;
          R = a.locateFile ? a.locateFile(fa, x) : x + fa;
        }
        function ha(b) {
          try {
            if (b == R && E)
              return new Uint8Array(E);
            var c = C(b);
            if (c)
              return c;
            if (A2)
              return A2(b);
            throw "both async and sync fetching of the wasm failed";
          } catch (d2) {
            F(d2);
          }
        }
        function ia(b) {
          if (!E && (u2 || v)) {
            if ("function" == typeof fetch && !b.startsWith("file://"))
              return fetch(b, { credentials: "same-origin" }).then(function(c) {
                if (!c.ok)
                  throw "failed to load wasm binary file at '" + b + "'";
                return c.arrayBuffer();
              }).catch(function() {
                return ha(b);
              });
            if (z)
              return new Promise(function(c, d2) {
                z(b, function(e) {
                  c(new Uint8Array(e));
                }, d2);
              });
          }
          return Promise.resolve().then(function() {
            return ha(b);
          });
        }
        function ja(b, c, d2) {
          return ia(b).then(function(e) {
            return WebAssembly.instantiate(e, c);
          }).then(function(e) {
            return e;
          }).then(d2, function(e) {
            D3("failed to asynchronously prepare wasm: " + e);
            F(e);
          });
        }
        function ka(b, c) {
          var d2 = R;
          return E || "function" != typeof WebAssembly.instantiateStreaming || d2.startsWith(Q) || d2.startsWith("file://") || w2 || "function" != typeof fetch ? ja(d2, b, c) : fetch(d2, { credentials: "same-origin" }).then(function(e) {
            return WebAssembly.instantiateStreaming(e, b).then(c, function(f) {
              D3("wasm streaming compile failed: " + f);
              D3("falling back to ArrayBuffer instantiation");
              return ja(d2, b, c);
            });
          });
        }
        function S2(b) {
          for (; 0 < b.length; )
            b.shift()(a);
        }
        var la = "undefined" != typeof TextDecoder ? new TextDecoder("utf8") : void 0;
        function na(b, c, d2) {
          var e = c + d2;
          for (d2 = c; b[d2] && !(d2 >= e); )
            ++d2;
          if (16 < d2 - c && b.buffer && la)
            return la.decode(b.subarray(c, d2));
          for (e = ""; c < d2; ) {
            var f = b[c++];
            if (f & 128) {
              var g = b[c++] & 63;
              if (192 == (f & 224))
                e += String.fromCharCode((f & 31) << 6 | g);
              else {
                var h2 = b[c++] & 63;
                f = 224 == (f & 240) ? (f & 15) << 12 | g << 6 | h2 : (f & 7) << 18 | g << 12 | h2 << 6 | b[c++] & 63;
                65536 > f ? e += String.fromCharCode(f) : (f -= 65536, e += String.fromCharCode(55296 | f >> 10, 56320 | f & 1023));
              }
            } else
              e += String.fromCharCode(f);
          }
          return e;
        }
        function T(b, c) {
          return b ? na(J, b, c) : "";
        }
        var oa = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335], pa = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
        function U(b) {
          for (var c = 0, d2 = 0; d2 < b.length; ++d2) {
            var e = b.charCodeAt(d2);
            127 >= e ? c++ : 2047 >= e ? c += 2 : 55296 <= e && 57343 >= e ? (c += 4, ++d2) : c += 3;
          }
          return c;
        }
        function V(b, c, d2) {
          var e = J;
          if (!(0 < d2))
            return 0;
          var f = c;
          d2 = c + d2 - 1;
          for (var g = 0; g < b.length; ++g) {
            var h2 = b.charCodeAt(g);
            if (55296 <= h2 && 57343 >= h2) {
              var k = b.charCodeAt(++g);
              h2 = 65536 + ((h2 & 1023) << 10) | k & 1023;
            }
            if (127 >= h2) {
              if (c >= d2)
                break;
              e[c++] = h2;
            } else {
              if (2047 >= h2) {
                if (c + 1 >= d2)
                  break;
                e[c++] = 192 | h2 >> 6;
              } else {
                if (65535 >= h2) {
                  if (c + 2 >= d2)
                    break;
                  e[c++] = 224 | h2 >> 12;
                } else {
                  if (c + 3 >= d2)
                    break;
                  e[c++] = 240 | h2 >> 18;
                  e[c++] = 128 | h2 >> 12 & 63;
                }
                e[c++] = 128 | h2 >> 6 & 63;
              }
              e[c++] = 128 | h2 & 63;
            }
          }
          e[c] = 0;
          return c - f;
        }
        function qa(b) {
          var c = U(b) + 1, d2 = ra(c);
          d2 && V(b, d2, c);
          return d2;
        }
        var W = {};
        function sa() {
          if (!X2) {
            var b = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: ("object" == typeof navigator && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8", _: t2 || "./this.program" }, c;
            for (c in W)
              void 0 === W[c] ? delete b[c] : b[c] = W[c];
            var d2 = [];
            for (c in b)
              d2.push(c + "=" + b[c]);
            X2 = d2;
          }
          return X2;
        }
        var X2, ta = [null, [], []];
        function ua(b, c, d2, e) {
          var f = { string: (l) => {
            var q = 0;
            if (null !== l && void 0 !== l && 0 !== l) {
              q = U(l) + 1;
              var ma = Y2(q);
              V(l, ma, q);
              q = ma;
            }
            return q;
          }, array: (l) => {
            var q = Y2(l.length);
            I2.set(l, q);
            return q;
          } };
          b = a["_" + b];
          var g = [], h2 = 0;
          if (e)
            for (var k = 0; k < e.length; k++) {
              var r = f[d2[k]];
              r ? (0 === h2 && (h2 = va()), g[k] = r(e[k])) : g[k] = e[k];
            }
          d2 = b.apply(null, g);
          return d2 = function(l) {
            0 !== h2 && wa(h2);
            return "string" === c ? T(l) : "boolean" === c ? !!l : l;
          }(d2);
        }
        var xa = "function" == typeof atob ? atob : function(b) {
          var c = "", d2 = 0;
          b = b.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d2++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d2++));
            var g = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d2++));
            var h2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(b.charAt(d2++));
            e = e << 2 | f >> 4;
            f = (f & 15) << 4 | g >> 2;
            var k = (g & 3) << 6 | h2;
            c += String.fromCharCode(e);
            64 !== g && (c += String.fromCharCode(f));
            64 !== h2 && (c += String.fromCharCode(k));
          } while (d2 < b.length);
          return c;
        };
        function C(b) {
          if (b.startsWith(Q)) {
            b = b.slice(Q.length);
            if ("boolean" == typeof w2 && w2) {
              var c = Buffer.from(b, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else
              try {
                var d2 = xa(b), e = new Uint8Array(d2.length);
                for (b = 0; b < d2.length; ++b)
                  e[b] = d2.charCodeAt(b);
                c = e;
              } catch (f) {
                throw Error("Converting base64 string to bytes failed.");
              }
            return c;
          }
        }
        var ya = {
          a: function(b, c, d2, e) {
            F("Assertion failed: " + T(b) + ", at: " + [c ? T(c) : "unknown filename", d2, e ? T(e) : "unknown function"]);
          },
          l: function(b, c) {
            b = new Date(1e3 * (L2[b >> 2] + 4294967296 * K[b + 4 >> 2]));
            K[c >> 2] = b.getSeconds();
            K[c + 4 >> 2] = b.getMinutes();
            K[c + 8 >> 2] = b.getHours();
            K[c + 12 >> 2] = b.getDate();
            K[c + 16 >> 2] = b.getMonth();
            K[c + 20 >> 2] = b.getFullYear() - 1900;
            K[c + 24 >> 2] = b.getDay();
            var d2 = b.getFullYear();
            K[c + 28 >> 2] = (0 !== d2 % 4 || 0 === d2 % 100 && 0 !== d2 % 400 ? pa : oa)[b.getMonth()] + b.getDate() - 1 | 0;
            K[c + 36 >> 2] = -(60 * b.getTimezoneOffset());
            d2 = new Date(b.getFullYear(), 6, 1).getTimezoneOffset();
            var e = new Date(b.getFullYear(), 0, 1).getTimezoneOffset();
            K[c + 32 >> 2] = (d2 != e && b.getTimezoneOffset() == Math.min(e, d2)) | 0;
          },
          k: function(b, c, d2) {
            function e(r) {
              return (r = r.toTimeString().match(/\(([A-Za-z ]+)\)$/)) ? r[1] : "GMT";
            }
            var f = (/* @__PURE__ */ new Date()).getFullYear(), g = new Date(f, 0, 1), h2 = new Date(f, 6, 1);
            f = g.getTimezoneOffset();
            var k = h2.getTimezoneOffset();
            L2[b >> 2] = 60 * Math.max(f, k);
            K[c >> 2] = Number(f != k);
            b = e(g);
            c = e(h2);
            b = qa(b);
            c = qa(c);
            k < f ? (L2[d2 >> 2] = b, L2[d2 + 4 >> 2] = c) : (L2[d2 >> 2] = c, L2[d2 + 4 >> 2] = b);
          },
          b: function() {
            F("");
          },
          m: function() {
            return Date.now();
          },
          j: function(b) {
            var c = J.length;
            b >>>= 0;
            if (2147483648 < b)
              return false;
            for (var d2 = 1; 4 >= d2; d2 *= 2) {
              var e = c * (1 + 0.2 / d2);
              e = Math.min(e, b + 100663296);
              var f = Math, g = f.min;
              e = Math.max(b, e);
              e += (65536 - e % 65536) % 65536;
              a: {
                var h2 = G.buffer;
                try {
                  G.grow(g.call(f, 2147483648, e) - h2.byteLength + 65535 >>> 16);
                  M2();
                  var k = 1;
                  break a;
                } catch (r) {
                }
                k = void 0;
              }
              if (k)
                return true;
            }
            return false;
          },
          e: function(b, c) {
            var d2 = 0;
            sa().forEach(function(e, f) {
              var g = c + d2;
              f = L2[b + 4 * f >> 2] = g;
              for (g = 0; g < e.length; ++g)
                I2[f++ >> 0] = e.charCodeAt(g);
              I2[f >> 0] = 0;
              d2 += e.length + 1;
            });
            return 0;
          },
          f: function(b, c) {
            var d2 = sa();
            L2[b >> 2] = d2.length;
            var e = 0;
            d2.forEach(function(f) {
              e += f.length + 1;
            });
            L2[c >> 2] = e;
            return 0;
          },
          d: function() {
            return 52;
          },
          i: function() {
            return 70;
          },
          c: function(b, c, d2, e) {
            for (var f = 0, g = 0; g < d2; g++) {
              var h2 = L2[c >> 2], k = L2[c + 4 >> 2];
              c += 8;
              for (var r = 0; r < k; r++) {
                var l = J[h2 + r], q = ta[b];
                0 === l || 10 === l ? ((1 === b ? aa : D3)(na(q, 0)), q.length = 0) : q.push(l);
              }
              f += k;
            }
            L2[e >> 2] = f;
            return 0;
          },
          o: function(b, c, d2, e, f) {
            return a.callbacks.callFunction(void 0, b, c, d2, e, f);
          },
          n: function(b) {
            return a.callbacks.shouldInterrupt(void 0, b);
          },
          h: function(b, c, d2) {
            d2 = T(d2);
            return a.callbacks.loadModuleSource(void 0, b, c, d2);
          },
          g: function(b, c, d2, e) {
            d2 = T(d2);
            e = T(e);
            return a.callbacks.normalizeModule(void 0, b, c, d2, e);
          }
        };
        (function() {
          function b(d2) {
            d2 = d2.exports;
            a.asm = d2;
            G = a.asm.p;
            M2();
            ca.unshift(a.asm.q);
            N--;
            a.monitorRunDependencies && a.monitorRunDependencies(N);
            if (0 == N && P) {
              var e = P;
              P = null;
              e();
            }
            return d2;
          }
          var c = { a: ya };
          N++;
          a.monitorRunDependencies && a.monitorRunDependencies(N);
          if (a.instantiateWasm)
            try {
              return a.instantiateWasm(c, b);
            } catch (d2) {
              D3("Module.instantiateWasm callback failed with error: " + d2), n(d2);
            }
          ka(c, function(d2) {
            b(d2.instance);
          }).catch(n);
          return {};
        })();
        var ra = a._malloc = function() {
          return (ra = a._malloc = a.asm.r).apply(null, arguments);
        };
        a._QTS_Throw = function() {
          return (a._QTS_Throw = a.asm.s).apply(null, arguments);
        };
        a._QTS_NewError = function() {
          return (a._QTS_NewError = a.asm.t).apply(null, arguments);
        };
        a._QTS_RuntimeSetMemoryLimit = function() {
          return (a._QTS_RuntimeSetMemoryLimit = a.asm.u).apply(null, arguments);
        };
        a._QTS_RuntimeComputeMemoryUsage = function() {
          return (a._QTS_RuntimeComputeMemoryUsage = a.asm.v).apply(null, arguments);
        };
        a._QTS_RuntimeDumpMemoryUsage = function() {
          return (a._QTS_RuntimeDumpMemoryUsage = a.asm.w).apply(null, arguments);
        };
        a._QTS_RecoverableLeakCheck = function() {
          return (a._QTS_RecoverableLeakCheck = a.asm.x).apply(null, arguments);
        };
        a._QTS_BuildIsSanitizeLeak = function() {
          return (a._QTS_BuildIsSanitizeLeak = a.asm.y).apply(null, arguments);
        };
        a._QTS_RuntimeSetMaxStackSize = function() {
          return (a._QTS_RuntimeSetMaxStackSize = a.asm.z).apply(null, arguments);
        };
        a._QTS_GetUndefined = function() {
          return (a._QTS_GetUndefined = a.asm.A).apply(null, arguments);
        };
        a._QTS_GetNull = function() {
          return (a._QTS_GetNull = a.asm.B).apply(null, arguments);
        };
        a._QTS_GetFalse = function() {
          return (a._QTS_GetFalse = a.asm.C).apply(null, arguments);
        };
        a._QTS_GetTrue = function() {
          return (a._QTS_GetTrue = a.asm.D).apply(null, arguments);
        };
        a._QTS_NewRuntime = function() {
          return (a._QTS_NewRuntime = a.asm.E).apply(null, arguments);
        };
        a._QTS_FreeRuntime = function() {
          return (a._QTS_FreeRuntime = a.asm.F).apply(null, arguments);
        };
        a._QTS_NewContext = function() {
          return (a._QTS_NewContext = a.asm.G).apply(null, arguments);
        };
        a._QTS_FreeContext = function() {
          return (a._QTS_FreeContext = a.asm.H).apply(null, arguments);
        };
        a._QTS_FreeValuePointer = function() {
          return (a._QTS_FreeValuePointer = a.asm.I).apply(null, arguments);
        };
        a._free = function() {
          return (a._free = a.asm.J).apply(null, arguments);
        };
        a._QTS_FreeValuePointerRuntime = function() {
          return (a._QTS_FreeValuePointerRuntime = a.asm.K).apply(null, arguments);
        };
        a._QTS_FreeVoidPointer = function() {
          return (a._QTS_FreeVoidPointer = a.asm.L).apply(null, arguments);
        };
        a._QTS_FreeCString = function() {
          return (a._QTS_FreeCString = a.asm.M).apply(null, arguments);
        };
        a._QTS_DupValuePointer = function() {
          return (a._QTS_DupValuePointer = a.asm.N).apply(null, arguments);
        };
        a._QTS_NewObject = function() {
          return (a._QTS_NewObject = a.asm.O).apply(null, arguments);
        };
        a._QTS_NewObjectProto = function() {
          return (a._QTS_NewObjectProto = a.asm.P).apply(null, arguments);
        };
        a._QTS_NewArray = function() {
          return (a._QTS_NewArray = a.asm.Q).apply(null, arguments);
        };
        a._QTS_NewFloat64 = function() {
          return (a._QTS_NewFloat64 = a.asm.R).apply(null, arguments);
        };
        a._QTS_GetFloat64 = function() {
          return (a._QTS_GetFloat64 = a.asm.S).apply(null, arguments);
        };
        a._QTS_NewString = function() {
          return (a._QTS_NewString = a.asm.T).apply(null, arguments);
        };
        a._QTS_GetString = function() {
          return (a._QTS_GetString = a.asm.U).apply(null, arguments);
        };
        a._QTS_NewSymbol = function() {
          return (a._QTS_NewSymbol = a.asm.V).apply(null, arguments);
        };
        a._QTS_GetSymbolDescriptionOrKey = function() {
          return (a._QTS_GetSymbolDescriptionOrKey = a.asm.W).apply(null, arguments);
        };
        a._QTS_IsGlobalSymbol = function() {
          return (a._QTS_IsGlobalSymbol = a.asm.X).apply(null, arguments);
        };
        a._QTS_IsJobPending = function() {
          return (a._QTS_IsJobPending = a.asm.Y).apply(null, arguments);
        };
        a._QTS_ExecutePendingJob = function() {
          return (a._QTS_ExecutePendingJob = a.asm.Z).apply(null, arguments);
        };
        a._QTS_GetProp = function() {
          return (a._QTS_GetProp = a.asm._).apply(null, arguments);
        };
        a._QTS_SetProp = function() {
          return (a._QTS_SetProp = a.asm.$).apply(null, arguments);
        };
        a._QTS_DefineProp = function() {
          return (a._QTS_DefineProp = a.asm.aa).apply(null, arguments);
        };
        a._QTS_Call = function() {
          return (a._QTS_Call = a.asm.ba).apply(null, arguments);
        };
        a._QTS_ResolveException = function() {
          return (a._QTS_ResolveException = a.asm.ca).apply(null, arguments);
        };
        a._QTS_Dump = function() {
          return (a._QTS_Dump = a.asm.da).apply(null, arguments);
        };
        a._QTS_Eval = function() {
          return (a._QTS_Eval = a.asm.ea).apply(null, arguments);
        };
        a._QTS_Typeof = function() {
          return (a._QTS_Typeof = a.asm.fa).apply(null, arguments);
        };
        a._QTS_GetGlobalObject = function() {
          return (a._QTS_GetGlobalObject = a.asm.ga).apply(null, arguments);
        };
        a._QTS_NewPromiseCapability = function() {
          return (a._QTS_NewPromiseCapability = a.asm.ha).apply(null, arguments);
        };
        a._QTS_TestStringArg = function() {
          return (a._QTS_TestStringArg = a.asm.ia).apply(null, arguments);
        };
        a._QTS_BuildIsDebug = function() {
          return (a._QTS_BuildIsDebug = a.asm.ja).apply(null, arguments);
        };
        a._QTS_BuildIsAsyncify = function() {
          return (a._QTS_BuildIsAsyncify = a.asm.ka).apply(null, arguments);
        };
        a._QTS_NewFunction = function() {
          return (a._QTS_NewFunction = a.asm.la).apply(null, arguments);
        };
        a._QTS_ArgvGetJSValueConstPointer = function() {
          return (a._QTS_ArgvGetJSValueConstPointer = a.asm.ma).apply(null, arguments);
        };
        a._QTS_RuntimeEnableInterruptHandler = function() {
          return (a._QTS_RuntimeEnableInterruptHandler = a.asm.na).apply(null, arguments);
        };
        a._QTS_RuntimeDisableInterruptHandler = function() {
          return (a._QTS_RuntimeDisableInterruptHandler = a.asm.oa).apply(null, arguments);
        };
        a._QTS_RuntimeEnableModuleLoader = function() {
          return (a._QTS_RuntimeEnableModuleLoader = a.asm.pa).apply(null, arguments);
        };
        a._QTS_RuntimeDisableModuleLoader = function() {
          return (a._QTS_RuntimeDisableModuleLoader = a.asm.qa).apply(null, arguments);
        };
        function va() {
          return (va = a.asm.sa).apply(null, arguments);
        }
        function wa() {
          return (wa = a.asm.ta).apply(null, arguments);
        }
        function Y2() {
          return (Y2 = a.asm.ua).apply(null, arguments);
        }
        a.___start_em_js = 74916;
        a.___stop_em_js = 75818;
        a.cwrap = function(b, c, d2, e) {
          var f = !d2 || d2.every((g) => "number" === g || "boolean" === g);
          return "string" !== c && f && !e ? a["_" + b] : function() {
            return ua(b, c, d2, arguments);
          };
        };
        a.UTF8ToString = T;
        a.stringToUTF8 = function(b, c, d2) {
          return V(b, c, d2);
        };
        a.lengthBytesUTF8 = U;
        var Z2;
        P = function za() {
          Z2 || Aa();
          Z2 || (P = za);
        };
        function Aa() {
          function b() {
            if (!Z2 && (Z2 = true, a.calledRun = true, !H)) {
              S2(ca);
              m2(a);
              if (a.onRuntimeInitialized)
                a.onRuntimeInitialized();
              if (a.postRun)
                for ("function" == typeof a.postRun && (a.postRun = [a.postRun]); a.postRun.length; ) {
                  var c = a.postRun.shift();
                  da.unshift(c);
                }
              S2(da);
            }
          }
          if (!(0 < N)) {
            if (a.preRun)
              for ("function" == typeof a.preRun && (a.preRun = [a.preRun]); a.preRun.length; )
                ea();
            S2(ba);
            0 < N || (a.setStatus ? (a.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                a.setStatus("");
              }, 1);
              b();
            }, 1)) : b());
          }
        }
        if (a.preInit)
          for ("function" == typeof a.preInit && (a.preInit = [a.preInit]); 0 < a.preInit.length; )
            a.preInit.pop()();
        Aa();
        return QuickJSRaw2.ready;
      };
    })();
    module2.exports = QuickJSRaw;
  })(emscriptenModule_WASM_RELEASE_SYNC);
  return emscriptenModule_WASM_RELEASE_SYNC.exports;
}
var hasRequiredVariants;
function requireVariants() {
  if (hasRequiredVariants) return variants;
  hasRequiredVariants = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc2);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RELEASE_ASYNC = exports.DEBUG_ASYNC = exports.RELEASE_SYNC = exports.DEBUG_SYNC = exports.memoizePromiseFactory = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;
    const esmHelpers_1 = esmHelpers;
    async function newQuickJSWASMModule(variant = exports.RELEASE_SYNC) {
      const [wasmModuleLoader, QuickJSFFI, { QuickJSWASMModule }] = await Promise.all([
        variant.importModuleLoader(),
        variant.importFFI(),
        Promise.resolve().then(() => __importStar2(requireModule())).then(esmHelpers_1.unwrapTypescript)
      ]);
      const wasmModule = await wasmModuleLoader();
      wasmModule.type = "sync";
      const ffi = new QuickJSFFI(wasmModule);
      return new QuickJSWASMModule(wasmModule, ffi);
    }
    exports.newQuickJSWASMModule = newQuickJSWASMModule;
    async function newQuickJSAsyncWASMModule(variant = exports.RELEASE_ASYNC) {
      const [wasmModuleLoader, QuickJSAsyncFFI, { QuickJSAsyncWASMModule }] = await Promise.all([
        variant.importModuleLoader(),
        variant.importFFI(),
        Promise.resolve().then(() => __importStar2(requireModuleAsyncify())).then(esmHelpers_1.unwrapTypescript)
      ]);
      const wasmModule = await wasmModuleLoader();
      wasmModule.type = "async";
      const ffi = new QuickJSAsyncFFI(wasmModule);
      return new QuickJSAsyncWASMModule(wasmModule, ffi);
    }
    exports.newQuickJSAsyncWASMModule = newQuickJSAsyncWASMModule;
    function memoizePromiseFactory(fn) {
      let promise2;
      return () => {
        return promise2 ?? (promise2 = fn());
      };
    }
    exports.memoizePromiseFactory = memoizePromiseFactory;
    exports.DEBUG_SYNC = {
      type: "sync",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
    exports.RELEASE_SYNC = {
      type: "sync",
      async importFFI() {
        const mod = await Promise.resolve().then(() => __importStar2(requireFfi_WASM_RELEASE_SYNC()));
        return (0, esmHelpers_1.unwrapTypescript)(mod).QuickJSFFI;
      },
      async importModuleLoader() {
        const mod = await Promise.resolve().then(() => __importStar2(requireEmscriptenModule_WASM_RELEASE_SYNC()));
        return (0, esmHelpers_1.unwrapJavascript)(mod);
      }
    };
    exports.DEBUG_ASYNC = {
      type: "async",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
    exports.RELEASE_ASYNC = {
      type: "async",
      async importFFI() {
        throw new Error("not implemented");
      },
      async importModuleLoader() {
        throw new Error("not implemented");
      }
    };
  })(variants);
  return variants;
}
var vmInterface = {};
Object.defineProperty(vmInterface, "__esModule", { value: true });
vmInterface.isFail = vmInterface.isSuccess = void 0;
function isSuccess(successOrFail) {
  return "error" in successOrFail === false;
}
vmInterface.isSuccess = isSuccess;
function isFail(successOrFail) {
  return "error" in successOrFail === true;
}
vmInterface.isFail = isFail;
var moduleTest = {};
Object.defineProperty(moduleTest, "__esModule", { value: true });
moduleTest.TestQuickJSWASMModule = void 0;
const errors_1 = errors;
const lifetime_1 = lifetime;
class TestQuickJSWASMModule {
  constructor(parent) {
    this.parent = parent;
    this.contexts = /* @__PURE__ */ new Set();
    this.runtimes = /* @__PURE__ */ new Set();
  }
  newRuntime(options) {
    const runtime2 = this.parent.newRuntime({
      ...options,
      ownedLifetimes: [
        new lifetime_1.Lifetime(void 0, void 0, () => this.runtimes.delete(runtime2)),
        ...(options == null ? void 0 : options.ownedLifetimes) ?? []
      ]
    });
    this.runtimes.add(runtime2);
    return runtime2;
  }
  newContext(options) {
    const context2 = this.parent.newContext({
      ...options,
      ownedLifetimes: [
        new lifetime_1.Lifetime(void 0, void 0, () => this.contexts.delete(context2)),
        ...(options == null ? void 0 : options.ownedLifetimes) ?? []
      ]
    });
    this.contexts.add(context2);
    return context2;
  }
  evalCode(code2, options) {
    return this.parent.evalCode(code2, options);
  }
  disposeAll() {
    const allDisposables = [...this.contexts, ...this.runtimes];
    this.runtimes.clear();
    this.contexts.clear();
    allDisposables.forEach((d2) => {
      if (d2.alive) {
        d2.dispose();
      }
    });
  }
  assertNoMemoryAllocated() {
    const leaksDetected = this.getFFI().QTS_RecoverableLeakCheck();
    if (leaksDetected) {
      throw new errors_1.QuickJSMemoryLeakDetected("Leak sanitizer detected un-freed memory");
    }
    if (this.contexts.size > 0) {
      throw new errors_1.QuickJSMemoryLeakDetected(`${this.contexts.size} contexts leaked`);
    }
    if (this.runtimes.size > 0) {
      throw new errors_1.QuickJSMemoryLeakDetected(`${this.runtimes.size} runtimes leaked`);
    }
  }
  /** @private */
  getFFI() {
    return this.parent.getFFI();
  }
}
moduleTest.TestQuickJSWASMModule = TestQuickJSWASMModule;
var hasRequiredDist;
function requireDist() {
  if (hasRequiredDist) return dist;
  hasRequiredDist = 1;
  (function(exports) {
    var __createBinding2 = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc2 = Object.getOwnPropertyDescriptor(m2, k);
      if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
        desc2 = { enumerable: true, get: function() {
          return m2[k];
        } };
      }
      Object.defineProperty(o, k2, desc2);
    } : function(o, m2, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m2[k];
    });
    var __setModuleDefault2 = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __exportStar2 = commonjsGlobal && commonjsGlobal.__exportStar || function(m2, exports2) {
      for (var p in m2) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding2(exports2, m2, p);
    };
    var __importStar2 = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding2(result, mod, k);
      }
      __setModuleDefault2(result, mod);
      return result;
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shouldInterruptAfterDeadline = exports.newAsyncContext = exports.newAsyncRuntime = exports.getQuickJSSync = exports.getQuickJS = exports.errors = exports.RELEASE_SYNC = exports.RELEASE_ASYNC = exports.DEBUG_SYNC = exports.DEBUG_ASYNC = exports.newQuickJSAsyncWASMModule = exports.newQuickJSWASMModule = void 0;
    const variants_1 = requireVariants();
    Object.defineProperty(exports, "newQuickJSWASMModule", { enumerable: true, get: function() {
      return variants_1.newQuickJSWASMModule;
    } });
    Object.defineProperty(exports, "newQuickJSAsyncWASMModule", { enumerable: true, get: function() {
      return variants_1.newQuickJSAsyncWASMModule;
    } });
    Object.defineProperty(exports, "DEBUG_ASYNC", { enumerable: true, get: function() {
      return variants_1.DEBUG_ASYNC;
    } });
    Object.defineProperty(exports, "DEBUG_SYNC", { enumerable: true, get: function() {
      return variants_1.DEBUG_SYNC;
    } });
    Object.defineProperty(exports, "RELEASE_ASYNC", { enumerable: true, get: function() {
      return variants_1.RELEASE_ASYNC;
    } });
    Object.defineProperty(exports, "RELEASE_SYNC", { enumerable: true, get: function() {
      return variants_1.RELEASE_SYNC;
    } });
    __exportStar2(vmInterface, exports);
    __exportStar2(lifetime, exports);
    exports.errors = __importStar2(errors);
    __exportStar2(deferredPromise, exports);
    __exportStar2(moduleTest, exports);
    let singleton = void 0;
    let singletonPromise = void 0;
    async function getQuickJS() {
      singletonPromise ?? (singletonPromise = (0, variants_1.newQuickJSWASMModule)().then((instance) => {
        singleton = instance;
        return instance;
      }));
      return await singletonPromise;
    }
    exports.getQuickJS = getQuickJS;
    function getQuickJSSync() {
      if (!singleton) {
        throw new Error("QuickJS not initialized. Await getQuickJS() at least once.");
      }
      return singleton;
    }
    exports.getQuickJSSync = getQuickJSSync;
    async function newAsyncRuntime(options) {
      const module2 = await (0, variants_1.newQuickJSAsyncWASMModule)();
      return module2.newRuntime(options);
    }
    exports.newAsyncRuntime = newAsyncRuntime;
    async function newAsyncContext(options) {
      const module2 = await (0, variants_1.newQuickJSAsyncWASMModule)();
      return module2.newContext(options);
    }
    exports.newAsyncContext = newAsyncContext;
    function shouldInterruptAfterDeadline(deadline) {
      const deadlineAsNumber = typeof deadline === "number" ? deadline : deadline.getTime();
      return function() {
        return Date.now() > deadlineAsNumber;
      };
    }
    exports.shouldInterruptAfterDeadline = shouldInterruptAfterDeadline;
  })(dist);
  return dist;
}
var __createBinding = commonjsGlobal && commonjsGlobal.__createBinding || (Object.create ? function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  var desc2 = Object.getOwnPropertyDescriptor(m2, k);
  if (!desc2 || ("get" in desc2 ? !m2.__esModule : desc2.writable || desc2.configurable)) {
    desc2 = { enumerable: true, get: function() {
      return m2[k];
    } };
  }
  Object.defineProperty(o, k2, desc2);
} : function(o, m2, k, k2) {
  if (k2 === void 0) k2 = k;
  o[k2] = m2[k];
});
var __setModuleDefault = commonjsGlobal && commonjsGlobal.__setModuleDefault || (Object.create ? function(o, v) {
  Object.defineProperty(o, "default", { enumerable: true, value: v });
} : function(o, v) {
  o["default"] = v;
});
var __importStar = commonjsGlobal && commonjsGlobal.__importStar || function(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
};
var __importDefault = commonjsGlobal && commonjsGlobal.__importDefault || function(mod) {
  return mod && mod.__esModule ? mod : { "default": mod };
};
Object.defineProperty(dist$a, "__esModule", { value: true });
dist$a.PacProxyAgent = void 0;
const net = __importStar(require$$0$6);
const tls$1 = __importStar(require$$1$6);
const crypto$3 = __importStar(require$$2$3);
const events_1 = require$$0$8;
const debug_1 = __importDefault(srcExports);
const url_1 = require$$5$2;
const agent_base_1 = dist$9;
const http_proxy_agent_1 = dist$8;
const https_proxy_agent_1 = dist$7;
const socks_proxy_agent_1 = dist$6;
const get_uri_1 = dist$4;
const pac_resolver_1 = dist$2;
const quickjs_emscripten_1 = requireDist();
const debug$1 = (0, debug_1.default)("pac-proxy-agent");
let PacProxyAgent$1 = class PacProxyAgent extends agent_base_1.Agent {
  constructor(uri2, opts) {
    super(opts);
    this.clearResolverPromise = () => {
      this.resolverPromise = void 0;
    };
    const uriStr = typeof uri2 === "string" ? uri2 : uri2.href;
    this.uri = new url_1.URL(uriStr.replace(/^pac\+/i, ""));
    debug$1("Creating PacProxyAgent with URI %o", this.uri.href);
    this.opts = { ...opts };
    this.cache = void 0;
    this.resolver = void 0;
    this.resolverHash = "";
    this.resolverPromise = void 0;
    if (!this.opts.filename) {
      this.opts.filename = this.uri.href;
    }
  }
  /**
   * Loads the PAC proxy file from the source if necessary, and returns
   * a generated `FindProxyForURL()` resolver function to use.
   *
   * @api private
   */
  getResolver() {
    if (!this.resolverPromise) {
      this.resolverPromise = this.loadResolver();
      this.resolverPromise.then(this.clearResolverPromise, this.clearResolverPromise);
    }
    return this.resolverPromise;
  }
  async loadResolver() {
    try {
      const [qjs, code2] = await Promise.all([
        (0, quickjs_emscripten_1.getQuickJS)(),
        this.loadPacFile()
      ]);
      const hash2 = crypto$3.createHash("sha1").update(code2).digest("hex");
      if (this.resolver && this.resolverHash === hash2) {
        debug$1("Same sha1 hash for code - contents have not changed, reusing previous proxy resolver");
        return this.resolver;
      }
      debug$1("Creating new proxy resolver instance");
      this.resolver = (0, pac_resolver_1.createPacResolver)(qjs, code2, this.opts);
      this.resolverHash = hash2;
      return this.resolver;
    } catch (err) {
      if (this.resolver && err.code === "ENOTMODIFIED") {
        debug$1("Got ENOTMODIFIED response, reusing previous proxy resolver");
        return this.resolver;
      }
      throw err;
    }
  }
  /**
   * Loads the contents of the PAC proxy file.
   *
   * @api private
   */
  async loadPacFile() {
    debug$1("Loading PAC file: %o", this.uri);
    const rs = await (0, get_uri_1.getUri)(this.uri, { ...this.opts, cache: this.cache });
    debug$1("Got `Readable` instance for URI");
    this.cache = rs;
    const buf = await (0, agent_base_1.toBuffer)(rs);
    debug$1("Read %o byte PAC file from URI", buf.length);
    return buf.toString("utf8");
  }
  /**
   * Called when the node-core HTTP client library is creating a new HTTP request.
   */
  async connect(req2, opts) {
    const { secureEndpoint } = opts;
    const resolver = await this.getResolver();
    const defaultPort = secureEndpoint ? 443 : 80;
    let path3 = req2.path;
    let search = null;
    const firstQuestion = path3.indexOf("?");
    if (firstQuestion !== -1) {
      search = path3.substring(firstQuestion);
      path3 = path3.substring(0, firstQuestion);
    }
    const urlOpts = {
      ...opts,
      protocol: secureEndpoint ? "https:" : "http:",
      pathname: path3,
      search,
      // need to use `hostname` instead of `host` otherwise `port` is ignored
      hostname: opts.host,
      host: null,
      href: null,
      // set `port` to null when it is the protocol default port (80 / 443)
      port: defaultPort === opts.port ? null : opts.port
    };
    const url2 = (0, url_1.format)(urlOpts);
    debug$1("url: %o", url2);
    let result = await resolver(url2);
    if (!result) {
      result = "DIRECT";
    }
    const proxies = String(result).trim().split(/\s*;\s*/g).filter(Boolean);
    if (this.opts.fallbackToDirect && !proxies.includes("DIRECT")) {
      proxies.push("DIRECT");
    }
    for (const proxy of proxies) {
      let agent = null;
      let socket = null;
      const [type3, target] = proxy.split(/\s+/);
      debug$1("Attempting to use proxy: %o", proxy);
      if (type3 === "DIRECT") {
        if (secureEndpoint) {
          const servername = opts.servername || opts.host;
          socket = tls$1.connect({
            ...opts,
            servername
          });
        } else {
          socket = net.connect(opts);
        }
      } else if (type3 === "SOCKS" || type3 === "SOCKS5") {
        agent = new socks_proxy_agent_1.SocksProxyAgent(`socks://${target}`, this.opts);
      } else if (type3 === "SOCKS4") {
        agent = new socks_proxy_agent_1.SocksProxyAgent(`socks4a://${target}`, this.opts);
      } else if (type3 === "PROXY" || type3 === "HTTP" || type3 === "HTTPS") {
        const proxyURL = `${type3 === "HTTPS" ? "https" : "http"}://${target}`;
        if (secureEndpoint) {
          agent = new https_proxy_agent_1.HttpsProxyAgent(proxyURL, this.opts);
        } else {
          agent = new http_proxy_agent_1.HttpProxyAgent(proxyURL, this.opts);
        }
      }
      try {
        if (socket) {
          await (0, events_1.once)(socket, "connect");
          req2.emit("proxy", { proxy, socket });
          return socket;
        }
        if (agent) {
          const s2 = await agent.connect(req2, opts);
          if (!(s2 instanceof net.Socket)) {
            throw new Error("Expected a `net.Socket` to be returned from agent");
          }
          req2.emit("proxy", { proxy, socket: s2 });
          return s2;
        }
        throw new Error(`Could not determine proxy type for: ${proxy}`);
      } catch (err) {
        debug$1("Got error for proxy %o: %o", proxy, err);
        req2.emit("proxy", { proxy, error: err });
      }
    }
    throw new Error(`Failed to establish a socket connection to proxies: ${JSON.stringify(proxies)}`);
  }
};
PacProxyAgent$1.protocols = [
  "pac+data",
  "pac+file",
  "pac+ftp",
  "pac+http",
  "pac+https"
];
dist$a.PacProxyAgent = PacProxyAgent$1;
var tunnel$2 = {};
var tls = require$$1$6;
var http$1 = require$$0$a;
var https$1 = require$$2$4;
var events = require$$0$8;
var util$1 = require$$1$3;
tunnel$2.httpOverHttp = httpOverHttp;
tunnel$2.httpsOverHttp = httpsOverHttp;
tunnel$2.httpOverHttps = httpOverHttps;
tunnel$2.httpsOverHttps = httpsOverHttps;
function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http$1.request;
  return agent;
}
function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http$1.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}
function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https$1.request;
  return agent;
}
function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https$1.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent;
}
function TunnelingAgent(options) {
  var self3 = this;
  self3.options = options || {};
  self3.proxyOptions = self3.options.proxy || {};
  self3.maxSockets = self3.options.maxSockets || http$1.Agent.defaultMaxSockets;
  self3.requests = [];
  self3.sockets = [];
  self3.on("free", function onFree(socket, host2, port, localAddress) {
    var options2 = toOptions(host2, port, localAddress);
    for (var i = 0, len = self3.requests.length; i < len; ++i) {
      var pending = self3.requests[i];
      if (pending.host === options2.host && pending.port === options2.port) {
        self3.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return;
      }
    }
    socket.destroy();
    self3.removeSocket(socket);
  });
}
util$1.inherits(TunnelingAgent, events.EventEmitter);
TunnelingAgent.prototype.addRequest = function addRequest(req2, host2, port, localAddress) {
  var self3 = this;
  var options = mergeOptions({ request: req2 }, self3.options, toOptions(host2, port, localAddress));
  if (self3.sockets.length >= this.maxSockets) {
    self3.requests.push(options);
    return;
  }
  self3.createSocket(options, function(socket) {
    socket.on("free", onFree);
    socket.on("close", onCloseOrRemove);
    socket.on("agentRemove", onCloseOrRemove);
    req2.onSocket(socket);
    function onFree() {
      self3.emit("free", socket, options);
    }
    function onCloseOrRemove(err) {
      self3.removeSocket(socket);
      socket.removeListener("free", onFree);
      socket.removeListener("close", onCloseOrRemove);
      socket.removeListener("agentRemove", onCloseOrRemove);
    }
  });
};
TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self3 = this;
  var placeholder = {};
  self3.sockets.push(placeholder);
  var connectOptions = mergeOptions({}, self3.proxyOptions, {
    method: "CONNECT",
    path: options.host + ":" + options.port,
    agent: false,
    headers: {
      host: options.host + ":" + options.port
    }
  });
  if (options.localAddress) {
    connectOptions.localAddress = options.localAddress;
  }
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers["Proxy-Authorization"] = "Basic " + new Buffer(connectOptions.proxyAuth).toString("base64");
  }
  debug("making CONNECT request");
  var connectReq = self3.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false;
  connectReq.once("response", onResponse);
  connectReq.once("upgrade", onUpgrade);
  connectReq.once("connect", onConnect);
  connectReq.once("error", onError);
  connectReq.end();
  function onResponse(res2) {
    res2.upgrade = true;
  }
  function onUpgrade(res2, socket, head) {
    process.nextTick(function() {
      onConnect(res2, socket, head);
    });
  }
  function onConnect(res2, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();
    if (res2.statusCode !== 200) {
      debug(
        "tunneling socket could not be established, statusCode=%d",
        res2.statusCode
      );
      socket.destroy();
      var error2 = new Error("tunneling socket could not be established, statusCode=" + res2.statusCode);
      error2.code = "ECONNRESET";
      options.request.emit("error", error2);
      self3.removeSocket(placeholder);
      return;
    }
    if (head.length > 0) {
      debug("got illegal response body from proxy");
      socket.destroy();
      var error2 = new Error("got illegal response body from proxy");
      error2.code = "ECONNRESET";
      options.request.emit("error", error2);
      self3.removeSocket(placeholder);
      return;
    }
    debug("tunneling connection has established");
    self3.sockets[self3.sockets.indexOf(placeholder)] = socket;
    return cb(socket);
  }
  function onError(cause) {
    connectReq.removeAllListeners();
    debug(
      "tunneling socket could not be established, cause=%s\n",
      cause.message,
      cause.stack
    );
    var error2 = new Error("tunneling socket could not be established, cause=" + cause.message);
    error2.code = "ECONNRESET";
    options.request.emit("error", error2);
    self3.removeSocket(placeholder);
  }
};
TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket);
  if (pos === -1) {
    return;
  }
  this.sockets.splice(pos, 1);
  var pending = this.requests.shift();
  if (pending) {
    this.createSocket(pending, function(socket2) {
      pending.request.onSocket(socket2);
    });
  }
};
function createSecureSocket(options, cb) {
  var self3 = this;
  TunnelingAgent.prototype.createSocket.call(self3, options, function(socket) {
    var hostHeader = options.request.getHeader("host");
    var tlsOptions = mergeOptions({}, self3.options, {
      socket,
      servername: hostHeader ? hostHeader.replace(/:.*$/, "") : options.host
    });
    var secureSocket = tls.connect(0, tlsOptions);
    self3.sockets[self3.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}
function toOptions(host2, port, localAddress) {
  if (typeof host2 === "string") {
    return {
      host: host2,
      port,
      localAddress
    };
  }
  return host2;
}
function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === "object") {
      var keys2 = Object.keys(overrides);
      for (var j2 = 0, keyLen = keys2.length; j2 < keyLen; ++j2) {
        var k = keys2[j2];
        if (overrides[k] !== void 0) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target;
}
var debug;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === "string") {
      args[0] = "TUNNEL: " + args[0];
    } else {
      args.unshift("TUNNEL:");
    }
    console.error.apply(console, args);
  };
} else {
  debug = function() {
  };
}
tunnel$2.debug = debug;
var tunnel$1 = tunnel$2;
var util = {
  toBoolean(val) {
    if (typeof val === "boolean") return val;
    if (val === "") return val;
    return val === "true" || val == "1";
  },
  cookieToJson(cookie2) {
    if (!cookie2) return {};
    let cookieArr = cookie2.split(";");
    let obj = {};
    cookieArr.forEach((i) => {
      let arr = i.split("=");
      obj[arr[0]] = arr[1];
    });
    return obj;
  },
  cookieObjToString(cookie2) {
    return Object.keys(cookie2).map(
      (key) => `${encodeURIComponent(key)}=${encodeURIComponent(cookie2[key])}`
    ).join("; ");
  },
  getRandom(num) {
    var random = Math.floor(
      (Math.random() + Math.floor(Math.random() * 9 + 1)) * Math.pow(10, num - 1)
    );
    return random;
  },
  generateRandomChineseIP() {
    const chinaIPPrefixes = ["116.25", "116.76", "116.77", "116.78"];
    const randomPrefix = chinaIPPrefixes[Math.floor(Math.random() * chinaIPPrefixes.length)];
    return `${randomPrefix}.${generateIPSegment()}.${generateIPSegment()}`;
  }
};
function getRandomInt(min2, max2) {
  return Math.floor(Math.random() * (max2 - min2 + 1)) + min2;
}
function generateIPSegment() {
  return getRandomInt(1, 255);
}
const resourceTypeMap = {
  "0": "R_SO_4_",
  "1": "R_MV_5_",
  "2": "A_PL_0_",
  "3": "R_AL_3_",
  "4": "A_DJ_1_",
  "5": "R_VI_62_",
  "6": "A_EV_2_",
  "7": "A_DR_14_"
};
const APP_CONF$1 = {
  apiDomain: "https://interface.music.163.com",
  domain: "https://music.163.com",
  encrypt: true,
  encryptResponse: false
};
const require$$12 = {
  resourceTypeMap,
  APP_CONF: APP_CONF$1
};
const encrypt = crypto$4;
const CryptoJS = cryptoJsExports;
const { default: axios } = axios_1;
const { PacProxyAgent: PacProxyAgent2 } = dist$a;
const http = require$$0$a;
const https = require$$2$4;
const tunnel = tunnel$1;
const fs$3 = require$$0$7;
const path$4 = require$$1$2;
const tmpPath = require$$0$b.tmpdir();
const { cookieToJson: cookieToJson$1, cookieObjToString } = util;
const anonymous_token = fs$3.readFileSync(
  path$4.resolve(tmpPath, "./anonymous_token"),
  "utf-8"
);
const { URLSearchParams, URL: URL$1 } = require$$5$2;
const iosAppVersion = "9.0.65";
const { APP_CONF } = require$$12;
const chooseUserAgent = (uaType) => {
  const userAgentMap = {
    mobile: "Mozilla/5.0 (iPhone; CPU iPhone OS 17_4_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/17.4.1 Mobile/15E148 Safari/604.1",
    pc: "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36 Edg/124.0.0.0"
  };
  if (uaType === "mobile") {
    return userAgentMap.mobile;
  }
  return userAgentMap.pc;
};
const createRequest = (method, uri2, data2 = {}, options) => {
  const cookie2 = options.cookie || {};
  return new Promise((resolve3, reject) => {
    let headers = {
      "User-Agent": options.ua || chooseUserAgent(options.uaType),
      os: cookie2.os || "ios",
      appver: cookie2.appver || (cookie2.os != "pc" ? iosAppVersion : "")
    };
    options.headers = options.headers || {};
    headers = {
      ...headers,
      ...options.headers
    };
    if (method.toUpperCase() === "POST")
      headers["Content-Type"] = "application/x-www-form-urlencoded";
    let ip3 = options.realIP || options.ip || "";
    if (ip3) {
      headers["X-Real-IP"] = ip3;
      headers["X-Forwarded-For"] = ip3;
    }
    if (typeof options.cookie === "object") {
      options.cookie = {
        ...options.cookie,
        __remember_me: true,
        // NMTID: CryptoJS.lib.WordArray.random(16).toString(),
        _ntes_nuid: CryptoJS.lib.WordArray.random(16).toString(),
        os: options.cookie.os || "ios",
        appver: options.cookie.appver || (cookie2.os != "pc" ? iosAppVersion : "")
      };
      if (uri2.indexOf("login") === -1) {
        options.cookie["NMTID"] = CryptoJS.lib.WordArray.random(16).toString();
      }
      if (!options.cookie.MUSIC_U) {
        if (!options.cookie.MUSIC_A) {
          options.cookie.MUSIC_A = anonymous_token;
        }
      }
      headers["Cookie"] = cookieObjToString(options.cookie);
    } else if (options.cookie) {
      const cookie3 = cookieToJson$1(options.cookie);
      cookie3.os = cookie3.os || "ios";
      cookie3.appver = cookie3.appver || (cookie3.os != "pc" ? iosAppVersion : "");
      headers["Cookie"] = cookieObjToString(cookie3);
    } else {
      const cookie3 = cookieToJson$1("__remember_me=true; NMTID=xxx");
      cookie3.os = cookie3.os || "ios";
      cookie3.appver = cookie3.appver || (cookie3.os != "pc" ? iosAppVersion : "");
      headers["Cookie"] = cookieObjToString(cookie3);
    }
    let url2 = "", encryptData = "", crypto2 = options.crypto, csrfToken = cookie2["__csrf"] || "";
    if (crypto2 === "") {
      if (APP_CONF.encrypt) {
        crypto2 = "eapi";
      } else {
        crypto2 = "api";
      }
    }
    switch (crypto2) {
      case "weapi":
        headers["Referer"] = "https://music.163.com";
        headers["User-Agent"] = options.ua || chooseUserAgent("pc");
        data2.csrf_token = csrfToken;
        encryptData = encrypt.weapi(data2);
        url2 = APP_CONF.domain + "/weapi/" + uri2.substr(5);
        break;
      case "linuxapi":
        headers["User-Agent"] = "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/60.0.3112.90 Safari/537.36";
        encryptData = encrypt.linuxapi({
          method,
          url: APP_CONF.apiDomain + uri2,
          params: data2
        });
        url2 = "https://music.163.com/api/linux/forward";
        break;
      case "eapi":
      case "api":
        const cookie3 = options.cookie || {};
        const header3 = {
          osver: cookie3.osver || "17.4.1",
          //ç³»ç»Ÿç‰ˆæœ¬
          deviceId: cookie3.deviceId || commonjsGlobal.deviceId,
          appver: cookie3.appver || iosAppVersion,
          // appç‰ˆæœ¬
          versioncode: cookie3.versioncode || "140",
          //ç‰ˆæœ¬å·
          mobilename: cookie3.mobilename || "",
          //è®¾å¤‡model
          buildver: cookie3.buildver || Date.now().toString().substr(0, 10),
          resolution: cookie3.resolution || "1920x1080",
          //è®¾å¤‡åˆ†è¾¨çŽ‡
          __csrf: csrfToken,
          os: cookie3.os || "ios",
          channel: cookie3.channel || "",
          requestId: `${Date.now()}_${Math.floor(Math.random() * 1e3).toString().padStart(4, "0")}`
        };
        if (cookie3.MUSIC_U) header3["MUSIC_U"] = cookie3.MUSIC_U;
        if (cookie3.MUSIC_A) header3["MUSIC_A"] = cookie3.MUSIC_A;
        headers["Cookie"] = Object.keys(header3).map(
          (key) => encodeURIComponent(key) + "=" + encodeURIComponent(header3[key])
        ).join("; ");
        let eapi2 = () => {
          data2.header = header3;
          data2.e_r = options.e_r != void 0 ? options.e_r : data2.e_r != void 0 ? data2.e_r : APP_CONF.encryptResponse;
          encryptData = encrypt.eapi(uri2, data2);
          url2 = APP_CONF.apiDomain + "/eapi/" + uri2.substr(5);
        };
        let api2 = () => {
          url2 = APP_CONF.apiDomain + uri2;
          encryptData = data2;
        };
        if (crypto2 === "eapi") {
          eapi2();
        } else if (crypto2 === "api") {
          api2();
        }
        break;
      default:
        console.log("[ERR]", "Unknown Crypto:", crypto2);
        break;
    }
    const answer = { status: 500, body: {}, cookie: [] };
    let settings = {
      method,
      url: url2,
      headers,
      data: new URLSearchParams(encryptData).toString(),
      httpAgent: new http.Agent({ keepAlive: true }),
      httpsAgent: new https.Agent({ keepAlive: true })
    };
    if (data2.e_r) {
      settings = {
        ...settings,
        encoding: null,
        responseType: "arraybuffer"
      };
    }
    if (options.proxy) {
      if (options.proxy.indexOf("pac") > -1) {
        settings.httpAgent = new PacProxyAgent2(options.proxy);
        settings.httpsAgent = new PacProxyAgent2(options.proxy);
      } else {
        const purl = new URL$1(options.proxy);
        if (purl.hostname) {
          const agent = tunnel[purl.protocol === "https" ? "httpsOverHttp" : "httpOverHttp"]({
            proxy: {
              host: purl.hostname,
              port: purl.port || 80,
              proxyAuth: purl.username && purl.password ? purl.username + ":" + purl.password : ""
            }
          });
          settings.httpsAgent = agent;
          settings.httpAgent = agent;
          settings.proxy = false;
        } else {
          console.error("ä»£ç†é…ç½®æ— æ•ˆ,ä¸ä½¿ç”¨ä»£ç†");
        }
      }
    } else {
      settings.proxy = false;
    }
    axios(settings).then((res2) => {
      const body = res2.data;
      answer.cookie = (res2.headers["set-cookie"] || []).map(
        (x) => x.replace(/\s*Domain=[^(;|$)]+;*/, "")
      );
      try {
        if (data2.e_r) {
          answer.body = encrypt.eapiResDecrypt(
            body.toString("hex").toUpperCase()
          );
        } else {
          answer.body = typeof body == "object" ? body : JSON.parse(body.toString());
        }
        if (answer.body.code) {
          answer.body.code = Number(answer.body.code);
        }
        answer.status = Number(answer.body.code || res2.status);
        if ([201, 302, 400, 502, 800, 801, 802, 803].indexOf(answer.body.code) > -1) {
          answer.status = 200;
        }
      } catch (e) {
        answer.body = body;
        answer.status = res2.status;
      }
      answer.status = 100 < answer.status && answer.status < 600 ? answer.status : 400;
      if (answer.status === 200) resolve3(answer);
      else reject(answer);
    }).catch((err) => {
      answer.status = 502;
      answer.body = { code: 502, msg: err };
      reject(answer);
    });
  });
};
var request$1 = createRequest;
const name = "NeteaseCloudMusicApi";
const version = "4.22.0";
const description = "ç½‘æ˜“äº‘éŸ³ä¹ NodeJS ç‰ˆ API";
const scripts = {
  start: "node app.js",
  test: "mocha -r intelli-espower-loader -t 60000 server.test.js main.test.js --exit",
  lint: 'eslint "**/*.{js,ts}"',
  "lint-fix": 'eslint --fix "**/*.{js,ts}"',
  prepare: "husky install",
  pkgwin: "pkg . -t node18-win-x64 -C GZip -o bin/app --no-bytecode",
  pkglinux: "pkg . -t node18-linux-x64 -C GZip -o bin/app --no-bytecode",
  pkgmacos: "pkg . -t node18-macos-x64 -C GZip -o bin/app --no-bytecode"
};
const bin = "./app.js";
const pkg = {
  scripts: "module/*.js",
  assets: [
    "node_modules/axios",
    "node_modules/express",
    "node_modules/express-fileupload",
    "node_modules/md5",
    "node_modules/music-metadata",
    "node_modules/pac-proxy-agent",
    "node_modules/qrcode",
    "node_modules/safe-decode-uri-component",
    "node_modules/tunnel",
    "node_modules/yargs",
    "node_modules/tslib",
    "node_modules/vm2",
    "module",
    "public",
    "data"
  ]
};
const keywords = [
  "ç½‘æ˜“äº‘éŸ³ä¹",
  "ç½‘æ˜“äº‘",
  "éŸ³ä¹",
  "ç½‘æ˜“äº‘éŸ³ä¹nodejs"
];
const main = "main.js";
const types = "./interface.d.ts";
const engines = {
  node: ">=12"
};
const author = "binaryify";
const license = "MIT";
const files = [
  "module",
  "util",
  "plugins",
  "main.d.ts",
  "interface.d.ts",
  "module_types",
  "server.js",
  "generateConfig.js",
  "public",
  "data"
];
const dependencies = {
  axios: "^1.2.2",
  "crypto-js": "^4.2.0",
  express: "^4.17.1",
  "express-fileupload": "^1.1.9",
  md5: "^2.3.0",
  "music-metadata": "^7.5.3",
  "node-forge": "^1.3.1",
  "pac-proxy-agent": "^7.0.0",
  qrcode: "^1.4.4",
  "safe-decode-uri-component": "^1.2.1",
  tunnel: "^0.0.6",
  xml2js: "^0.6.2",
  yargs: "^17.1.1"
};
const devDependencies = {
  "@types/express": "^4.17.13",
  "@types/express-fileupload": "^1.2.2",
  "@types/mocha": "^9.1.0",
  "@types/node": "16.11.19",
  "@typescript-eslint/eslint-plugin": "5.0.0",
  "@typescript-eslint/parser": "5.0.0",
  eslint: "8.7.0",
  "eslint-config-prettier": "8.5.0",
  "eslint-plugin-html": "7.1.0",
  "eslint-plugin-prettier": "4.0.0",
  husky: "7.0.4",
  "intelli-espower-loader": "1.1.0",
  "lint-staged": "12.1.7",
  mocha: "10.0.0",
  pkg: "^5.8.0",
  "power-assert": "1.6.1",
  prettier: "2.7.1",
  typescript: "4.5.2"
};
const require$$4 = {
  name,
  version,
  description,
  scripts,
  bin,
  pkg,
  keywords,
  main,
  types,
  engines,
  "lint-staged": {
    "*.js": [
      "eslint --fix",
      "git add"
    ]
  },
  author,
  license,
  files,
  dependencies,
  devDependencies
};
function MemoryCache$1() {
  this.cache = {};
  this.size = 0;
}
MemoryCache$1.prototype.add = function(key, value2, time, timeoutCallback) {
  this.cache[key];
  var instance = this;
  var entry = {
    value: value2,
    expire: time + Date.now(),
    timeout: setTimeout(function() {
      instance.delete(key);
      return timeoutCallback && typeof timeoutCallback === "function" && timeoutCallback(value2, key);
    }, time)
  };
  this.cache[key] = entry;
  this.size = Object.keys(this.cache).length;
  return entry;
};
MemoryCache$1.prototype.delete = function(key) {
  var entry = this.cache[key];
  if (entry) {
    clearTimeout(entry.timeout);
  }
  delete this.cache[key];
  this.size = Object.keys(this.cache).length;
  return null;
};
MemoryCache$1.prototype.get = function(key) {
  var entry = this.cache[key];
  return entry;
};
MemoryCache$1.prototype.getValue = function(key) {
  var entry = this.get(key);
  return entry && entry.value;
};
MemoryCache$1.prototype.clear = function() {
  Object.keys(this.cache).forEach(function(key) {
    this.delete(key);
  }, this);
  return true;
};
var memoryCache = MemoryCache$1;
var url = require$$5$2;
var MemoryCache = memoryCache;
var t = {
  ms: 1,
  second: 1e3,
  minute: 6e4,
  hour: 36e5,
  day: 36e5 * 24,
  week: 36e5 * 24 * 7,
  month: 36e5 * 24 * 30
};
var instances = [];
var matches = function(a) {
  return function(b) {
    return a === b;
  };
};
var doesntMatch = function(a) {
  return function(b) {
    return !matches(a)(b);
  };
};
var logDuration = function(d2, prefix) {
  var str2 = d2 > 1e3 ? (d2 / 1e3).toFixed(2) + "sec" : d2 + "ms";
  return "\x1B[33m- " + (prefix ? prefix + " " : "") + str2 + "\x1B[0m";
};
function getSafeHeaders(res2) {
  return res2.getHeaders ? res2.getHeaders() : res2._headers;
}
function ApiCache() {
  var memCache = new MemoryCache();
  var globalOptions = {
    debug: false,
    defaultDuration: 36e5,
    enabled: true,
    appendKey: [],
    jsonp: false,
    redisClient: false,
    headerBlacklist: [],
    statusCodes: {
      include: [],
      exclude: []
    },
    events: {
      expire: void 0
    },
    headers: {
      // 'cache-control':  'no-cache' // example of header overwrite
    },
    trackPerformance: false
  };
  var middlewareOptions = [];
  var instance = this;
  var index2 = null;
  var timers = {};
  var performanceArray = [];
  instances.push(this);
  this.id = instances.length;
  function debug2(a, b, c, d2) {
    var arr = ["\x1B[36m[apicache]\x1B[0m", a, b, c, d2].filter(function(arg) {
      return arg !== void 0;
    });
    var debugEnv = process.env.DEBUG && process.env.DEBUG.split(",").indexOf("apicache") !== -1;
    return (globalOptions.debug || debugEnv) && console.log.apply(null, arr);
  }
  function shouldCacheResponse(request2, response2, toggle) {
    var opt = globalOptions;
    var codes2 = opt.statusCodes;
    if (!response2) return false;
    if (toggle && !toggle(request2, response2)) {
      return false;
    }
    if (codes2.exclude && codes2.exclude.length && codes2.exclude.indexOf(response2.statusCode) !== -1)
      return false;
    if (codes2.include && codes2.include.length && codes2.include.indexOf(response2.statusCode) === -1)
      return false;
    return true;
  }
  function addIndexEntries(key, req2) {
    var groupName = req2.apicacheGroup;
    if (groupName) {
      debug2('group detected "' + groupName + '"');
      var group = index2.groups[groupName] = index2.groups[groupName] || [];
      group.unshift(key);
    }
    index2.all.unshift(key);
  }
  function filterBlacklistedHeaders(headers) {
    return Object.keys(headers).filter(function(key) {
      return globalOptions.headerBlacklist.indexOf(key) === -1;
    }).reduce(function(acc, header3) {
      acc[header3] = headers[header3];
      return acc;
    }, {});
  }
  function createCacheObject(status3, headers, data2, encoding3) {
    return {
      status: status3,
      headers: filterBlacklistedHeaders(headers),
      data: data2,
      encoding: encoding3,
      timestamp: (/* @__PURE__ */ new Date()).getTime() / 1e3
      // seconds since epoch.  This is used to properly decrement max-age headers in cached responses.
    };
  }
  function cacheResponse(key, value2, duration) {
    var redis = globalOptions.redisClient;
    var expireCallback = globalOptions.events.expire;
    if (redis && redis.connected) {
      try {
        redis.hset(key, "response", JSON.stringify(value2));
        redis.hset(key, "duration", duration);
        redis.expire(key, duration / 1e3, expireCallback || function() {
        });
      } catch (err) {
        debug2("[apicache] error in redis.hset()");
      }
    } else {
      memCache.add(key, value2, duration, expireCallback);
    }
    timers[key] = setTimeout(function() {
      instance.clear(key, true);
    }, Math.min(duration, 2147483647));
  }
  function accumulateContent(res2, content) {
    if (content) {
      if (typeof content == "string") {
        res2._apicache.content = (res2._apicache.content || "") + content;
      } else if (Buffer.isBuffer(content)) {
        var oldContent = res2._apicache.content;
        if (typeof oldContent === "string") {
          oldContent = !Buffer.from ? new Buffer(oldContent) : Buffer.from(oldContent);
        }
        if (!oldContent) {
          oldContent = !Buffer.alloc ? new Buffer(0) : Buffer.alloc(0);
        }
        res2._apicache.content = Buffer.concat(
          [oldContent, content],
          oldContent.length + content.length
        );
      } else {
        res2._apicache.content = content;
      }
    }
  }
  function makeResponseCacheable(req2, res2, next, key, duration, strDuration, toggle) {
    res2._apicache = {
      write: res2.write,
      writeHead: res2.writeHead,
      end: res2.end,
      cacheable: true,
      content: void 0
    };
    Object.keys(globalOptions.headers).forEach(function(name2) {
      res2.setHeader(name2, globalOptions.headers[name2]);
    });
    res2.writeHead = function() {
      if (!globalOptions.headers["cache-control"]) {
        if (shouldCacheResponse(req2, res2, toggle)) {
          res2.setHeader(
            "cache-control",
            "max-age=" + (duration / 1e3).toFixed(0)
          );
        } else {
          res2.setHeader("cache-control", "no-cache, no-store, must-revalidate");
        }
      }
      res2._apicache.headers = Object.assign({}, getSafeHeaders(res2));
      return res2._apicache.writeHead.apply(this, arguments);
    };
    res2.write = function(content) {
      accumulateContent(res2, content);
      return res2._apicache.write.apply(this, arguments);
    };
    res2.end = function(content, encoding3) {
      if (shouldCacheResponse(req2, res2, toggle)) {
        accumulateContent(res2, content);
        if (res2._apicache.cacheable && res2._apicache.content) {
          addIndexEntries(key, req2);
          var headers = res2._apicache.headers || getSafeHeaders(res2);
          var cacheObject = createCacheObject(
            res2.statusCode,
            headers,
            res2._apicache.content,
            encoding3
          );
          cacheResponse(key, cacheObject, duration);
          var elapsed = /* @__PURE__ */ new Date() - req2.apicacheTimer;
          debug2(
            'adding cache entry for "' + key + '" @ ' + strDuration,
            logDuration(elapsed)
          );
          debug2("_apicache.headers: ", res2._apicache.headers);
          debug2("res.getHeaders(): ", getSafeHeaders(res2));
          debug2("cacheObject: ", cacheObject);
        }
      }
      return res2._apicache.end.apply(this, arguments);
    };
    next();
  }
  function sendCachedResponse(request2, response2, cacheObject, toggle, next, duration) {
    if (toggle && !toggle(request2, response2)) {
      return next();
    }
    var headers = getSafeHeaders(response2);
    Object.assign(
      headers,
      filterBlacklistedHeaders(cacheObject.headers || {}),
      {
        // set properly-decremented max-age header.  This ensures that max-age is in sync with the cache expiration.
        "cache-control": "max-age=" + Math.max(
          0,
          (duration / 1e3 - ((/* @__PURE__ */ new Date()).getTime() / 1e3 - cacheObject.timestamp)).toFixed(0)
        )
      }
    );
    var data2 = cacheObject.data;
    if (data2 && data2.type === "Buffer") {
      data2 = typeof data2.data === "number" ? new Buffer.alloc(data2.data) : new Buffer.from(data2.data);
    }
    var cachedEtag = cacheObject.headers.etag;
    var requestEtag = request2.headers["if-none-match"];
    if (requestEtag && cachedEtag === requestEtag) {
      response2.writeHead(304, headers);
      return response2.end();
    }
    response2.writeHead(cacheObject.status || 200, headers);
    return response2.end(data2, cacheObject.encoding);
  }
  function syncOptions() {
    for (var i in middlewareOptions) {
      Object.assign(
        middlewareOptions[i].options,
        globalOptions,
        middlewareOptions[i].localOptions
      );
    }
  }
  this.clear = function(target, isAutomatic) {
    var group = index2.groups[target];
    var redis = globalOptions.redisClient;
    if (group) {
      debug2('clearing group "' + target + '"');
      group.forEach(function(key) {
        debug2('clearing cached entry for "' + key + '"');
        clearTimeout(timers[key]);
        delete timers[key];
        if (!globalOptions.redisClient) {
          memCache.delete(key);
        } else {
          try {
            redis.del(key);
          } catch (err) {
            console.log('[apicache] error in redis.del("' + key + '")');
          }
        }
        index2.all = index2.all.filter(doesntMatch(key));
      });
      delete index2.groups[target];
    } else if (target) {
      debug2(
        "clearing " + (isAutomatic ? "expired" : "cached") + ' entry for "' + target + '"'
      );
      clearTimeout(timers[target]);
      delete timers[target];
      if (!redis) {
        memCache.delete(target);
      } else {
        try {
          redis.del(target);
        } catch (err) {
          console.log('[apicache] error in redis.del("' + target + '")');
        }
      }
      index2.all = index2.all.filter(doesntMatch(target));
      Object.keys(index2.groups).forEach(function(groupName) {
        index2.groups[groupName] = index2.groups[groupName].filter(
          doesntMatch(target)
        );
        if (!index2.groups[groupName].length) {
          delete index2.groups[groupName];
        }
      });
    } else {
      debug2("clearing entire index");
      if (!redis) {
        memCache.clear();
      } else {
        index2.all.forEach(function(key) {
          clearTimeout(timers[key]);
          delete timers[key];
          try {
            redis.del(key);
          } catch (err) {
            console.log('[apicache] error in redis.del("' + key + '")');
          }
        });
      }
      this.resetIndex();
    }
    return this.getIndex();
  };
  function parseDuration(duration, defaultDuration) {
    if (typeof duration === "number") return duration;
    if (typeof duration === "string") {
      var split = duration.match(/^([\d\.,]+)\s?(\w+)$/);
      if (split.length === 3) {
        var len = parseFloat(split[1]);
        var unit = split[2].replace(/s$/i, "").toLowerCase();
        if (unit === "m") {
          unit = "ms";
        }
        return (len || 1) * (t[unit] || 0);
      }
    }
    return defaultDuration;
  }
  this.getDuration = function(duration) {
    return parseDuration(duration, globalOptions.defaultDuration);
  };
  this.getPerformance = function() {
    return performanceArray.map(function(p) {
      return p.report();
    });
  };
  this.getIndex = function(group) {
    if (group) {
      return index2.groups[group];
    } else {
      return index2;
    }
  };
  this.middleware = function cache2(strDuration, middlewareToggle, localOptions) {
    var duration = instance.getDuration(strDuration);
    var opt = {};
    middlewareOptions.push({
      options: opt
    });
    var options = function(localOptions2) {
      if (localOptions2) {
        middlewareOptions.find(function(middleware) {
          return middleware.options === opt;
        }).localOptions = localOptions2;
      }
      syncOptions();
      return opt;
    };
    options(localOptions);
    function NOOPCachePerformance() {
      this.report = this.hit = this.miss = function() {
      };
    }
    function CachePerformance() {
      this.hitsLast100 = new Uint8Array(100 / 4);
      this.hitsLast1000 = new Uint8Array(1e3 / 4);
      this.hitsLast10000 = new Uint8Array(1e4 / 4);
      this.hitsLast100000 = new Uint8Array(1e5 / 4);
      this.callCount = 0;
      this.hitCount = 0;
      this.lastCacheHit = null;
      this.lastCacheMiss = null;
      this.report = function() {
        return {
          lastCacheHit: this.lastCacheHit,
          lastCacheMiss: this.lastCacheMiss,
          callCount: this.callCount,
          hitCount: this.hitCount,
          missCount: this.callCount - this.hitCount,
          hitRate: this.callCount == 0 ? null : this.hitCount / this.callCount,
          hitRateLast100: this.hitRate(this.hitsLast100),
          hitRateLast1000: this.hitRate(this.hitsLast1000),
          hitRateLast10000: this.hitRate(this.hitsLast10000),
          hitRateLast100000: this.hitRate(this.hitsLast100000)
        };
      };
      this.hitRate = function(array2) {
        var hits = 0;
        var misses = 0;
        for (var i = 0; i < array2.length; i++) {
          var n8 = array2[i];
          for (j = 0; j < 4; j++) {
            switch (n8 & 3) {
              case 1:
                hits++;
                break;
              case 2:
                misses++;
                break;
            }
            n8 >>= 2;
          }
        }
        var total = hits + misses;
        if (total == 0) return null;
        return hits / total;
      };
      this.recordHitInArray = function(array2, hit) {
        var arrayIndex = ~~(this.callCount / 4) % array2.length;
        var bitOffset = this.callCount % 4 * 2;
        var clearMask = ~(3 << bitOffset);
        var record = (hit ? 1 : 2) << bitOffset;
        array2[arrayIndex] = array2[arrayIndex] & clearMask | record;
      };
      this.recordHit = function(hit) {
        this.recordHitInArray(this.hitsLast100, hit);
        this.recordHitInArray(this.hitsLast1000, hit);
        this.recordHitInArray(this.hitsLast10000, hit);
        this.recordHitInArray(this.hitsLast100000, hit);
        if (hit) this.hitCount++;
        this.callCount++;
      };
      this.hit = function(key) {
        this.recordHit(true);
        this.lastCacheHit = key;
      };
      this.miss = function(key) {
        this.recordHit(false);
        this.lastCacheMiss = key;
      };
    }
    var perf = globalOptions.trackPerformance ? new CachePerformance() : new NOOPCachePerformance();
    performanceArray.push(perf);
    var cache22 = function(req2, res2, next) {
      function bypass() {
        debug2("bypass detected, skipping cache.");
        return next();
      }
      if (!opt.enabled) return bypass();
      if (req2.headers["x-apicache-bypass"] || req2.headers["x-apicache-force-fetch"])
        return bypass();
      req2.apicacheTimer = /* @__PURE__ */ new Date();
      var key = req2.hostname + (req2.originalUrl || req2.url) + JSON.stringify(req2.cookies);
      if (opt.jsonp) {
        key = url.parse(key).pathname;
      }
      if (typeof opt.appendKey === "function") {
        key += "$$appendKey=" + opt.appendKey(req2, res2);
      } else if (opt.appendKey.length > 0) {
        var appendKey = req2;
        for (var i = 0; i < opt.appendKey.length; i++) {
          appendKey = appendKey[opt.appendKey[i]];
        }
        key += "$$appendKey=" + appendKey;
      }
      var redis = opt.redisClient;
      var cached = !redis ? memCache.getValue(key) : null;
      if (cached) {
        var elapsed = /* @__PURE__ */ new Date() - req2.apicacheTimer;
        debug2(
          "sending cached (memory-cache) version of",
          key,
          logDuration(elapsed)
        );
        perf.hit(key);
        return sendCachedResponse(
          req2,
          res2,
          cached,
          middlewareToggle,
          next,
          duration
        );
      }
      if (redis && redis.connected) {
        try {
          redis.hgetall(key, function(err, obj) {
            if (!err && obj && obj.response) {
              var elapsed2 = /* @__PURE__ */ new Date() - req2.apicacheTimer;
              debug2(
                "sending cached (redis) version of",
                key,
                logDuration(elapsed2)
              );
              perf.hit(key);
              return sendCachedResponse(
                req2,
                res2,
                JSON.parse(obj.response),
                middlewareToggle,
                next,
                duration
              );
            } else {
              perf.miss(key);
              return makeResponseCacheable(
                req2,
                res2,
                next,
                key,
                duration,
                strDuration,
                middlewareToggle
              );
            }
          });
        } catch (err) {
          perf.miss(key);
          return makeResponseCacheable(
            req2,
            res2,
            next,
            key,
            duration,
            strDuration,
            middlewareToggle
          );
        }
      } else {
        perf.miss(key);
        return makeResponseCacheable(
          req2,
          res2,
          next,
          key,
          duration,
          strDuration,
          middlewareToggle
        );
      }
    };
    cache22.options = options;
    return cache22;
  };
  this.options = function(options) {
    if (options) {
      Object.assign(globalOptions, options);
      syncOptions();
      if ("defaultDuration" in options) {
        globalOptions.defaultDuration = parseDuration(
          globalOptions.defaultDuration,
          36e5
        );
      }
      if (globalOptions.trackPerformance) {
        debug2(
          "WARNING: using trackPerformance flag can cause high memory usage!"
        );
      }
      return this;
    } else {
      return globalOptions;
    }
  };
  this.resetIndex = function() {
    index2 = {
      all: [],
      groups: {}
    };
  };
  this.newInstance = function(config) {
    var instance2 = new ApiCache();
    if (config) {
      instance2.options(config);
    }
    return instance2;
  };
  this.clone = function() {
    return this.newInstance(this.options());
  };
  this.resetIndex();
}
var apicache = new ApiCache();
function parseContentType$2(str2) {
  if (str2.length === 0)
    return;
  const params = /* @__PURE__ */ Object.create(null);
  let i = 0;
  for (; i < str2.length; ++i) {
    const code2 = str2.charCodeAt(i);
    if (TOKEN$1[code2] !== 1) {
      if (code2 !== 47 || i === 0)
        return;
      break;
    }
  }
  if (i === str2.length)
    return;
  const type3 = str2.slice(0, i).toLowerCase();
  const subtypeStart = ++i;
  for (; i < str2.length; ++i) {
    const code2 = str2.charCodeAt(i);
    if (TOKEN$1[code2] !== 1) {
      if (i === subtypeStart)
        return;
      if (parseContentTypeParams(str2, i, params) === void 0)
        return;
      break;
    }
  }
  if (i === subtypeStart)
    return;
  const subtype = str2.slice(subtypeStart, i).toLowerCase();
  return { type: type3, subtype, params };
}
function parseContentTypeParams(str2, i, params) {
  while (i < str2.length) {
    for (; i < str2.length; ++i) {
      const code2 = str2.charCodeAt(i);
      if (code2 !== 32 && code2 !== 9)
        break;
    }
    if (i === str2.length)
      break;
    if (str2.charCodeAt(i++) !== 59)
      return;
    for (; i < str2.length; ++i) {
      const code2 = str2.charCodeAt(i);
      if (code2 !== 32 && code2 !== 9)
        break;
    }
    if (i === str2.length)
      return;
    let name2;
    const nameStart = i;
    for (; i < str2.length; ++i) {
      const code2 = str2.charCodeAt(i);
      if (TOKEN$1[code2] !== 1) {
        if (code2 !== 61)
          return;
        break;
      }
    }
    if (i === str2.length)
      return;
    name2 = str2.slice(nameStart, i);
    ++i;
    if (i === str2.length)
      return;
    let value2 = "";
    let valueStart;
    if (str2.charCodeAt(i) === 34) {
      valueStart = ++i;
      let escaping = false;
      for (; i < str2.length; ++i) {
        const code2 = str2.charCodeAt(i);
        if (code2 === 92) {
          if (escaping) {
            valueStart = i;
            escaping = false;
          } else {
            value2 += str2.slice(valueStart, i);
            escaping = true;
          }
          continue;
        }
        if (code2 === 34) {
          if (escaping) {
            valueStart = i;
            escaping = false;
            continue;
          }
          value2 += str2.slice(valueStart, i);
          break;
        }
        if (escaping) {
          valueStart = i - 1;
          escaping = false;
        }
        if (QDTEXT[code2] !== 1)
          return;
      }
      if (i === str2.length)
        return;
      ++i;
    } else {
      valueStart = i;
      for (; i < str2.length; ++i) {
        const code2 = str2.charCodeAt(i);
        if (TOKEN$1[code2] !== 1) {
          if (i === valueStart)
            return;
          break;
        }
      }
      value2 = str2.slice(valueStart, i);
    }
    name2 = name2.toLowerCase();
    if (params[name2] === void 0)
      params[name2] = value2;
  }
  return params;
}
function parseDisposition$1(str2, defDecoder) {
  if (str2.length === 0)
    return;
  const params = /* @__PURE__ */ Object.create(null);
  let i = 0;
  for (; i < str2.length; ++i) {
    const code2 = str2.charCodeAt(i);
    if (TOKEN$1[code2] !== 1) {
      if (parseDispositionParams(str2, i, params, defDecoder) === void 0)
        return;
      break;
    }
  }
  const type3 = str2.slice(0, i).toLowerCase();
  return { type: type3, params };
}
function parseDispositionParams(str2, i, params, defDecoder) {
  while (i < str2.length) {
    for (; i < str2.length; ++i) {
      const code2 = str2.charCodeAt(i);
      if (code2 !== 32 && code2 !== 9)
        break;
    }
    if (i === str2.length)
      break;
    if (str2.charCodeAt(i++) !== 59)
      return;
    for (; i < str2.length; ++i) {
      const code2 = str2.charCodeAt(i);
      if (code2 !== 32 && code2 !== 9)
        break;
    }
    if (i === str2.length)
      return;
    let name2;
    const nameStart = i;
    for (; i < str2.length; ++i) {
      const code2 = str2.charCodeAt(i);
      if (TOKEN$1[code2] !== 1) {
        if (code2 === 61)
          break;
        return;
      }
    }
    if (i === str2.length)
      return;
    let value2 = "";
    let valueStart;
    let charset3;
    name2 = str2.slice(nameStart, i);
    if (name2.charCodeAt(name2.length - 1) === 42) {
      const charsetStart = ++i;
      for (; i < str2.length; ++i) {
        const code2 = str2.charCodeAt(i);
        if (CHARSET[code2] !== 1) {
          if (code2 !== 39)
            return;
          break;
        }
      }
      if (i === str2.length)
        return;
      charset3 = str2.slice(charsetStart, i);
      ++i;
      for (; i < str2.length; ++i) {
        const code2 = str2.charCodeAt(i);
        if (code2 === 39)
          break;
      }
      if (i === str2.length)
        return;
      ++i;
      if (i === str2.length)
        return;
      valueStart = i;
      let encode2 = 0;
      for (; i < str2.length; ++i) {
        const code2 = str2.charCodeAt(i);
        if (EXTENDED_VALUE[code2] !== 1) {
          if (code2 === 37) {
            let hexUpper;
            let hexLower;
            if (i + 2 < str2.length && (hexUpper = HEX_VALUES$1[str2.charCodeAt(i + 1)]) !== -1 && (hexLower = HEX_VALUES$1[str2.charCodeAt(i + 2)]) !== -1) {
              const byteVal = (hexUpper << 4) + hexLower;
              value2 += str2.slice(valueStart, i);
              value2 += String.fromCharCode(byteVal);
              i += 2;
              valueStart = i + 1;
              if (byteVal >= 128)
                encode2 = 2;
              else if (encode2 === 0)
                encode2 = 1;
              continue;
            }
            return;
          }
          break;
        }
      }
      value2 += str2.slice(valueStart, i);
      value2 = convertToUTF8$1(value2, charset3, encode2);
      if (value2 === void 0)
        return;
    } else {
      ++i;
      if (i === str2.length)
        return;
      if (str2.charCodeAt(i) === 34) {
        valueStart = ++i;
        let escaping = false;
        for (; i < str2.length; ++i) {
          const code2 = str2.charCodeAt(i);
          if (code2 === 92) {
            if (escaping) {
              valueStart = i;
              escaping = false;
            } else {
              value2 += str2.slice(valueStart, i);
              escaping = true;
            }
            continue;
          }
          if (code2 === 34) {
            if (escaping) {
              valueStart = i;
              escaping = false;
              continue;
            }
            value2 += str2.slice(valueStart, i);
            break;
          }
          if (escaping) {
            valueStart = i - 1;
            escaping = false;
          }
          if (QDTEXT[code2] !== 1)
            return;
        }
        if (i === str2.length)
          return;
        ++i;
      } else {
        valueStart = i;
        for (; i < str2.length; ++i) {
          const code2 = str2.charCodeAt(i);
          if (TOKEN$1[code2] !== 1) {
            if (i === valueStart)
              return;
            break;
          }
        }
        value2 = str2.slice(valueStart, i);
      }
      value2 = defDecoder(value2, 2);
      if (value2 === void 0)
        return;
    }
    name2 = name2.toLowerCase();
    if (params[name2] === void 0)
      params[name2] = value2;
  }
  return params;
}
function getDecoder$2(charset3) {
  let lc;
  while (true) {
    switch (charset3) {
      case "utf-8":
      case "utf8":
        return decoders.utf8;
      case "latin1":
      case "ascii":
      case "us-ascii":
      case "iso-8859-1":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "windows-1252":
      case "iso_8859-1:1987":
      case "cp1252":
      case "x-cp1252":
        return decoders.latin1;
      case "utf16le":
      case "utf-16le":
      case "ucs2":
      case "ucs-2":
        return decoders.utf16le;
      case "base64":
        return decoders.base64;
      default:
        if (lc === void 0) {
          lc = true;
          charset3 = charset3.toLowerCase();
          continue;
        }
        return decoders.other.bind(charset3);
    }
  }
}
const decoders = {
  utf8: (data2, hint) => {
    if (data2.length === 0)
      return "";
    if (typeof data2 === "string") {
      if (hint < 2)
        return data2;
      data2 = Buffer.from(data2, "latin1");
    }
    return data2.utf8Slice(0, data2.length);
  },
  latin1: (data2, hint) => {
    if (data2.length === 0)
      return "";
    if (typeof data2 === "string")
      return data2;
    return data2.latin1Slice(0, data2.length);
  },
  utf16le: (data2, hint) => {
    if (data2.length === 0)
      return "";
    if (typeof data2 === "string")
      data2 = Buffer.from(data2, "latin1");
    return data2.ucs2Slice(0, data2.length);
  },
  base64: (data2, hint) => {
    if (data2.length === 0)
      return "";
    if (typeof data2 === "string")
      data2 = Buffer.from(data2, "latin1");
    return data2.base64Slice(0, data2.length);
  },
  other: (data2, hint) => {
    if (data2.length === 0)
      return "";
    if (typeof data2 === "string")
      data2 = Buffer.from(data2, "latin1");
    try {
      const decoder = new TextDecoder(void 0);
      return decoder.decode(data2);
    } catch {
    }
  }
};
function convertToUTF8$1(data2, charset3, hint) {
  const decode2 = getDecoder$2(charset3);
  if (decode2)
    return decode2(data2, hint);
}
function basename$1(path3) {
  if (typeof path3 !== "string")
    return "";
  for (let i = path3.length - 1; i >= 0; --i) {
    switch (path3.charCodeAt(i)) {
      case 47:
      case 92:
        path3 = path3.slice(i + 1);
        return path3 === ".." || path3 === "." ? "" : path3;
    }
  }
  return path3 === ".." || path3 === "." ? "" : path3;
}
const TOKEN$1 = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const QDTEXT = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1
];
const CHARSET = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const EXTENDED_VALUE = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const HEX_VALUES$1 = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
];
var utils = {
  basename: basename$1,
  convertToUTF8: convertToUTF8$1,
  getDecoder: getDecoder$2,
  parseContentType: parseContentType$2,
  parseDisposition: parseDisposition$1
};
function memcmp(buf1, pos1, buf2, pos2, num) {
  for (let i = 0; i < num; ++i) {
    if (buf1[pos1 + i] !== buf2[pos2 + i])
      return false;
  }
  return true;
}
class SBMH {
  constructor(needle, cb) {
    if (typeof cb !== "function")
      throw new Error("Missing match callback");
    if (typeof needle === "string")
      needle = Buffer.from(needle);
    else if (!Buffer.isBuffer(needle))
      throw new Error(`Expected Buffer for needle, got ${typeof needle}`);
    const needleLen = needle.length;
    this.maxMatches = Infinity;
    this.matches = 0;
    this._cb = cb;
    this._lookbehindSize = 0;
    this._needle = needle;
    this._bufPos = 0;
    this._lookbehind = Buffer.allocUnsafe(needleLen);
    this._occ = [
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen,
      needleLen
    ];
    if (needleLen > 1) {
      for (let i = 0; i < needleLen - 1; ++i)
        this._occ[needle[i]] = needleLen - 1 - i;
    }
  }
  reset() {
    this.matches = 0;
    this._lookbehindSize = 0;
    this._bufPos = 0;
  }
  push(chunk, pos) {
    let result;
    if (!Buffer.isBuffer(chunk))
      chunk = Buffer.from(chunk, "latin1");
    const chunkLen = chunk.length;
    this._bufPos = pos || 0;
    while (result !== chunkLen && this.matches < this.maxMatches)
      result = feed(this, chunk);
    return result;
  }
  destroy() {
    const lbSize = this._lookbehindSize;
    if (lbSize)
      this._cb(false, this._lookbehind, 0, lbSize, false);
    this.reset();
  }
}
function feed(self3, data2) {
  const len = data2.length;
  const needle = self3._needle;
  const needleLen = needle.length;
  let pos = -self3._lookbehindSize;
  const lastNeedleCharPos = needleLen - 1;
  const lastNeedleChar = needle[lastNeedleCharPos];
  const end = len - needleLen;
  const occ = self3._occ;
  const lookbehind = self3._lookbehind;
  if (pos < 0) {
    while (pos < 0 && pos <= end) {
      const nextPos = pos + lastNeedleCharPos;
      const ch = nextPos < 0 ? lookbehind[self3._lookbehindSize + nextPos] : data2[nextPos];
      if (ch === lastNeedleChar && matchNeedle(self3, data2, pos, lastNeedleCharPos)) {
        self3._lookbehindSize = 0;
        ++self3.matches;
        if (pos > -self3._lookbehindSize)
          self3._cb(true, lookbehind, 0, self3._lookbehindSize + pos, false);
        else
          self3._cb(true, void 0, 0, 0, true);
        return self3._bufPos = pos + needleLen;
      }
      pos += occ[ch];
    }
    while (pos < 0 && !matchNeedle(self3, data2, pos, len - pos))
      ++pos;
    if (pos < 0) {
      const bytesToCutOff = self3._lookbehindSize + pos;
      if (bytesToCutOff > 0) {
        self3._cb(false, lookbehind, 0, bytesToCutOff, false);
      }
      self3._lookbehindSize -= bytesToCutOff;
      lookbehind.copy(lookbehind, 0, bytesToCutOff, self3._lookbehindSize);
      lookbehind.set(data2, self3._lookbehindSize);
      self3._lookbehindSize += len;
      self3._bufPos = len;
      return len;
    }
    self3._cb(false, lookbehind, 0, self3._lookbehindSize, false);
    self3._lookbehindSize = 0;
  }
  pos += self3._bufPos;
  const firstNeedleChar = needle[0];
  while (pos <= end) {
    const ch = data2[pos + lastNeedleCharPos];
    if (ch === lastNeedleChar && data2[pos] === firstNeedleChar && memcmp(needle, 0, data2, pos, lastNeedleCharPos)) {
      ++self3.matches;
      if (pos > 0)
        self3._cb(true, data2, self3._bufPos, pos, true);
      else
        self3._cb(true, void 0, 0, 0, true);
      return self3._bufPos = pos + needleLen;
    }
    pos += occ[ch];
  }
  while (pos < len) {
    if (data2[pos] !== firstNeedleChar || !memcmp(data2, pos, needle, 0, len - pos)) {
      ++pos;
      continue;
    }
    data2.copy(lookbehind, 0, pos, len);
    self3._lookbehindSize = len - pos;
    break;
  }
  if (pos > 0)
    self3._cb(false, data2, self3._bufPos, pos < len ? pos : len, true);
  self3._bufPos = len;
  return len;
}
function matchNeedle(self3, data2, pos, len) {
  const lb = self3._lookbehind;
  const lbSize = self3._lookbehindSize;
  const needle = self3._needle;
  for (let i = 0; i < len; ++i, ++pos) {
    const ch = pos < 0 ? lb[lbSize + pos] : data2[pos];
    if (ch !== needle[i])
      return false;
  }
  return true;
}
var sbmh = SBMH;
const { Readable: Readable$1, Writable: Writable$1 } = require$$1$4;
const StreamSearch = sbmh;
const {
  basename,
  convertToUTF8,
  getDecoder: getDecoder$1,
  parseContentType: parseContentType$1,
  parseDisposition
} = utils;
const BUF_CRLF = Buffer.from("\r\n");
const BUF_CR = Buffer.from("\r");
const BUF_DASH = Buffer.from("-");
function noop$1() {
}
const MAX_HEADER_PAIRS = 2e3;
const MAX_HEADER_SIZE = 16 * 1024;
const HPARSER_NAME = 0;
const HPARSER_PRE_OWS = 1;
const HPARSER_VALUE = 2;
class HeaderParser {
  constructor(cb) {
    this.header = /* @__PURE__ */ Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = "";
    this.value = "";
    this.crlf = 0;
    this.cb = cb;
  }
  reset() {
    this.header = /* @__PURE__ */ Object.create(null);
    this.pairCount = 0;
    this.byteCount = 0;
    this.state = HPARSER_NAME;
    this.name = "";
    this.value = "";
    this.crlf = 0;
  }
  push(chunk, pos, end) {
    let start = pos;
    while (pos < end) {
      switch (this.state) {
        case HPARSER_NAME: {
          let done = false;
          for (; pos < end; ++pos) {
            if (this.byteCount === MAX_HEADER_SIZE)
              return -1;
            ++this.byteCount;
            const code2 = chunk[pos];
            if (TOKEN[code2] !== 1) {
              if (code2 !== 58)
                return -1;
              this.name += chunk.latin1Slice(start, pos);
              if (this.name.length === 0)
                return -1;
              ++pos;
              done = true;
              this.state = HPARSER_PRE_OWS;
              break;
            }
          }
          if (!done) {
            this.name += chunk.latin1Slice(start, pos);
            break;
          }
        }
        case HPARSER_PRE_OWS: {
          let done = false;
          for (; pos < end; ++pos) {
            if (this.byteCount === MAX_HEADER_SIZE)
              return -1;
            ++this.byteCount;
            const code2 = chunk[pos];
            if (code2 !== 32 && code2 !== 9) {
              start = pos;
              done = true;
              this.state = HPARSER_VALUE;
              break;
            }
          }
          if (!done)
            break;
        }
        case HPARSER_VALUE:
          switch (this.crlf) {
            case 0:
              for (; pos < end; ++pos) {
                if (this.byteCount === MAX_HEADER_SIZE)
                  return -1;
                ++this.byteCount;
                const code2 = chunk[pos];
                if (FIELD_VCHAR[code2] !== 1) {
                  if (code2 !== 13)
                    return -1;
                  ++this.crlf;
                  break;
                }
              }
              this.value += chunk.latin1Slice(start, pos++);
              break;
            case 1:
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              if (chunk[pos++] !== 10)
                return -1;
              ++this.crlf;
              break;
            case 2: {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              const code2 = chunk[pos];
              if (code2 === 32 || code2 === 9) {
                start = pos;
                this.crlf = 0;
              } else {
                if (++this.pairCount < MAX_HEADER_PAIRS) {
                  this.name = this.name.toLowerCase();
                  if (this.header[this.name] === void 0)
                    this.header[this.name] = [this.value];
                  else
                    this.header[this.name].push(this.value);
                }
                if (code2 === 13) {
                  ++this.crlf;
                  ++pos;
                } else {
                  start = pos;
                  this.crlf = 0;
                  this.state = HPARSER_NAME;
                  this.name = "";
                  this.value = "";
                }
              }
              break;
            }
            case 3: {
              if (this.byteCount === MAX_HEADER_SIZE)
                return -1;
              ++this.byteCount;
              if (chunk[pos++] !== 10)
                return -1;
              const header3 = this.header;
              this.reset();
              this.cb(header3);
              return pos;
            }
          }
          break;
      }
    }
    return pos;
  }
}
class FileStream extends Readable$1 {
  constructor(opts, owner) {
    super(opts);
    this.truncated = false;
    this._readcb = null;
    this.once("end", () => {
      this._read();
      if (--owner._fileEndsLeft === 0 && owner._finalcb) {
        const cb = owner._finalcb;
        owner._finalcb = null;
        process.nextTick(cb);
      }
    });
  }
  _read(n) {
    const cb = this._readcb;
    if (cb) {
      this._readcb = null;
      cb();
    }
  }
}
const ignoreData = {
  push: (chunk, pos) => {
  },
  destroy: () => {
  }
};
function callAndUnsetCb(self3, err) {
  const cb = self3._writecb;
  self3._writecb = null;
  if (cb)
    cb();
}
function nullDecoder(val, hint) {
  return val;
}
class Multipart extends Writable$1 {
  constructor(cfg) {
    const streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
    };
    super(streamOpts);
    if (!cfg.conType.params || typeof cfg.conType.params.boundary !== "string")
      throw new Error("Multipart: Boundary not found");
    const boundary = cfg.conType.params.boundary;
    const paramDecoder = typeof cfg.defParamCharset === "string" && cfg.defParamCharset ? getDecoder$1(cfg.defParamCharset) : nullDecoder;
    const defCharset = cfg.defCharset || "utf8";
    const preservePath = cfg.preservePath;
    const fileOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.fileHwm === "number" ? cfg.fileHwm : void 0
    };
    const limits = cfg.limits;
    const fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
    const fileSizeLimit = limits && typeof limits.fileSize === "number" ? limits.fileSize : Infinity;
    const filesLimit = limits && typeof limits.files === "number" ? limits.files : Infinity;
    const fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
    const partsLimit = limits && typeof limits.parts === "number" ? limits.parts : Infinity;
    let parts = -1;
    let fields = 0;
    let files2 = 0;
    let skipPart = false;
    this._fileEndsLeft = 0;
    this._fileStream = void 0;
    this._complete = false;
    let fileSize = 0;
    let field;
    let fieldSize = 0;
    let partCharset;
    let partEncoding;
    let partType;
    let partName;
    let partTruncated = false;
    let hitFilesLimit = false;
    let hitFieldsLimit = false;
    this._hparser = null;
    const hparser = new HeaderParser((header3) => {
      this._hparser = null;
      skipPart = false;
      partType = "text/plain";
      partCharset = defCharset;
      partEncoding = "7bit";
      partName = void 0;
      partTruncated = false;
      let filename;
      if (!header3["content-disposition"]) {
        skipPart = true;
        return;
      }
      const disp = parseDisposition(
        header3["content-disposition"][0],
        paramDecoder
      );
      if (!disp || disp.type !== "form-data") {
        skipPart = true;
        return;
      }
      if (disp.params) {
        if (disp.params.name)
          partName = disp.params.name;
        if (disp.params["filename*"])
          filename = disp.params["filename*"];
        else if (disp.params.filename)
          filename = disp.params.filename;
        if (filename !== void 0 && !preservePath)
          filename = basename(filename);
      }
      if (header3["content-type"]) {
        const conType = parseContentType$1(header3["content-type"][0]);
        if (conType) {
          partType = `${conType.type}/${conType.subtype}`;
          if (conType.params && typeof conType.params.charset === "string")
            partCharset = conType.params.charset.toLowerCase();
        }
      }
      if (header3["content-transfer-encoding"])
        partEncoding = header3["content-transfer-encoding"][0].toLowerCase();
      if (partType === "application/octet-stream" || filename !== void 0) {
        if (files2 === filesLimit) {
          if (!hitFilesLimit) {
            hitFilesLimit = true;
            this.emit("filesLimit");
          }
          skipPart = true;
          return;
        }
        ++files2;
        if (this.listenerCount("file") === 0) {
          skipPart = true;
          return;
        }
        fileSize = 0;
        this._fileStream = new FileStream(fileOpts, this);
        ++this._fileEndsLeft;
        this.emit(
          "file",
          partName,
          this._fileStream,
          {
            filename,
            encoding: partEncoding,
            mimeType: partType
          }
        );
      } else {
        if (fields === fieldsLimit) {
          if (!hitFieldsLimit) {
            hitFieldsLimit = true;
            this.emit("fieldsLimit");
          }
          skipPart = true;
          return;
        }
        ++fields;
        if (this.listenerCount("field") === 0) {
          skipPart = true;
          return;
        }
        field = [];
        fieldSize = 0;
      }
    });
    let matchPostBoundary = 0;
    const ssCb = (isMatch, data2, start, end, isDataSafe) => {
      retrydata:
        while (data2) {
          if (this._hparser !== null) {
            const ret = this._hparser.push(data2, start, end);
            if (ret === -1) {
              this._hparser = null;
              hparser.reset();
              this.emit("error", new Error("Malformed part header"));
              break;
            }
            start = ret;
          }
          if (start === end)
            break;
          if (matchPostBoundary !== 0) {
            if (matchPostBoundary === 1) {
              switch (data2[start]) {
                case 45:
                  matchPostBoundary = 2;
                  ++start;
                  break;
                case 13:
                  matchPostBoundary = 3;
                  ++start;
                  break;
                default:
                  matchPostBoundary = 0;
              }
              if (start === end)
                return;
            }
            if (matchPostBoundary === 2) {
              matchPostBoundary = 0;
              if (data2[start] === 45) {
                this._complete = true;
                this._bparser = ignoreData;
                return;
              }
              const writecb = this._writecb;
              this._writecb = noop$1;
              ssCb(false, BUF_DASH, 0, 1, false);
              this._writecb = writecb;
            } else if (matchPostBoundary === 3) {
              matchPostBoundary = 0;
              if (data2[start] === 10) {
                ++start;
                if (parts >= partsLimit)
                  break;
                this._hparser = hparser;
                if (start === end)
                  break;
                continue retrydata;
              } else {
                const writecb = this._writecb;
                this._writecb = noop$1;
                ssCb(false, BUF_CR, 0, 1, false);
                this._writecb = writecb;
              }
            }
          }
          if (!skipPart) {
            if (this._fileStream) {
              let chunk;
              const actualLen = Math.min(end - start, fileSizeLimit - fileSize);
              if (!isDataSafe) {
                chunk = Buffer.allocUnsafe(actualLen);
                data2.copy(chunk, 0, start, start + actualLen);
              } else {
                chunk = data2.slice(start, start + actualLen);
              }
              fileSize += chunk.length;
              if (fileSize === fileSizeLimit) {
                if (chunk.length > 0)
                  this._fileStream.push(chunk);
                this._fileStream.emit("limit");
                this._fileStream.truncated = true;
                skipPart = true;
              } else if (!this._fileStream.push(chunk)) {
                if (this._writecb)
                  this._fileStream._readcb = this._writecb;
                this._writecb = null;
              }
            } else if (field !== void 0) {
              let chunk;
              const actualLen = Math.min(
                end - start,
                fieldSizeLimit - fieldSize
              );
              if (!isDataSafe) {
                chunk = Buffer.allocUnsafe(actualLen);
                data2.copy(chunk, 0, start, start + actualLen);
              } else {
                chunk = data2.slice(start, start + actualLen);
              }
              fieldSize += actualLen;
              field.push(chunk);
              if (fieldSize === fieldSizeLimit) {
                skipPart = true;
                partTruncated = true;
              }
            }
          }
          break;
        }
      if (isMatch) {
        matchPostBoundary = 1;
        if (this._fileStream) {
          this._fileStream.push(null);
          this._fileStream = null;
        } else if (field !== void 0) {
          let data3;
          switch (field.length) {
            case 0:
              data3 = "";
              break;
            case 1:
              data3 = convertToUTF8(field[0], partCharset, 0);
              break;
            default:
              data3 = convertToUTF8(
                Buffer.concat(field, fieldSize),
                partCharset,
                0
              );
          }
          field = void 0;
          fieldSize = 0;
          this.emit(
            "field",
            partName,
            data3,
            {
              nameTruncated: false,
              valueTruncated: partTruncated,
              encoding: partEncoding,
              mimeType: partType
            }
          );
        }
        if (++parts === partsLimit)
          this.emit("partsLimit");
      }
    };
    this._bparser = new StreamSearch(`\r
--${boundary}`, ssCb);
    this._writecb = null;
    this._finalcb = null;
    this.write(BUF_CRLF);
  }
  static detect(conType) {
    return conType.type === "multipart" && conType.subtype === "form-data";
  }
  _write(chunk, enc, cb) {
    this._writecb = cb;
    this._bparser.push(chunk, 0);
    if (this._writecb)
      callAndUnsetCb(this);
  }
  _destroy(err, cb) {
    this._hparser = null;
    this._bparser = ignoreData;
    if (!err)
      err = checkEndState(this);
    const fileStream = this._fileStream;
    if (fileStream) {
      this._fileStream = null;
      fileStream.destroy(err);
    }
    cb(err);
  }
  _final(cb) {
    this._bparser.destroy();
    if (!this._complete)
      return cb(new Error("Unexpected end of form"));
    if (this._fileEndsLeft)
      this._finalcb = finalcb.bind(null, this, cb);
    else
      finalcb(this, cb);
  }
}
function finalcb(self3, cb, err) {
  if (err)
    return cb(err);
  err = checkEndState(self3);
  cb(err);
}
function checkEndState(self3) {
  if (self3._hparser)
    return new Error("Malformed part header");
  const fileStream = self3._fileStream;
  if (fileStream) {
    self3._fileStream = null;
    fileStream.destroy(new Error("Unexpected end of file"));
  }
  if (!self3._complete)
    return new Error("Unexpected end of form");
}
const TOKEN = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  1,
  1,
  0,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
];
const FIELD_VCHAR = [
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1
];
var multipart = Multipart;
const { Writable } = require$$1$4;
const { getDecoder } = utils;
class URLEncoded extends Writable {
  constructor(cfg) {
    const streamOpts = {
      autoDestroy: true,
      emitClose: true,
      highWaterMark: typeof cfg.highWaterMark === "number" ? cfg.highWaterMark : void 0
    };
    super(streamOpts);
    let charset3 = cfg.defCharset || "utf8";
    if (cfg.conType.params && typeof cfg.conType.params.charset === "string")
      charset3 = cfg.conType.params.charset;
    this.charset = charset3;
    const limits = cfg.limits;
    this.fieldSizeLimit = limits && typeof limits.fieldSize === "number" ? limits.fieldSize : 1 * 1024 * 1024;
    this.fieldsLimit = limits && typeof limits.fields === "number" ? limits.fields : Infinity;
    this.fieldNameSizeLimit = limits && typeof limits.fieldNameSize === "number" ? limits.fieldNameSize : 100;
    this._inKey = true;
    this._keyTrunc = false;
    this._valTrunc = false;
    this._bytesKey = 0;
    this._bytesVal = 0;
    this._fields = 0;
    this._key = "";
    this._val = "";
    this._byte = -2;
    this._lastPos = 0;
    this._encode = 0;
    this._decoder = getDecoder(charset3);
  }
  static detect(conType) {
    return conType.type === "application" && conType.subtype === "x-www-form-urlencoded";
  }
  _write(chunk, enc, cb) {
    if (this._fields >= this.fieldsLimit)
      return cb();
    let i = 0;
    const len = chunk.length;
    this._lastPos = 0;
    if (this._byte !== -2) {
      i = readPctEnc(this, chunk, i, len);
      if (i === -1)
        return cb(new Error("Malformed urlencoded form"));
      if (i >= len)
        return cb();
      if (this._inKey)
        ++this._bytesKey;
      else
        ++this._bytesVal;
    }
    main:
      while (i < len) {
        if (this._inKey) {
          i = skipKeyBytes(this, chunk, i, len);
          while (i < len) {
            switch (chunk[i]) {
              case 61:
                if (this._lastPos < i)
                  this._key += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = ++i;
                this._key = this._decoder(this._key, this._encode);
                this._encode = 0;
                this._inKey = false;
                continue main;
              case 38:
                if (this._lastPos < i)
                  this._key += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = ++i;
                this._key = this._decoder(this._key, this._encode);
                this._encode = 0;
                if (this._bytesKey > 0) {
                  this.emit(
                    "field",
                    this._key,
                    "",
                    {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: false,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    }
                  );
                }
                this._key = "";
                this._val = "";
                this._keyTrunc = false;
                this._valTrunc = false;
                this._bytesKey = 0;
                this._bytesVal = 0;
                if (++this._fields >= this.fieldsLimit) {
                  this.emit("fieldsLimit");
                  return cb();
                }
                continue;
              case 43:
                if (this._lastPos < i)
                  this._key += chunk.latin1Slice(this._lastPos, i);
                this._key += " ";
                this._lastPos = i + 1;
                break;
              case 37:
                if (this._encode === 0)
                  this._encode = 1;
                if (this._lastPos < i)
                  this._key += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = i + 1;
                this._byte = -1;
                i = readPctEnc(this, chunk, i + 1, len);
                if (i === -1)
                  return cb(new Error("Malformed urlencoded form"));
                if (i >= len)
                  return cb();
                ++this._bytesKey;
                i = skipKeyBytes(this, chunk, i, len);
                continue;
            }
            ++i;
            ++this._bytesKey;
            i = skipKeyBytes(this, chunk, i, len);
          }
          if (this._lastPos < i)
            this._key += chunk.latin1Slice(this._lastPos, i);
        } else {
          i = skipValBytes(this, chunk, i, len);
          while (i < len) {
            switch (chunk[i]) {
              case 38:
                if (this._lastPos < i)
                  this._val += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = ++i;
                this._inKey = true;
                this._val = this._decoder(this._val, this._encode);
                this._encode = 0;
                if (this._bytesKey > 0 || this._bytesVal > 0) {
                  this.emit(
                    "field",
                    this._key,
                    this._val,
                    {
                      nameTruncated: this._keyTrunc,
                      valueTruncated: this._valTrunc,
                      encoding: this.charset,
                      mimeType: "text/plain"
                    }
                  );
                }
                this._key = "";
                this._val = "";
                this._keyTrunc = false;
                this._valTrunc = false;
                this._bytesKey = 0;
                this._bytesVal = 0;
                if (++this._fields >= this.fieldsLimit) {
                  this.emit("fieldsLimit");
                  return cb();
                }
                continue main;
              case 43:
                if (this._lastPos < i)
                  this._val += chunk.latin1Slice(this._lastPos, i);
                this._val += " ";
                this._lastPos = i + 1;
                break;
              case 37:
                if (this._encode === 0)
                  this._encode = 1;
                if (this._lastPos < i)
                  this._val += chunk.latin1Slice(this._lastPos, i);
                this._lastPos = i + 1;
                this._byte = -1;
                i = readPctEnc(this, chunk, i + 1, len);
                if (i === -1)
                  return cb(new Error("Malformed urlencoded form"));
                if (i >= len)
                  return cb();
                ++this._bytesVal;
                i = skipValBytes(this, chunk, i, len);
                continue;
            }
            ++i;
            ++this._bytesVal;
            i = skipValBytes(this, chunk, i, len);
          }
          if (this._lastPos < i)
            this._val += chunk.latin1Slice(this._lastPos, i);
        }
      }
    cb();
  }
  _final(cb) {
    if (this._byte !== -2)
      return cb(new Error("Malformed urlencoded form"));
    if (!this._inKey || this._bytesKey > 0 || this._bytesVal > 0) {
      if (this._inKey)
        this._key = this._decoder(this._key, this._encode);
      else
        this._val = this._decoder(this._val, this._encode);
      this.emit(
        "field",
        this._key,
        this._val,
        {
          nameTruncated: this._keyTrunc,
          valueTruncated: this._valTrunc,
          encoding: this.charset,
          mimeType: "text/plain"
        }
      );
    }
    cb();
  }
}
function readPctEnc(self3, chunk, pos, len) {
  if (pos >= len)
    return len;
  if (self3._byte === -1) {
    const hexUpper = HEX_VALUES[chunk[pos++]];
    if (hexUpper === -1)
      return -1;
    if (hexUpper >= 8)
      self3._encode = 2;
    if (pos < len) {
      const hexLower = HEX_VALUES[chunk[pos++]];
      if (hexLower === -1)
        return -1;
      if (self3._inKey)
        self3._key += String.fromCharCode((hexUpper << 4) + hexLower);
      else
        self3._val += String.fromCharCode((hexUpper << 4) + hexLower);
      self3._byte = -2;
      self3._lastPos = pos;
    } else {
      self3._byte = hexUpper;
    }
  } else {
    const hexLower = HEX_VALUES[chunk[pos++]];
    if (hexLower === -1)
      return -1;
    if (self3._inKey)
      self3._key += String.fromCharCode((self3._byte << 4) + hexLower);
    else
      self3._val += String.fromCharCode((self3._byte << 4) + hexLower);
    self3._byte = -2;
    self3._lastPos = pos;
  }
  return pos;
}
function skipKeyBytes(self3, chunk, pos, len) {
  if (self3._bytesKey > self3.fieldNameSizeLimit) {
    if (!self3._keyTrunc) {
      if (self3._lastPos < pos)
        self3._key += chunk.latin1Slice(self3._lastPos, pos - 1);
    }
    self3._keyTrunc = true;
    for (; pos < len; ++pos) {
      const code2 = chunk[pos];
      if (code2 === 61 || code2 === 38)
        break;
      ++self3._bytesKey;
    }
    self3._lastPos = pos;
  }
  return pos;
}
function skipValBytes(self3, chunk, pos, len) {
  if (self3._bytesVal > self3.fieldSizeLimit) {
    if (!self3._valTrunc) {
      if (self3._lastPos < pos)
        self3._val += chunk.latin1Slice(self3._lastPos, pos - 1);
    }
    self3._valTrunc = true;
    for (; pos < len; ++pos) {
      if (chunk[pos] === 38)
        break;
      ++self3._bytesVal;
    }
    self3._lastPos = pos;
  }
  return pos;
}
const HEX_VALUES = [
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  10,
  11,
  12,
  13,
  14,
  15,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1,
  -1
];
var urlencoded = URLEncoded;
const { parseContentType } = utils;
function getInstance(cfg) {
  const headers = cfg.headers;
  const conType = parseContentType(headers["content-type"]);
  if (!conType)
    throw new Error("Malformed content type");
  for (const type3 of TYPES) {
    const matched = type3.detect(conType);
    if (!matched)
      continue;
    const instanceCfg = {
      limits: cfg.limits,
      headers,
      conType,
      highWaterMark: void 0,
      fileHwm: void 0,
      defCharset: void 0,
      defParamCharset: void 0,
      preservePath: false
    };
    if (cfg.highWaterMark)
      instanceCfg.highWaterMark = cfg.highWaterMark;
    if (cfg.fileHwm)
      instanceCfg.fileHwm = cfg.fileHwm;
    instanceCfg.defCharset = cfg.defCharset;
    instanceCfg.defParamCharset = cfg.defParamCharset;
    instanceCfg.preservePath = cfg.preservePath;
    return new type3(instanceCfg);
  }
  throw new Error(`Unsupported content type: ${headers["content-type"]}`);
}
const TYPES = [
  multipart,
  urlencoded
].filter(function(typemod) {
  return typeof typemod.detect === "function";
});
var lib$1 = (cfg) => {
  if (typeof cfg !== "object" || cfg === null)
    cfg = {};
  if (typeof cfg.headers !== "object" || cfg.headers === null || typeof cfg.headers["content-type"] !== "string") {
    throw new Error("Missing Content-Type");
  }
  return getInstance(cfg);
};
let UploadTimer$1 = class UploadTimer {
  /**
   * @constructor
   * @param {number} timeout - timer timeout in msecs.
   * @param {Function} callback - callback to run when timeout reached.
   */
  constructor(timeout, callback) {
    this.timeout = timeout || 0;
    this.callback = callback || (() => {
    });
    this.timer = null;
  }
  /**
   * Sets the timer.
   * Initializes & starts the timer.
   * @returns {boolean} True if timer has been set.
   */
  set() {
    if (this.timer || !this.timeout) return false;
    this.timer = setTimeout(() => {
      this.clear();
      this.callback();
    }, this.timeout);
    return true;
  }
  /**
   * Clears the timer.
   * If timer cleared, it has to be re-initialized again with set method.
   */
  clear() {
    clearTimeout(this.timer);
  }
  /**
   * Refreshes timer.
   * @returns {boolean} True if timer has been refreshed.
   */
  refresh() {
    if (!this.timer) return false;
    this.timer.refresh();
    return true;
  }
};
var uploadtimer = UploadTimer$1;
const fs$2 = require$$0$7;
const path$3 = require$$1$2;
const crypto$2 = require$$2$3;
const { Readable } = require$$1$4;
const SAFE_FILE_NAME_REGEX = /[^\w-]/g;
const MAX_EXTENSION_LENGTH = 3;
const TEMP_COUNTER_MAX = 65536;
const TEMP_PREFIX = "tmp";
let tempCounter = 0;
const debugLog$5 = (options, msg) => {
  const opts = options || {};
  if (!opts.debug || !opts.logger || typeof opts.logger.log !== "function") return false;
  opts.logger.log(`Express-file-upload: ${msg}`);
  return true;
};
const getTempFilename$1 = (prefix = TEMP_PREFIX) => {
  tempCounter = tempCounter >= TEMP_COUNTER_MAX ? 1 : tempCounter + 1;
  return `${prefix}-${tempCounter}-${Date.now()}`;
};
const isFunc$2 = (func) => func && func.constructor && func.call && func.apply ? true : false;
const errorFunc = (resolve3, reject) => isFunc$2(reject) ? reject : resolve3;
const promiseCallback$1 = (resolve3, reject) => {
  let hasFired = false;
  return (err) => {
    if (hasFired) {
      return;
    }
    hasFired = true;
    return err ? errorFunc(resolve3, reject)(err) : resolve3();
  };
};
const buildOptions$2 = function() {
  const result = {};
  [...arguments].forEach((options) => {
    if (!options || typeof options !== "object") return;
    Object.keys(options).forEach((i) => result[i] = options[i]);
  });
  if (crypto$2.getHashes().find((h2) => result.hashAlgorithm === h2) === void 0) {
    throw Error(
      `Hashing algorithm '${result.hashAlgorithm}' is not supported by this system's OpenSSL version`
    );
  }
  return result;
};
const OBJECT_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Object.prototype);
const ARRAY_PROTOTYPE_KEYS = Object.getOwnPropertyNames(Array.prototype);
const isSafeFromPollution$1 = (base, key) => {
  const TOUCHES_ARRAY_PROTOTYPE = base instanceof Array && ARRAY_PROTOTYPE_KEYS.includes(key);
  const TOUCHES_OBJECT_PROTOTYPE = OBJECT_PROTOTYPE_KEYS.includes(key);
  return !TOUCHES_ARRAY_PROTOTYPE && !TOUCHES_OBJECT_PROTOTYPE;
};
const buildFields$1 = (instance, field, value2) => {
  if (value2 === null || value2 === void 0) return instance;
  instance = instance || /* @__PURE__ */ Object.create(null);
  if (!isSafeFromPollution$1(instance, field)) {
    return instance;
  }
  if (!instance[field]) {
    instance[field] = value2;
    return instance;
  }
  if (instance[field] instanceof Array) {
    instance[field].push(value2);
  } else {
    instance[field] = [instance[field], value2];
  }
  return instance;
};
const checkAndMakeDir$2 = (fileUploadOptions, filePath) => {
  if (!fileUploadOptions) return false;
  if (!fileUploadOptions.createParentPath) return false;
  if (!filePath) return false;
  const parentPath = path$3.dirname(filePath);
  if (!fs$2.existsSync(parentPath)) fs$2.mkdirSync(parentPath, { recursive: true });
  return fs$2.existsSync(parentPath);
};
const deleteFile$1 = (file2, callback) => fs$2.unlink(file2, callback);
const copyFile = (src2, dst, callback) => {
  let cbCalled = false;
  let runCb = (err) => {
    if (cbCalled) return;
    cbCalled = true;
    callback(err);
  };
  let readable = fs$2.createReadStream(src2);
  readable.on("error", runCb);
  let writable = fs$2.createWriteStream(dst);
  writable.on("error", (err) => {
    readable.destroy();
    runCb(err);
  });
  writable.on("close", () => runCb());
  readable.pipe(writable);
};
const moveFile$1 = (src2, dst, callback) => fs$2.rename(src2, dst, (err) => {
  if (err) {
    copyFile(src2, dst, (cpErr) => cpErr ? callback(cpErr) : deleteFile$1(src2, callback));
    return;
  }
  callback(null, true);
});
const saveBufferToFile$1 = (buffer, filePath, callback) => {
  if (!Buffer.isBuffer(buffer)) {
    return callback(new Error("buffer variable should be type of Buffer!"));
  }
  let streamData = buffer;
  let readStream2 = Readable();
  readStream2._read = () => {
    readStream2.push(streamData);
    streamData = null;
  };
  let fstream = fs$2.createWriteStream(filePath);
  fstream.on("error", (err) => {
    callback(err);
  });
  fstream.on("close", () => {
    callback();
  });
  readStream2.pipe(fstream);
};
const uriDecodeFileName = (opts, fileName) => {
  if (!opts || !opts.uriDecodeFileNames) {
    return fileName;
  }
  try {
    return decodeURIComponent(fileName);
  } catch (err) {
    const matcher = /(%[a-f0-9]{2})/gi;
    return fileName.split(matcher).map((str2) => {
      try {
        return decodeURIComponent(str2);
      } catch (err2) {
        return "";
      }
    }).join("");
  }
};
const parseFileNameExtension = (preserveExtension, fileName) => {
  const preserveExtensionLength = parseInt(preserveExtension);
  const result = { name: fileName, extension: "" };
  if (!preserveExtension && preserveExtensionLength !== 0) return result;
  const maxExtLength = isNaN(preserveExtensionLength) ? MAX_EXTENSION_LENGTH : Math.abs(preserveExtensionLength);
  const nameParts = fileName.split(".");
  if (nameParts.length < 2) return result;
  let extension = nameParts.pop();
  if (extension.length > maxExtLength && maxExtLength > 0) {
    nameParts[nameParts.length - 1] += "." + extension.substr(0, extension.length - maxExtLength);
    extension = extension.substr(-maxExtLength);
  }
  result.extension = maxExtLength ? extension : "";
  result.name = nameParts.join(".");
  return result;
};
const parseFileName$1 = (opts, fileName) => {
  if (!fileName || typeof fileName !== "string") return getTempFilename$1();
  let parsedName = fileName.length <= 255 ? fileName : fileName.substr(0, 255);
  parsedName = uriDecodeFileName(opts, parsedName);
  if (!opts.safeFileNames) return parsedName;
  const nameRegex = typeof opts.safeFileNames === "object" && opts.safeFileNames instanceof RegExp ? opts.safeFileNames : SAFE_FILE_NAME_REGEX;
  let { name: name2, extension } = parseFileNameExtension(opts.preserveExtension, parsedName);
  if (extension.length) extension = "." + extension.replace(nameRegex, "");
  return name2.replace(nameRegex, "").concat(extension);
};
var utilities = {
  isFunc: isFunc$2,
  debugLog: debugLog$5,
  copyFile,
  // For testing purpose.
  moveFile: moveFile$1,
  errorFunc,
  deleteFile: deleteFile$1,
  // For testing purpose.
  buildFields: buildFields$1,
  buildOptions: buildOptions$2,
  parseFileName: parseFileName$1,
  getTempFilename: getTempFilename$1,
  promiseCallback: promiseCallback$1,
  checkAndMakeDir: checkAndMakeDir$2,
  saveBufferToFile: saveBufferToFile$1,
  uriDecodeFileName,
  isSafeFromPollution: isSafeFromPollution$1
};
const {
  isFunc: isFunc$1,
  debugLog: debugLog$4,
  moveFile,
  promiseCallback,
  checkAndMakeDir: checkAndMakeDir$1,
  saveBufferToFile
} = utilities;
const moveFromTemp = (filePath, options, fileUploadOptions) => (resolve3, reject) => {
  debugLog$4(fileUploadOptions, `Moving temporary file ${options.tempFilePath} to ${filePath}`);
  moveFile(options.tempFilePath, filePath, promiseCallback(resolve3, reject));
};
const moveFromBuffer = (filePath, options, fileUploadOptions) => (resolve3, reject) => {
  debugLog$4(fileUploadOptions, `Moving uploaded buffer to ${filePath}`);
  saveBufferToFile(options.buffer, filePath, promiseCallback(resolve3, reject));
};
var fileFactory$1 = (options, fileUploadOptions = {}) => {
  return {
    name: options.name,
    data: options.buffer,
    size: options.size,
    encoding: options.encoding,
    tempFilePath: options.tempFilePath,
    truncated: options.truncated,
    mimetype: options.mimetype,
    md5: options.hash,
    mv: (filePath, callback) => {
      const moveFunc = fileUploadOptions.useTempFiles ? moveFromTemp(filePath, options, fileUploadOptions) : moveFromBuffer(filePath, options, fileUploadOptions);
      checkAndMakeDir$1(fileUploadOptions, filePath);
      return isFunc$1(callback) ? moveFunc(callback) : new Promise(moveFunc);
    }
  };
};
const crypto$1 = require$$2$3;
const { debugLog: debugLog$3 } = utilities;
var memHandler$1 = (options, fieldname, filename) => {
  const buffers = [];
  const hash2 = crypto$1.createHash(options.hashAlgorithm);
  let fileSize = 0;
  let completed = false;
  const getBuffer = () => Buffer.concat(buffers, fileSize);
  return {
    dataHandler: (data2) => {
      if (completed === true) {
        debugLog$3(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);
        return;
      }
      buffers.push(data2);
      hash2.update(data2);
      fileSize += data2.length;
      debugLog$3(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);
    },
    getBuffer,
    getFilePath: () => "",
    getFileSize: () => fileSize,
    getHash: () => hash2.digest("hex"),
    complete: () => {
      debugLog$3(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);
      completed = true;
      return getBuffer();
    },
    cleanup: () => {
      completed = true;
    },
    getWritePromise: () => Promise.resolve()
  };
};
const fs$1 = require$$0$7;
const path$2 = require$$1$2;
const crypto = require$$2$3;
const {
  debugLog: debugLog$2,
  checkAndMakeDir,
  getTempFilename,
  deleteFile
} = utilities;
var tempFileHandler$1 = (options, fieldname, filename) => {
  const dir = path$2.normalize(options.tempFileDir);
  const tempFilePath = path$2.join(dir, getTempFilename());
  checkAndMakeDir({ createParentPath: true }, tempFilePath);
  debugLog$2(options, `Temporary file path is ${tempFilePath}`);
  const hash2 = crypto.createHash(options.hashAlgorithm);
  let fileSize = 0;
  let completed = false;
  debugLog$2(options, `Opening write stream for ${fieldname}->${filename}...`);
  const writeStream = fs$1.createWriteStream(tempFilePath);
  const writePromise = new Promise((resolve3, reject) => {
    writeStream.on("finish", () => resolve3());
    writeStream.on("error", (err) => {
      debugLog$2(options, `Error write temp file: ${err}`);
      reject(err);
    });
  });
  return {
    dataHandler: (data2) => {
      if (completed === true) {
        debugLog$2(options, `Error: got ${fieldname}->${filename} data chunk for completed upload!`);
        return;
      }
      writeStream.write(data2);
      hash2.update(data2);
      fileSize += data2.length;
      debugLog$2(options, `Uploading ${fieldname}->${filename}, bytes:${fileSize}...`);
    },
    getFilePath: () => tempFilePath,
    getFileSize: () => fileSize,
    getHash: () => hash2.digest("hex"),
    complete: () => {
      completed = true;
      debugLog$2(options, `Upload ${fieldname}->${filename} completed, bytes:${fileSize}.`);
      if (writeStream !== false) writeStream.end();
      return Buffer.concat([]);
    },
    cleanup: () => {
      completed = true;
      debugLog$2(options, `Cleaning up temporary file ${tempFilePath}...`);
      writeStream.end();
      deleteFile(tempFilePath, (err) => err ? debugLog$2(options, `Cleaning up temporary file ${tempFilePath} failed: ${err}`) : debugLog$2(options, `Cleaning up temporary file ${tempFilePath} done.`));
    },
    getWritePromise: () => writePromise
  };
};
const { isSafeFromPollution } = utilities;
var processNested$1 = function(data2) {
  if (!data2 || data2.length < 1) return /* @__PURE__ */ Object.create(null);
  let d2 = /* @__PURE__ */ Object.create(null), keys2 = Object.keys(data2);
  for (let i = 0; i < keys2.length; i++) {
    let key = keys2[i], value2 = data2[key], current = d2, keyParts = key.replace(new RegExp(/\[/g), ".").replace(new RegExp(/\]/g), "").split(".");
    for (let index2 = 0; index2 < keyParts.length; index2++) {
      let k = keyParts[index2];
      if (!isSafeFromPollution(current, k)) {
        continue;
      }
      if (index2 >= keyParts.length - 1) {
        current[k] = value2;
      } else {
        if (!current[k]) current[k] = !isNaN(keyParts[index2 + 1]) ? [] : /* @__PURE__ */ Object.create(null);
        current = current[k];
      }
    }
  }
  return d2;
};
const Busboy = lib$1;
const UploadTimer2 = uploadtimer;
const fileFactory = fileFactory$1;
const memHandler = memHandler$1;
const tempFileHandler = tempFileHandler$1;
const processNested = processNested$1;
const {
  isFunc,
  debugLog: debugLog$1,
  buildFields,
  buildOptions: buildOptions$1,
  parseFileName
} = utilities;
const waitFlushProperty = Symbol("wait flush property symbol");
var processMultipart$1 = (options, req2, res2, next) => {
  req2.files = null;
  const busboyOptions = buildOptions$1(options, { headers: req2.headers });
  const busboy = Busboy(busboyOptions);
  const closeConnection = (code2, reason) => {
    req2.unpipe(busboy);
    req2.resume();
    if (res2.headersSent) {
      debugLog$1(options, "Headers already sent, can't close connection.");
      return;
    }
    const resCode = code2;
    const resReason = reason || "Bad Request";
    debugLog$1(options, `Closing connection with ${resCode}: ${resReason}`);
    res2.writeHead(resCode, { Connection: "close" });
    res2.end(resReason);
  };
  if (req2.body instanceof Buffer) {
    req2.body = /* @__PURE__ */ Object.create(null);
  }
  busboy.on("field", (field, val) => req2.body = buildFields(req2.body, field, val));
  busboy.on("file", (field, file2, info) => {
    const { filename: name2, encoding: encoding3, mimeType: mime2 } = info;
    const filename = parseFileName(options, name2);
    const {
      dataHandler,
      getFilePath,
      getFileSize,
      getHash,
      complete,
      cleanup,
      getWritePromise
    } = options.useTempFiles ? tempFileHandler(options, field, filename) : memHandler(options, field, filename);
    const writePromise = options.useTempFiles ? getWritePromise().catch((err) => {
      req2.unpipe(busboy);
      req2.resume();
      cleanup();
      next(err);
    }) : getWritePromise();
    const uploadTimer = new UploadTimer2(options.uploadTimeout, () => {
      file2.removeAllListeners("data");
      file2.resume();
      const err = new Error(`Upload timeout for ${field}->${filename}, bytes:${getFileSize()}`);
      return isFunc(file2.destroy) ? file2.destroy(err) : file2.emit("error", err);
    });
    file2.on("limit", () => {
      debugLog$1(options, `Size limit reached for ${field}->${filename}, bytes:${getFileSize()}`);
      uploadTimer.clear();
      if (isFunc(options.limitHandler)) {
        options.limitHandler(req2, res2, next);
      }
      if (options.abortOnLimit) {
        debugLog$1(options, `Aborting upload because of size limit ${field}->${filename}.`);
        closeConnection(413, options.responseOnLimit);
        cleanup();
      }
    });
    file2.on("data", (data2) => {
      uploadTimer.refresh();
      dataHandler(data2);
    });
    file2.on("end", () => {
      const size = getFileSize();
      debugLog$1(options, `Upload finished ${field}->${filename}, bytes:${size}`);
      uploadTimer.clear();
      if (!name2 && size === 0) {
        if (options.useTempFiles) {
          cleanup();
          debugLog$1(options, `Removing the empty file ${field}->${filename}`);
        }
        return debugLog$1(options, `Don't add file instance if original name and size are empty`);
      }
      req2.files = buildFields(req2.files, field, fileFactory({
        buffer: complete(),
        name: filename,
        tempFilePath: getFilePath(),
        hash: getHash(),
        size,
        encoding: encoding3,
        truncated: file2.truncated,
        mimetype: mime2
      }, options));
      if (!req2[waitFlushProperty]) {
        req2[waitFlushProperty] = [];
      }
      req2[waitFlushProperty].push(writePromise);
    });
    file2.on("error", (err) => {
      uploadTimer.clear();
      debugLog$1(options, err);
      cleanup();
      next();
    });
    debugLog$1(options, `New upload started ${field}->${filename}, bytes:${getFileSize()}`);
    uploadTimer.set();
  });
  busboy.on("finish", () => {
    debugLog$1(options, `Busboy finished parsing request.`);
    if (options.parseNested) {
      req2.body = processNested(req2.body);
      req2.files = processNested(req2.files);
    }
    if (!req2[waitFlushProperty]) return next();
    Promise.all(req2[waitFlushProperty]).then(() => {
      delete req2[waitFlushProperty];
      next();
    });
  });
  busboy.on("error", (err) => {
    debugLog$1(options, `Busboy error`);
    next(err);
  });
  req2.pipe(busboy);
};
const ACCEPTABLE_CONTENT_TYPE = /^multipart\/[\w'"()+-_?/:=,.]+(?:; ?[\w'"()+-_?/:=,.]*)+$/i;
const UNACCEPTABLE_METHODS = /* @__PURE__ */ new Set(["GET", "HEAD", "DELETE", "OPTIONS", "CONNECT", "TRACE"]);
const hasBody = (req2) => {
  return "transfer-encoding" in req2.headers || "content-length" in req2.headers && req2.headers["content-length"] !== "0";
};
const hasAcceptableMethod = (req2) => !UNACCEPTABLE_METHODS.has(req2.method);
const hasAcceptableContentType = (req2) => {
  const contType = req2.headers["content-type"];
  return contType.includes("boundary=") && ACCEPTABLE_CONTENT_TYPE.test(contType);
};
var isEligibleRequest$1 = (req2) => {
  try {
    return hasBody(req2) && hasAcceptableMethod(req2) && hasAcceptableContentType(req2);
  } catch (e) {
    return false;
  }
};
const path$1 = require$$1$2;
const processMultipart = processMultipart$1;
const isEligibleRequest = isEligibleRequest$1;
const { buildOptions, debugLog } = utilities;
const DEFAULT_OPTIONS = {
  debug: false,
  logger: console,
  uploadTimeout: 6e4,
  fileHandler: false,
  uriDecodeFileNames: false,
  safeFileNames: false,
  preserveExtension: false,
  abortOnLimit: false,
  responseOnLimit: "File size limit has been reached",
  limitHandler: false,
  createParentPath: false,
  parseNested: false,
  useTempFiles: false,
  tempFileDir: path$1.join(process.cwd(), "tmp"),
  hashAlgorithm: "md5"
};
var lib = (options) => {
  const uploadOptions = buildOptions(DEFAULT_OPTIONS, options);
  return (req2, res2, next) => {
    if (!isEligibleRequest(req2)) {
      debugLog(uploadOptions, "Request is not eligible for file upload!");
      return next();
    }
    processMultipart(uploadOptions, req2, res2, next);
  };
};
var src = function decodeURIComponent2(string2) {
  var k = string2.indexOf("%");
  if (k === -1) return string2;
  var length = string2.length;
  var decoded = "";
  var last = 0;
  var codepoint = 0;
  var startOfOctets = k;
  state$1 = UTF8_ACCEPT;
  while (k > -1 && k < length - 2) {
    var high = hexCodeToInt(string2[k + 1], 4);
    var low = hexCodeToInt(string2[k + 2], 0);
    codepoint = decode$1(codepoint, high | low);
    switch (state$1) {
      case UTF8_ACCEPT:
        decoded += string2.substring(last, startOfOctets);
        decoded += codepoint <= 65535 ? String.fromCharCode(codepoint) : String.fromCharCode(
          55232 + (codepoint >> 10),
          56320 + (codepoint & 1023)
        );
        codepoint = 0;
        last = k + 3;
        k = startOfOctets = string2.indexOf("%", last);
        break;
      default:
        k += 3;
        if (k < length && string2[k] === "%") break;
      case UTF8_REJECT:
        state$1 = UTF8_ACCEPT;
        codepoint = 0;
        k = startOfOctets = string2.indexOf("%", startOfOctets + 1);
        break;
    }
  }
  return decoded + string2.substring(last);
};
var HEX = Object.assign(/* @__PURE__ */ Object.create(null), {
  "0": 0,
  "1": 1,
  "2": 2,
  "3": 3,
  "4": 4,
  "5": 5,
  "6": 6,
  "7": 7,
  "8": 8,
  "9": 9,
  "a": 10,
  "A": 10,
  "b": 11,
  "B": 11,
  "c": 12,
  "C": 12,
  "d": 13,
  "D": 13,
  "e": 14,
  "E": 14,
  "f": 15,
  "F": 15
});
function hexCodeToInt(c, shift) {
  var i = HEX[c];
  return i === void 0 ? 255 : i << shift;
}
var UTF8_ACCEPT = 12;
var UTF8_REJECT = 0;
var UTF8_DATA = [
  // The first part of the table maps bytes to character to a transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  3,
  4,
  4,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  5,
  6,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  7,
  8,
  7,
  7,
  10,
  9,
  9,
  9,
  11,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  4,
  // The second part of the table maps a state to a new state when adding a
  // transition.
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  12,
  0,
  0,
  0,
  0,
  24,
  36,
  48,
  60,
  72,
  84,
  96,
  0,
  12,
  12,
  12,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  24,
  24,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  48,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  // The third part maps the current transition to a mask that needs to apply
  // to the byte.
  127,
  63,
  63,
  63,
  0,
  31,
  15,
  15,
  15,
  7,
  7,
  7
];
var state$1 = UTF8_ACCEPT;
function decode$1(codepoint, byte) {
  var type3 = UTF8_DATA[byte];
  state$1 = UTF8_DATA[256 + state$1 + type3];
  return codepoint << 6 | byte & UTF8_DATA[364 + type3];
}
const fs = require$$0$7;
const path2 = require$$1$2;
const express = express$1;
const request = request$1;
const packageJSON = require$$4;
const exec = require$$5$4.exec;
const cache = apicache.middleware;
const { cookieToJson } = util;
const fileUpload = lib;
const decode = src;
const VERSION_CHECK_RESULT = {
  FAILED: -1,
  NOT_LATEST: 0,
  LATEST: 1
};
async function getModulesDefinitions(modulesPath, specificRoute, doRequire = true) {
  const files2 = await fs.promises.readdir(modulesPath);
  const parseRoute = (fileName) => specificRoute && fileName in specificRoute ? specificRoute[fileName] : `/${fileName.replace(/\.js$/i, "").replace(/_/g, "/")}`;
  const modules = files2.reverse().filter((file2) => file2.endsWith(".js")).map((file2) => {
    const identifier = file2.split(".").shift();
    const route3 = parseRoute(file2);
    const modulePath = path2.join(modulesPath, file2);
    const module2 = doRequire ? commonjsRequire(modulePath) : modulePath;
    return { identifier, route: route3, module: module2 };
  });
  return modules;
}
async function checkVersion() {
  return new Promise((resolve3) => {
    exec("npm info NeteaseCloudMusicApi version", (err, stdout) => {
      if (!err) {
        let version2 = stdout.trim();
        const resolveStatus = (status3) => resolve3({
          status: status3,
          ourVersion: packageJSON.version,
          npmVersion: version2
        });
        resolveStatus(
          packageJSON.version < version2 ? VERSION_CHECK_RESULT.NOT_LATEST : VERSION_CHECK_RESULT.LATEST
        );
      } else {
        resolve3({
          status: VERSION_CHECK_RESULT.FAILED
        });
      }
    });
  });
}
async function consturctServer(moduleDefs) {
  const app2 = express();
  const { CORS_ALLOW_ORIGIN } = process.env;
  app2.set("trust proxy", true);
  app2.use(express.static(path2.join(__dirname, "public")));
  app2.use((req2, res2, next) => {
    if (req2.path !== "/" && !req2.path.includes(".")) {
      res2.set({
        "Access-Control-Allow-Credentials": true,
        "Access-Control-Allow-Origin": CORS_ALLOW_ORIGIN || req2.headers.origin || "*",
        "Access-Control-Allow-Headers": "X-Requested-With,Content-Type",
        "Access-Control-Allow-Methods": "PUT,POST,GET,DELETE,OPTIONS",
        "Content-Type": "application/json; charset=utf-8"
      });
    }
    req2.method === "OPTIONS" ? res2.status(204).end() : next();
  });
  app2.use((req2, _, next) => {
    req2.cookies = {};
    (req2.headers.cookie || "").split(new RegExp(";\\s+|(?<!\\s)\\s+$", "g")).forEach((pair) => {
      let crack = pair.indexOf("=");
      if (crack < 1 || crack == pair.length - 1) return;
      req2.cookies[decode(pair.slice(0, crack)).trim()] = decode(
        pair.slice(crack + 1)
      ).trim();
    });
    next();
  });
  app2.use(express.json({ limit: "50mb" }));
  app2.use(express.urlencoded({ extended: false, limit: "50mb" }));
  app2.use(fileUpload());
  app2.use(cache("2 minutes", (_, res2) => res2.statusCode === 200));
  const special = {
    "daily_signin.js": "/daily_signin",
    "fm_trash.js": "/fm_trash",
    "personal_fm.js": "/personal_fm"
  };
  const moduleDefinitions = moduleDefs || await getModulesDefinitions(path2.join(__dirname, "module"), special);
  for (const moduleDef of moduleDefinitions) {
    app2.use(moduleDef.route, async (req2, res2) => {
      [req2.query, req2.body].forEach((item) => {
        if (typeof item.cookie === "string") {
          item.cookie = cookieToJson(decode(item.cookie));
        }
      });
      let query = Object.assign(
        {},
        { cookie: req2.cookies },
        req2.query,
        req2.body,
        req2.files
      );
      try {
        const moduleResponse = await moduleDef.module(query, (...params) => {
          const obj = [...params];
          let ip3 = req2.ip;
          if (ip3.substr(0, 7) == "::ffff:") {
            ip3 = ip3.substr(7);
          }
          if (ip3 == "::1") {
            ip3 = commonjsGlobal.cnIp;
          }
          obj[3] = {
            ...obj[3],
            ip: ip3
          };
          return request(...obj);
        });
        console.log("[OK]", decode(req2.originalUrl));
        const cookies2 = moduleResponse.cookie;
        if (!query.noCookie) {
          if (Array.isArray(cookies2) && cookies2.length > 0) {
            if (req2.protocol === "https") {
              res2.append(
                "Set-Cookie",
                cookies2.map((cookie2) => {
                  return cookie2 + "; SameSite=None; Secure";
                })
              );
            } else {
              res2.append("Set-Cookie", cookies2);
            }
          }
        }
        res2.status(moduleResponse.status).send(moduleResponse.body);
      } catch (moduleResponse) {
        console.log("[ERR]", decode(req2.originalUrl), {
          status: moduleResponse.status,
          body: moduleResponse.body
        });
        if (!moduleResponse.body) {
          res2.status(404).send({
            code: 404,
            data: null,
            msg: "Not Found"
          });
          return;
        }
        if (moduleResponse.body.code == "301")
          moduleResponse.body.msg = "éœ€è¦ç™»å½•";
        if (!query.noCookie) {
          res2.append("Set-Cookie", moduleResponse.cookie);
        }
        res2.status(moduleResponse.status).send(moduleResponse.body);
      }
    });
  }
  return app2;
}
async function serveNcmApi(options) {
  const port = Number(options.port || process.env.PORT || "3000");
  const host2 = options.host || process.env.HOST || "";
  const checkVersionSubmission = options.checkVersion && checkVersion().then(({ npmVersion, ourVersion, status: status3 }) => {
    if (status3 == VERSION_CHECK_RESULT.NOT_LATEST) {
      console.log(
        `æœ€æ–°ç‰ˆæœ¬: ${npmVersion}, å½“å‰ç‰ˆæœ¬: ${ourVersion}, è¯·åŠæ—¶æ›´æ–°`
      );
    }
  });
  const constructServerSubmission = consturctServer(options.moduleDefs);
  const [_, app2] = await Promise.all([
    checkVersionSubmission,
    constructServerSubmission
  ]);
  const appExt = app2;
  appExt.server = app2.listen(port, host2, () => {
    console.log(`server running @ http://${host2 ? host2 : "localhost"}:${port}`);
  });
  return appExt;
}
var server = {
  serveNcmApi,
  getModulesDefinitions
};
const server$1 = /* @__PURE__ */ getDefaultExportFromCjs(server);
var d$4 = { exports: {} };
var _undefined$1 = void 0;
var is$6 = function(value2) {
  return value2 !== _undefined$1 && value2 !== null;
};
var isValue$8 = is$6;
var possibleTypes = {
  "object": true,
  "function": true,
  "undefined": true
  /* document.all */
};
var is$5 = function(value2) {
  if (!isValue$8(value2)) return false;
  return hasOwnProperty.call(possibleTypes, typeof value2);
};
var isObject$2 = is$5;
var is$4 = function(value2) {
  if (!isObject$2(value2)) return false;
  try {
    if (!value2.constructor) return false;
    return value2.constructor.prototype === value2;
  } catch (error2) {
    return false;
  }
};
var isPrototype = is$4;
var is$3 = function(value2) {
  if (typeof value2 !== "function") return false;
  if (!hasOwnProperty.call(value2, "length")) return false;
  try {
    if (typeof value2.length !== "number") return false;
    if (typeof value2.call !== "function") return false;
    if (typeof value2.apply !== "function") return false;
  } catch (error2) {
    return false;
  }
  return !isPrototype(value2);
};
var isFunction$1 = is$3;
var classRe = /^\s*class[\s{/}]/, functionToString = Function.prototype.toString;
var is$2 = function(value2) {
  if (!isFunction$1(value2)) return false;
  if (classRe.test(functionToString.call(value2))) return false;
  return true;
};
var isImplemented$a = function() {
  var assign2 = Object.assign, obj;
  if (typeof assign2 !== "function") return false;
  obj = { foo: "raz" };
  assign2(obj, { bar: "dwa" }, { trzy: "trzy" });
  return obj.foo + obj.bar + obj.trzy === "razdwatrzy";
};
var isImplemented$9;
var hasRequiredIsImplemented$5;
function requireIsImplemented$5() {
  if (hasRequiredIsImplemented$5) return isImplemented$9;
  hasRequiredIsImplemented$5 = 1;
  isImplemented$9 = function() {
    try {
      Object.keys("primitive");
      return true;
    } catch (e) {
      return false;
    }
  };
  return isImplemented$9;
}
var noop = function() {
};
var _undefined = noop();
var isValue$7 = function(val) {
  return val !== _undefined && val !== null;
};
var shim$8;
var hasRequiredShim$8;
function requireShim$8() {
  if (hasRequiredShim$8) return shim$8;
  hasRequiredShim$8 = 1;
  var isValue2 = isValue$7;
  var keys2 = Object.keys;
  shim$8 = function(object) {
    return keys2(isValue2(object) ? Object(object) : object);
  };
  return shim$8;
}
var keys$1;
var hasRequiredKeys;
function requireKeys() {
  if (hasRequiredKeys) return keys$1;
  hasRequiredKeys = 1;
  keys$1 = requireIsImplemented$5()() ? Object.keys : requireShim$8();
  return keys$1;
}
var isValue$6 = isValue$7;
var validValue = function(value2) {
  if (!isValue$6(value2)) throw new TypeError("Cannot use null or undefined");
  return value2;
};
var shim$7;
var hasRequiredShim$7;
function requireShim$7() {
  if (hasRequiredShim$7) return shim$7;
  hasRequiredShim$7 = 1;
  var keys2 = requireKeys(), value2 = validValue, max2 = Math.max;
  shim$7 = function(dest, src2) {
    var error2, i, length = max2(arguments.length, 2), assign2;
    dest = Object(value2(dest));
    assign2 = function(key) {
      try {
        dest[key] = src2[key];
      } catch (e) {
        if (!error2) error2 = e;
      }
    };
    for (i = 1; i < length; ++i) {
      src2 = arguments[i];
      keys2(src2).forEach(assign2);
    }
    if (error2 !== void 0) throw error2;
    return dest;
  };
  return shim$7;
}
var assign$3 = isImplemented$a() ? Object.assign : requireShim$7();
var isValue$5 = isValue$7;
var forEach$6 = Array.prototype.forEach, create$3 = Object.create;
var process$1 = function(src2, obj) {
  var key;
  for (key in src2) obj[key] = src2[key];
};
var normalizeOptions = function(opts1) {
  var result = create$3(null);
  forEach$6.call(arguments, function(options) {
    if (!isValue$5(options)) return;
    process$1(Object(options), result);
  });
  return result;
};
var str = "razdwatrzy";
var isImplemented$8 = function() {
  if (typeof str.contains !== "function") return false;
  return str.contains("dwa") === true && str.contains("foo") === false;
};
var shim$6;
var hasRequiredShim$6;
function requireShim$6() {
  if (hasRequiredShim$6) return shim$6;
  hasRequiredShim$6 = 1;
  var indexOf2 = String.prototype.indexOf;
  shim$6 = function(searchString) {
    return indexOf2.call(this, searchString, arguments[1]) > -1;
  };
  return shim$6;
}
var contains$2 = isImplemented$8() ? String.prototype.contains : requireShim$6();
var isValue$4 = is$6, isPlainFunction$1 = is$2, assign$2 = assign$3, normalizeOpts$2 = normalizeOptions, contains$1 = contains$2;
var d$3 = d$4.exports = function(dscr, value2) {
  var c, e, w2, options, desc2;
  if (arguments.length < 2 || typeof dscr !== "string") {
    options = value2;
    value2 = dscr;
    dscr = null;
  } else {
    options = arguments[2];
  }
  if (isValue$4(dscr)) {
    c = contains$1.call(dscr, "c");
    e = contains$1.call(dscr, "e");
    w2 = contains$1.call(dscr, "w");
  } else {
    c = w2 = true;
    e = false;
  }
  desc2 = { value: value2, configurable: c, enumerable: e, writable: w2 };
  return !options ? desc2 : assign$2(normalizeOpts$2(options), desc2);
};
d$3.gs = function(dscr, get2, set) {
  var c, e, options, desc2;
  if (typeof dscr !== "string") {
    options = set;
    set = get2;
    get2 = dscr;
    dscr = null;
  } else {
    options = arguments[3];
  }
  if (!isValue$4(get2)) {
    get2 = void 0;
  } else if (!isPlainFunction$1(get2)) {
    options = get2;
    get2 = set = void 0;
  } else if (!isValue$4(set)) {
    set = void 0;
  } else if (!isPlainFunction$1(set)) {
    options = set;
    set = void 0;
  }
  if (isValue$4(dscr)) {
    c = contains$1.call(dscr, "c");
    e = contains$1.call(dscr, "e");
  } else {
    c = true;
    e = false;
  }
  desc2 = { get: get2, set, configurable: c, enumerable: e };
  return !options ? desc2 : assign$2(normalizeOpts$2(options), desc2);
};
var dExports = d$4.exports;
var validCallable = function(fn) {
  if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
  return fn;
};
var callable$6 = validCallable, value$3 = validValue, bind = Function.prototype.bind, call$4 = Function.prototype.call, keys = Object.keys, objPropertyIsEnumerable$1 = Object.prototype.propertyIsEnumerable;
var _iterate = function(method, defVal) {
  return function(obj, cb) {
    var list, thisArg = arguments[2], compareFn = arguments[3];
    obj = Object(value$3(obj));
    callable$6(cb);
    list = keys(obj);
    if (compareFn) {
      list.sort(typeof compareFn === "function" ? bind.call(compareFn, obj) : void 0);
    }
    if (typeof method !== "function") method = list[method];
    return call$4.call(method, list, function(key, index2) {
      if (!objPropertyIsEnumerable$1.call(obj, key)) return defVal;
      return call$4.call(cb, thisArg, obj[key], key, obj, index2);
    });
  };
};
var forEach$5 = _iterate("forEach");
var callable$5 = validCallable, forEach$4 = forEach$5, call$3 = Function.prototype.call;
var map$2 = function(obj, cb) {
  var result = {}, thisArg = arguments[2];
  callable$5(cb);
  forEach$4(obj, function(value2, key, targetObj, index2) {
    result[key] = call$3.call(cb, thisArg, value2, key, targetObj, index2);
  });
  return result;
};
var forEach$3 = Array.prototype.forEach, create$2 = Object.create;
var primitiveSet$1 = function(arg) {
  var set = create$2(null);
  forEach$3.call(arguments, function(name2) {
    set[name2] = true;
  });
  return set;
};
var create$1 = Object.create, getPrototypeOf$1 = Object.getPrototypeOf, plainObject = {};
var isImplemented$7 = function() {
  var setPrototypeOf2 = Object.setPrototypeOf, customCreate = arguments[0] || create$1;
  if (typeof setPrototypeOf2 !== "function") return false;
  return getPrototypeOf$1(setPrototypeOf2(customCreate(null), plainObject)) === plainObject;
};
var isObject$1;
var hasRequiredIsObject;
function requireIsObject() {
  if (hasRequiredIsObject) return isObject$1;
  hasRequiredIsObject = 1;
  var isValue2 = isValue$7;
  var map2 = { function: true, object: true };
  isObject$1 = function(value2) {
    return isValue2(value2) && map2[typeof value2] || false;
  };
  return isObject$1;
}
var create_1;
var hasRequiredCreate;
function requireCreate() {
  if (hasRequiredCreate) return create_1;
  hasRequiredCreate = 1;
  var create2 = Object.create, shim2;
  if (!isImplemented$7()) {
    shim2 = requireShim$5();
  }
  create_1 = function() {
    var nullObject, polyProps, desc2;
    if (!shim2) return create2;
    if (shim2.level !== 1) return create2;
    nullObject = {};
    polyProps = {};
    desc2 = { configurable: false, enumerable: false, writable: true, value: void 0 };
    Object.getOwnPropertyNames(Object.prototype).forEach(function(name2) {
      if (name2 === "__proto__") {
        polyProps[name2] = {
          configurable: true,
          enumerable: false,
          writable: true,
          value: void 0
        };
        return;
      }
      polyProps[name2] = desc2;
    });
    Object.defineProperties(nullObject, polyProps);
    Object.defineProperty(shim2, "nullPolyfill", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: nullObject
    });
    return function(prototype2, props) {
      return create2(prototype2 === null ? nullObject : prototype2, props);
    };
  }();
  return create_1;
}
var shim$5;
var hasRequiredShim$5;
function requireShim$5() {
  if (hasRequiredShim$5) return shim$5;
  hasRequiredShim$5 = 1;
  var isObject2 = requireIsObject(), value2 = validValue, objIsPrototypeOf = Object.prototype.isPrototypeOf, defineProperty2 = Object.defineProperty, nullDesc = { configurable: true, enumerable: false, writable: true, value: void 0 }, validate;
  validate = function(obj, prototype2) {
    value2(obj);
    if (prototype2 === null || isObject2(prototype2)) return obj;
    throw new TypeError("Prototype must be null or an object");
  };
  shim$5 = function(status3) {
    var fn, set;
    if (!status3) return null;
    if (status3.level === 2) {
      if (status3.set) {
        set = status3.set;
        fn = function(obj, prototype2) {
          set.call(validate(obj, prototype2), prototype2);
          return obj;
        };
      } else {
        fn = function(obj, prototype2) {
          validate(obj, prototype2).__proto__ = prototype2;
          return obj;
        };
      }
    } else {
      fn = function self3(obj, prototype2) {
        var isNullBase;
        validate(obj, prototype2);
        isNullBase = objIsPrototypeOf.call(self3.nullPolyfill, obj);
        if (isNullBase) delete self3.nullPolyfill.__proto__;
        if (prototype2 === null) prototype2 = self3.nullPolyfill;
        obj.__proto__ = prototype2;
        if (isNullBase) defineProperty2(self3.nullPolyfill, "__proto__", nullDesc);
        return obj;
      };
    }
    return Object.defineProperty(fn, "level", {
      configurable: false,
      enumerable: false,
      writable: false,
      value: status3.level
    });
  }(
    function() {
      var tmpObj1 = /* @__PURE__ */ Object.create(null), tmpObj2 = {}, set, desc2 = Object.getOwnPropertyDescriptor(Object.prototype, "__proto__");
      if (desc2) {
        try {
          set = desc2.set;
          set.call(tmpObj1, tmpObj2);
        } catch (ignore) {
        }
        if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { set, level: 2 };
      }
      tmpObj1.__proto__ = tmpObj2;
      if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 2 };
      tmpObj1 = {};
      tmpObj1.__proto__ = tmpObj2;
      if (Object.getPrototypeOf(tmpObj1) === tmpObj2) return { level: 1 };
      return false;
    }()
  );
  requireCreate();
  return shim$5;
}
var setPrototypeOf$1 = isImplemented$7() ? Object.setPrototypeOf : requireShim$5();
var isImplemented$6 = function() {
  var sign2 = Math.sign;
  if (typeof sign2 !== "function") return false;
  return sign2(10) === 1 && sign2(-20) === -1;
};
var shim$4;
var hasRequiredShim$4;
function requireShim$4() {
  if (hasRequiredShim$4) return shim$4;
  hasRequiredShim$4 = 1;
  shim$4 = function(value2) {
    value2 = Number(value2);
    if (isNaN(value2) || value2 === 0) return value2;
    return value2 > 0 ? 1 : -1;
  };
  return shim$4;
}
var sign$1 = isImplemented$6() ? Math.sign : requireShim$4();
var sign = sign$1, abs$1 = Math.abs, floor$1 = Math.floor;
var toInteger$1 = function(value2) {
  if (isNaN(value2)) return 0;
  value2 = Number(value2);
  if (value2 === 0 || !isFinite(value2)) return value2;
  return sign(value2) * floor$1(abs$1(value2));
};
var toInteger = toInteger$1, max$2 = Math.max;
var toPosInteger = function(value2) {
  return max$2(0, toInteger(value2));
};
var toPosInt$3 = toPosInteger;
var resolveLength$3 = function(optsLength, fnLength, isAsync) {
  var length;
  if (isNaN(optsLength)) {
    length = fnLength;
    if (!(length >= 0)) return 1;
    if (isAsync && length) return length - 1;
    return length;
  }
  if (optsLength === false) return false;
  return toPosInt$3(optsLength);
};
var registeredExtensions = {};
var custom = { exports: {} };
(function(module2) {
  var assign2 = assign$3, isObject2 = requireIsObject(), isValue2 = isValue$7, captureStackTrace = Error.captureStackTrace;
  module2.exports = function(message) {
    var err = new Error(message), code2 = arguments[1], ext = arguments[2];
    if (!isValue2(ext)) {
      if (isObject2(code2)) {
        ext = code2;
        code2 = null;
      }
    }
    if (isValue2(ext)) assign2(err, ext);
    if (isValue2(code2)) err.code = code2;
    if (captureStackTrace) captureStackTrace(err, module2.exports);
    return err;
  };
})(custom);
var customExports = custom.exports;
var _defineLength = { exports: {} };
var mixin$1;
var hasRequiredMixin;
function requireMixin() {
  if (hasRequiredMixin) return mixin$1;
  hasRequiredMixin = 1;
  var value2 = validValue, defineProperty2 = Object.defineProperty, getOwnPropertyDescriptor2 = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols;
  mixin$1 = function(target, source) {
    var error2, sourceObject = Object(value2(source));
    target = Object(value2(target));
    getOwnPropertyNames(sourceObject).forEach(function(name2) {
      try {
        defineProperty2(target, name2, getOwnPropertyDescriptor2(source, name2));
      } catch (e) {
        error2 = e;
      }
    });
    if (typeof getOwnPropertySymbols === "function") {
      getOwnPropertySymbols(sourceObject).forEach(function(symbol) {
        try {
          defineProperty2(target, symbol, getOwnPropertyDescriptor2(source, symbol));
        } catch (e) {
          error2 = e;
        }
      });
    }
    if (error2 !== void 0) throw error2;
    return target;
  };
  return mixin$1;
}
var toPosInt$2 = toPosInteger;
var test = function(arg1, arg2) {
  return arg2;
};
var desc, defineProperty$2, generate$1, mixin;
try {
  Object.defineProperty(test, "length", {
    configurable: true,
    writable: false,
    enumerable: false,
    value: 1
  });
} catch (ignore) {
}
if (test.length === 1) {
  desc = { configurable: true, writable: false, enumerable: false };
  defineProperty$2 = Object.defineProperty;
  _defineLength.exports = function(fn, length) {
    length = toPosInt$2(length);
    if (fn.length === length) return fn;
    desc.value = length;
    return defineProperty$2(fn, "length", desc);
  };
} else {
  mixin = requireMixin();
  generate$1 = /* @__PURE__ */ function() {
    var cache2 = [];
    return function(length) {
      var args, i = 0;
      if (cache2[length]) return cache2[length];
      args = [];
      while (length--) args.push("a" + (++i).toString(36));
      return new Function(
        "fn",
        "return function (" + args.join(", ") + ") { return fn.apply(this, arguments); };"
      );
    };
  }();
  _defineLength.exports = function(src2, length) {
    var target;
    length = toPosInt$2(length);
    if (src2.length === length) return src2;
    target = generate$1(length)(src2);
    try {
      mixin(target, src2);
    } catch (ignore) {
    }
    return target;
  };
}
var _defineLengthExports = _defineLength.exports;
var eventEmitter = { exports: {} };
(function(module2, exports) {
  var d2 = dExports, callable2 = validCallable, apply2 = Function.prototype.apply, call2 = Function.prototype.call, create2 = Object.create, defineProperty2 = Object.defineProperty, defineProperties2 = Object.defineProperties, hasOwnProperty2 = Object.prototype.hasOwnProperty, descriptor = { configurable: true, enumerable: false, writable: true }, on2, once, off, emit2, methods2, descriptors2, base;
  on2 = function(type3, listener2) {
    var data2;
    callable2(listener2);
    if (!hasOwnProperty2.call(this, "__ee__")) {
      data2 = descriptor.value = create2(null);
      defineProperty2(this, "__ee__", descriptor);
      descriptor.value = null;
    } else {
      data2 = this.__ee__;
    }
    if (!data2[type3]) data2[type3] = listener2;
    else if (typeof data2[type3] === "object") data2[type3].push(listener2);
    else data2[type3] = [data2[type3], listener2];
    return this;
  };
  once = function(type3, listener2) {
    var once2, self3;
    callable2(listener2);
    self3 = this;
    on2.call(this, type3, once2 = function() {
      off.call(self3, type3, once2);
      apply2.call(listener2, this, arguments);
    });
    once2.__eeOnceListener__ = listener2;
    return this;
  };
  off = function(type3, listener2) {
    var data2, listeners, candidate, i;
    callable2(listener2);
    if (!hasOwnProperty2.call(this, "__ee__")) return this;
    data2 = this.__ee__;
    if (!data2[type3]) return this;
    listeners = data2[type3];
    if (typeof listeners === "object") {
      for (i = 0; candidate = listeners[i]; ++i) {
        if (candidate === listener2 || candidate.__eeOnceListener__ === listener2) {
          if (listeners.length === 2) data2[type3] = listeners[i ? 0 : 1];
          else listeners.splice(i, 1);
        }
      }
    } else {
      if (listeners === listener2 || listeners.__eeOnceListener__ === listener2) {
        delete data2[type3];
      }
    }
    return this;
  };
  emit2 = function(type3) {
    var i, l, listener2, listeners, args;
    if (!hasOwnProperty2.call(this, "__ee__")) return;
    listeners = this.__ee__[type3];
    if (!listeners) return;
    if (typeof listeners === "object") {
      l = arguments.length;
      args = new Array(l - 1);
      for (i = 1; i < l; ++i) args[i - 1] = arguments[i];
      listeners = listeners.slice();
      for (i = 0; listener2 = listeners[i]; ++i) {
        apply2.call(listener2, this, args);
      }
    } else {
      switch (arguments.length) {
        case 1:
          call2.call(listeners, this);
          break;
        case 2:
          call2.call(listeners, this, arguments[1]);
          break;
        case 3:
          call2.call(listeners, this, arguments[1], arguments[2]);
          break;
        default:
          l = arguments.length;
          args = new Array(l - 1);
          for (i = 1; i < l; ++i) {
            args[i - 1] = arguments[i];
          }
          apply2.call(listeners, this, args);
      }
    }
  };
  methods2 = {
    on: on2,
    once,
    off,
    emit: emit2
  };
  descriptors2 = {
    on: d2(on2),
    once: d2(once),
    off: d2(off),
    emit: d2(emit2)
  };
  base = defineProperties2({}, descriptors2);
  module2.exports = exports = function(o) {
    return o == null ? create2(base) : defineProperties2(Object(o), descriptors2);
  };
  exports.methods = methods2;
})(eventEmitter, eventEmitter.exports);
var eventEmitterExports = eventEmitter.exports;
var isImplemented$5;
var hasRequiredIsImplemented$4;
function requireIsImplemented$4() {
  if (hasRequiredIsImplemented$4) return isImplemented$5;
  hasRequiredIsImplemented$4 = 1;
  isImplemented$5 = function() {
    var from2 = Array.from, arr, result;
    if (typeof from2 !== "function") return false;
    arr = ["raz", "dwa"];
    result = from2(arr);
    return Boolean(result && result !== arr && result[1] === "dwa");
  };
  return isImplemented$5;
}
var isImplemented$4;
var hasRequiredIsImplemented$3;
function requireIsImplemented$3() {
  if (hasRequiredIsImplemented$3) return isImplemented$4;
  hasRequiredIsImplemented$3 = 1;
  isImplemented$4 = function() {
    if (typeof globalThis !== "object") return false;
    if (!globalThis) return false;
    return globalThis.Array === Array;
  };
  return isImplemented$4;
}
var implementation;
var hasRequiredImplementation;
function requireImplementation() {
  if (hasRequiredImplementation) return implementation;
  hasRequiredImplementation = 1;
  var naiveFallback = function() {
    if (typeof self === "object" && self) return self;
    if (typeof window === "object" && window) return window;
    throw new Error("Unable to resolve global `this`");
  };
  implementation = function() {
    if (this) return this;
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function() {
          return this;
        },
        configurable: true
      });
    } catch (error2) {
      return naiveFallback();
    }
    try {
      if (!__global__) return naiveFallback();
      return __global__;
    } finally {
      delete Object.prototype.__global__;
    }
  }();
  return implementation;
}
var globalThis_1;
var hasRequiredGlobalThis;
function requireGlobalThis() {
  if (hasRequiredGlobalThis) return globalThis_1;
  hasRequiredGlobalThis = 1;
  globalThis_1 = requireIsImplemented$3()() ? globalThis : requireImplementation();
  return globalThis_1;
}
var isImplemented$3;
var hasRequiredIsImplemented$2;
function requireIsImplemented$2() {
  if (hasRequiredIsImplemented$2) return isImplemented$3;
  hasRequiredIsImplemented$2 = 1;
  var global2 = requireGlobalThis(), validTypes = { object: true, symbol: true };
  isImplemented$3 = function() {
    var Symbol2 = global2.Symbol;
    var symbol;
    if (typeof Symbol2 !== "function") return false;
    symbol = Symbol2("test symbol");
    try {
      String(symbol);
    } catch (e) {
      return false;
    }
    if (!validTypes[typeof Symbol2.iterator]) return false;
    if (!validTypes[typeof Symbol2.toPrimitive]) return false;
    if (!validTypes[typeof Symbol2.toStringTag]) return false;
    return true;
  };
  return isImplemented$3;
}
var isSymbol;
var hasRequiredIsSymbol;
function requireIsSymbol() {
  if (hasRequiredIsSymbol) return isSymbol;
  hasRequiredIsSymbol = 1;
  isSymbol = function(value2) {
    if (!value2) return false;
    if (typeof value2 === "symbol") return true;
    if (!value2.constructor) return false;
    if (value2.constructor.name !== "Symbol") return false;
    return value2[value2.constructor.toStringTag] === "Symbol";
  };
  return isSymbol;
}
var validateSymbol;
var hasRequiredValidateSymbol;
function requireValidateSymbol() {
  if (hasRequiredValidateSymbol) return validateSymbol;
  hasRequiredValidateSymbol = 1;
  var isSymbol2 = requireIsSymbol();
  validateSymbol = function(value2) {
    if (!isSymbol2(value2)) throw new TypeError(value2 + " is not a symbol");
    return value2;
  };
  return validateSymbol;
}
var generateName;
var hasRequiredGenerateName;
function requireGenerateName() {
  if (hasRequiredGenerateName) return generateName;
  hasRequiredGenerateName = 1;
  var d2 = dExports;
  var create2 = Object.create, defineProperty2 = Object.defineProperty, objPrototype = Object.prototype;
  var created = create2(null);
  generateName = function(desc2) {
    var postfix = 0, name2, ie11BugWorkaround;
    while (created[desc2 + (postfix || "")]) ++postfix;
    desc2 += postfix || "";
    created[desc2] = true;
    name2 = "@@" + desc2;
    defineProperty2(
      objPrototype,
      name2,
      d2.gs(null, function(value2) {
        if (ie11BugWorkaround) return;
        ie11BugWorkaround = true;
        defineProperty2(this, name2, d2(value2));
        ie11BugWorkaround = false;
      })
    );
    return name2;
  };
  return generateName;
}
var standardSymbols;
var hasRequiredStandardSymbols;
function requireStandardSymbols() {
  if (hasRequiredStandardSymbols) return standardSymbols;
  hasRequiredStandardSymbols = 1;
  var d2 = dExports, NativeSymbol = requireGlobalThis().Symbol;
  standardSymbols = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
      // To ensure proper interoperability with other native functions (e.g. Array.from)
      // fallback to eventual native implementation of given symbol
      hasInstance: d2(
        "",
        NativeSymbol && NativeSymbol.hasInstance || SymbolPolyfill("hasInstance")
      ),
      isConcatSpreadable: d2(
        "",
        NativeSymbol && NativeSymbol.isConcatSpreadable || SymbolPolyfill("isConcatSpreadable")
      ),
      iterator: d2("", NativeSymbol && NativeSymbol.iterator || SymbolPolyfill("iterator")),
      match: d2("", NativeSymbol && NativeSymbol.match || SymbolPolyfill("match")),
      replace: d2("", NativeSymbol && NativeSymbol.replace || SymbolPolyfill("replace")),
      search: d2("", NativeSymbol && NativeSymbol.search || SymbolPolyfill("search")),
      species: d2("", NativeSymbol && NativeSymbol.species || SymbolPolyfill("species")),
      split: d2("", NativeSymbol && NativeSymbol.split || SymbolPolyfill("split")),
      toPrimitive: d2(
        "",
        NativeSymbol && NativeSymbol.toPrimitive || SymbolPolyfill("toPrimitive")
      ),
      toStringTag: d2(
        "",
        NativeSymbol && NativeSymbol.toStringTag || SymbolPolyfill("toStringTag")
      ),
      unscopables: d2(
        "",
        NativeSymbol && NativeSymbol.unscopables || SymbolPolyfill("unscopables")
      )
    });
  };
  return standardSymbols;
}
var symbolRegistry;
var hasRequiredSymbolRegistry;
function requireSymbolRegistry() {
  if (hasRequiredSymbolRegistry) return symbolRegistry;
  hasRequiredSymbolRegistry = 1;
  var d2 = dExports, validateSymbol2 = requireValidateSymbol();
  var registry = /* @__PURE__ */ Object.create(null);
  symbolRegistry = function(SymbolPolyfill) {
    return Object.defineProperties(SymbolPolyfill, {
      for: d2(function(key) {
        if (registry[key]) return registry[key];
        return registry[key] = SymbolPolyfill(String(key));
      }),
      keyFor: d2(function(symbol) {
        var key;
        validateSymbol2(symbol);
        for (key in registry) {
          if (registry[key] === symbol) return key;
        }
        return void 0;
      })
    });
  };
  return symbolRegistry;
}
var polyfill;
var hasRequiredPolyfill;
function requirePolyfill() {
  if (hasRequiredPolyfill) return polyfill;
  hasRequiredPolyfill = 1;
  var d2 = dExports, validateSymbol2 = requireValidateSymbol(), NativeSymbol = requireGlobalThis().Symbol, generateName2 = requireGenerateName(), setupStandardSymbols = requireStandardSymbols(), setupSymbolRegistry = requireSymbolRegistry();
  var create2 = Object.create, defineProperties2 = Object.defineProperties, defineProperty2 = Object.defineProperty;
  var SymbolPolyfill, HiddenSymbol, isNativeSafe;
  if (typeof NativeSymbol === "function") {
    try {
      String(NativeSymbol());
      isNativeSafe = true;
    } catch (ignore) {
    }
  } else {
    NativeSymbol = null;
  }
  HiddenSymbol = function Symbol2(description2) {
    if (this instanceof HiddenSymbol) throw new TypeError("Symbol is not a constructor");
    return SymbolPolyfill(description2);
  };
  polyfill = SymbolPolyfill = function Symbol2(description2) {
    var symbol;
    if (this instanceof Symbol2) throw new TypeError("Symbol is not a constructor");
    if (isNativeSafe) return NativeSymbol(description2);
    symbol = create2(HiddenSymbol.prototype);
    description2 = description2 === void 0 ? "" : String(description2);
    return defineProperties2(symbol, {
      __description__: d2("", description2),
      __name__: d2("", generateName2(description2))
    });
  };
  setupStandardSymbols(SymbolPolyfill);
  setupSymbolRegistry(SymbolPolyfill);
  defineProperties2(HiddenSymbol.prototype, {
    constructor: d2(SymbolPolyfill),
    toString: d2("", function() {
      return this.__name__;
    })
  });
  defineProperties2(SymbolPolyfill.prototype, {
    toString: d2(function() {
      return "Symbol (" + validateSymbol2(this).__description__ + ")";
    }),
    valueOf: d2(function() {
      return validateSymbol2(this);
    })
  });
  defineProperty2(
    SymbolPolyfill.prototype,
    SymbolPolyfill.toPrimitive,
    d2("", function() {
      var symbol = validateSymbol2(this);
      if (typeof symbol === "symbol") return symbol;
      return symbol.toString();
    })
  );
  defineProperty2(SymbolPolyfill.prototype, SymbolPolyfill.toStringTag, d2("c", "Symbol"));
  defineProperty2(
    HiddenSymbol.prototype,
    SymbolPolyfill.toStringTag,
    d2("c", SymbolPolyfill.prototype[SymbolPolyfill.toStringTag])
  );
  defineProperty2(
    HiddenSymbol.prototype,
    SymbolPolyfill.toPrimitive,
    d2("c", SymbolPolyfill.prototype[SymbolPolyfill.toPrimitive])
  );
  return polyfill;
}
var es6Symbol;
var hasRequiredEs6Symbol;
function requireEs6Symbol() {
  if (hasRequiredEs6Symbol) return es6Symbol;
  hasRequiredEs6Symbol = 1;
  es6Symbol = requireIsImplemented$2()() ? requireGlobalThis().Symbol : requirePolyfill();
  return es6Symbol;
}
var isArguments;
var hasRequiredIsArguments;
function requireIsArguments() {
  if (hasRequiredIsArguments) return isArguments;
  hasRequiredIsArguments = 1;
  var objToString = Object.prototype.toString, id = objToString.call(/* @__PURE__ */ function() {
    return arguments;
  }());
  isArguments = function(value2) {
    return objToString.call(value2) === id;
  };
  return isArguments;
}
var isFunction;
var hasRequiredIsFunction;
function requireIsFunction() {
  if (hasRequiredIsFunction) return isFunction;
  hasRequiredIsFunction = 1;
  var objToString = Object.prototype.toString, isFunctionStringTag = RegExp.prototype.test.bind(/^[object [A-Za-z0-9]*Function]$/);
  isFunction = function(value2) {
    return typeof value2 === "function" && isFunctionStringTag(objToString.call(value2));
  };
  return isFunction;
}
var isString;
var hasRequiredIsString;
function requireIsString() {
  if (hasRequiredIsString) return isString;
  hasRequiredIsString = 1;
  var objToString = Object.prototype.toString, id = objToString.call("");
  isString = function(value2) {
    return typeof value2 === "string" || value2 && typeof value2 === "object" && (value2 instanceof String || objToString.call(value2) === id) || false;
  };
  return isString;
}
var shim$3;
var hasRequiredShim$3;
function requireShim$3() {
  if (hasRequiredShim$3) return shim$3;
  hasRequiredShim$3 = 1;
  var iteratorSymbol = requireEs6Symbol().iterator, isArguments2 = requireIsArguments(), isFunction2 = requireIsFunction(), toPosInt2 = toPosInteger, callable2 = validCallable, validValue$1 = validValue, isValue2 = isValue$7, isString2 = requireIsString(), isArray2 = Array.isArray, call2 = Function.prototype.call, desc2 = { configurable: true, enumerable: true, writable: true, value: null }, defineProperty2 = Object.defineProperty;
  shim$3 = function(arrayLike) {
    var mapFn = arguments[1], thisArg = arguments[2], Context, i, j2, arr, length, code2, iterator, result, getIterator, value2;
    arrayLike = Object(validValue$1(arrayLike));
    if (isValue2(mapFn)) callable2(mapFn);
    if (!this || this === Array || !isFunction2(this)) {
      if (!mapFn) {
        if (isArguments2(arrayLike)) {
          length = arrayLike.length;
          if (length !== 1) return Array.apply(null, arrayLike);
          arr = new Array(1);
          arr[0] = arrayLike[0];
          return arr;
        }
        if (isArray2(arrayLike)) {
          arr = new Array(length = arrayLike.length);
          for (i = 0; i < length; ++i) arr[i] = arrayLike[i];
          return arr;
        }
      }
      arr = [];
    } else {
      Context = this;
    }
    if (!isArray2(arrayLike)) {
      if ((getIterator = arrayLike[iteratorSymbol]) !== void 0) {
        iterator = callable2(getIterator).call(arrayLike);
        if (Context) arr = new Context();
        result = iterator.next();
        i = 0;
        while (!result.done) {
          value2 = mapFn ? call2.call(mapFn, thisArg, result.value, i) : result.value;
          if (Context) {
            desc2.value = value2;
            defineProperty2(arr, i, desc2);
          } else {
            arr[i] = value2;
          }
          result = iterator.next();
          ++i;
        }
        length = i;
      } else if (isString2(arrayLike)) {
        length = arrayLike.length;
        if (Context) arr = new Context();
        for (i = 0, j2 = 0; i < length; ++i) {
          value2 = arrayLike[i];
          if (i + 1 < length) {
            code2 = value2.charCodeAt(0);
            if (code2 >= 55296 && code2 <= 56319) value2 += arrayLike[++i];
          }
          value2 = mapFn ? call2.call(mapFn, thisArg, value2, j2) : value2;
          if (Context) {
            desc2.value = value2;
            defineProperty2(arr, j2, desc2);
          } else {
            arr[j2] = value2;
          }
          ++j2;
        }
        length = j2;
      }
    }
    if (length === void 0) {
      length = toPosInt2(arrayLike.length);
      if (Context) arr = new Context(length);
      for (i = 0; i < length; ++i) {
        value2 = mapFn ? call2.call(mapFn, thisArg, arrayLike[i], i) : arrayLike[i];
        if (Context) {
          desc2.value = value2;
          defineProperty2(arr, i, desc2);
        } else {
          arr[i] = value2;
        }
      }
    }
    if (Context) {
      desc2.value = null;
      arr.length = length;
    }
    return arr;
  };
  return shim$3;
}
var from$1;
var hasRequiredFrom;
function requireFrom() {
  if (hasRequiredFrom) return from$1;
  hasRequiredFrom = 1;
  from$1 = requireIsImplemented$4()() ? Array.from : requireShim$3();
  return from$1;
}
var from = requireFrom(), isArray = Array.isArray;
var toArray$1 = function(arrayLike) {
  return isArray(arrayLike) ? arrayLike : from(arrayLike);
};
var toArray = toArray$1, isValue$3 = isValue$7, callable$4 = validCallable;
var slice$1 = Array.prototype.slice, resolveArgs;
resolveArgs = function(args) {
  return this.map(function(resolve3, i) {
    return resolve3 ? resolve3(args[i]) : args[i];
  }).concat(
    slice$1.call(args, this.length)
  );
};
var resolveResolve$1 = function(resolvers2) {
  resolvers2 = toArray(resolvers2);
  resolvers2.forEach(function(resolve3) {
    if (isValue$3(resolve3)) callable$4(resolve3);
  });
  return resolveArgs.bind(resolvers2);
};
var callable$3 = validCallable;
var resolveNormalize$1 = function(userNormalizer) {
  var normalizer;
  if (typeof userNormalizer === "function") return { set: userNormalizer, get: userNormalizer };
  normalizer = { get: callable$3(userNormalizer.get) };
  if (userNormalizer.set !== void 0) {
    normalizer.set = callable$3(userNormalizer.set);
    if (userNormalizer.delete) normalizer.delete = callable$3(userNormalizer.delete);
    if (userNormalizer.clear) normalizer.clear = callable$3(userNormalizer.clear);
    return normalizer;
  }
  normalizer.set = normalizer.get;
  return normalizer;
};
var customError = customExports, defineLength = _defineLengthExports, d$2 = dExports, ee = eventEmitterExports.methods, resolveResolve = resolveResolve$1, resolveNormalize = resolveNormalize$1;
var apply = Function.prototype.apply, call$2 = Function.prototype.call, create = Object.create, defineProperties = Object.defineProperties, on = ee.on, emit = ee.emit;
var configureMap = function(original, length, options) {
  var cache2 = create(null), conf, memLength, get2, set, del, clear2, extDel, extGet, extHas, normalizer, getListeners, setListeners, deleteListeners, memoized2, resolve3;
  if (length !== false) memLength = length;
  else if (isNaN(original.length)) memLength = 1;
  else memLength = original.length;
  if (options.normalizer) {
    normalizer = resolveNormalize(options.normalizer);
    get2 = normalizer.get;
    set = normalizer.set;
    del = normalizer.delete;
    clear2 = normalizer.clear;
  }
  if (options.resolvers != null) resolve3 = resolveResolve(options.resolvers);
  if (get2) {
    memoized2 = defineLength(function(arg) {
      var id, result, args = arguments;
      if (resolve3) args = resolve3(args);
      id = get2(args);
      if (id !== null) {
        if (hasOwnProperty.call(cache2, id)) {
          if (getListeners) conf.emit("get", id, args, this);
          return cache2[id];
        }
      }
      if (args.length === 1) result = call$2.call(original, this, args[0]);
      else result = apply.call(original, this, args);
      if (id === null) {
        id = get2(args);
        if (id !== null) throw customError("Circular invocation", "CIRCULAR_INVOCATION");
        id = set(args);
      } else if (hasOwnProperty.call(cache2, id)) {
        throw customError("Circular invocation", "CIRCULAR_INVOCATION");
      }
      cache2[id] = result;
      if (setListeners) conf.emit("set", id, null, result);
      return result;
    }, memLength);
  } else if (length === 0) {
    memoized2 = function() {
      var result;
      if (hasOwnProperty.call(cache2, "data")) {
        if (getListeners) conf.emit("get", "data", arguments, this);
        return cache2.data;
      }
      if (arguments.length) result = apply.call(original, this, arguments);
      else result = call$2.call(original, this);
      if (hasOwnProperty.call(cache2, "data")) {
        throw customError("Circular invocation", "CIRCULAR_INVOCATION");
      }
      cache2.data = result;
      if (setListeners) conf.emit("set", "data", null, result);
      return result;
    };
  } else {
    memoized2 = function(arg) {
      var result, args = arguments, id;
      if (resolve3) args = resolve3(arguments);
      id = String(args[0]);
      if (hasOwnProperty.call(cache2, id)) {
        if (getListeners) conf.emit("get", id, args, this);
        return cache2[id];
      }
      if (args.length === 1) result = call$2.call(original, this, args[0]);
      else result = apply.call(original, this, args);
      if (hasOwnProperty.call(cache2, id)) {
        throw customError("Circular invocation", "CIRCULAR_INVOCATION");
      }
      cache2[id] = result;
      if (setListeners) conf.emit("set", id, null, result);
      return result;
    };
  }
  conf = {
    original,
    memoized: memoized2,
    profileName: options.profileName,
    get: function(args) {
      if (resolve3) args = resolve3(args);
      if (get2) return get2(args);
      return String(args[0]);
    },
    has: function(id) {
      return hasOwnProperty.call(cache2, id);
    },
    delete: function(id) {
      var result;
      if (!hasOwnProperty.call(cache2, id)) return;
      if (del) del(id);
      result = cache2[id];
      delete cache2[id];
      if (deleteListeners) conf.emit("delete", id, result);
    },
    clear: function() {
      var oldCache = cache2;
      if (clear2) clear2();
      cache2 = create(null);
      conf.emit("clear", oldCache);
    },
    on: function(type3, listener2) {
      if (type3 === "get") getListeners = true;
      else if (type3 === "set") setListeners = true;
      else if (type3 === "delete") deleteListeners = true;
      return on.call(this, type3, listener2);
    },
    emit,
    updateEnv: function() {
      original = conf.original;
    }
  };
  if (get2) {
    extDel = defineLength(function(arg) {
      var id, args = arguments;
      if (resolve3) args = resolve3(args);
      id = get2(args);
      if (id === null) return;
      conf.delete(id);
    }, memLength);
  } else if (length === 0) {
    extDel = function() {
      return conf.delete("data");
    };
  } else {
    extDel = function(arg) {
      if (resolve3) arg = resolve3(arguments)[0];
      return conf.delete(arg);
    };
  }
  extGet = defineLength(function() {
    var id, args = arguments;
    if (length === 0) return cache2.data;
    if (resolve3) args = resolve3(args);
    if (get2) id = get2(args);
    else id = String(args[0]);
    return cache2[id];
  });
  extHas = defineLength(function() {
    var id, args = arguments;
    if (length === 0) return conf.has("data");
    if (resolve3) args = resolve3(args);
    if (get2) id = get2(args);
    else id = String(args[0]);
    if (id === null) return false;
    return conf.has(id);
  });
  defineProperties(memoized2, {
    __memoized__: d$2(true),
    delete: d$2(extDel),
    clear: d$2(conf.clear),
    _get: d$2(extGet),
    _has: d$2(extHas)
  });
  return conf;
};
var callable$2 = validCallable, forEach$2 = forEach$5, extensions$1 = registeredExtensions, configure = configureMap, resolveLength$2 = resolveLength$3;
var plain$1 = function self2(fn) {
  var options, length, conf;
  callable$2(fn);
  options = Object(arguments[1]);
  if (options.async && options.promise) {
    throw new Error("Options 'async' and 'promise' cannot be used together");
  }
  if (hasOwnProperty.call(fn, "__memoized__") && !options.force) return fn;
  length = resolveLength$2(options.length, fn.length, options.async && extensions$1.async);
  conf = configure(fn, length, options);
  forEach$2(extensions$1, function(extFn, name2) {
    if (options[name2]) extFn(options[name2], conf, options);
  });
  if (self2.__profiler__) self2.__profiler__(conf);
  conf.updateEnv();
  return conf.memoized;
};
var primitive;
var hasRequiredPrimitive;
function requirePrimitive() {
  if (hasRequiredPrimitive) return primitive;
  hasRequiredPrimitive = 1;
  primitive = function(args) {
    var id, i, length = args.length;
    if (!length) return "";
    id = String(args[i = 0]);
    while (--length) id += "" + args[++i];
    return id;
  };
  return primitive;
}
var getPrimitiveFixed;
var hasRequiredGetPrimitiveFixed;
function requireGetPrimitiveFixed() {
  if (hasRequiredGetPrimitiveFixed) return getPrimitiveFixed;
  hasRequiredGetPrimitiveFixed = 1;
  getPrimitiveFixed = function(length) {
    if (!length) {
      return function() {
        return "";
      };
    }
    return function(args) {
      var id = String(args[0]), i = 0, currentLength = length;
      while (--currentLength) {
        id += "" + args[++i];
      }
      return id;
    };
  };
  return getPrimitiveFixed;
}
var isImplemented$2 = function() {
  var numberIsNaN2 = Number.isNaN;
  if (typeof numberIsNaN2 !== "function") return false;
  return !numberIsNaN2({}) && numberIsNaN2(NaN) && !numberIsNaN2(34);
};
var shim$2;
var hasRequiredShim$2;
function requireShim$2() {
  if (hasRequiredShim$2) return shim$2;
  hasRequiredShim$2 = 1;
  shim$2 = function(value2) {
    return value2 !== value2;
  };
  return shim$2;
}
var isNan = isImplemented$2() ? Number.isNaN : requireShim$2();
var numberIsNaN = isNan, toPosInt$1 = toPosInteger, value$2 = validValue, indexOf$1 = Array.prototype.indexOf, objHasOwnProperty$1 = Object.prototype.hasOwnProperty, abs = Math.abs, floor = Math.floor;
var eIndexOf = function(searchElement) {
  var i, length, fromIndex, val;
  if (!numberIsNaN(searchElement)) return indexOf$1.apply(this, arguments);
  length = toPosInt$1(value$2(this).length);
  fromIndex = arguments[1];
  if (isNaN(fromIndex)) fromIndex = 0;
  else if (fromIndex >= 0) fromIndex = floor(fromIndex);
  else fromIndex = toPosInt$1(this.length) - floor(abs(fromIndex));
  for (i = fromIndex; i < length; ++i) {
    if (objHasOwnProperty$1.call(this, i)) {
      val = this[i];
      if (numberIsNaN(val)) return i;
    }
  }
  return -1;
};
var get$1;
var hasRequiredGet$1;
function requireGet$1() {
  if (hasRequiredGet$1) return get$1;
  hasRequiredGet$1 = 1;
  var indexOf2 = eIndexOf;
  var create2 = Object.create;
  get$1 = function() {
    var lastId = 0, map2 = [], cache2 = create2(null);
    return {
      get: function(args) {
        var index2 = 0, set = map2, i, length = args.length;
        if (length === 0) return set[length] || null;
        if (set = set[length]) {
          while (index2 < length - 1) {
            i = indexOf2.call(set[0], args[index2]);
            if (i === -1) return null;
            set = set[1][i];
            ++index2;
          }
          i = indexOf2.call(set[0], args[index2]);
          if (i === -1) return null;
          return set[1][i] || null;
        }
        return null;
      },
      set: function(args) {
        var index2 = 0, set = map2, i, length = args.length;
        if (length === 0) {
          set[length] = ++lastId;
        } else {
          if (!set[length]) {
            set[length] = [[], []];
          }
          set = set[length];
          while (index2 < length - 1) {
            i = indexOf2.call(set[0], args[index2]);
            if (i === -1) {
              i = set[0].push(args[index2]) - 1;
              set[1].push([[], []]);
            }
            set = set[1][i];
            ++index2;
          }
          i = indexOf2.call(set[0], args[index2]);
          if (i === -1) {
            i = set[0].push(args[index2]) - 1;
          }
          set[1][i] = ++lastId;
        }
        cache2[lastId] = args;
        return lastId;
      },
      delete: function(id) {
        var index2 = 0, set = map2, i, args = cache2[id], length = args.length, path3 = [];
        if (length === 0) {
          delete set[length];
        } else if (set = set[length]) {
          while (index2 < length - 1) {
            i = indexOf2.call(set[0], args[index2]);
            if (i === -1) {
              return;
            }
            path3.push(set, i);
            set = set[1][i];
            ++index2;
          }
          i = indexOf2.call(set[0], args[index2]);
          if (i === -1) {
            return;
          }
          id = set[1][i];
          set[0].splice(i, 1);
          set[1].splice(i, 1);
          while (!set[0].length && path3.length) {
            i = path3.pop();
            set = path3.pop();
            set[0].splice(i, 1);
            set[1].splice(i, 1);
          }
        }
        delete cache2[id];
      },
      clear: function() {
        map2 = [];
        cache2 = create2(null);
      }
    };
  };
  return get$1;
}
var get1;
var hasRequiredGet1;
function requireGet1() {
  if (hasRequiredGet1) return get1;
  hasRequiredGet1 = 1;
  var indexOf2 = eIndexOf;
  get1 = function() {
    var lastId = 0, argsMap = [], cache2 = [];
    return {
      get: function(args) {
        var index2 = indexOf2.call(argsMap, args[0]);
        return index2 === -1 ? null : cache2[index2];
      },
      set: function(args) {
        argsMap.push(args[0]);
        cache2.push(++lastId);
        return lastId;
      },
      delete: function(id) {
        var index2 = indexOf2.call(cache2, id);
        if (index2 !== -1) {
          argsMap.splice(index2, 1);
          cache2.splice(index2, 1);
        }
      },
      clear: function() {
        argsMap = [];
        cache2 = [];
      }
    };
  };
  return get1;
}
var getFixed;
var hasRequiredGetFixed;
function requireGetFixed() {
  if (hasRequiredGetFixed) return getFixed;
  hasRequiredGetFixed = 1;
  var indexOf2 = eIndexOf, create2 = Object.create;
  getFixed = function(length) {
    var lastId = 0, map2 = [[], []], cache2 = create2(null);
    return {
      get: function(args) {
        var index2 = 0, set = map2, i;
        while (index2 < length - 1) {
          i = indexOf2.call(set[0], args[index2]);
          if (i === -1) return null;
          set = set[1][i];
          ++index2;
        }
        i = indexOf2.call(set[0], args[index2]);
        if (i === -1) return null;
        return set[1][i] || null;
      },
      set: function(args) {
        var index2 = 0, set = map2, i;
        while (index2 < length - 1) {
          i = indexOf2.call(set[0], args[index2]);
          if (i === -1) {
            i = set[0].push(args[index2]) - 1;
            set[1].push([[], []]);
          }
          set = set[1][i];
          ++index2;
        }
        i = indexOf2.call(set[0], args[index2]);
        if (i === -1) {
          i = set[0].push(args[index2]) - 1;
        }
        set[1][i] = ++lastId;
        cache2[lastId] = args;
        return lastId;
      },
      delete: function(id) {
        var index2 = 0, set = map2, i, path3 = [], args = cache2[id];
        while (index2 < length - 1) {
          i = indexOf2.call(set[0], args[index2]);
          if (i === -1) {
            return;
          }
          path3.push(set, i);
          set = set[1][i];
          ++index2;
        }
        i = indexOf2.call(set[0], args[index2]);
        if (i === -1) {
          return;
        }
        id = set[1][i];
        set[0].splice(i, 1);
        set[1].splice(i, 1);
        while (!set[0].length && path3.length) {
          i = path3.pop();
          set = path3.pop();
          set[0].splice(i, 1);
          set[1].splice(i, 1);
        }
        delete cache2[id];
      },
      clear: function() {
        map2 = [[], []];
        cache2 = create2(null);
      }
    };
  };
  return getFixed;
}
var async = {};
var nextTick;
var hasRequiredNextTick;
function requireNextTick() {
  if (hasRequiredNextTick) return nextTick;
  hasRequiredNextTick = 1;
  var ensureCallable = function(fn) {
    if (typeof fn !== "function") throw new TypeError(fn + " is not a function");
    return fn;
  };
  var byObserver = function(Observer) {
    var node2 = document.createTextNode(""), queue, currentQueue, i = 0;
    new Observer(function() {
      var callback;
      if (!queue) {
        if (!currentQueue) return;
        queue = currentQueue;
      } else if (currentQueue) {
        queue = currentQueue.concat(queue);
      }
      currentQueue = queue;
      queue = null;
      if (typeof currentQueue === "function") {
        callback = currentQueue;
        currentQueue = null;
        callback();
        return;
      }
      node2.data = i = ++i % 2;
      while (currentQueue) {
        callback = currentQueue.shift();
        if (!currentQueue.length) currentQueue = null;
        callback();
      }
    }).observe(node2, { characterData: true });
    return function(fn) {
      ensureCallable(fn);
      if (queue) {
        if (typeof queue === "function") queue = [queue, fn];
        else queue.push(fn);
        return;
      }
      queue = fn;
      node2.data = i = ++i % 2;
    };
  };
  nextTick = function() {
    if (typeof process === "object" && process && typeof process.nextTick === "function") {
      return process.nextTick;
    }
    if (typeof queueMicrotask === "function") {
      return function(cb) {
        queueMicrotask(ensureCallable(cb));
      };
    }
    if (typeof document === "object" && document) {
      if (typeof MutationObserver === "function") return byObserver(MutationObserver);
      if (typeof WebKitMutationObserver === "function") return byObserver(WebKitMutationObserver);
    }
    if (typeof setImmediate === "function") {
      return function(cb) {
        setImmediate(ensureCallable(cb));
      };
    }
    if (typeof setTimeout === "function" || typeof setTimeout === "object") {
      return function(cb) {
        setTimeout(ensureCallable(cb), 0);
      };
    }
    return null;
  }();
  return nextTick;
}
var hasRequiredAsync;
function requireAsync() {
  if (hasRequiredAsync) return async;
  hasRequiredAsync = 1;
  var aFrom = requireFrom(), objectMap = map$2, mixin2 = requireMixin(), defineLength2 = _defineLengthExports, nextTick2 = requireNextTick();
  var slice2 = Array.prototype.slice, apply2 = Function.prototype.apply, create2 = Object.create;
  registeredExtensions.async = function(tbi, conf) {
    var waiting = create2(null), cache2 = create2(null), base = conf.memoized, original = conf.original, currentCallback, currentContext, currentArgs;
    conf.memoized = defineLength2(function(arg) {
      var args = arguments, last = args[args.length - 1];
      if (typeof last === "function") {
        currentCallback = last;
        args = slice2.call(args, 0, -1);
      }
      return base.apply(currentContext = this, currentArgs = args);
    }, base);
    try {
      mixin2(conf.memoized, base);
    } catch (ignore) {
    }
    conf.on("get", function(id) {
      var cb, context2, args;
      if (!currentCallback) return;
      if (waiting[id]) {
        if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback];
        else waiting[id].push(currentCallback);
        currentCallback = null;
        return;
      }
      cb = currentCallback;
      context2 = currentContext;
      args = currentArgs;
      currentCallback = currentContext = currentArgs = null;
      nextTick2(function() {
        var data2;
        if (hasOwnProperty.call(cache2, id)) {
          data2 = cache2[id];
          conf.emit("getasync", id, args, context2);
          apply2.call(cb, data2.context, data2.args);
        } else {
          currentCallback = cb;
          currentContext = context2;
          currentArgs = args;
          base.apply(context2, args);
        }
      });
    });
    conf.original = function() {
      var args, cb, origCb, result;
      if (!currentCallback) return apply2.call(original, this, arguments);
      args = aFrom(arguments);
      cb = function self3(err) {
        var cb2, args2, id = self3.id;
        if (id == null) {
          nextTick2(apply2.bind(self3, this, arguments));
          return void 0;
        }
        delete self3.id;
        cb2 = waiting[id];
        delete waiting[id];
        if (!cb2) {
          return void 0;
        }
        args2 = aFrom(arguments);
        if (conf.has(id)) {
          if (err) {
            conf.delete(id);
          } else {
            cache2[id] = { context: this, args: args2 };
            conf.emit("setasync", id, typeof cb2 === "function" ? 1 : cb2.length);
          }
        }
        if (typeof cb2 === "function") {
          result = apply2.call(cb2, this, args2);
        } else {
          cb2.forEach(function(cb3) {
            result = apply2.call(cb3, this, args2);
          }, this);
        }
        return result;
      };
      origCb = currentCallback;
      currentCallback = currentContext = currentArgs = null;
      args.push(cb);
      result = apply2.call(original, this, args);
      cb.cb = origCb;
      currentCallback = cb;
      return result;
    };
    conf.on("set", function(id) {
      if (!currentCallback) {
        conf.delete(id);
        return;
      }
      if (waiting[id]) {
        if (typeof waiting[id] === "function") waiting[id] = [waiting[id], currentCallback.cb];
        else waiting[id].push(currentCallback.cb);
      } else {
        waiting[id] = currentCallback.cb;
      }
      delete currentCallback.cb;
      currentCallback.id = id;
      currentCallback = null;
    });
    conf.on("delete", function(id) {
      var result;
      if (hasOwnProperty.call(waiting, id)) return;
      if (!cache2[id]) return;
      result = cache2[id];
      delete cache2[id];
      conf.emit("deleteasync", id, slice2.call(result.args, 1));
    });
    conf.on("clear", function() {
      var oldCache = cache2;
      cache2 = create2(null);
      conf.emit(
        "clearasync",
        objectMap(oldCache, function(data2) {
          return slice2.call(data2.args, 1);
        })
      );
    });
  };
  return async;
}
var promise = {};
var isCallable;
var hasRequiredIsCallable;
function requireIsCallable() {
  if (hasRequiredIsCallable) return isCallable;
  hasRequiredIsCallable = 1;
  isCallable = function(obj) {
    return typeof obj === "function";
  };
  return isCallable;
}
var validateStringifiable;
var hasRequiredValidateStringifiable;
function requireValidateStringifiable() {
  if (hasRequiredValidateStringifiable) return validateStringifiable;
  hasRequiredValidateStringifiable = 1;
  var isCallable2 = requireIsCallable();
  validateStringifiable = function(stringifiable) {
    try {
      if (stringifiable && isCallable2(stringifiable.toString)) return stringifiable.toString();
      return String(stringifiable);
    } catch (e) {
      throw new TypeError("Passed argument cannot be stringifed");
    }
  };
  return validateStringifiable;
}
var validateStringifiableValue;
var hasRequiredValidateStringifiableValue;
function requireValidateStringifiableValue() {
  if (hasRequiredValidateStringifiableValue) return validateStringifiableValue;
  hasRequiredValidateStringifiableValue = 1;
  var ensureValue2 = validValue, stringifiable = requireValidateStringifiable();
  validateStringifiableValue = function(value2) {
    return stringifiable(ensureValue2(value2));
  };
  return validateStringifiableValue;
}
var safeToString$2;
var hasRequiredSafeToString;
function requireSafeToString() {
  if (hasRequiredSafeToString) return safeToString$2;
  hasRequiredSafeToString = 1;
  var isCallable2 = requireIsCallable();
  safeToString$2 = function(value2) {
    try {
      if (value2 && isCallable2(value2.toString)) return value2.toString();
      return String(value2);
    } catch (e) {
      return "<Non-coercible to string value>";
    }
  };
  return safeToString$2;
}
var toShortStringRepresentation;
var hasRequiredToShortStringRepresentation;
function requireToShortStringRepresentation() {
  if (hasRequiredToShortStringRepresentation) return toShortStringRepresentation;
  hasRequiredToShortStringRepresentation = 1;
  var safeToString2 = requireSafeToString();
  var reNewLine2 = /[\n\r\u2028\u2029]/g;
  toShortStringRepresentation = function(value2) {
    var string2 = safeToString2(value2);
    if (string2.length > 100) string2 = string2.slice(0, 99) + "â€¦";
    string2 = string2.replace(reNewLine2, function(char) {
      return JSON.stringify(char).slice(1, -1);
    });
    return string2;
  };
  return toShortStringRepresentation;
}
var isPromise = { exports: {} };
var hasRequiredIsPromise;
function requireIsPromise() {
  if (hasRequiredIsPromise) return isPromise.exports;
  hasRequiredIsPromise = 1;
  isPromise.exports = isPromise$1;
  isPromise.exports.default = isPromise$1;
  function isPromise$1(obj) {
    return !!obj && (typeof obj === "object" || typeof obj === "function") && typeof obj.then === "function";
  }
  return isPromise.exports;
}
var hasRequiredPromise;
function requirePromise() {
  if (hasRequiredPromise) return promise;
  hasRequiredPromise = 1;
  var objectMap = map$2, primitiveSet2 = primitiveSet$1, ensureString = requireValidateStringifiableValue(), toShortString2 = requireToShortStringRepresentation(), isPromise2 = requireIsPromise(), nextTick2 = requireNextTick();
  var create2 = Object.create, supportedModes = primitiveSet2("then", "then:finally", "done", "done:finally");
  registeredExtensions.promise = function(mode, conf) {
    var waiting = create2(null), cache2 = create2(null), promises = create2(null);
    if (mode === true) {
      mode = null;
    } else {
      mode = ensureString(mode);
      if (!supportedModes[mode]) {
        throw new TypeError("'" + toShortString2(mode) + "' is not valid promise mode");
      }
    }
    conf.on("set", function(id, ignore, promise2) {
      var isFailed = false;
      if (!isPromise2(promise2)) {
        cache2[id] = promise2;
        conf.emit("setasync", id, 1);
        return;
      }
      waiting[id] = 1;
      promises[id] = promise2;
      var onSuccess = function(result) {
        var count = waiting[id];
        if (isFailed) {
          throw new Error(
            "Memoizee error: Detected unordered then|done & finally resolution, which in turn makes proper detection of success/failure impossible (when in 'done:finally' mode)\nConsider to rely on 'then' or 'done' mode instead."
          );
        }
        if (!count) return;
        delete waiting[id];
        cache2[id] = result;
        conf.emit("setasync", id, count);
      };
      var onFailure = function() {
        isFailed = true;
        if (!waiting[id]) return;
        delete waiting[id];
        delete promises[id];
        conf.delete(id);
      };
      var resolvedMode = mode;
      if (!resolvedMode) resolvedMode = "then";
      if (resolvedMode === "then") {
        var nextTickFailure = function() {
          nextTick2(onFailure);
        };
        promise2 = promise2.then(function(result) {
          nextTick2(onSuccess.bind(this, result));
        }, nextTickFailure);
        if (typeof promise2.finally === "function") {
          promise2.finally(nextTickFailure);
        }
      } else if (resolvedMode === "done") {
        if (typeof promise2.done !== "function") {
          throw new Error(
            "Memoizee error: Retrieved promise does not implement 'done' in 'done' mode"
          );
        }
        promise2.done(onSuccess, onFailure);
      } else if (resolvedMode === "done:finally") {
        if (typeof promise2.done !== "function") {
          throw new Error(
            "Memoizee error: Retrieved promise does not implement 'done' in 'done:finally' mode"
          );
        }
        if (typeof promise2.finally !== "function") {
          throw new Error(
            "Memoizee error: Retrieved promise does not implement 'finally' in 'done:finally' mode"
          );
        }
        promise2.done(onSuccess);
        promise2.finally(onFailure);
      }
    });
    conf.on("get", function(id, args, context2) {
      var promise2;
      if (waiting[id]) {
        ++waiting[id];
        return;
      }
      promise2 = promises[id];
      var emit2 = function() {
        conf.emit("getasync", id, args, context2);
      };
      if (isPromise2(promise2)) {
        if (typeof promise2.done === "function") promise2.done(emit2);
        else {
          promise2.then(function() {
            nextTick2(emit2);
          });
        }
      } else {
        emit2();
      }
    });
    conf.on("delete", function(id) {
      delete promises[id];
      if (waiting[id]) {
        delete waiting[id];
        return;
      }
      if (!hasOwnProperty.call(cache2, id)) return;
      var result = cache2[id];
      delete cache2[id];
      conf.emit("deleteasync", id, [result]);
    });
    conf.on("clear", function() {
      var oldCache = cache2;
      cache2 = create2(null);
      waiting = create2(null);
      promises = create2(null);
      conf.emit("clearasync", objectMap(oldCache, function(data2) {
        return [data2];
      }));
    });
  };
  return promise;
}
var dispose = {};
var hasRequiredDispose;
function requireDispose() {
  if (hasRequiredDispose) return dispose;
  hasRequiredDispose = 1;
  var callable2 = validCallable, forEach2 = forEach$5, extensions2 = registeredExtensions, apply2 = Function.prototype.apply;
  extensions2.dispose = function(dispose2, conf, options) {
    var del;
    callable2(dispose2);
    if (options.async && extensions2.async || options.promise && extensions2.promise) {
      conf.on(
        "deleteasync",
        del = function(id, resultArray) {
          apply2.call(dispose2, null, resultArray);
        }
      );
      conf.on("clearasync", function(cache2) {
        forEach2(cache2, function(result, id) {
          del(id, result);
        });
      });
      return;
    }
    conf.on("delete", del = function(id, result) {
      dispose2(result);
    });
    conf.on("clear", function(cache2) {
      forEach2(cache2, function(result, id) {
        del(id, result);
      });
    });
  };
  return dispose;
}
var maxAge = {};
var maxTimeout;
var hasRequiredMaxTimeout;
function requireMaxTimeout() {
  if (hasRequiredMaxTimeout) return maxTimeout;
  hasRequiredMaxTimeout = 1;
  maxTimeout = 2147483647;
  return maxTimeout;
}
var validTimeout;
var hasRequiredValidTimeout;
function requireValidTimeout() {
  if (hasRequiredValidTimeout) return validTimeout;
  hasRequiredValidTimeout = 1;
  var toPosInt2 = toPosInteger, maxTimeout2 = requireMaxTimeout();
  validTimeout = function(value2) {
    value2 = toPosInt2(value2);
    if (value2 > maxTimeout2) throw new TypeError(value2 + " exceeds maximum possible timeout");
    return value2;
  };
  return validTimeout;
}
var hasRequiredMaxAge;
function requireMaxAge() {
  if (hasRequiredMaxAge) return maxAge;
  hasRequiredMaxAge = 1;
  var aFrom = requireFrom(), forEach2 = forEach$5, nextTick2 = requireNextTick(), isPromise2 = requireIsPromise(), timeout = requireValidTimeout(), extensions2 = registeredExtensions;
  var noop2 = Function.prototype, max2 = Math.max, min2 = Math.min, create2 = Object.create;
  extensions2.maxAge = function(maxAge2, conf, options) {
    var timeouts, postfix, preFetchAge, preFetchTimeouts;
    maxAge2 = timeout(maxAge2);
    if (!maxAge2) return;
    timeouts = create2(null);
    postfix = options.async && extensions2.async || options.promise && extensions2.promise ? "async" : "";
    conf.on("set" + postfix, function(id) {
      timeouts[id] = setTimeout(function() {
        conf.delete(id);
      }, maxAge2);
      if (typeof timeouts[id].unref === "function") timeouts[id].unref();
      if (!preFetchTimeouts) return;
      if (preFetchTimeouts[id]) {
        if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
      }
      preFetchTimeouts[id] = setTimeout(function() {
        delete preFetchTimeouts[id];
      }, preFetchAge);
      if (typeof preFetchTimeouts[id].unref === "function") preFetchTimeouts[id].unref();
    });
    conf.on("delete" + postfix, function(id) {
      clearTimeout(timeouts[id]);
      delete timeouts[id];
      if (!preFetchTimeouts) return;
      if (preFetchTimeouts[id] !== "nextTick") clearTimeout(preFetchTimeouts[id]);
      delete preFetchTimeouts[id];
    });
    if (options.preFetch) {
      if (options.preFetch === true || isNaN(options.preFetch)) {
        preFetchAge = 0.333;
      } else {
        preFetchAge = max2(min2(Number(options.preFetch), 1), 0);
      }
      if (preFetchAge) {
        preFetchTimeouts = {};
        preFetchAge = (1 - preFetchAge) * maxAge2;
        conf.on("get" + postfix, function(id, args, context2) {
          if (!preFetchTimeouts[id]) {
            preFetchTimeouts[id] = "nextTick";
            nextTick2(function() {
              var result;
              if (preFetchTimeouts[id] !== "nextTick") return;
              delete preFetchTimeouts[id];
              conf.delete(id);
              if (options.async) {
                args = aFrom(args);
                args.push(noop2);
              }
              result = conf.memoized.apply(context2, args);
              if (options.promise) {
                if (isPromise2(result)) {
                  if (typeof result.done === "function") result.done(noop2, noop2);
                  else result.then(noop2, noop2);
                }
              }
            });
          }
        });
      }
    }
    conf.on("clear" + postfix, function() {
      forEach2(timeouts, function(id) {
        clearTimeout(id);
      });
      timeouts = {};
      if (preFetchTimeouts) {
        forEach2(preFetchTimeouts, function(id) {
          if (id !== "nextTick") clearTimeout(id);
        });
        preFetchTimeouts = {};
      }
    });
  };
  return maxAge;
}
var max$1 = {};
var lruQueue;
var hasRequiredLruQueue;
function requireLruQueue() {
  if (hasRequiredLruQueue) return lruQueue;
  hasRequiredLruQueue = 1;
  var toPosInt2 = toPosInteger, create2 = Object.create, hasOwnProperty2 = Object.prototype.hasOwnProperty;
  lruQueue = function(limit) {
    var size = 0, base = 1, queue = create2(null), map2 = create2(null), index2 = 0, del;
    limit = toPosInt2(limit);
    return {
      hit: function(id) {
        var oldIndex = map2[id], nuIndex = ++index2;
        queue[nuIndex] = id;
        map2[id] = nuIndex;
        if (!oldIndex) {
          ++size;
          if (size <= limit) return;
          id = queue[base];
          del(id);
          return id;
        }
        delete queue[oldIndex];
        if (base !== oldIndex) return;
        while (!hasOwnProperty2.call(queue, ++base)) continue;
      },
      delete: del = function(id) {
        var oldIndex = map2[id];
        if (!oldIndex) return;
        delete queue[oldIndex];
        delete map2[id];
        --size;
        if (base !== oldIndex) return;
        if (!size) {
          index2 = 0;
          base = 1;
          return;
        }
        while (!hasOwnProperty2.call(queue, ++base)) continue;
      },
      clear: function() {
        size = 0;
        base = 1;
        queue = create2(null);
        map2 = create2(null);
        index2 = 0;
      }
    };
  };
  return lruQueue;
}
var hasRequiredMax;
function requireMax() {
  if (hasRequiredMax) return max$1;
  hasRequiredMax = 1;
  var toPosInteger$1 = toPosInteger, lruQueue2 = requireLruQueue(), extensions2 = registeredExtensions;
  extensions2.max = function(max2, conf, options) {
    var postfix, queue, hit;
    max2 = toPosInteger$1(max2);
    if (!max2) return;
    queue = lruQueue2(max2);
    postfix = options.async && extensions2.async || options.promise && extensions2.promise ? "async" : "";
    conf.on(
      "set" + postfix,
      hit = function(id) {
        id = queue.hit(id);
        if (id === void 0) return;
        conf.delete(id);
      }
    );
    conf.on("get" + postfix, hit);
    conf.on("delete" + postfix, queue.delete);
    conf.on("clear" + postfix, queue.clear);
  };
  return max$1;
}
var refCounter = {};
var hasRequiredRefCounter;
function requireRefCounter() {
  if (hasRequiredRefCounter) return refCounter;
  hasRequiredRefCounter = 1;
  var d2 = dExports, extensions2 = registeredExtensions, create2 = Object.create, defineProperties2 = Object.defineProperties;
  extensions2.refCounter = function(ignore, conf, options) {
    var cache2, postfix;
    cache2 = create2(null);
    postfix = options.async && extensions2.async || options.promise && extensions2.promise ? "async" : "";
    conf.on("set" + postfix, function(id, length) {
      cache2[id] = length || 1;
    });
    conf.on("get" + postfix, function(id) {
      ++cache2[id];
    });
    conf.on("delete" + postfix, function(id) {
      delete cache2[id];
    });
    conf.on("clear" + postfix, function() {
      cache2 = {};
    });
    defineProperties2(conf.memoized, {
      deleteRef: d2(function() {
        var id = conf.get(arguments);
        if (id === null) return null;
        if (!cache2[id]) return null;
        if (!--cache2[id]) {
          conf.delete(id);
          return true;
        }
        return false;
      }),
      getRefCount: d2(function() {
        var id = conf.get(arguments);
        if (id === null) return 0;
        if (!cache2[id]) return 0;
        return cache2[id];
      })
    });
  };
  return refCounter;
}
var normalizeOpts$1 = normalizeOptions, resolveLength$1 = resolveLength$3, plain = plain$1;
var memoizee = function(fn) {
  var options = normalizeOpts$1(arguments[1]), length;
  if (!options.normalizer) {
    length = options.length = resolveLength$1(options.length, fn.length, options.async);
    if (length !== 0) {
      if (options.primitive) {
        if (length === false) {
          options.normalizer = requirePrimitive();
        } else if (length > 1) {
          options.normalizer = requireGetPrimitiveFixed()(length);
        }
      } else if (length === false) options.normalizer = requireGet$1()();
      else if (length === 1) options.normalizer = requireGet1()();
      else options.normalizer = requireGetFixed()(length);
    }
  }
  if (options.async) requireAsync();
  if (options.promise) requirePromise();
  if (options.dispose) requireDispose();
  if (options.maxAge) requireMaxAge();
  if (options.max) requireMax();
  if (options.refCounter) requireRefCounter();
  return plain(fn, options);
};
var isValue$2 = is$6, isObject = is$5;
var objectToString = Object.prototype.toString;
var coerce = function(value2) {
  if (!isValue$2(value2)) return null;
  if (isObject(value2)) {
    var valueToString = value2.toString;
    if (typeof valueToString !== "function") return null;
    if (valueToString === objectToString) return null;
  }
  try {
    return "" + value2;
  } catch (error2) {
    return null;
  }
};
var safeToString$1 = function(value2) {
  try {
    return value2.toString();
  } catch (error2) {
    try {
      return String(value2);
    } catch (error22) {
      return null;
    }
  }
};
var safeToString = safeToString$1;
var reNewLine = /[\n\r\u2028\u2029]/g;
var toShortString$1 = function(value2) {
  var string2 = safeToString(value2);
  if (string2 === null) return "<Non-coercible to string value>";
  if (string2.length > 100) string2 = string2.slice(0, 99) + "â€¦";
  string2 = string2.replace(reNewLine, function(char) {
    switch (char) {
      case "\n":
        return "\\n";
      case "\r":
        return "\\r";
      case "\u2028":
        return "\\u2028";
      case "\u2029":
        return "\\u2029";
      default:
        throw new Error("Unexpected character");
    }
  });
  return string2;
};
var stringCoerce = coerce, toShortString = toShortString$1;
var resolveErrorMessage$1 = function(errorMessage, value2, inputOptions) {
  if (inputOptions && inputOptions.errorMessage) {
    errorMessage = stringCoerce(inputOptions.errorMessage);
  }
  var valueInsertIndex = errorMessage.indexOf("%v");
  var valueToken = valueInsertIndex > -1 ? toShortString(value2) : null;
  if (inputOptions && inputOptions.name) {
    var nameInsertIndex = errorMessage.indexOf("%n");
    if (nameInsertIndex > -1) {
      if (valueInsertIndex > -1) {
        var firstToken, secondToken, firstInsertIndex, secondInsertIndex;
        if (nameInsertIndex > valueInsertIndex) {
          firstToken = valueToken;
          firstInsertIndex = valueInsertIndex;
          secondToken = inputOptions.name;
          secondInsertIndex = nameInsertIndex;
        } else {
          firstToken = inputOptions.name;
          firstInsertIndex = nameInsertIndex;
          secondToken = valueToken;
          secondInsertIndex = valueInsertIndex;
        }
        return errorMessage.slice(0, firstInsertIndex) + firstToken + errorMessage.slice(firstInsertIndex + 2, secondInsertIndex) + secondToken + errorMessage.slice(secondInsertIndex + 2);
      }
      return errorMessage.slice(0, nameInsertIndex) + inputOptions.name + errorMessage.slice(nameInsertIndex + 2);
    }
  }
  if (valueInsertIndex > -1) {
    return errorMessage.slice(0, valueInsertIndex) + valueToken + errorMessage.slice(valueInsertIndex + 2);
  }
  return errorMessage;
};
var isValue$1 = is$6, resolveErrorMessage = resolveErrorMessage$1;
var resolveException$1 = function(value2, defaultMessage2, inputOptions) {
  if (inputOptions && !isValue$1(value2)) {
    if ("default" in inputOptions) return inputOptions["default"];
    if (inputOptions.isOptional) return null;
  }
  var ErrorConstructor = inputOptions && inputOptions.Error || TypeError;
  var error2 = new ErrorConstructor(resolveErrorMessage(defaultMessage2, value2, inputOptions));
  if (inputOptions && inputOptions.errorCode) error2.code = inputOptions.errorCode;
  throw error2;
};
var resolveException = resolveException$1, is$1 = is$6;
var ensure$1 = function(value2) {
  if (is$1(value2)) return value2;
  var options = arguments[1];
  var errorMessage = options && options.name ? "Expected a value for %n, received %v" : "Cannot use %v";
  return resolveException(value2, errorMessage, options);
};
var isPlainFunction = is$2, ensureValue = ensure$1, isValue = is$6, map$1 = map$2, contains = contains$2;
var call$1 = Function.prototype.call, defineProperty$1 = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getPrototypeOf = Object.getPrototypeOf, hasOwnProperty$1 = Object.prototype.hasOwnProperty, cacheDesc = { configurable: false, enumerable: false, writable: false, value: null }, define;
define = function(name2, options) {
  var value2, dgs, cacheName, desc2, writable = false, resolvable, flat;
  options = Object(ensureValue(options));
  cacheName = options.cacheName;
  flat = options.flat;
  if (!isValue(cacheName)) cacheName = name2;
  delete options.cacheName;
  value2 = options.value;
  resolvable = isPlainFunction(value2);
  delete options.value;
  dgs = { configurable: Boolean(options.configurable), enumerable: Boolean(options.enumerable) };
  if (name2 !== cacheName) {
    dgs.get = function() {
      if (hasOwnProperty$1.call(this, cacheName)) return this[cacheName];
      cacheDesc.value = resolvable ? call$1.call(value2, this, options) : value2;
      cacheDesc.writable = writable;
      defineProperty$1(this, cacheName, cacheDesc);
      cacheDesc.value = null;
      if (desc2) defineProperty$1(this, name2, desc2);
      return this[cacheName];
    };
  } else if (!flat) {
    dgs.get = function self3() {
      var ownDesc;
      if (hasOwnProperty$1.call(this, name2)) {
        ownDesc = getOwnPropertyDescriptor(this, name2);
        if (ownDesc) {
          if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
          if (typeof ownDesc.get === "function" && ownDesc.get !== self3) {
            return ownDesc.get.call(this);
          }
          return value2;
        }
      }
      desc2.value = resolvable ? call$1.call(value2, this, options) : value2;
      defineProperty$1(this, name2, desc2);
      desc2.value = null;
      return this[name2];
    };
  } else {
    dgs.get = function self3() {
      var base = this, ownDesc;
      if (hasOwnProperty$1.call(this, name2)) {
        ownDesc = getOwnPropertyDescriptor(this, name2);
        if (ownDesc.hasOwnProperty("value")) return ownDesc.value;
        if (typeof ownDesc.get === "function" && ownDesc.get !== self3) {
          return ownDesc.get.call(this);
        }
      }
      while (!hasOwnProperty$1.call(base, name2)) base = getPrototypeOf(base);
      desc2.value = resolvable ? call$1.call(value2, base, options) : value2;
      defineProperty$1(base, name2, desc2);
      desc2.value = null;
      return base[name2];
    };
  }
  dgs.set = function(value3) {
    if (hasOwnProperty$1.call(this, name2)) {
      throw new TypeError("Cannot assign to lazy defined '" + name2 + "' property of " + this);
    }
    dgs.get.call(this);
    this[cacheName] = value3;
  };
  if (options.desc) {
    desc2 = {
      configurable: contains.call(options.desc, "c"),
      enumerable: contains.call(options.desc, "e")
    };
    if (cacheName === name2) {
      desc2.writable = contains.call(options.desc, "w");
      desc2.value = null;
    } else {
      writable = contains.call(options.desc, "w");
      desc2.get = dgs.get;
      desc2.set = dgs.set;
    }
    delete options.desc;
  } else if (cacheName === name2) {
    desc2 = {
      configurable: Boolean(options.configurable),
      enumerable: Boolean(options.enumerable),
      writable: Boolean(options.writable),
      value: null
    };
  }
  delete options.configurable;
  delete options.enumerable;
  delete options.writable;
  return dgs;
};
var lazy$1 = function(props) {
  return map$1(props, function(desc2, name2) {
    return define(name2, desc2);
  });
};
var forEach$1 = forEach$5, normalizeOpts = normalizeOptions, callable$1 = validCallable, lazy = lazy$1, resolveLength = resolveLength$3, extensions = registeredExtensions;
var methods$1 = function(memoize2) {
  return function(props) {
    forEach$1(props, function(desc2) {
      var fn = callable$1(desc2.value), length;
      desc2.value = function(options) {
        if (options.getNormalizer) {
          options = normalizeOpts(options);
          if (length === void 0) {
            length = resolveLength(
              options.length,
              fn.length,
              options.async && extensions.async
            );
          }
          options.normalizer = options.getNormalizer(length);
          delete options.getNormalizer;
        }
        return memoize2(fn.bind(this), options);
      };
    });
    return lazy(props);
  };
};
var methods = methods$1(memoizee);
var value$1 = validValue, objPropertyIsEnumerable = Object.prototype.propertyIsEnumerable;
var firstKey = function(obj) {
  var i;
  value$1(obj);
  for (i in obj) {
    if (objPropertyIsEnumerable.call(obj, i)) return i;
  }
  return null;
};
var toPosInt = toPosInteger, callable = validCallable, value = validValue, objHasOwnProperty = Object.prototype.hasOwnProperty, call = Function.prototype.call;
var forEachRight$1 = function(cb) {
  var i, self3, thisArg;
  self3 = Object(value(this));
  callable(cb);
  thisArg = arguments[1];
  for (i = toPosInt(self3.length) - 1; i >= 0; --i) {
    if (objHasOwnProperty.call(self3, i)) call.call(cb, thisArg, self3[i], i, self3);
  }
};
var indexOf = eIndexOf, filter2 = Array.prototype.filter, isFirst;
isFirst = function(value2, index2) {
  return indexOf.call(this, value2) === index2;
};
var uniq$1 = function() {
  return filter2.call(this, isFirst, this);
};
var assign$1 = assign$3, includes = contains$2, forOwn = forEach$5, onlyKey = firstKey, forEachRight = forEachRight$1, uniq = uniq$1;
var CSI = "\x1B[";
var sgr$1 = function(code2) {
  return CSI + code2 + "m";
};
sgr$1.CSI = CSI;
var mods$1 = assign$1(
  {
    // Style
    bold: { _bold: [1, 22] },
    italic: { _italic: [3, 23] },
    underline: { _underline: [4, 24] },
    blink: { _blink: [5, 25] },
    inverse: { _inverse: [7, 27] },
    strike: { _strike: [9, 29] }
    // Color
  },
  ["black", "red", "green", "yellow", "blue", "magenta", "cyan", "white"].reduce(function(obj, color, index2) {
    obj[color] = { _fg: [30 + index2, 39] };
    obj[color + "Bright"] = { _fg: [90 + index2, 39] };
    obj["bg" + color[0].toUpperCase() + color.slice(1)] = { _bg: [40 + index2, 49] };
    obj["bg" + color[0].toUpperCase() + color.slice(1) + "Bright"] = { _bg: [100 + index2, 49] };
    return obj;
  }, {})
);
sgr$1.mods = mods$1;
sgr$1.openers = {};
sgr$1.closers = {};
forOwn(mods$1, function(mod) {
  var modPair = mod[onlyKey(mod)];
  sgr$1.openers[modPair[0]] = modPair;
  sgr$1.closers[modPair[1]] = modPair;
});
sgr$1.openStyle = function(openedMods, code2) {
  openedMods.push(sgr$1.openers[code2]);
};
sgr$1.closeStyle = function(openedMods, code2) {
  forEachRight.call(openedMods, function(modPair, index2) {
    if (modPair[1] === code2) {
      openedMods.splice(index2, 1);
    }
  });
};
sgr$1.prepend = function(currentMods) {
  return currentMods.map(function(modPair) {
    return sgr$1(modPair[0]);
  });
};
sgr$1.complete = function(openedMods, closerCodes) {
  closerCodes.forEach(function(code2) {
    sgr$1.closeStyle(openedMods, code2);
  });
  openedMods = openedMods.reverse();
  openedMods = openedMods.map(function(modPair) {
    return modPair[1];
  });
  openedMods = uniq.call(openedMods);
  return openedMods.map(sgr$1);
};
var hasCSI = function(str2) {
  return includes.call(str2, CSI);
};
sgr$1.hasCSI = hasCSI;
var extractCode = function(csi) {
  var code2 = csi.slice(2, -1);
  code2 = Number(code2);
  return code2;
};
sgr$1.extractCode = extractCode;
var sgr_1 = sgr$1;
var state = null;
var enableColor = function() {
  state = true;
};
var disableColor = function() {
  state = false;
};
var autoDetectSupport = function() {
  state = null;
};
var isColorSupported = function() {
  return state === null ? !process.env.NO_COLOR : state;
};
var supportsColor$1 = {
  enableColor,
  disableColor,
  autoDetectSupport,
  isColorSupported
};
var xtermColors;
var hasRequiredXtermColors;
function requireXtermColors() {
  if (hasRequiredXtermColors) return xtermColors;
  hasRequiredXtermColors = 1;
  xtermColors = [
    "000000",
    "800000",
    "008000",
    "808000",
    "000080",
    "800080",
    "008080",
    "c0c0c0",
    "808080",
    "ff0000",
    "00ff00",
    "ffff00",
    "0000ff",
    "ff00ff",
    "00ffff",
    "ffffff",
    "000000",
    "00005f",
    "000087",
    "0000af",
    "0000d7",
    "0000ff",
    "005f00",
    "005f5f",
    "005f87",
    "005faf",
    "005fd7",
    "005fff",
    "008700",
    "00875f",
    "008787",
    "0087af",
    "0087d7",
    "0087ff",
    "00af00",
    "00af5f",
    "00af87",
    "00afaf",
    "00afd7",
    "00afff",
    "00d700",
    "00d75f",
    "00d787",
    "00d7af",
    "00d7d7",
    "00d7ff",
    "00ff00",
    "00ff5f",
    "00ff87",
    "00ffaf",
    "00ffd7",
    "00ffff",
    "5f0000",
    "5f005f",
    "5f0087",
    "5f00af",
    "5f00d7",
    "5f00ff",
    "5f5f00",
    "5f5f5f",
    "5f5f87",
    "5f5faf",
    "5f5fd7",
    "5f5fff",
    "5f8700",
    "5f875f",
    "5f8787",
    "5f87af",
    "5f87d7",
    "5f87ff",
    "5faf00",
    "5faf5f",
    "5faf87",
    "5fafaf",
    "5fafd7",
    "5fafff",
    "5fd700",
    "5fd75f",
    "5fd787",
    "5fd7af",
    "5fd7d7",
    "5fd7ff",
    "5fff00",
    "5fff5f",
    "5fff87",
    "5fffaf",
    "5fffd7",
    "5fffff",
    "870000",
    "87005f",
    "870087",
    "8700af",
    "8700d7",
    "8700ff",
    "875f00",
    "875f5f",
    "875f87",
    "875faf",
    "875fd7",
    "875fff",
    "878700",
    "87875f",
    "878787",
    "8787af",
    "8787d7",
    "8787ff",
    "87af00",
    "87af5f",
    "87af87",
    "87afaf",
    "87afd7",
    "87afff",
    "87d700",
    "87d75f",
    "87d787",
    "87d7af",
    "87d7d7",
    "87d7ff",
    "87ff00",
    "87ff5f",
    "87ff87",
    "87ffaf",
    "87ffd7",
    "87ffff",
    "af0000",
    "af005f",
    "af0087",
    "af00af",
    "af00d7",
    "af00ff",
    "af5f00",
    "af5f5f",
    "af5f87",
    "af5faf",
    "af5fd7",
    "af5fff",
    "af8700",
    "af875f",
    "af8787",
    "af87af",
    "af87d7",
    "af87ff",
    "afaf00",
    "afaf5f",
    "afaf87",
    "afafaf",
    "afafd7",
    "afafff",
    "afd700",
    "afd75f",
    "afd787",
    "afd7af",
    "afd7d7",
    "afd7ff",
    "afff00",
    "afff5f",
    "afff87",
    "afffaf",
    "afffd7",
    "afffff",
    "d70000",
    "d7005f",
    "d70087",
    "d700af",
    "d700d7",
    "d700ff",
    "d75f00",
    "d75f5f",
    "d75f87",
    "d75faf",
    "d75fd7",
    "d75fff",
    "d78700",
    "d7875f",
    "d78787",
    "d787af",
    "d787d7",
    "d787ff",
    "d7af00",
    "d7af5f",
    "d7af87",
    "d7afaf",
    "d7afd7",
    "d7afff",
    "d7d700",
    "d7d75f",
    "d7d787",
    "d7d7af",
    "d7d7d7",
    "d7d7ff",
    "d7ff00",
    "d7ff5f",
    "d7ff87",
    "d7ffaf",
    "d7ffd7",
    "d7ffff",
    "ff0000",
    "ff005f",
    "ff0087",
    "ff00af",
    "ff00d7",
    "ff00ff",
    "ff5f00",
    "ff5f5f",
    "ff5f87",
    "ff5faf",
    "ff5fd7",
    "ff5fff",
    "ff8700",
    "ff875f",
    "ff8787",
    "ff87af",
    "ff87d7",
    "ff87ff",
    "ffaf00",
    "ffaf5f",
    "ffaf87",
    "ffafaf",
    "ffafd7",
    "ffafff",
    "ffd700",
    "ffd75f",
    "ffd787",
    "ffd7af",
    "ffd7d7",
    "ffd7ff",
    "ffff00",
    "ffff5f",
    "ffff87",
    "ffffaf",
    "ffffd7",
    "ffffff",
    "080808",
    "121212",
    "1c1c1c",
    "262626",
    "303030",
    "3a3a3a",
    "444444",
    "4e4e4e",
    "585858",
    "626262",
    "6c6c6c",
    "767676",
    "808080",
    "8a8a8a",
    "949494",
    "9e9e9e",
    "a8a8a8",
    "b2b2b2",
    "bcbcbc",
    "c6c6c6",
    "d0d0d0",
    "dadada",
    "e4e4e4",
    "eeeeee"
  ];
  return xtermColors;
}
var xtermMatch$1;
var hasRequiredXtermMatch;
function requireXtermMatch() {
  if (hasRequiredXtermMatch) return xtermMatch$1;
  hasRequiredXtermMatch = 1;
  var push = Array.prototype.push, reduce2 = Array.prototype.reduce, abs2 = Math.abs, colors, match2, result, i;
  colors = requireXtermColors().map(function(color) {
    return {
      r: parseInt(color.slice(0, 2), 16),
      g: parseInt(color.slice(2, 4), 16),
      b: parseInt(color.slice(4), 16)
    };
  });
  match2 = colors.slice(0, 16);
  xtermMatch$1 = result = [];
  i = 0;
  while (i < 8) {
    result.push(30 + i++);
  }
  i = 0;
  while (i < 8) {
    result.push(90 + i++);
  }
  push.apply(
    result,
    colors.slice(16).map(function(data2) {
      var index2, diff = Infinity;
      match2.every(function(innerMatch, currentIndex) {
        var ndiff = reduce2.call(
          "rgb",
          function(currentDiff, channel) {
            currentDiff += abs2(innerMatch[channel] - data2[channel]);
            return currentDiff;
          },
          0
        );
        if (ndiff < diff) {
          index2 = currentIndex;
          diff = ndiff;
        }
        return ndiff;
      });
      return result[index2];
    })
  );
  return xtermMatch$1;
}
var d$1 = dExports, assign = assign$3, forEach = forEach$5, map = map$2, primitiveSet = primitiveSet$1, setPrototypeOf = setPrototypeOf$1, memoize = memoizee, memoizeMethods = methods, sgr = sgr_1, supportsColor = supportsColor$1;
var mods = sgr.mods, join = Array.prototype.join, defineProperty = Object.defineProperty, max = Math.max, min = Math.min, variantModes = primitiveSet("_fg", "_bg"), xtermMatch = process.platform === "win32" ? requireXtermMatch() : null;
var getFn;
var memoized = memoize(function(scope2, mod) {
  return defineProperty(getFn(), "_cliColorData", d$1(assign({}, scope2._cliColorData, mod)));
});
var proto = Object.create(
  Function.prototype,
  assign(
    map(mods, function(mod) {
      return d$1.gs(function() {
        return memoized(this, mod);
      });
    }),
    memoizeMethods({
      // xterm (255) color
      xterm: d$1(function(code2) {
        code2 = isNaN(code2) ? 255 : min(max(code2, 0), 255);
        return defineProperty(
          getFn(),
          "_cliColorData",
          d$1(
            assign({}, this._cliColorData, {
              _fg: [xtermMatch ? xtermMatch[code2] : "38;5;" + code2, 39]
            })
          )
        );
      }),
      bgXterm: d$1(function(code2) {
        code2 = isNaN(code2) ? 255 : min(max(code2, 0), 255);
        return defineProperty(
          getFn(),
          "_cliColorData",
          d$1(
            assign({}, this._cliColorData, {
              _bg: [xtermMatch ? xtermMatch[code2] + 10 : "48;5;" + code2, 49]
            })
          )
        );
      })
    })
  )
);
var getEndRe = memoize(function(code2) {
  return new RegExp("\x1B\\[" + code2 + "m", "g");
}, {
  primitive: true
});
getFn = function() {
  return setPrototypeOf(
    function self3() {
      var start = "", end = "", msg = join.call(arguments, " "), conf = self3._cliColorData, hasAnsi = sgr.hasCSI(msg);
      forEach(
        conf,
        function(mod, key) {
          end = sgr(mod[1]) + end;
          start += sgr(mod[0]);
          if (hasAnsi) {
            msg = msg.replace(getEndRe(mod[1]), variantModes[key] ? sgr(mod[0]) : "");
          }
        },
        null,
        true
      );
      if (!supportsColor.isColorSupported()) return msg;
      return start + msg + end;
    },
    proto
  );
};
var bare = Object.defineProperties(getFn(), {
  xtermSupported: d$1(!xtermMatch),
  _cliColorData: d$1("", {})
});
var windowSize = {};
var hasRequiredWindowSize;
function requireWindowSize() {
  if (hasRequiredWindowSize) return windowSize;
  hasRequiredWindowSize = 1;
  (function(exports) {
    var d2 = dExports;
    Object.defineProperties(exports, {
      width: d2.gs("ce", function() {
        return process.stdout.columns || 0;
      }),
      height: d2.gs("ce", function() {
        return process.stdout.rows || 0;
      })
    });
  })(windowSize);
  return windowSize;
}
var erase;
var hasRequiredErase;
function requireErase() {
  if (hasRequiredErase) return erase;
  hasRequiredErase = 1;
  erase = {
    screen: "\x1B[2J",
    screenLeft: "\x1B[1J",
    screenRight: "\x1B[J",
    line: "\x1B[2K",
    lineLeft: "\x1B[1K",
    lineRight: "\x1B[K"
  };
  return erase;
}
var isImplemented$1;
var hasRequiredIsImplemented$1;
function requireIsImplemented$1() {
  if (hasRequiredIsImplemented$1) return isImplemented$1;
  hasRequiredIsImplemented$1 = 1;
  isImplemented$1 = function() {
    var trunc2 = Math.trunc;
    if (typeof trunc2 !== "function") return false;
    return trunc2(13.67) === 13 && trunc2(-13.67) === -13;
  };
  return isImplemented$1;
}
var shim$1;
var hasRequiredShim$1;
function requireShim$1() {
  if (hasRequiredShim$1) return shim$1;
  hasRequiredShim$1 = 1;
  var floor2 = Math.floor;
  shim$1 = function(value2) {
    if (isNaN(value2)) return NaN;
    value2 = Number(value2);
    if (value2 === 0) return value2;
    if (value2 === Infinity) return Infinity;
    if (value2 === -Infinity) return -Infinity;
    if (value2 > 0) return floor2(value2);
    return -floor2(-value2);
  };
  return shim$1;
}
var trunc;
var hasRequiredTrunc;
function requireTrunc() {
  if (hasRequiredTrunc) return trunc;
  hasRequiredTrunc = 1;
  trunc = requireIsImplemented$1()() ? Math.trunc : requireShim$1();
  return trunc;
}
var move;
var hasRequiredMove;
function requireMove() {
  if (hasRequiredMove) return move;
  hasRequiredMove = 1;
  var d2 = dExports, trunc2 = requireTrunc();
  var up, down, right, left, abs2 = Math.abs, floor2 = Math.floor, max2 = Math.max;
  var getMove = function(control) {
    return function(num) {
      num = isNaN(num) ? 0 : max2(floor2(num), 0);
      return num ? "\x1B[" + num + control : "";
    };
  };
  move = Object.defineProperties(
    function(x, y2) {
      x = isNaN(x) ? 0 : floor2(x);
      y2 = isNaN(y2) ? 0 : floor2(y2);
      return (x > 0 ? right(x) : left(-x)) + (y2 > 0 ? down(y2) : up(-y2));
    },
    {
      up: d2(up = getMove("A")),
      down: d2(down = getMove("B")),
      right: d2(right = getMove("C")),
      left: d2(left = getMove("D")),
      to: d2(function(x, y2) {
        x = isNaN(x) ? 1 : max2(floor2(x), 0) + 1;
        y2 = isNaN(y2) ? 1 : max2(floor2(y2), 0) + 1;
        return "\x1B[" + y2 + ";" + x + "H";
      }),
      lines: d2(function(n) {
        var dir;
        n = trunc2(n) || 0;
        dir = n >= 0 ? "B" : "A";
        n = floor2(abs2(n));
        return "\x1B[" + n + dir + "\x1B[1G";
      }),
      top: d2("\x1B[5000F"),
      bottom: d2("\x1B[5000B"),
      lineBegin: d2("\x1B[5000D"),
      lineEnd: d2("\x1B[5000C")
    }
  );
  return move;
}
var beep;
var hasRequiredBeep;
function requireBeep() {
  if (hasRequiredBeep) return beep;
  hasRequiredBeep = 1;
  beep = "\x07";
  return beep;
}
var generate;
var hasRequiredGenerate;
function requireGenerate() {
  if (hasRequiredGenerate) return generate;
  hasRequiredGenerate = 1;
  var toPosInt2 = toPosInteger, value2 = validValue, slice2 = Array.prototype.slice;
  generate = function(length) {
    var arr, currentLength;
    length = toPosInt2(value2(length));
    if (length === 0) return [];
    arr = arguments.length < 2 ? [void 0] : slice2.call(arguments, 1, 1 + length);
    while ((currentLength = arr.length) < length) {
      arr = arr.concat(arr.slice(0, length - currentLength));
    }
    return arr;
  };
  return generate;
}
var isArrayLike;
var hasRequiredIsArrayLike;
function requireIsArrayLike() {
  if (hasRequiredIsArrayLike) return isArrayLike;
  hasRequiredIsArrayLike = 1;
  var isFunction2 = requireIsFunction(), isObject2 = requireIsObject(), isValue2 = isValue$7;
  isArrayLike = function(value2) {
    return isValue2(value2) && typeof value2.length === "number" && // Just checking ((typeof x === 'object') && (typeof x !== 'function'))
    // won't work right for some cases, e.g.:
    // type of instance of NodeList in Safari is a 'function'
    (isObject2(value2) && !isFunction2(value2) || typeof value2 === "string") || false;
  };
  return isArrayLike;
}
var is2;
var hasRequiredIs;
function requireIs() {
  if (hasRequiredIs) return is2;
  hasRequiredIs = 1;
  var iteratorSymbol = requireEs6Symbol().iterator, isValue2 = isValue$7, isArrayLike2 = requireIsArrayLike();
  is2 = function(value2) {
    if (!isValue2(value2)) return false;
    if (typeof value2[iteratorSymbol] === "function") return true;
    return isArrayLike2(value2);
  };
  return is2;
}
var validateObject;
var hasRequiredValidateObject;
function requireValidateObject() {
  if (hasRequiredValidateObject) return validateObject;
  hasRequiredValidateObject = 1;
  var isObject2 = requireIsObject(), is3 = requireIs();
  validateObject = function(value2) {
    if (is3(value2) && isObject2(value2)) return value2;
    throw new TypeError(value2 + " is not an iterable or array-like object");
  };
  return validateObject;
}
var isImplemented;
var hasRequiredIsImplemented;
function requireIsImplemented() {
  if (hasRequiredIsImplemented) return isImplemented;
  hasRequiredIsImplemented = 1;
  var str2 = "foo";
  isImplemented = function() {
    if (typeof str2.repeat !== "function") return false;
    return str2.repeat(2) === "foofoo";
  };
  return isImplemented;
}
var shim;
var hasRequiredShim;
function requireShim() {
  if (hasRequiredShim) return shim;
  hasRequiredShim = 1;
  var value2 = validValue, toInteger2 = toInteger$1;
  shim = function(count) {
    var str2 = String(value2(this)), result;
    count = toInteger2(count);
    if (count < 0) throw new RangeError("Count must be >= 0");
    if (!isFinite(count)) throw new RangeError("Count must be < âˆž");
    result = "";
    while (count) {
      if (count % 2) result += str2;
      if (count > 1) str2 += str2;
      count >>= 1;
    }
    return result;
  };
  return shim;
}
var repeat;
var hasRequiredRepeat;
function requireRepeat() {
  if (hasRequiredRepeat) return repeat;
  hasRequiredRepeat = 1;
  repeat = requireIsImplemented()() ? String.prototype.repeat : requireShim();
  return repeat;
}
var regexAnsi;
var hasRequiredRegexAnsi;
function requireRegexAnsi() {
  if (hasRequiredRegexAnsi) return regexAnsi;
  hasRequiredRegexAnsi = 1;
  regexAnsi = function() {
    return new RegExp(
      "[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))",
      "g"
    );
  };
  return regexAnsi;
}
var strip;
var hasRequiredStrip;
function requireStrip() {
  if (hasRequiredStrip) return strip;
  hasRequiredStrip = 1;
  var stringifiable = requireValidateStringifiable(), r = requireRegexAnsi()();
  strip = function(str2) {
    return stringifiable(str2).replace(r, "");
  };
  return strip;
}
var getStrippedLength;
var hasRequiredGetStrippedLength;
function requireGetStrippedLength() {
  if (hasRequiredGetStrippedLength) return getStrippedLength;
  hasRequiredGetStrippedLength = 1;
  var strip2 = requireStrip();
  getStrippedLength = function(str2) {
    return strip2(str2).length;
  };
  return getStrippedLength;
}
var columns;
var hasRequiredColumns;
function requireColumns() {
  if (hasRequiredColumns) return columns;
  hasRequiredColumns = 1;
  var generate2 = requireGenerate(), from2 = requireFrom(), iterable = requireValidateObject(), isValue2 = isValue$7, stringifiable = requireValidateStringifiable(), repeat2 = requireRepeat(), getStrippedLength2 = requireGetStrippedLength();
  var push = Array.prototype.push;
  columns = function(inputRows) {
    var options = Object(arguments[1]), colsMeta = [], colsOptions = options.columns || [], rows = [];
    from2(iterable(inputRows), function(row) {
      var rowRows = [[]];
      from2(iterable(row), function(cellStr, columnIndex) {
        var cellRows = stringifiable(cellStr).split("\n");
        while (cellRows.length > rowRows.length) rowRows.push(generate2(columnIndex, ""));
        cellRows.forEach(function(cellRow, rowRowIndex) {
          rowRows[rowRowIndex][columnIndex] = cellRow;
        });
      });
      push.apply(rows, rowRows);
    });
    return rows.map(function(row) {
      return from2(iterable(row), function(str2, index2) {
        var col = colsMeta[index2], strLength;
        if (!col) col = colsMeta[index2] = { width: 0 };
        str2 = stringifiable(str2);
        strLength = getStrippedLength2(str2);
        if (strLength > col.width) col.width = strLength;
        return { str: str2, length: strLength };
      });
    }).map(function(row) {
      return row.map(function(item, index2) {
        var pad, align = "left", colOptions = colsOptions && colsOptions[index2];
        align = colOptions && colOptions.align === "right" ? "right" : "left";
        pad = repeat2.call(" ", colsMeta[index2].width - item.length);
        if (align === "left") return item.str + pad;
        return pad + item.str;
      }).join(isValue2(options.sep) ? options.sep : " | ");
    }).join("\n") + "\n";
  };
  return columns;
}
var slice;
var hasRequiredSlice;
function requireSlice() {
  if (hasRequiredSlice) return slice;
  hasRequiredSlice = 1;
  var reAnsi = requireRegexAnsi(), stringifiable = requireValidateStringifiableValue(), length = requireGetStrippedLength(), sgr2 = sgr_1, max2 = Math.max;
  var Token = function(token) {
    this.token = token;
  };
  var tokenize = function(str2) {
    var match2 = reAnsi().exec(str2);
    if (!match2) {
      return [str2];
    }
    var index2 = match2.index, head, prehead, tail;
    if (index2 === 0) {
      head = match2[0];
      tail = str2.slice(head.length);
      return [new Token(head)].concat(tokenize(tail));
    }
    prehead = str2.slice(0, index2);
    head = match2[0];
    tail = str2.slice(index2 + head.length);
    return [prehead, new Token(head)].concat(tokenize(tail));
  };
  var isChunkInSlice = function(chunk, index2, begin, end) {
    var endIndex = chunk.length + index2;
    if (begin > endIndex) return false;
    if (end < index2) return false;
    return true;
  };
  var sliceSeq = function(seq, begin, end) {
    var sliced = seq.reduce(
      function(state2, chunk) {
        var index2 = state2.index;
        if (chunk instanceof Token) {
          var code2 = sgr2.extractCode(chunk.token);
          if (index2 <= begin) {
            if (code2 in sgr2.openers) {
              sgr2.openStyle(state2.preOpeners, code2);
            }
            if (code2 in sgr2.closers) {
              sgr2.closeStyle(state2.preOpeners, code2);
            }
          } else if (index2 < end) {
            if (code2 in sgr2.openers) {
              sgr2.openStyle(state2.inOpeners, code2);
              state2.seq.push(chunk);
            } else if (code2 in sgr2.closers) {
              state2.inClosers.push(code2);
              state2.seq.push(chunk);
            }
          }
        } else {
          var nextChunk = "";
          if (isChunkInSlice(chunk, index2, begin, end)) {
            var relBegin = Math.max(begin - index2, 0), relEnd = Math.min(end - index2, chunk.length);
            nextChunk = chunk.slice(relBegin, relEnd);
          }
          state2.seq.push(nextChunk);
          state2.index = index2 + chunk.length;
        }
        return state2;
      },
      {
        index: 0,
        seq: [],
        // preOpeners -> [ mod ]
        // preOpeners must be prepended to the slice if they wasn't closed til the end of it
        // preOpeners must be closed if they wasn't closed til the end of the slice
        preOpeners: [],
        // inOpeners  -> [ mod ]
        // inOpeners already in the slice and must not be prepended to the slice
        // inOpeners must be closed if they wasn't closed til the end of the slice
        inOpeners: [],
        // opener CSI inside slice
        // inClosers -> [ code ]
        // closer CSIs for determining which pre/in-Openers must be closed
        inClosers: []
      }
    );
    sliced.seq = [].concat(
      sgr2.prepend(sliced.preOpeners),
      sliced.seq,
      sgr2.complete([].concat(sliced.preOpeners, sliced.inOpeners), sliced.inClosers)
    );
    return sliced.seq;
  };
  slice = function(str2) {
    var seq, begin = Number(arguments[1]), end = Number(arguments[2]), len;
    str2 = stringifiable(str2);
    len = length(str2);
    if (isNaN(begin)) {
      begin = 0;
    }
    if (isNaN(end)) {
      end = len;
    }
    if (begin < 0) {
      begin = max2(len + begin, 0);
    }
    if (end < 0) {
      end = max2(len + end, 0);
    }
    seq = tokenize(str2);
    seq = sliceSeq(seq, begin, end);
    return seq.map(function(chunk) {
      if (chunk instanceof Token) {
        return chunk.token;
      }
      return chunk;
    }).join("");
  };
  return slice;
}
var throbber = { exports: {} };
var compose;
var hasRequiredCompose;
function requireCompose() {
  if (hasRequiredCompose) return compose;
  hasRequiredCompose = 1;
  var isValue2 = isValue$7, callable2 = validCallable, aFrom = requireFrom();
  var apply2 = Function.prototype.apply, call2 = Function.prototype.call, callFn = function(arg, fn) {
    return call2.call(fn, this, arg);
  };
  compose = function(fnIgnored) {
    var fns, first2;
    var args = aFrom(arguments);
    fns = isValue2(this) ? [this].concat(args) : args;
    fns.forEach(callable2);
    fns = fns.reverse();
    first2 = fns[0];
    fns = fns.slice(1);
    return function(argIgnored) {
      return fns.reduce(callFn, apply2.call(first2, this, arguments));
    };
  };
  return compose;
}
var hasRequiredThrobber;
function requireThrobber() {
  if (hasRequiredThrobber) return throbber.exports;
  hasRequiredThrobber = 1;
  (function(module2, exports) {
    var compose2 = requireCompose(), callable2 = validCallable, d2 = dExports, validTimeout2 = requireValidTimeout();
    var chars = "-\\|/", l = chars.length, ThrobberIterator;
    ThrobberIterator = function() {
    };
    Object.defineProperties(ThrobberIterator.prototype, {
      index: d2(-1),
      running: d2(false),
      next: d2(function() {
        var str2 = this.running ? "\b" : "";
        if (!this.running) this.running = true;
        return str2 + chars[this.index = (this.index + 1) % l];
      }),
      reset: d2(function() {
        if (!this.running) return "";
        this.index = -1;
        this.running = false;
        return "\b";
      })
    });
    module2.exports = exports = function(write, interval) {
      var format2 = arguments[2], token, iterator = new ThrobberIterator();
      callable2(write);
      interval = validTimeout2(interval);
      if (format2 !== void 0) write = compose2.call(write, callable2(format2));
      return {
        start: function() {
          if (token) return;
          token = setInterval(function() {
            write(iterator.next());
          }, interval);
        },
        restart: function() {
          this.stop();
          this.start();
        },
        stop: function() {
          if (!token) return;
          clearInterval(token);
          token = null;
          write(iterator.reset());
        }
      };
    };
    Object.defineProperty(exports, "Iterator", d2(ThrobberIterator));
  })(throbber, throbber.exports);
  return throbber.exports;
}
var reset;
var hasRequiredReset;
function requireReset() {
  if (hasRequiredReset) return reset;
  hasRequiredReset = 1;
  reset = "\x1B[2J\x1B[0;0H";
  return reset;
}
var validObject;
var hasRequiredValidObject;
function requireValidObject() {
  if (hasRequiredValidObject) return validObject;
  hasRequiredValidObject = 1;
  var isObject2 = requireIsObject();
  validObject = function(value2) {
    if (!isObject2(value2)) throw new TypeError(value2 + " is not an Object");
    return value2;
  };
  return validObject;
}
var array = { exports: {} };
var clear;
var hasRequiredClear;
function requireClear() {
  if (hasRequiredClear) return clear;
  hasRequiredClear = 1;
  var value2 = validValue;
  clear = function() {
    value2(this).length = 0;
    return this;
  };
  return clear;
}
var ensure;
var hasRequiredEnsure;
function requireEnsure() {
  if (hasRequiredEnsure) return ensure;
  hasRequiredEnsure = 1;
  var resolveException2 = resolveException$1, is3 = is$2;
  ensure = function(value2) {
    if (is3(value2)) return value2;
    var options = arguments[1];
    var errorMessage = options && options.name ? "Expected a plain function for %n, received %v" : "%v is not a plain function";
    return resolveException2(value2, errorMessage, options);
  };
  return ensure;
}
var copy;
var hasRequiredCopy;
function requireCopy() {
  if (hasRequiredCopy) return copy;
  hasRequiredCopy = 1;
  var aFrom = requireFrom(), assign2 = assign$3, value2 = validValue;
  copy = function(obj) {
    var copy2 = Object(value2(obj)), propertyNames = arguments[1], options = Object(arguments[2]);
    if (copy2 !== obj && !propertyNames) return copy2;
    var result = {};
    if (propertyNames) {
      aFrom(propertyNames, function(propertyName) {
        if (options.ensure || propertyName in obj) result[propertyName] = obj[propertyName];
      });
    } else {
      assign2(result, obj);
    }
    return result;
  };
  return copy;
}
var autoBind;
var hasRequiredAutoBind;
function requireAutoBind() {
  if (hasRequiredAutoBind) return autoBind;
  hasRequiredAutoBind = 1;
  var isValue2 = is$6, ensureValue2 = ensure$1, ensurePlainFunction = requireEnsure(), copy2 = requireCopy(), normalizeOptions$1 = normalizeOptions, map2 = map$2;
  var bind2 = Function.prototype.bind, defineProperty2 = Object.defineProperty, hasOwnProperty2 = Object.prototype.hasOwnProperty, define2;
  define2 = function(name2, desc2, options) {
    var value2 = ensureValue2(desc2) && ensurePlainFunction(desc2.value), dgs;
    dgs = copy2(desc2);
    delete dgs.writable;
    delete dgs.value;
    dgs.get = function() {
      if (!options.overwriteDefinition && hasOwnProperty2.call(this, name2)) return value2;
      desc2.value = bind2.call(value2, options.resolveContext ? options.resolveContext(this) : this);
      defineProperty2(this, name2, desc2);
      return this[name2];
    };
    return dgs;
  };
  autoBind = function(props) {
    var options = normalizeOptions$1(arguments[1]);
    if (isValue2(options.resolveContext)) ensurePlainFunction(options.resolveContext);
    return map2(props, function(desc2, name2) {
      return define2(name2, desc2, options);
    });
  };
  return autoBind;
}
var es6Iterator;
var hasRequiredEs6Iterator;
function requireEs6Iterator() {
  if (hasRequiredEs6Iterator) return es6Iterator;
  hasRequiredEs6Iterator = 1;
  var clear2 = requireClear(), assign2 = assign$3, callable2 = validCallable, value2 = validValue, d2 = dExports, autoBind2 = requireAutoBind(), Symbol2 = requireEs6Symbol();
  var defineProperty2 = Object.defineProperty, defineProperties2 = Object.defineProperties, Iterator2;
  es6Iterator = Iterator2 = function(list, context2) {
    if (!(this instanceof Iterator2)) throw new TypeError("Constructor requires 'new'");
    defineProperties2(this, {
      __list__: d2("w", value2(list)),
      __context__: d2("w", context2),
      __nextIndex__: d2("w", 0)
    });
    if (!context2) return;
    callable2(context2.on);
    context2.on("_add", this._onAdd);
    context2.on("_delete", this._onDelete);
    context2.on("_clear", this._onClear);
  };
  delete Iterator2.prototype.constructor;
  defineProperties2(
    Iterator2.prototype,
    assign2(
      {
        _next: d2(function() {
          var i;
          if (!this.__list__) return void 0;
          if (this.__redo__) {
            i = this.__redo__.shift();
            if (i !== void 0) return i;
          }
          if (this.__nextIndex__ < this.__list__.length) return this.__nextIndex__++;
          this._unBind();
          return void 0;
        }),
        next: d2(function() {
          return this._createResult(this._next());
        }),
        _createResult: d2(function(i) {
          if (i === void 0) return { done: true, value: void 0 };
          return { done: false, value: this._resolve(i) };
        }),
        _resolve: d2(function(i) {
          return this.__list__[i];
        }),
        _unBind: d2(function() {
          this.__list__ = null;
          delete this.__redo__;
          if (!this.__context__) return;
          this.__context__.off("_add", this._onAdd);
          this.__context__.off("_delete", this._onDelete);
          this.__context__.off("_clear", this._onClear);
          this.__context__ = null;
        }),
        toString: d2(function() {
          return "[object " + (this[Symbol2.toStringTag] || "Object") + "]";
        })
      },
      autoBind2({
        _onAdd: d2(function(index2) {
          if (index2 >= this.__nextIndex__) return;
          ++this.__nextIndex__;
          if (!this.__redo__) {
            defineProperty2(this, "__redo__", d2("c", [index2]));
            return;
          }
          this.__redo__.forEach(function(redo, i) {
            if (redo >= index2) this.__redo__[i] = ++redo;
          }, this);
          this.__redo__.push(index2);
        }),
        _onDelete: d2(function(index2) {
          var i;
          if (index2 >= this.__nextIndex__) return;
          --this.__nextIndex__;
          if (!this.__redo__) return;
          i = this.__redo__.indexOf(index2);
          if (i !== -1) this.__redo__.splice(i, 1);
          this.__redo__.forEach(function(redo, j2) {
            if (redo > index2) this.__redo__[j2] = --redo;
          }, this);
        }),
        _onClear: d2(function() {
          if (this.__redo__) clear2.call(this.__redo__);
          this.__nextIndex__ = 0;
        })
      })
    )
  );
  defineProperty2(
    Iterator2.prototype,
    Symbol2.iterator,
    d2(function() {
      return this;
    })
  );
  return es6Iterator;
}
var hasRequiredArray;
function requireArray() {
  if (hasRequiredArray) return array.exports;
  hasRequiredArray = 1;
  var setPrototypeOf2 = setPrototypeOf$1, contains2 = contains$2, d2 = dExports, Symbol2 = requireEs6Symbol(), Iterator2 = requireEs6Iterator();
  var defineProperty2 = Object.defineProperty, ArrayIterator;
  ArrayIterator = array.exports = function(arr, kind) {
    if (!(this instanceof ArrayIterator)) throw new TypeError("Constructor requires 'new'");
    Iterator2.call(this, arr);
    if (!kind) kind = "value";
    else if (contains2.call(kind, "key+value")) kind = "key+value";
    else if (contains2.call(kind, "key")) kind = "key";
    else kind = "value";
    defineProperty2(this, "__kind__", d2("", kind));
  };
  if (setPrototypeOf2) setPrototypeOf2(ArrayIterator, Iterator2);
  delete ArrayIterator.prototype.constructor;
  ArrayIterator.prototype = Object.create(Iterator2.prototype, {
    _resolve: d2(function(i) {
      if (this.__kind__ === "value") return this.__list__[i];
      if (this.__kind__ === "key+value") return [i, this.__list__[i]];
      return i;
    })
  });
  defineProperty2(ArrayIterator.prototype, Symbol2.toStringTag, d2("c", "Array Iterator"));
  return array.exports;
}
var string = { exports: {} };
var hasRequiredString;
function requireString() {
  if (hasRequiredString) return string.exports;
  hasRequiredString = 1;
  var setPrototypeOf2 = setPrototypeOf$1, d2 = dExports, Symbol2 = requireEs6Symbol(), Iterator2 = requireEs6Iterator();
  var defineProperty2 = Object.defineProperty, StringIterator;
  StringIterator = string.exports = function(str2) {
    if (!(this instanceof StringIterator)) throw new TypeError("Constructor requires 'new'");
    str2 = String(str2);
    Iterator2.call(this, str2);
    defineProperty2(this, "__length__", d2("", str2.length));
  };
  if (setPrototypeOf2) setPrototypeOf2(StringIterator, Iterator2);
  delete StringIterator.prototype.constructor;
  StringIterator.prototype = Object.create(Iterator2.prototype, {
    _next: d2(function() {
      if (!this.__list__) return void 0;
      if (this.__nextIndex__ < this.__length__) return this.__nextIndex__++;
      this._unBind();
      return void 0;
    }),
    _resolve: d2(function(i) {
      var char = this.__list__[i], code2;
      if (this.__nextIndex__ === this.__length__) return char;
      code2 = char.charCodeAt(0);
      if (code2 >= 55296 && code2 <= 56319) return char + this.__list__[this.__nextIndex__++];
      return char;
    })
  });
  defineProperty2(StringIterator.prototype, Symbol2.toStringTag, d2("c", "String Iterator"));
  return string.exports;
}
var isIterable;
var hasRequiredIsIterable;
function requireIsIterable() {
  if (hasRequiredIsIterable) return isIterable;
  hasRequiredIsIterable = 1;
  var isArguments2 = requireIsArguments(), isValue2 = isValue$7, isString2 = requireIsString();
  var iteratorSymbol = requireEs6Symbol().iterator, isArray2 = Array.isArray;
  isIterable = function(value2) {
    if (!isValue2(value2)) return false;
    if (isArray2(value2)) return true;
    if (isString2(value2)) return true;
    if (isArguments2(value2)) return true;
    return typeof value2[iteratorSymbol] === "function";
  };
  return isIterable;
}
var validIterable;
var hasRequiredValidIterable;
function requireValidIterable() {
  if (hasRequiredValidIterable) return validIterable;
  hasRequiredValidIterable = 1;
  var isIterable2 = requireIsIterable();
  validIterable = function(value2) {
    if (!isIterable2(value2)) throw new TypeError(value2 + " is not iterable");
    return value2;
  };
  return validIterable;
}
var get;
var hasRequiredGet;
function requireGet() {
  if (hasRequiredGet) return get;
  hasRequiredGet = 1;
  var isArguments2 = requireIsArguments(), isString2 = requireIsString(), ArrayIterator = requireArray(), StringIterator = requireString(), iterable = requireValidIterable(), iteratorSymbol = requireEs6Symbol().iterator;
  get = function(obj) {
    if (typeof iterable(obj)[iteratorSymbol] === "function") return obj[iteratorSymbol]();
    if (isArguments2(obj)) return new ArrayIterator(obj);
    if (isString2(obj)) return new StringIterator(obj);
    return new ArrayIterator(obj);
  };
  return get;
}
var forOf;
var hasRequiredForOf;
function requireForOf() {
  if (hasRequiredForOf) return forOf;
  hasRequiredForOf = 1;
  var isArguments2 = requireIsArguments(), callable2 = validCallable, isString2 = requireIsString(), get2 = requireGet();
  var isArray2 = Array.isArray, call2 = Function.prototype.call, some = Array.prototype.some;
  forOf = function(iterable, cb) {
    var mode, thisArg = arguments[2], result, doBreak, broken, i, length, char, code2;
    if (isArray2(iterable) || isArguments2(iterable)) mode = "array";
    else if (isString2(iterable)) mode = "string";
    else iterable = get2(iterable);
    callable2(cb);
    doBreak = function() {
      broken = true;
    };
    if (mode === "array") {
      some.call(iterable, function(value2) {
        call2.call(cb, thisArg, value2, doBreak);
        return broken;
      });
      return;
    }
    if (mode === "string") {
      length = iterable.length;
      for (i = 0; i < length; ++i) {
        char = iterable[i];
        if (i + 1 < length) {
          code2 = char.charCodeAt(0);
          if (code2 >= 55296 && code2 <= 56319) char += iterable[++i];
        }
        call2.call(cb, thisArg, char, doBreak);
        if (broken) break;
      }
      return;
    }
    result = iterable.next();
    while (!result.done) {
      call2.call(cb, thisArg, result.value, doBreak);
      if (broken) return;
      result = iterable.next();
    }
  };
  return forOf;
}
var art;
var hasRequiredArt;
function requireArt() {
  if (hasRequiredArt) return art;
  hasRequiredArt = 1;
  var object = requireValidObject(), stringifiable = requireValidateStringifiableValue(), forOf2 = requireForOf();
  art = function(text, style) {
    var result = "";
    text = stringifiable(text);
    object(style);
    forOf2(text, function(char) {
      result += style[char] || char;
    });
    return result;
  };
  return art;
}
var d = dExports;
var cliColor = Object.defineProperties(bare, {
  windowSize: d(requireWindowSize()),
  erase: d(requireErase()),
  move: d(requireMove()),
  beep: d(requireBeep()),
  columns: d(requireColumns()),
  strip: d(requireStrip()),
  getStrippedLength: d(requireGetStrippedLength()),
  slice: d(requireSlice()),
  throbber: d(requireThrobber()),
  reset: d(requireReset()),
  art: d(requireArt())
});
const clc = /* @__PURE__ */ getDefaultExportFromCjs(cliColor);
const require$1 = createRequire(import.meta.url);
async function startMusicServer() {
  console.log(`${clc.redBright("[Music Server]")} Starting...`);
  await server$1.serveNcmApi({
    port: 30888,
    moduleDefs: require$1("./musicModelDef.mjs")
  });
}
createRequire(import.meta.url);
const __dirname$1 = path$m.dirname(fileURLToPath(import.meta.url));
process.env.APP_ROOT = path$m.join(__dirname$1, "..");
const VITE_DEV_SERVER_URL = process.env["VITE_DEV_SERVER_URL"];
const MAIN_DIST = path$m.join(process.env.APP_ROOT, "dist-electron");
const RENDERER_DIST = path$m.join(process.env.APP_ROOT, "dist");
process.env.VITE_PUBLIC = VITE_DEV_SERVER_URL ? path$m.join(process.env.APP_ROOT, "public") : RENDERER_DIST;
let win;
function createWindow() {
  startMusicServer();
  win = new BrowserWindow({
    width: 1200,
    height: 800,
    icon: path$m.join(process.env.VITE_PUBLIC, "electron-vite.svg"),
    webPreferences: {
      preload: path$m.join(__dirname$1, "preload.mjs")
    }
  });
  win.webContents.on("did-finish-load", () => {
    win == null ? void 0 : win.webContents.send("main-process-message", (/* @__PURE__ */ new Date()).toLocaleString());
  });
  if (VITE_DEV_SERVER_URL) {
    win.loadURL(VITE_DEV_SERVER_URL);
  } else {
    win.loadFile(path$m.join(RENDERER_DIST, "index.html"));
  }
}
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
    win = null;
  }
});
app.on("activate", () => {
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});
app.whenReady().then(createWindow);
export {
  MAIN_DIST,
  RENDERER_DIST,
  VITE_DEV_SERVER_URL
};
